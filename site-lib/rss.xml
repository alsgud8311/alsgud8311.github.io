<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[mh_obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>mh_obsidian</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 02 Feb 2025 14:53:03 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 02 Feb 2025 14:49:47 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[index]]></title><description><![CDATA[개발 관련한 모든 것들을 기록하는 저장소입니다.
<a data-href="알고리즘" href="알고리즘/알고리즘.html#_0" class="internal-link" target="_self" rel="noopener nofollow">알고리즘</a>
<br><a data-href="학습 정리" href="부스트캠프/챌린지/학습-정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">학습 정리</a>
]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Sun, 02 Feb 2025 14:24:09 GMT</pubDate></item><item><title><![CDATA[기술면접]]></title><description><![CDATA[주관식JavaScript에서 객체가 속성과 메서드를 찾을 때 프로토타입 체인이 어떤 역할을 하는지 간단히 설명하세요. 혹시 Object.create가 무엇인지 알면 추가로 설명해주세요.주관식리액트 컴포넌트 간의 상태를 공유하는 효과적인 방법을 설명해보세요.주관식Proxy API와 Object.defineProperty를 사용한 데이터 바인딩의 차이점을 설명하고, 각각의 장단점을 비교하세요. 한가지만 설명해도 좋습니다.객관식-단일 응답React에서 고차 컴포넌트(Higher-Order Component, HOC)의 주요 단점은 무엇인가요?객관식-단일 응답React Router v6에서 중첩된 라우트(Nested Routes)를 구현할 때 사용하는 컴포넌트는 무엇인가요?객관식-단일 응답React의 Suspense 컴포넌트가 비동기 컴포넌트 로딩을 처리할 때 사용하는 주요 메커니즘은 무엇인가요?ww주관식브라우저 주소창에 URL입력후 화면에 콘텐츠가 보이기까지의 과정을 설명해보세요. (브라우저, 네트워크, 백엔드 모두 설명해도 됨)주관식DOM 트리에서 querySelector를 사용할 때, 선택자(selector)의 구체성이 성능에 미치는 영향을 설명해보세요주관식Flexbox에서 flex-grow, flex-shrink, flex-basis의 역할을 설명하고, 이들이 레이아웃 구성에 어떻게 기여하는지 설명하세요. (아는 내용만 설명해도 좋습니다)주관식번들링 과정에서 일어날 수 있는 '트리 쉐이킹'이 어떻게 동작 가능한 것인지 설명해보세요.주관식Promise.all과 Promise.race의 차이점을 설명하고, 각각의 사용 사례가 떠오르면 설명해보세요.주관식옵저버 패턴이 MVC 아키텍처에서 어떻게 활용되는지 설명하고, 프론트엔드 프레임워크에서의 구현 예를 설명해보세요.주관식제네릭(Generic)이 타입스크립트에서 어떻게 활용되는지 설명해보세요주관식useReducer Hook을 useState와 비교하여 설명하고, 복잡한 상태 관리에 useReducer를 사용하는 장점을 설명하세요주관식스스로 생각하는 코드의 품질저하 지점은 무엇인가요? 이를 개선하기 위한 리팩토링 전략을 말해주세요this의 활용
화살표함수에서 this는 무엇을 가르키는가?Q10
웹 브라우저에서 렌더링을 담당하는 엔진에 대해 알고 있나요? 사파리, 파이어폭스, 크롬의 렌더링 엔진을 알고 있다면 이름과 특징에 대해 간략히 설명해 주세요. 웹 상에서 웹 페이지를 불러왔을 때 렌더링 엔진이 화면에 결과를 표시하는 방식을 시간순서대로 설명해 주세요.Q11
크롬 브라우저와 node.js에서 자바스크립트는 v8 엔진에 의해 실행됩니다. 자바스크립트 코드가 실제 v8에 의해 실행되는 과정을 자세히 설명해 주세요. 그리고 V8의 구성요소 중 Ignition과 TurboFan에 대해서도 설명해 주세요.Q12
CDN에 대해 알고 있는 내용을 전부 설명해주세요. 단, 이 키워드들에 대해 설명해주시면 좋습니다.무엇을 해결하고자 사용하는 기술인가요?CDN이 문제를 해결하는 방식을 서술해주세요.CDN 사용 경험이 있다면, 사용 하기 전과 사용 후의 결과를 토대로 비교해주세요. 사용 경험이 없다면 생략해도 무방합니다.Q13
HTTPS 프로토콜에 대해 알고 있는 내용을 전부 설명해주세요. 단, 이 키워드들에 대해 설명해주시면 좋습니다.
무엇을 해결하고자 사용하는 기술인가요?
HTTPS 프로토콜이 문제를 해결하는 방식을 서술해주세요.
HTTPS 프로토콜 사용 경험이 있다면, 사용 하기 전과 사용 후의 결과를 토대로 비교해주세요. 사용 경험이 없다면 생략해도 무방합니다.
Q14
blocking과 non-blocking의 차이와 non-blocking이 문제를 해결하는 방식을 이야기 해주세요.
sync와 async의 차이와 async가 문제를 해결하는 방식을 이야기 해주세요.
blocking + sync / blocking + async / non-blocking + async / non-blocking + sync 등 각 조합이 동작하는 방식과 특징을 설명해주세요.
nodejs와 mysql 같은 rdb를 사용할 때는 3번의 사례중 무엇에 해당할까요?
nodejs와 mongodb 같은 no-sql을 사용할 때는 3번의 사례중 무엇에 해당할까요?
nodejs와 궁합이 좋은 데이터베이스는 무엇이고 이유가 뭘까요?
Q15
이벤트루프에 대해 설명해주세요.
javascript는 왜 이벤트루프 방식으로 동작하는걸까요? 그래야만 하는 이유가 있을까요? 싱글스레드, 멀티스레드의 장단점과 연관지어서 설명해주세요.
Q16
TCP / IP 소켓을 이용해서 간단한 클라이언트 / 서버 프로그램을 작성하고 있습니다. (1) v1에서 클라이언트 한 명은 정상 동작했지만 두 번째 클라이언트는 정상 접속되지 않았습니다. 예상 원인은 무엇일까요? (2) v2는 멀티스레드 방식으로 구현하려고 합니다. 프로그램의 흐름에 대해 간단히 설명해 주세요. (3) 스레드 갯수만큼 서버에도 별도의 소켓이 생성된다고 들었는데 이게 맞는 건가요? 그럼 각 스레드의 포트 번호는 몇 번이 할당될까요? (4) 클라이언트의 비정상 종료 감지 및 재접속을 구현하고 싶습니다. 어떻게 해야 할까요?Q17
(1) 데이터베이스의 트랜잭션 고립 수준에 대해 간단히 설명해 주세요. (2) nest.js에서 트랜잭션 고립 수준을 적용하는 방법과 적용 단위에 대해 설명해 보세요. (3) select ... for upate 구문의 용도와 동작 방식에 대해 설명해 주세요.Q18
MySQL 8.0 기본 설정 상태에서(1) 인덱스는 어떤 자료 구조로 만들어지나요?(2) 인덱스 노드의 크기는 얼마인가요? 이유는?(3) 현재 인덱스 노드는 하나 뿐이며 가득 찬 상태입니다. 이 때 새로운 데이터가 삽입될 경우의 동작 알고리즘을 설명해 보세요.Q19
(1) 관계형 데이터베이스에서 커서란 무엇인가요? 커서를 사용해 본 적이 있나요?(2) 서버사이드 커서와 클라이언트 사이드 커서의 차이점에 대해 알고 있나요?(3) 페이지네이션이란 무엇이며 MySQL에서는 어떻게 구현되나요?(4) 커서 기반 페이지네이션이란 무엇이며 어떤 경우 사용하게 될까요? 이 때 사용되는 커서는 어떤 종류의 커서일까요?Q20
게시판 본문에 대한 자연어 검색을 하고 싶습니다. (1) MySQL에서 가능할까요? 자세한 방법을 알려 주세요. (2) (1)이 잘 된다는 가정하에 한국어 검색도 잘 되나요? (3) Elastic Search와 MySQL의 자연어 검색의 동작 방식에 대해 설명해 주세요. (4) 여러분은 MySQL과 Elastic Search 중 본문 검색으로 무엇을 쓰실 건가요? 그 이유는?Q21
클라우드에서 저렴한 단일 서버로 node.js, nest.js, mysql 백엔드를 구성했습니다.테스트 코드를 열심히 짜서 돌리는데 로컬에서는 잘 되는 코드가 서버에서는 갑자기 죽습니다.(1) 원인에는 어떤 것들이 있을 수 있을까요?(2) OOM 킬러가 원인이라고 한다면 어떻게 해결할 수 있을까요?(3) 리눅스에서 swap의 동작 방식에 대해 설명해 보세요.(4) LRU와 clock의 차이는 무엇인가요?(5) 실제 리눅스의 페이지 교체 알고리즘에 대해 아는데까지 설명해 보세요.Q22
(1) AWS에는 사용할 수 있는 CPU가 Intel CPU와 graviton CPU가 있습니다. 둘 사이에는 어떤 차이가 있을까요?(2) 특정 서버에는 GPU가 있는 경우가 있습니다. GPU와 CPU의 차이는 무엇이고 이 서버는 어떤 워크로드에 유리할까요?(3) 일반적으로 사용하는 X64 아키텍쳐에서 int는 몇 비트일까요? 그리고 word 크기는 몇 비트일까요? 가장 효율적인 연산은 몇 비트일까요?(4) CPU에는 SIMD라는 연산이 있는데 무엇을 의미하나요? 어떤 용도로 사용될까요?Q23
XSS
XSS는 무엇일까요?
XSS를 예방하는 방법과 원리에 대해 설명해주세요.
CSRF 방어
CSRF는 무엇일까요?
CSRF 공격을 방어 하는 방법과 원리에 대해 설명해주세요.
CORS
CORS는 무엇일까요?
CORS를 설정하는 방법과 원리에 대해 설명해주세요.
Q24
2077년 철수는 할아버지의 유품에서 USB 메모리를 찾았습니다. 그 안에는 비트코인 지갑이 들어있는 것으로 추정되는데 현재 사용중인 윈도우즈 77에 연결해 보니 파일을 읽을 수 없습니다."해당 파일 시스템은 지원하지 않습니다." 라는 오류 메시지가 출력되고 보관상태가 좋아 물리적인 손상은 전혀 없는 것으로 추정되는데 이 경우 어떻게 우리는 비트코인 지갑을 복구할 수 있을까요?]]></description><link>부스트캠프/멤버십/8주차/기술면접.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/기술면접.md</guid><pubDate>Sun, 02 Feb 2025 12:58:06 GMT</pubDate></item><item><title><![CDATA[[백준31784] 포닉스의 문단속]]></title><description><![CDATA[<img src="https://i.imgur.com/p4MrRmQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
N개의 다이얼이 연결된 자물쇠를 돌려서 풀어야 하는데 다이얼 중 하나를 골라 1번 돌리는 작업을 해야 하는데, K번을 돌려서 나올 수 있는 단어 중에 가장 사전순으로 앞인 단어를 찾으면 된다.내가 가진 정보는 자물쇠의 길이 N과 작업의 횟수 K
그리고 다음 줄에는 문자열 S가 주어진다
해당 문자열에서 돌려서 가장 사전순으로 작은 문자열을 만들면 된다.<br><img src="https://i.imgur.com/zSYDvvb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
예제를 보자.4 3
ABCD
의 경우, 3번을 돌려 나올 수 있는 사전순으로 가장 작은 단어는 ABCG이다.
ABC는 어차피 사전순으로 가장 앞이므로 D를 세번 돌려 D -&gt; E -&gt; F -&gt; G를 만들었다.4 5
XYZW
해당 문자열은 XYZW가 AAZW로 변했다.
X -&gt; Y -&gt; Z -&gt; A
Y -&gt; Z -&gt; A
로 총 5번을 돌렸다.이를 통해 가장 앞인 문자부터 검사해서 돌려서 만약 알파벳 앞 순위의 숫자로 변환할 수 있다면 변환하는 것을 알 수 있다.
그리디 알고리즘이 이에 대해 가장 잘 맞는 알고리즘같다.
앞문자열부터 하나씩 검사
알파벳의 아스키코드를 더했을 때 이전보다 사전순으로 앞인 알파벳이 나오면 더한다.
없으면 뒤로 돌린다
마지막에 남은 횟수를 다 돌린다.
정도로 생각할 수 있다.
]]></description><link>알고리즘/[백준31784]-포닉스의-문단속.html</link><guid isPermaLink="false">알고리즘/[백준31784] 포닉스의 문단속.md</guid><pubDate>Sat, 01 Feb 2025 02:45:38 GMT</pubDate><enclosure url="https://i.imgur.com/p4MrRmQ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/p4MrRmQ.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[알고리즘]]></title><description><![CDATA[<a data-href="[백준 1004] 어린왕자" href="알고리즘/[백준-1004]-어린왕자.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 1004] 어린왕자</a><br>
<a data-href="[프로그래머스] 방금그곡" href="알고리즘/[프로그래머스]-방금그곡.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 방금그곡</a><br>
<a data-href="[프로그래머스] 두 원 사이의 정수 쌍" href="알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 두 원 사이의 정수 쌍</a><br>
<a data-href="[프로그래머스] 행렬 테두리 회전하기" href="알고리즘/[프로그래머스]-행렬-테두리-회전하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 행렬 테두리 회전하기</a><br>
<a data-href="[프로그래머스] 주차 요금 계산" href="알고리즘/[프로그래머스]-주차-요금-계산.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 주차 요금 계산</a><br>
<a data-href="[백준 12865] 평범한 배낭" href="알고리즘/[백준-12865]-평범한-배낭.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 12865] 평범한 배낭</a><br>
<a data-href="[백준 7576] 토마토" href="알고리즘/[백준-7576]-토마토.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 7576] 토마토</a><br>
<a data-href="[프로그래머스] 석유 시추" href="알고리즘/[프로그래머스]-석유-시추.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 석유 시추</a><br>
<a data-href="[프로그래머스] 요격 시스템" href="알고리즘/[프로그래머스]-요격-시스템.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 요격 시스템</a><br>
<a data-href="[백준 9251] LCS" href="알고리즘/[백준-9251]-lcs.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 9251] LCS</a><br>
<a data-href="[백준 1912] 연속합" href="알고리즘/[백준-1912]-연속합.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 1912] 연속합</a><br>
<a data-href="[백준11631] ASCII Addition" href="알고리즘/[백준11631]-ascii-addition.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준11631] ASCII Addition</a><br>
<a data-href="[백준14596] Quilting(smaill)" href="알고리즘/[백준14596]-quilting(smaill).html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준14596] Quilting(smaill)</a><br>
<a data-href="[백준 17123] 배열 놀이" href="알고리즘/[백준-17123]-배열-놀이.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 17123] 배열 놀이</a><br>
<a data-href="[백준31784] 포닉스의 문단속" href="알고리즘/[백준31784]-포닉스의-문단속.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준31784] 포닉스의 문단속</a>]]></description><link>알고리즘/알고리즘.html</link><guid isPermaLink="false">알고리즘/알고리즘.md</guid><pubDate>Sat, 01 Feb 2025 02:34:19 GMT</pubDate></item><item><title><![CDATA[[백준 17123] 배열 놀이]]></title><description><![CDATA[<img src="https://i.imgur.com/XDa3R5Q.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">N x N의 행렬에서 [r1,c1] - [r2,c2]로 이루어진 사각형에 v를 더하면 된다
각 대각선으로 된 꼭짓점의 좌표이므로
[r1,c1] - [r1,c2] - [r2,c1] - [r2,c2] 가 각 꼭짓점인 사각형의 값들에 대해서 전부 v씩 더하면 된다.특정한 알고리즘이 딱히 필요한 것 같지는 않다const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const inputs = require("fs") .readFileSync(INPUT_FILE) .toString() .trim() .split("\n"); const t = +inputs[0]; for (let i = 1; i &lt; inputs.length; i++) { const [n, m] = inputs[i].split(" ").map(Number); const map = inputs .slice(i + 1, i + n + 1) .map((row) =&gt; row.split(" ").map(Number)); const tests = inputs .slice(i + n + 1, i + n + m + 1) .map((test) =&gt; test.split(" ").map(Number)); for (const [r1, c1, r2, c2, v] of tests) { for (let k = r1 - 1; k &lt;= r2 - 1; k++) { for (let j = c1 - 1; j &lt;= c2 - 1; j++) { map[k][j] += v; } } } const resultRow = map.map((row) =&gt; row.reduce((acc, curr) =&gt; acc + curr, 0)); const resultCol = Array(n).fill(0); //열 for (let l = 0; l &lt; n; l++) { let acc = 0; for (let h = 0; h &lt; n; h++) { acc += map[h][l]; } resultCol[l] = acc; } console.log(resultRow.join(" ")); console.log(resultCol.join(" ")); i += n + m;
} 그래서 그냥 했다
근데 시간 초과가 떴다]]></description><link>알고리즘/[백준-17123]-배열-놀이.html</link><guid isPermaLink="false">알고리즘/[백준 17123] 배열 놀이.md</guid><pubDate>Fri, 31 Jan 2025 03:14:43 GMT</pubDate><enclosure url="https://i.imgur.com/XDa3R5Q.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/XDa3R5Q.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준14596] Quilting(smaill)]]></title><description><![CDATA[두 패턴의 이미지를 포개면서, 가장 최적의 동선을 통해 부자연스러움의 정도가 가장 낮은 경계를 골라 해당 동선의 부자연스러움의 정도를 출력해야 한다.<img src="https://i.imgur.com/aR713da.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/jU8rnI2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
문제 드럽게 기네;일단 여기서 주의해야 할 점은
아래 같은 인덱스거나 +-1 의 경계까지만 움직일 수 있으므로 여기서 가장 주의를 해야한다그렇다면 맨 위에서부터 가장 최적의 동선을 골라야 할텐데, 이게 어디서 시작하느냐에 따라서도 최적의 경계가 바뀔 수도 있다. 그러므로 해당 문제는 가장 위쪽 모든 인덱스에서 출발하면서 최적의 동선을 가지는 쪽으로 움직여야 하기 때문에 dp로 풀어야 함을 알 수 있다.그렇다면 시작점을 기준으로 배열을 만든 다음, 해당 시작점에서 가지는 최소의 부자연스러움을 각각 구한다음에 그 중 최소인 부자연스러움 정도를 가지고 오면 된다.]]></description><link>알고리즘/[백준14596]-quilting(smaill).html</link><guid isPermaLink="false">알고리즘/[백준14596] Quilting(smaill).md</guid><pubDate>Wed, 29 Jan 2025 14:24:49 GMT</pubDate><enclosure url="https://i.imgur.com/aR713da.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/aR713da.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준11631] ASCII Addition]]></title><description><![CDATA[아.. 이거 전에 모 코테에서 본 문제와 비슷한 문제
그 때 제대로 풀지 못해서 멘붕 왔었는데 이번엔 제대로 풀어본다.<img src="https://i.imgur.com/xQr9x8I.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">아스키 아트는 칠해지는 부분이 x로 되어 있고, 총 7개의 row와 5개의 column으로 되어 있다.
a+b의 형태로 아스키 아트가 주어지면 이를 인식하고 이에 대한 두 수의 합을 다시 아스키 코드로 나타내야 한다.const fs = require("fs"); const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const input = fs.readFileSync(INPUT_FILE).toString().trim().split("\n"); const asciiPatterns = [ `xxxxx\nx...x\nx...x\nx...x\nx...x\nx...x\nxxxxx`, `....x\n....x\n....x\n....x\n....x\n....x\n....x`, `xxxxx\n....x\n....x\nxxxxx\nx....\nx....\nxxxxx`, `xxxxx\n....x\n....x\nxxxxx\n....x\n....x\nxxxxx`, `x...x\nx...x\nx...x\nxxxxx\n....x\n....x\n....x`, `xxxxx\nx....\nx....\nxxxxx\n....x\n....x\nxxxxx`, `xxxxx\nx....\nx....\nxxxxx\nx...x\nx...x\nxxxxx`, `xxxxx\n....x\n....x\n....x\n....x\n....x\n....x`, `xxxxx\nx...x\nx...x\nxxxxx\nx...x\nx...x\nxxxxx`, `xxxxx\nx...x\nx...x\nxxxxx\n....x\n....x\nxxxxx`, `.....\n..x..\n..x..\nxxxxx\n..x..\n..x..\n.....`,
]; const asciiToCharMap = {};
asciiPatterns.forEach((pattern, index) =&gt; { asciiToCharMap[pattern] = index === 10 ? "+" : index.toString();
}); const ROWS = 7;
const COLS = 5; const splitInput = [];
for (let i = 0; i &lt; input[0].length; i += COLS + 1) { const block = []; for (let j = 0; j &lt; ROWS; j++) { block.push(input[j].slice(i, i + COLS)); } splitInput.push(block.join("\n"));
} const expression = splitInput.map((block) =&gt; asciiToCharMap[block]).join("");
const [a, b] = expression.split("+").map(BigInt); const result = (a + b).toString(); const charToAsciiMap = Object.fromEntries( asciiPatterns.map((pattern, index) =&gt; [ index === 10 ? "+" : index.toString(), pattern, ])
); const resultAscii = Array(ROWS).fill("");
for (const char of result) { const asciiBlock = charToAsciiMap[char].split("\n"); for (let i = 0; i &lt; ROWS; i++) { resultAscii[i] += (resultAscii[i] ? "." : "") + asciiBlock[i]; }
} console.log(resultAscii.join("\n")); 응 다 노가다로 아스키 맵 만들면 그만이야~
이딴 문제 만들지좀 마라]]></description><link>알고리즘/[백준11631]-ascii-addition.html</link><guid isPermaLink="false">알고리즘/[백준11631] ASCII Addition.md</guid><pubDate>Tue, 28 Jan 2025 06:56:39 GMT</pubDate><enclosure url="https://i.imgur.com/xQr9x8I.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/xQr9x8I.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 1912] 연속합]]></title><description><![CDATA[
n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
문제에서 나온 예시로 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌을 때, 여기서 정답은 12+21인 33이 정답이 된다.해당 문제에서 주목해야 할 점은 연속된 몇 개의 수와 구할 수 있는 합 중 가장 큰 합이다.
그럼 연속된 몇 개의 수는 어떻게 구해야 하는가?
일단은 계속 배열을 돌아가면서 최대한 큰 수를 만들 수 있도록 해야 하는데 이를 기록하고 가장 큰 값을 도출해내기 위해선 동적 계획법을 통해 풀어야 함을 알았다.그렇다면 동적 계획법에서 중요한 것은 점화식인데, 어떤 식으로 점화식을 도출해 낼까?
일단 우리에게 주어지는 것은 n의 정보와 수열의 정보이다. 이를 가지고 연속된 수 중에 가장 최대한 큰 수를 계속 기록하기 위해서는 수열이 배열이라는 가정 하에 생각해보면 된다.
배열을 처음부터 끝까지 돌면서 우리는 연속된 수들을 만날 것이다. 이 연속된 수에서 우리는 기존의 누적된 값을 현재 보고 있는 값과 비교해야 한다.
여기서 중요한 점은 무조건 음수라고 해서 거기서 끊어야 하는게 아닌, 음수라고 하더라도 그 뒤에 연속되는 값을 더했을 때 가장 큰 수가 된다면 음수라도 포함할 수 있는 경우를 생각해야 한다.
그렇다면 점화식은 이전까지 누적된 값과 현재 보고 있는 값을 더했을 때와 현재 값 중에 더 큰 값을 골라야 한다. dp[n] = max(dp[n-1] + arr[n], arr[n])]]></description><link>알고리즘/[백준-1912]-연속합.html</link><guid isPermaLink="false">알고리즘/[백준 1912] 연속합.md</guid><pubDate>Tue, 07 Jan 2025 01:33:34 GMT</pubDate></item><item><title><![CDATA[학습 정리]]></title><description><![CDATA[<a data-href="쓰레드 풀이란?" href=".html" class="internal-link" target="_self" rel="noopener nofollow">쓰레드 풀이란?</a><br>
<a data-href="클로저" href="부스트캠프/챌린지/클로저.html#_0" class="internal-link" target="_self" rel="noopener nofollow">클로저</a><br>
<a data-href="sql 기본문법" href="부스트캠프/챌린지/sql-기본문법.html#_0" class="internal-link" target="_self" rel="noopener nofollow">sql 기본문법</a><br>
<a data-href="트랜잭션과 비즈니스 로직" href="부스트캠프/챌린지/트랜잭션과-비즈니스-로직.html#_0" class="internal-link" target="_self" rel="noopener nofollow">트랜잭션과 비즈니스 로직</a><br>
<a data-href="TCP-IP" href="부스트캠프/챌린지/tcp-ip.html#_0" class="internal-link" target="_self" rel="noopener nofollow">TCP-IP</a><br>
<a data-href="TELNET과 SSH" href="부스트캠프/챌린지/telnet과-ssh.html#_0" class="internal-link" target="_self" rel="noopener nofollow">TELNET과 SSH</a><br>
<a data-href="Broadcast, Unicast, Multicast" href="부스트캠프/챌린지/broadcast,-unicast,-multicast.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Broadcast, Unicast, Multicast</a><br>
<a data-href="OSI 7 Layer" href="부스트캠프/챌린지/osi-7-layer.html#_0" class="internal-link" target="_self" rel="noopener nofollow">OSI 7 Layer</a><br>
<a data-href="Pub-Sub 패턴" href="부스트캠프/챌린지/pub-sub-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Pub-Sub 패턴</a><br>
<a data-href="Observer 패턴" href="부스트캠프/챌린지/observer-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Observer 패턴</a><br>
<a data-href="DBMS와 RDBMS" href="부스트캠프/챌린지/dbms와-rdbms.html#_0" class="internal-link" target="_self" rel="noopener nofollow">DBMS와 RDBMS</a><br>
<a data-href="이벤트 루프와 비동기" href="부스트캠프/챌린지/이벤트-루프와-비동기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">이벤트 루프와 비동기</a><br>
<a data-href="ReactiveX" href="부스트캠프/챌린지/reactivex.html#_0" class="internal-link" target="_self" rel="noopener nofollow">ReactiveX</a><br>
<a data-href="가상 메모리" href="부스트캠프/챌린지/가상-메모리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">가상 메모리</a><br>
<a data-href="express+pug로 templating해서 SSR + CSR 구현하기" href="부스트캠프/멤버십/1주차/express+pug로-templating해서-ssr-+-csr-구현하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">express+pug로 templating해서 SSR + CSR 구현하기</a><br>
<a data-href="이벤트 전파와 위임에 대한 고찰" href="부스트캠프/멤버십/1주차/이벤트-전파와-위임에-대한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">이벤트 전파와 위임에 대한 고찰</a><br>
<a data-href="this 바인딩과 간접 호출" href="부스트캠프/멤버십/1주차/this-바인딩과-간접-호출.html#_0" class="internal-link" target="_self" rel="noopener nofollow">this 바인딩과 간접 호출</a><br>
<a data-href="fsd 패턴" href="부스트캠프/멤버십/2주차/fsd-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">fsd 패턴</a><br>
<a data-href="클린 코드와 코드 리뷰" href="부스트캠프/멤버십/2주차/클린-코드와-코드-리뷰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">클린 코드와 코드 리뷰</a><br>
<a data-href="MVC패턴" href="부스트캠프/멤버십/2주차/mvc패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">MVC패턴</a><br>
<a data-href="xss 공격" href="부스트캠프/멤버십/3주차/xss-공격.html#_0" class="internal-link" target="_self" rel="noopener nofollow">xss 공격</a><br>
<a data-href="sql 트리거" href="부스트캠프/멤버십/3주차/sql-트리거.html#_0" class="internal-link" target="_self" rel="noopener nofollow">sql 트리거</a><br>
<a data-href="쿠키와 세션" href="부스트캠프/멤버십/3주차/쿠키와-세션.html#_0" class="internal-link" target="_self" rel="noopener nofollow">쿠키와 세션</a><br>
<a data-href="Passport의 로컬 인증전략" href="부스트캠프/멤버십/3주차/passport의-로컬-인증전략.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Passport의 로컬 인증전략</a><br>
<a data-href="mysql Join" href="부스트캠프/멤버십/3주차/mysql-join.html#_0" class="internal-link" target="_self" rel="noopener nofollow">mysql Join</a><br>
<a data-href="aws 배포" href="부스트캠프/멤버십/3주차/aws-배포.html#_0" class="internal-link" target="_self" rel="noopener nofollow">aws 배포</a><br>
<a data-href="커스텀 에러 만들기" href="부스트캠프/챌린지/커스텀-에러-만들기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">커스텀 에러 만들기</a><br>
<a data-href="REST API" href="부스트캠프/챌린지/rest-api.html#_0" class="internal-link" target="_self" rel="noopener nofollow">REST API</a><br>
<a data-href="Node.js Libuv에 대한 고찰" href="부스트캠프/멤버십/5주차/node.js-libuv에-대한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Node.js Libuv에 대한 고찰</a><br>
<a data-href="JSX에 대해서" href="부스트캠프/멤버십/5주차/jsx에-대해서.html#_0" class="internal-link" target="_self" rel="noopener nofollow">JSX에 대해서</a><br>
<a data-href="React의 동작 단계 구현" href="부스트캠프/멤버십/5주차/react의-동작-단계-구현.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React의 동작 단계 구현</a><br>
<a data-href="React의 내부구조" href="부스트캠프/멤버십/5주차/react의-내부구조.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React의 내부구조</a><br>
<a data-href="React Fiber" href="부스트캠프/멤버십/5주차/react-fiber.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React Fiber</a><br>
<a data-href="MongoDb 설치부터 첫 시작까지" href="부스트캠프/멤버십/6주차/mongodb-설치부터-첫-시작까지.html#_0" class="internal-link" target="_self" rel="noopener nofollow">MongoDb 설치부터 첫 시작까지</a><br>
<a data-href="npm" href="부스트캠프/멤버십/6주차/npm.html#_0" class="internal-link" target="_self" rel="noopener nofollow">npm</a><br>
<a data-href="firebase functions" href="부스트캠프/멤버십/6주차/firebase-functions.html#_0" class="internal-link" target="_self" rel="noopener nofollow">firebase functions</a><br>
<a data-href="Prettier 설정하기" href="부스트캠프/멤버십/7주차/prettier-설정하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Prettier 설정하기</a><br>
<a data-href="Tailwind 설정하기" href="부스트캠프/멤버십/7주차/tailwind-설정하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Tailwind 설정하기</a><br>
<a data-href="Atomic Design" href="부스트캠프/멤버십/7주차/atomic-design.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Atomic Design</a><br>
<a data-href="배럴 파일에 대한 고찰" href="부스트캠프/멤버십/8주차/배럴-파일에-대한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">배럴 파일에 대한 고찰</a><br>
<a data-href="상태 관리를 위한 context API와 전역 상태 라이브러리에 대한 고찰" href="부스트캠프/멤버십/8주차/상태-관리를-위한-context-api와-전역-상태-라이브러리에-대한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">상태 관리를 위한 context API와 전역 상태 라이브러리에 대한 고찰</a><br>
<a data-href="NOSQL 맛보기" href="부스트캠프/멤버십/8주차/nosql-맛보기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">NOSQL 맛보기</a><br>
<a data-href="setInterval과 setTimeout" href="부스트캠프/멤버십/8주차/setinterval과-settimeout.html#_0" class="internal-link" target="_self" rel="noopener nofollow">setInterval과 setTimeout</a><br>
<a data-href="React Portal" href="부스트캠프/멤버십/8주차/react-portal.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React Portal</a><br>
<a data-href="Error boundary와 Suspense" href="부스트캠프/멤버십/8주차/error-boundary와-suspense.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Error boundary와 Suspense</a><br>
<a data-href="tree shaking과 code splitting" href="부스트캠프/멤버십/8주차/tree-shaking과-code-splitting.html#_0" class="internal-link" target="_self" rel="noopener nofollow">tree shaking과 code splitting</a><br>
<a data-href="Concurrent mode" href="부스트캠프/멤버십/8주차/concurrent-mode.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Concurrent mode</a><br>
<a data-href="React 19 베타에서 새롭게 추가된 것들" href="부스트캠프/챌린지/react-19-베타에서-새롭게-추가된-것들.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React 19 베타에서 새롭게 추가된 것들</a><br>
<a data-href="React Query" href="부스트캠프/챌린지/react-query.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React Query</a><br>
<a data-href="canvas에서의 드래그앤드롭" href="부스트캠프/멤버십/8주차/canvas에서의-드래그앤드롭.html#_0" class="internal-link" target="_self" rel="noopener nofollow">canvas에서의 드래그앤드롭</a><br>
<a data-href="브라우저의 렌더링과 캔버스" href="부스트캠프/멤버십/8주차/브라우저의-렌더링과-캔버스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">브라우저의 렌더링과 캔버스</a><br>
<a data-href="react-konva를 이용하여 원 사이 라인 그리기" href="부스트캠프/멤버십/8주차/react-konva를-이용하여-원-사이-라인-그리기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">react-konva를 이용하여 원 사이 라인 그리기</a><br>
<a data-href="react-konva를 이용하여 원 사이 충돌 방지 시키기" href="부스트캠프/멤버십/8주차/react-konva를-이용하여-원-사이-충돌-방지-시키기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">react-konva를 이용하여 원 사이 충돌 방지 시키기</a><br>
<a data-href="react-konva를 이용하여 노드 추가기능 구현하기" href="부스트캠프/멤버십/8주차/react-konva를-이용하여-노드-추가기능-구현하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">react-konva를 이용하여 노드 추가기능 구현하기</a><br>
<a data-href="Oauth2.0" href="부스트캠프/멤버십/8주차/oauth2.0.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Oauth2.0</a><br>
<a data-href="11.20 호눅스님 마스터클래스" href="부스트캠프/멤버십/8주차/11.20-호눅스님-마스터클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">11.20 호눅스님 마스터클래스</a><br>
<a data-href="React Next" href="부스트캠프/멤버십/8주차/react-next.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React Next</a><br>
<a data-href="파일 시스템" href="부스트캠프/멤버십/8주차/파일-시스템.html#_0" class="internal-link" target="_self" rel="noopener nofollow">파일 시스템</a><br>
<a data-href="SEO" href="부스트캠프/멤버십/8주차/seo.html#_0" class="internal-link" target="_self" rel="noopener nofollow">SEO</a><br>
<a data-href="리눅스 마스터 정리" href="부스트캠프/멤버십/8주차/리눅스-마스터-정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">리눅스 마스터 정리</a><br>
<a data-href="tanstack-query의 쿼리 키 관리" href="부스트캠프/멤버십/8주차/tanstack-query의-쿼리-키-관리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">tanstack-query의 쿼리 키 관리</a><br>
<a data-href="별이삼샵 UX 개선" href="부스트캠프/멤버십/8주차/별이삼샵-ux-개선.html#_0" class="internal-link" target="_self" rel="noopener nofollow">별이삼샵 UX 개선</a>]]></description><link>부스트캠프/챌린지/학습-정리.html</link><guid isPermaLink="false">부스트캠프/챌린지/학습 정리.md</guid><pubDate>Mon, 06 Jan 2025 10:18:01 GMT</pubDate></item><item><title><![CDATA[별이삼샵 UX 개선]]></title><description><![CDATA[별이삼샵은 이번에 새로운 서비스를 연말이기도 하고 토이프로젝트 겸 만든 프로젝트이다.<a data-tooltip-position="top" aria-label="https://star23sharp.site" rel="noopener nofollow" class="external-link is-unresolved" href="https://star23sharp.site" target="_self"></a><img alt="Image" src="https://i.imgur.com/6tUnFXC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
| 해당 사진을 누르면 프로젝트로 이동합니다.<br><img src="https://i.imgur.com/X9E5ceI.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이런 식으로 옛날 폴더폰 쓰던 시절의 감성을 살려 롤링페이퍼 서비스를 기획했다.
항상 연말마다 나오는 롤링페이퍼들 서비스를 보면서 나는 이전 롤링페이퍼들이 항상 공개적으로 되어있어 다른 사람이 볼 수 있다는 점을 그리 좋아하지 않았다.왜냐면 나는 친구가 없어서 얼마 오지 않은걸 공개확인사살 당하기 때문<br>
<img src="https://i.imgur.com/Z8gThEs.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그렇게 만들어진 프라이빗 롤링페이퍼는 내가 링크를 간편하게 만들고 공유하여 받은 링크를 통해 접속하고, 해당 링크에서 바로 메세지를 작성할 수 있게끔 해주어 최대한 유저가 불편하지 않도록 하였다.그렇게 만들고 제일 먼저 홍보할 사람은 주변 사람밖에 없기 때문에 그나마 있는 동아리 단톡방에 홍보를 해봤다.<br>
<img src="https://i.imgur.com/Po2TX5j.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="max-width: 100%;">
일단 메세지의 링크를 공유하면서 바로 아차! 했다.
일단 링크에 담긴 meta 태그의 썸네일이나 title, description 모두 이 링크가 무슨 링크를 의미하는지 의미하는 것을 아무것도 찾을 수 없었다.<br><img src="https://i.imgur.com/PXPX33F.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="max-width: 100%;">
그렇기에 위에처럼 처음 링크에 들어갔을 때 다짜고짜 메세지 작성만 있으니까 당황스러운 유저의 마음을 생각하지 못했었다.<br><img src="https://i.imgur.com/AqVrwrP.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/xRBz8zZ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이는 처음 맛만 보고 떠난 유저의 마음도 이랬으리라 생각한다.
그렇기 때문에 카카오톡 공유 시에 적당한 안내가 있으면 UX를 보다 개선할 수 있겠다고 생각했다.카카오톡은 메시지 API를 통해 사용자가 카카오톡 친구에게 카카오톡 메시지를 보내는 기능을 제공한다.
물론 이 기능은 일단 카카오디벨로퍼스에 자신의 서비스를 등록한 뒤 사용할 수 있다.이 메시지 API에도 두 가지 종류가 있는데, 카카오톡 공유 API와 카카오톡 메시지 API가 있다.보통 카카오톡 메시지 API의 경우는 보니 친구목록 가져오기 API를 사용해서 구현해야 하는 만큼, 카카오톡 로그인을 통해서 카카오 계정 정보를 수집하는 계정만 가능하다.우리의 서비스는 최대한 로그인과 같은 기능을 줄이려 노력하고자 소셜 로그인을 사용하지 않았고, 웬투미트와 같이 가볍게 이름과 커스텀 비밀번호만 입력하면 사용할 수 있는 방법으로 구현하였다. 그렇기에 카카오톡 공유 API가 보다 적합한 API 사용이라고 결정하였다.<br><img src="https://i.imgur.com/iihN73O.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">카카오톡 공유 API는 서비스 클라이언트에서 카카오톡 앱을 실행시켜 카카오톡 메시지를 보낼 수 있도록 한다. 사용자의 클라이언트 측에서 카카오가 제공하는 카카오톡 친구 또는 대화 목록 페이지를 띄워 사용자가 메시지를 보낼 수 있도록 하기 때문에 서비스가 카카오톡 친구 정보를 출력하는 페이지를 직접 만들 필요가 없고, 모든 카카오톡 친구가 목록에 포함된다.
대신, 카카오톡 친구 정보를 데이터로 제공하지 않기 때문에 앞서 말했듯 일부 친구를 걸러서 보여준다던지 한다는 기능은 구현할 수 없다. 카카오톡 sdk를 맨 처음 불러와야 해당 sdk를 window객체에서 가져와 사용할 수 있다. 따라서 앱의 엔트리 포인트인index.html에 스크립트로 sdk를 가져올 수 있도록 헤드에 스크립트를 추가했다.&lt;script src="https://developers.kakao.com/sdk/js/kakao.js"&gt;&lt;/script&gt;
추가적으로 sdk를 Window객체에 할당했다면 따로 타입을 정의해주어야 한다. interface Window { Kakao: any;
} .d.ts 파일은 타입을 정의(declare)하기 위해서 존재하는 파일이다.
기본적인 타입스크립트 환경에서 린팅을 기본 세팅으로 두게 된다면 script에 카카오 공유하기 관련 API를 불러온 상태이지만Window 객체는 Kakao라는 API가 불려졌는지 모르기 때문에 찾을 수 없는 프로퍼티로 나오게 된다. 그렇기 때문에 만약 기존 객체에서 확장을 하려면 따로 타입 정의를 통해 기존의 Window 객체에 카카오 API를 추가해주어야 한다.// /types/kakao.d.ts
interface Window { Kakao: any;
} 추가적으로 .d.ts 파일에 대해 이야기 해보자면 vite-env.d.ts를 만들어 readonly로 내가 가져오는 환경 변수들에 대한 타입을 미리 정의하게 되면 타입스크립트 환경에서 인텔리센스를 통해 타입을 추론할 수 있게 되고, 이를 통해 import.meta.env에서의 인텔리센스를 활성화시켜 개발자의 실수를 방지할 뿐만 아니라 사용성 또한 좋아진다./// &lt;reference types="vite/client" /&gt;
interface ImportMetaEnv { readonly VITE_APP_TITLE: string // 다른 환경 변수들에 대한 타입 정의...
} interface ImportMeta { readonly env: ImportMetaEnv
}
어느정도 api를 사용하기 위한 준비가 되었다면 이제는 해당 API를 불러 사용하기만 하면 된다.
카카오는 공유하기를 할 때, 미리 주어지는 기본 템플릿과 사용자 정의 템플릿을 사용할 수 있다.나같은 경우는 미리 사진같은 것들은 따로 리소스를 차지해야 하다 보니, 굳이 이렇게 기본 템플릿에 사진을 코드로 넣어주기 보다는 미리 카카오톡에서 필요한 리소스를 업로드하여 커스텀 템플릿으로 만든 후에 필요한 string값만 전달해줄 수 있도록 하였다.<br><img src="https://i.imgur.com/Vo501nj.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이렇게 기본 템플릿을 커스텀 해주고, 어차피 공유할 때 가는 사진은 동적으로 결정되지 않다보니, 카카오디벨로퍼스에서 설정해주었다.type ShareMessageSendProps = { receiverId: string; receiverName: string;
};
export default function shareMessageSend({ receiverName, receiverId,
}: ShareMessageSendProps) { window.Kakao.Share.sendCustom({ templateId: +import.meta.env.VITE_APP_KAKOTALK_MESSAGESEND_TEMPLATE_ID, templateArgs: { RECEIVER_NAME: receiverName, RECEIVER_ID: receiverId, }, });
} 템플릿을 만든 뒤에는 메세지를 보내는 함수를 만들었다.
templateId는 number 값으로 가야 하기 때문에 앞에 +를 붙여 타입을 변환시켜 주었다.하지만 이 API도 만약 사용자가 카카오톡 앱이 없을 경우에는 앱의 공유하기 기능을 사용할 수 없으므로 에러를 내뱉게 된다. 대부분은 카카오톡이 설치되어 있겠지만 에러를 제대로 관리하지 않을 경우 서비스가 사용 중 그대로 멈춰버릴 수도 있으므로 이러한 부분 또한 세심하게 에러를 처리해줄 필요가 있다고 생각했다. const share = async () =&gt; { try { const { title: receiverName } = await getMessageTitle(receiverId); shareMessageSend({ receiverId, receiverName }); } catch (error) { console.error(error); pushError( "예상치 못한 에러가 발생했어요. \n 잠시 후 다시 시도해 주세요.", ); } };
그래서 공유하기 버튼을 눌렀을 때, 해당 작성자의 이름을 가져오는 로직과 함께 카카오톡 공유하기 api를 호출하는 부분을 try~catch로 잡아주고, 만약 에러가 생겼을 경우, 내가 만든 커스텀 에러 모달을 띄워줄 수 있도록 했다.<br><img src="https://i.imgur.com/d3xzt7h.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">약간 만들고 나서 생각해보니 위의 로직을 가진 함수는 생각보다 템플릿 ID를 미리 인자로 꽂아넣고 사용하다보니 생각보다 사용성이 떨어진다는 생각을 하게 되었다.위와 같이 코드를 작성한다면 나중에도 카카오의 sendCustom 프로토타입 메서드를 사용할 일이 생길 때 저 코드를 전부 작성해줘야 하기 때문에 확장하기가 다소 힘든 코드 구조를 가지고 있었다. 여러 템플릿이 생긴 경우 위 코드랑 매우 유사하게 생긴 함수를 여러개 만들어야 한다는 뜻이기도 하다. 따라서 이를 조금 고쳐보기로 했다.export default function shareMessageSend( receiverName: string, receiverId: string,
) { kakaoShareCustom(+import.meta.env.VITE_APP_KAKOTALK_MESSAGESEND_TEMPLATE_ID, { RECEIVER_NAME: receiverName, RECEIVER_ID: receiverId, });
} type CustomTemplateArgs = { [key: string]: string;
}; function kakaoShareCustom( templateId: number, templateArgs: CustomTemplateArgs,
) { window.Kakao.Share.sendCustom({ templateId, templateArgs, });
} kakao api를 부르는 부분과 각각의 템플릿에 맞추어 api를 실행하는 함수를 따로 만듦으로써 내가 인자를 확인하고 각각의 커스텀 템플릿에 따라 타입 또한 검사할 수 있는 로직으로 변경하였다.하지만 요렇게 해도 결국 뭔가 코드가 더 길어졌기도 하고 그렇게 드라마틱하게 변경된 것은 없는데 빙빙 둘러 간다는 느낌만 들었다.export type ShareMessageSendLink = { RECEIVER_NAME: string; RECEIVER_ID: string;
}; export function kakaoShareCustom&lt;T&gt;(templateId: number, templateArgs: T) { window.Kakao.Share.sendCustom({ templateId, templateArgs, });
} 그래서 의존성을 아예 주입하는 방식으로 가면 어떨까? 생각해서 생각한 방향대로 리팩토링을 다시 해보았다. 각 템플릿에 맞춰 필요한 인자들의 경우만 타입으로 선언해주어 제네릭을 통해 넘겨주면 인텔리센스를 사용할 뿐만 아니라 타입 안정성까지 보장될 수 있도록 해주었다.
추가적으로 따로 템플릿별로 호출하는 함수를 둘 중간 과정이 필요없다고 생각하여 삭제했더니 코드의 수도 거의 반정도 감소했다.const share = async () =&gt; { try { const { title: receiverName } = await getMessageTitle(receiverId); kakaoShareCustom&lt;ShareMessageSendLink&gt;( +import.meta.env.VITE_APP_KAKOTALK_MESSAGESEND_TEMPLATE_ID, { RECEIVER_ID: receiverId, RECEIVER_NAME: receiverName }, ); } catch (error) { console.error(error); pushError( "예상치 못한 에러가 발생했어요. \n 잠시 후 다시 시도해 주세요.", ); } };
해당 코드를 부를 때는 제네릭으로 필요한 템플릿에 대한 인자 타입만 import 해와서 사용하고, 인자로 templateid와 해당 템플릿에 맞는 타입만 넣어주면 된다.하지만 여기서도 만족이 안 됐다,, 왜냐면 코드에 함수의 인자로 저렇게 긴 환경변수를 가져와 넣는 것이 그리 가독성이 좋아보이진 않는다고 생각했기 때문이다.export type ShareMessageSendLink = { RECEIVER_NAME: string; RECEIVER_ID: string;
}; export enum CustomShare { MESSAGESEND = +import.meta.env.VITE_APP_KAKOTALK_MESSAGESEND_TEMPLATE_ID,
} export type CustomArgs = Record&lt;keyof typeof CustomShare, any&gt; &amp; { MESSAGESEND: ShareMessageSendLink;
}; export function kakaoShareCustom&lt;K extends keyof typeof CustomShare&gt;( templateId: K, templateArgs: CustomArgs[K],
) { window.Kakao.Share.sendCustom({ templateId: CustomShare[templateId], templateArgs, });
} 조금 더 타입을 활용하여 고쳐보았다.
CustomShare라는 enum을 두고, 이 enum에 따라서 필요한 인자 값을 타입을 받는 templateId에 따른 타입을 선언해놓아 templateArgs가 커스텀 템플릿 별로 타입이 강제될 수 있도록 하였다.kakaoShareCustom("MESSAGESEND", { RECEIVER_ID: receiverId, RECEIVER_NAME: receiverName, });
그렇게 해당 함수를 고쳤더니 이런 식으로 훨씬 코드가 예뻐졌으며, 인텔리센스를 통한 자동완성또한 가능해 개발자의 실수도 보다 줄일 수 있는 좋은 코드가 되었다고 생각한다!사실 카카오 공유하기는 그렇게 빡세진 않았다. 차근차근 문서를 보면서 하면 충분히 쉽게 할 수 있는 영역이라고 생각한다.하지만 리팩토링을 시작하면서 어떻게 해야 확장성 있고, 간결하며, 사용성 있는 코드, 즉 '좋은 코드'가 될 수 있을까?에 대해서 고민하면서 쓰다보니 생각보다 내가 생각 없이 쓰던 코드도 계속해서 발전할 여지가 있었음을 알게 됐다. 타입스크립트 또한 기존의 type정도의 사용만 했었다고 생각한다. 이번에 extends를 통한 enum의 강제와 record를 사용하여 키에 매핑되는 타입의 강제 등을 새롭게 알고 적용하면서 타입스크립트를 통해 보다 간결하고 가독성 좋은 코드를 작성할 수 있게 되어 타입스크립트의 중요성 또한 몸소 깨닫게 되는 경험이었다고 생각한다.]]></description><link>부스트캠프/멤버십/8주차/별이삼샵-ux-개선.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/별이삼샵 UX 개선.md</guid><pubDate>Thu, 02 Jan 2025 15:08:10 GMT</pubDate><enclosure url="https://i.imgur.com/6tUnFXC.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/6tUnFXC.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[트러블슈팅]]></title><description><![CDATA[import NoMessage from "@/components/messages/noMessage";
import useMessageList from "@/hooks/useMessageList";
import useModal from "@/hooks/useModal";
import useObserver from "@/hooks/useObserver";
import { Message } from "@/types/message";
import { useNavigate } from "@tanstack/react-router";
import { useRef } from "react"; export default function MessageList() { const { modal: linkmodal, openModal, closeModal } = useModal(); const { data: messages, fetchNextPage, hasNextPage } = useMessageList(); const bottomRef = useRef(null); const onIntersect = ([entry]: IntersectionObserverEntry[]) =&gt; entry.isIntersecting &amp;&amp; hasNextPage &amp;&amp; fetchNextPage(); const navigate = useNavigate(); useObserver&lt;Message[]&gt;({ target: bottomRef, onIntersect, }); if (!messages.length) return ( &lt;NoMessage modal={linkmodal} openModal={openModal} closeModal={closeModal} /&gt; ); return ( &lt;div className="relative h-full w-full overflow-hidden"&gt; &lt;div className="absolute inset-0 h-full overflow-y-auto"&gt; {messages.map((message: Message, index: number) =&gt; ( &lt;div key={index} className="flex h-14 w-full items-center gap-4 border-b border-black p-2" onClick={() =&gt; navigate({ to: "/messages/$messageId", params: { messageId: message.id.toString() }, }) } &gt; &lt;span className="w-3"&gt;{index + 1}&lt;/span&gt; &lt;span className="w-full overflow-hidden text-ellipsis whitespace-nowrap"&gt; {message.body} &lt;/span&gt; &lt;/div&gt; ))} &lt;div className="h-10" ref={bottomRef}&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );
} 시바 기껏 무한스크롤 만들어 놨더니 안되네import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { TbMailDown } from "react-icons/tb";
import linkIcon from "@assets/link.png";
import MessageList from "@/components/messages/messageList";
import useModal from "@/hooks/useModal";
import LinkModal from "@/components/modals/linkModal";
import { useRoomStore } from "@/store/useRoomStore";
import { roomSignOut } from "@/api/auth.api";
import { FaChevronLeft, FaChevronRight } from "react-icons/fa6"; import useMessageList from "@/hooks/useMessageList"; export const Route = createFileRoute("/messages/")({ component: MessagesComponent,
}); function MessagesComponent() { const navigate = useNavigate(); const { modal, openModal, closeModal } = useModal(); const { data: messages, fetchNextPage, hasNextPage, hasPreviousPage, fetchPreviousPage, } = useMessageList(); const deleteToken = useRoomStore((state) =&gt; state.signOut); async function signOut() { await roomSignOut(); deleteToken(); navigate({ to: "/" }); } return ( &lt;&gt; &lt;div className="relative flex h-full w-full flex-col justify-between"&gt; &lt;header className="flex h-16 w-full items-center justify-between gap-2 border-y-2 border-black px-2 text-xl"&gt; &lt;div&gt; {hasPreviousPage &amp;&amp; ( &lt;button onClick={() =&gt; fetchPreviousPage()}&gt; &lt;FaChevronLeft /&gt; &lt;/button&gt; )} &lt;/div&gt; &lt;div className="flex gap-2"&gt; &lt;TbMailDown size={30} color="crimson" /&gt; 받은 메시지 &lt;/div&gt; &lt;div&gt; {hasNextPage &amp;&amp; ( &lt;button onClick={() =&gt; fetchNextPage()}&gt; &lt;FaChevronRight /&gt; &lt;/button&gt; )} &lt;/div&gt; &lt;/header&gt; &lt;button className="flex h-10 items-center justify-center gap-2 border-b bg-yellow-100 p-2" onClick={openModal} &gt; &lt;img src={linkIcon} alt="link" className="w-5" /&gt; 링크 공유하기 &lt;/button&gt; &lt;MessageList messages={messages} /&gt; &lt;footer className="flex h-10 w-full items-center justify-between border-y-2 border-black text-xl"&gt; &lt;button className="w-1/3" onClick={() =&gt; navigate({ to: ".." })}&gt; 홈 &lt;/button&gt; &lt;button className="w-1/3"&gt;확인&lt;/button&gt; &lt;button className="w-1/3" onClick={signOut}&gt; 나가기 &lt;/button&gt; &lt;/footer&gt; &lt;/div&gt; &lt;LinkModal openModal={openModal} closeModal={closeModal} modal={modal} /&gt; &lt;/&gt; );
} ]]></description><link>부스트캠프/멤버십/8주차/트러블슈팅.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/트러블슈팅.md</guid><pubDate>Wed, 25 Dec 2024 13:20:11 GMT</pubDate></item><item><title><![CDATA[tanstack-query의 쿼리 키 관리]]></title><description><![CDATA[우리는 서버의 상태를 관리하기 위해 Tanstack Query를 사용하게 됩니다.Tanstack Query는 caching, invalidate, refetch, prefetch등 다양한 인터페이스를 통해 개발자가 클라이언트에서 서버상태를 효과적으로 관리할 수 있게 도와줍니다. 덕분에 개발자에게 서버 상태 관리 라이브러리는 거의 선택이 아닌 필수가 되어가고 있는 듯 보입니다. (일단 저는 필수네요. 😁)앞으로의 글은 Tanstack Query를 사용하면서, 불편했던 쿼리키를 구조화하고, 이를 쉽게 구조화 해주는 함수를 통해 코드베이스에서 효과적으로 QueryKey를 관리한 방법들을 설명하고자합니다.그렇다면 QueryKey를 왜 구조화 해야할까요? QueryKey의 중요성에 대해서 간단하게 알아보겠습니다.Tanstack Query에서 queryKey는 다음과 같은 역할을 합니다.
tanstack-query에서 내부적으로 data를 queryKey와 함께 mapping해 cache를 관리합니다.
이후 query에 대한&nbsp;dependency가 변경될 때 자동으로&nbsp;refetch&nbsp;합니다.
개발자가 특정 mutation을 실행하고, 필요시 queryClient를 통해 해당 queryKey를 invalidate 시키거나, cache를 조작합니다.
요약하자면 Query Key는 서버 상태와의 연결고리로, 이를 통해 개발자는 서버 상태를 효율적으로 조회하거나 조작할 수 있습니다.이러한 Query Key를 잘못 설계하거나 관리하지 않고 사용하면,개발자는 혼란과 오류를 초래할 수 있습니다.아래의 예시를 통해 설명해 보겠습니다:const QUERY_KEYS = { LIST : ['LIST'], DETAIL : ['DETAIL']
} // 세분화가 필요없는 쿼리의 경우 이렇게 가능합니다
const { data } = useQuery({ queryKey: QUERY_KEYS.LIST, queryFn: () =&gt; fetchList()
}) const mutate = useMutation({ ... onSuccess: () =&gt; { queryClient.invalidateQuries({ queryKey : QUERY_KEYS.LIST }) }
}) // 세분화가 필요한 쿼리의 경우엔 불편함이 다가옵니다
const { data } = useQuery({ queryKey: [...QUERY_KEYS.DETAIL, id], queryFn: () =&gt; fetchDetailByID(id)
}) // 엄청 머나먼 코드의 위치! const mutate = useMutation({ ... onSuccess: () =&gt; { // 외부에서 사용할때 queryKey의 구조를 개발자가 기억해야합니다. // 앗! 실수 queryClient.invalidateQuries({ queryKey : [id, ...QUERY_KEYS.DETAIL] }) }
})
이런 경우 왜 문제가 될까요?Query Key는 배열 형태로 비교되므로, 요소의 순서가 달라지면 완전히 다른 키로 인식됩니다. 예를 들어, [..., QUERY_KEYS.DETAIL, id]와 [id, ...QUERY_KEYS.DETAIL]는 서로 다른 Query Key로 처리됩니다.위와 같이 개발자는 언제나 실수하기 마련입니다. 이러한 실수로 인해 의도치 않은 에러를 만들 가능성이 있습니다. 만약 Query Key가 일관성 없이 관리된다면, 잘못된 캐시 관리로 인해 다음과 같은 문제가 발생할 수 있습니다:
기존 캐시 데이터가 잘못된 데이터로 덮어써짐
필요하지 않은 캐시 데이터가 삭제되거나, 의도치 않은 캐시가 무효화됨
이로 인해 서버 상태관리가 불안정해질 수 있습니다.이를 방지하기 위해, Query Key를 구조화하는 것이 중요합니다. Query Key를 구조화하면 다음과 같은 이점을 얻을 수 있습니다:
일관성 유지: Query Key의 순서를 명확히 정의함으로써 키의 혼동을 방지할 수 있습니다.
가독성 향상: 구조화된 Query Key는 어떤 데이터를 가리키는지 명확히 파악할 수 있어 유지보수에 용이합니다.
오류 예방: 잘못된 키 정의로 인한 캐싱 오류를 줄일 수 있습니다.
먼저 queryKey를 구조화하기 전에 구조화가 어떻게 가능한지 살펴보겠습니다.Tanstack Query는 Query Key를 배열이나 객체로 구조화하고도 매끄럽게 일치하는 Query Key를 찾아낼 수 있습니다. 이게 가능한 이유는&nbsp;Query Cache와&nbsp;Fuzzy Matching&nbsp;때문입니다.내부적으로&nbsp;Query Cache는 직렬화된 Query Key인 key와 메타데이터를 더한 Query Data인 value로 이루어진 Javascript 객체입니다. Query Key들은&nbsp;deterministic&nbsp;한 방법으로 해시 처리되기에 key에 객체를 사용할 수 있습니다.<a data-tooltip-position="top" aria-label="https://tanstack.com/query/v4/docs/framework/react/guides/query-keys#query-keys-are-hashed-deterministically" rel="noopener nofollow" class="external-link is-unresolved" href="https://tanstack.com/query/v4/docs/framework/react/guides/query-keys#query-keys-are-hashed-deterministically" target="_self">**deterministic한 방법?</a>d**eterministic한 방법이란 객체가 들어왔을때 객체 프로퍼티의 순서에 상관없이 프로퍼티들이 동일하다면 같은 QueryKey로 보는 방법을 말합니다.export function hashQueryKeyByOptions&lt;TQueryKey extends QueryKey = QueryKey&gt;( queryKey: TQueryKey, options?: Pick&lt;QueryOptions&lt;any, any, any, any&gt;, 'queryKeyHashFn'&gt;,
): string { const hashFn = options?.queryKeyHashFn || hashKey return hashFn(queryKey)
} /** * Default query &amp; mutation keys hash function. * Hashes the value into a stable hash. */
export function hashKey(queryKey: QueryKey | MutationKey): string { return JSON.stringify(queryKey, (_, val) =&gt; isPlainObject(val) ? Object.keys(val) .sort() .reduce((result, key) =&gt; { result[key] = val[key] return result }, {} as any) : val, )
}
Tanstack Query는 일치하는 Query Key를 찾을 때&nbsp;fuzzy하게 찾습니다. 여기서&nbsp;fuzzy는 직역하면&nbsp;유사나&nbsp;흐릿으로 나오는데 예시로 설명하겠습니다.예를 들어,&nbsp;[‘A’, ‘B’, ‘C’]와 같은 Query Key가 있다고 할 때&nbsp;queryClient.invalidateQuerires&nbsp;메서드에 Query Key 인수를&nbsp;[‘A’]만 전달하여도 React Query가 찾아내는 Query Key 목록 안에&nbsp;[‘A’, ‘B’, ‘C’]가 포함됩니다.export function partialDeepEqual(a: any, b: any): boolean { if (a === b) { return true } if (typeof a !== typeof b) { return false } if (a &amp;&amp; b &amp;&amp; typeof a === 'object' &amp;&amp; typeof b === 'object') { return !Object.keys(b).some(key =&gt; !partialDeepEqual(a[key], b[key])) }
}
이 두가지 로직 덕분에 개발자는 효과적으로 Query Key를 구조화할 수 있습니다.Query Key를 체계적으로 관리하기 위한 다양한 방법들이 존재합니다. 이 중 Tanstack Query의 공식 문서와 메인테이너 블로그에서 권장하는 방법을 중심으로 살펴보겠습니다.<br>Tanstack Query의 메인테이너인 TkDodo는 <a data-tooltip-position="top" aria-label="https://tkdodo.eu/blog/effective-react-query-keys" rel="noopener nofollow" class="external-link is-unresolved" href="https://tkdodo.eu/blog/effective-react-query-keys" target="_self">자신의 블로그에서</a> 쿼리키 구조화의 중요성에 대해서 언급합니다.<br>특히, <a data-tooltip-position="top" aria-label="https://tkdodo.eu/blog/effective-react-query-keys#use-query-key-factories" rel="noopener nofollow" class="external-link is-unresolved" href="https://tkdodo.eu/blog/effective-react-query-keys#use-query-key-factories" target="_self"><strong></strong></a>Use Query Key Factories 섹션에서, Query Key를 수동으로 선언하지 않고 도메인별로 그룹화하여 Factory 패턴으로 관리할 것을 권장합니다.const todoKeys = { all: ['todos'] as const, lists: () =&gt; [...todoKeys.all, 'list'] as const, list: (filters: string) =&gt; [...todoKeys.lists(), { filters }] as const, details: () =&gt; [...todoKeys.all, 'detail'] as const, detail: (id: number) =&gt; [...todoKeys.details(), id] as const,
}
이렇게 사용하면 개발자는 각 도메인에 해당하는 Query Key를 선언적이고 일관되게 관리할 수 있습니다.// 🕺 remove everything related
// to the todos feature
queryClient.removeQueries({ queryKey: todoKeys.all
}) // 🚀 invalidate all the lists
queryClient.invalidateQueries({ queryKey: todoKeys.lists()
}) // 🙌 prefetch a single todo
queryClient.prefetchQueries({ queryKey: todoKeys.detail(id), queryFn: () =&gt; fetchTodo(id),
}) Query Key Factory를 직접 구현하는 대신, 이미 만들어진 라이브러리를 활용할 수도 있습니다.<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://tanstack.com/query/v4/docs/framework/react/community/lukemorales-query-key-factory#fine-grained-declaration-by-features" target="_self">https://tanstack.com/query/v4/docs/framework/react/community/lukemorales-query-key-factory#fine-grained-declaration-by-features</a>
import { createQueryKeyStore } from '@lukemorales/query-key-factory' export const queryKeys = createQueryKeyStore({ users: null, todos: { detail: (todoId: string) =&gt; [todoId], list: (filters: TodoFilters) =&gt; ({ queryKey: [{ filters }], queryFn: (ctx) =&gt; api.getTodos({ filters, page: ctx.pageParam }), }), },
다음과 같은 방식으로 Query Key를 구조화 해 사용할 수 있습니다.
아래의 방법은 정답이 아닙니다. 이는 다양한 접근 방식 중 하나로, Froxy팀에서 가장 사용하기 적합하다고 판단한 구조입니다.
그렇다면 이제는 저희팀에서 쿼리키를 구조화한 방식을 소개하겠습니다.Froxy서비스(또한 작성자가 생각하기에 대부분의 웹 서비스)는 복잡한 요청을 포함해 다양한 도메인에서 CRUD로직을 작성하게 됩니다. 기본적으로 서비스는 HTTP의 REST API를 통해 이를 구조화하기 때문에 이를 활용해 Query Key를 구조화 하고자 했습니다.간단한 포스팅 사이트를 생각해 봅시다. 포스팅 사이트에서는 대부분 다음과 같은 엔드포인트를 가지게 됩니다.이런 명세를 통해서 Query Key에서 사용해야하는 것들을 추려 구조화 하면 다음과 같습니다.API 명세를 기반으로 Query Key에 사용할 요소들을 추출하였으므로 이를 조합하여 API별로 고유한 Query Key 객체를 만들어 낼 수 있습니다.이제 구조화된 Query Key를 가지게 되었습니다. 이를 통해 다음과 같은 기대값을 가질 수 있습니다.
queryClinet.invalidateQueries([{ scope: ‘posts’ }])를 통해 Posts도메인의 모든 쿼리를 무효화 할 수 있습니다.
queryClient.removeQueries([{ id: 1 }])을 실행하여&nbsp;id가 1인 특정 포스트와 관련된 캐시 데이터를 전부 삭제하는 작업도 가능합니다.
Query Key를 구조화하는 작업은 일관성을 유지하고 오류를 줄이는 데 유용하지만, 개발자가 매번 수동으로 작성하는 것은 번거롭고, 실수를 유발할 가능성이 높습니다. 특히 Query Key가 복잡할수록, 이를 작성하면서 발생하는 휴먼 에러의 가능성도 커집니다.따라서 앞서 메인테이너가 언급한 것 처럼 Query Key를 구조화 시켜줄 구현체가 필요해졌습니다.어떻게 할 수 있을까요?앞선 Froxy의 Query Key 구조화 파트 도입부에서 우리는 REST API의 엔드포인트를 통해 쿼리키를 구조화해 냈습니다. 이를 활용하면 어떨까요?심지어 우리는 REST API fatch를 위한 함수를 만들면서, 필요한 정보들을 파라미터를 통해 효과적으로 선언하고 있습니다. 아래와 같은 방식을 통해서 말이죠.const PostApi = { list: (): Promise&lt;Post[]&gt; =&gt; fetch("/api/list").then((res) =&gt; res.json()), get: (id: number): Promise&lt;Post&gt; =&gt; fetch(`/api/get/${id}`).then((res) =&gt; res.json()), search: ({ keyword }: { keyword: string }): Promise&lt;Post&gt; =&gt; fetch(`/api/search?keyword=${keyword}`).then((res) =&gt; res.json()),
}; 위의 PostApi 함수는 우리가 이전에 Query Key를 구조화 하기위해 사용했던 모든 정보를 포함하고 있습니다.
scope : post 도메인 스코프로 감싸져있기 때문에 post 가 scope가 될 것입니다.
type : 각각에 타입에 맞게 우리는 PostApi의 key를 선언하고 있습니다. 그 타입에 대한 동작으로 데이터 패칭 함수를 값으로 가지고 있습니다.
data : 각각의 타입에 해당하는 데이터 패칭 함수는 데이터를 불러오기 위해 적당한 파라미터를 가지고 있습니다. 이 파라미터는 Query Key에서 사용할 정보로 충분합니다.
이제 QueryOptions Factory함수를 설계해 API 계층 코드를 활용해보겠습니다.// 인터페이스 선언
interface Post { id: number; title: string; description: string; content: string; draft: boolean; createdAt: Date;
} // API 계층 코드 const PostAPI = { list: (): Promise&lt;Post[]&gt; =&gt; fetch("/api/list").then((res) =&gt; res.json()), get: ({ id } : { id: number }): Promise&lt;Post&gt; =&gt; fetch(`/api/get/${id}`).then((res) =&gt; res.json()), search: ({ keyword }: { keyword: string }) :as Promise&lt;Post[]&gt; =&gt; fetch(`/api/search?keyword=${keyword}`).then((res) =&gt; res.json()),
}; // Query Options 생성
const PostQueryOptions = createQueryOptions("post", PostAPI); // 사용
PostQueryOptions.all().queryKey; // [{"scope": "post"}]
PostQueryOptions.type("list").queryKey; // [{"scope": "post", "type": "list"}]
PostQueryOptions.list().queryKey; // [{"scope": "post", "type": "list" }]
PostQueryOptions.get({id : 1}).queryKey; // [{"scope": "post", "type": "get", "id": 1}]
PostQueryOptions.search({ keyword: "react" }).queryKey; // [{ "scope": "post", "type": "search","keyword": "react"}]
이제는 더이상 Query를 추상화하기 위한 계층이 필요없습니다. API계층이 존재한다면, createQueryOptions를 통해 Query 계층을 간단하게 생성할 수 있습니다.앞서 구현한 factory 덕분에 Froxy팀의 코드베이스는 효과적으로 Tanstack Query와 관련된 코드를 개선할 수 있었습니다.기존에는 쿼리 설정을 추상화하는 과정에서 긴 네이밍이 필요했고, 각 쿼리마다 별도의 커스텀 훅을 작성해야 했습니다. Query Key Factory를 도입한 후, 선언적으로 옵션을 넘겨 간결하고 직관적인 코드를 작성할 수 있게 되었습니다.export function SuspenseUserLotusPagination({ page = 1 }: { page?: number }) { // 바뀌기 전에 매우 길고 끔찍한 Query Hook 네이밍 // 필요한 쿼리마다 재작성 필요 const { data: lotusList } = useUserLotusListSuspenseQuery({ page }); const navigate = useNavigate(); return ( &lt;Pagination totalPages={lotusList?.page?.max ?? 1} initialPage={page} onChangePage={(page) =&gt; navigate({ to: '/user', search: { page } })} /&gt; );
} 기존에는 쿼리에 대한 여러 설정을 추상화하기 위해 긴 네이밍을 이용했습니다.export function SuspenseUserLotusPagination({ page = 1 }: { page?: number }) { // 직관적인 네이밍과 효과적인 재사용 const { data: lotusList } = useSuspenseQuery(userQueryOptions.lotusList({ page })); const navigate = useNavigate(); return ( &lt;Pagination totalPages={lotusList?.page?.max ?? 1} initialPage={page} onChangePage={(page) =&gt; navigate({ to: '/user', search: { page } })} /&gt; );
} // 유저의 Lotus 리스트 쿼리 무효화
queryClient.invalidateQueries(userQueryOptions.type('lotusList'));
이제는 기본적인 query훅을 커스텀하지 않고 팩토리로 만들어진 option을 넘겨 사용합니다.또한 query훅 뿐만이 아닌 QueryOptions을 인터페이스로 사용하는 모든 요소에서 사용할 수 있습니다. 개발자는 하나의 options으로 직관적인 코드를 작성할 수 있게 되고, 휴먼에러를 방지할 수 있습니다.저희는 Tanstack Query를 보다 선언적으로 사용하기 위해서 React의 ErrorBoundary와 Suspense를 이용해 부수상태(pending, error)를 컴포넌트 외부에서 선언적으로 다루고 있습니다.하지만 모든 코드를 선언적인 방식으로 작성할 수 있는 것은 아닙니다. 때로는 절차적인 코드가 더 직관적이거나 부수상태를 컴포넌트 내부에서 사용해야하는 경우가 있습니다.기존에는 이를 위해서 useQuery와 useSuspenseQuery를 위한 각각의 쿼리훅을 커스텀했습니다.export const useUserQuery = () =&gt; { const query = useQuery({ queryKey: ['user'], queryFn: getUserInfo, retry: 1 }); return query;
}; export const useUserSuspenseQuery = () =&gt; { const query = useSuspenseQuery({ queryKey: ['user'], queryFn: getUserInfo }); return query;
};
둘은 같은 의도를 가진 코드이지만, 사용하는 방식이 다르다는 이유로 동시에 다른 곳에서 관리되고 있었습니다.이제는 factory를 통해 하나의 option을 가지게 되므로 사용처에서 선언해 사용하면 됩니다. const query = useQuery({ ...userQueryOptions.get({ id : 1 }) retry: 1
}); const query = useSuspenseQuery(userQueryOptions.get({ id : 1 })); 컴포넌트를 설계하다보면, UI는 동일하지만 다른 방식으로 같은 인터페이스의 데이터를 가져와야하는 경우가 존재합니다.저희 서비스에서도 사용자의 Lotus 목록을 보여주거나, Public Lotus 목록을 보여주는 등 다양한 시나리오에서 Lotus 목록을 불러와야 했습니다. 기존에는 이를 해결하기 위해 각각의 데이터 로직에 대응하는 별도의 컴포넌트를 작성해야 했습니다.\export function SuspenseLotusPagination({ page = 1 }: { page?: number }) { const { data: lotusList } = useLotusListSuspenseQuery({ page }); const navigate = useNavigate(); return ( &lt;Pagination totalPages={lotusList?.page?.max ?? 1} initialPage={page} onChangePage={(page) =&gt; navigate({ to: '/lotus', search: { page } })} /&gt; );
} export function SuspenseUserLotusPagination({ page = 1 }: { page?: number }) { const { data: lotusList } = useUserLotusListSuspenseQuery({ page }); const navigate = useNavigate(); return ( &lt;Pagination totalPages={lotusList?.page?.max ?? 1} initialPage={page} onChangePage={(page) =&gt; navigate({ to: '/user', search: { page } })} /&gt; );
} ]]></description><link>부스트캠프/멤버십/8주차/tanstack-query의-쿼리-키-관리.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/tanstack-query의 쿼리 키 관리.md</guid><pubDate>Mon, 23 Dec 2024 12:24:31 GMT</pubDate></item><item><title><![CDATA[커피챗 - 새겨둬야 할 것들]]></title><description><![CDATA[
일반적인 직장인과 비슷한 생활 흐름을 가지려 노력하기 7시 기상, 공부 시간과 점심시간 정해놓기
매일 할 일을 적어놓고 할당량을 채우지 못하면 야근(더 공부하기) 매 요일마다 해야 할 학습 내용에 대한 규칙을 세웠고 이를 수행하며, 고쳐나가기 매주 목표했던 계획과 수행이 어느 정도 달성했는가를 체크하여, 너무 많은 목표를 가져가려 해서 달성률이 낮다면 목표를 줄이고, 다 채운다면 조금 더 도전해 보는 식으로 포맷을 매주 고쳐나가기
규칙적으로 학습을 계획하고 진행 사항을 체크하는 것을 하다보면 인성 면접에서 좋은 소스가 될 수 있음 다른 사람과 프로젝트를 진행하는 것 자체가 좋은 경험
코드를 설계할 때 코드의 설계, 패키지 선정, 코드 구조등 모든 부분에 제 생각과 문제 해결 과정을 담는 것에 집중해보기
하루에 일정 시간을 사이드 프로젝트에 투자
'하니까 되던데'라는 말을 하기 보다는, 어떻게 문제를 해결했는가에 대해서 기록하기 일주일 두번정도 첫 번째 만남 각자 4~5개정도의 면접 키워드에 대한 질문을 대비하기 위해 이를 설명해주는 강의 자료 만들기
만든 자료를 공유하면서 알려주기
4~5명만 있어도 일주이렝 20개 정도의 질문에 대비할 수 있는 자료를 가질 수 있음
공유받은 자료를 가지고 학습해오기 두 번째 만남 학습해온 면접 키워드를 기반으로 4~5개의 랜덤 면접 질문을 던지고 답하기 단순 암기보다는 CS의 원리 학습에 좀 더 집중하기 원리를 하나씩 쌓아가면 추후 면접에서 제가 모르는 CS 질문이 오더라도 기억하던 원리를 기반으로 조금 더 질문이나 힌트를 유도하면서 면접에 대한 답에 다가갈 수 있음 일주일에 글 1편 쓰기를 목표로 개인 블로그 글을 작성했습니다.
기술 블로그를 작성할 때 가장 중요하게 생각한 것은 '문제 해결 역량'을 글을 작성하며 길러보는 것이었습니다. '내가 왜 이것을 문제라고 생각했는지(문제 파악 능력)'
'나는 이 문제의 원인을 어떻게 분석 했는지(문제 분석 능력)'
'문제 원인을 기반으로 어떤 해결방식을 생각해냈는지(문제 해결 능력)'
'문제 해결 결과 어떤 것을 배우고 깨달았는지(문제 극복을 통한 성장 내역)'
위 4가지 요소를 중점적으로 생각하고 글에 담아내려 했습니다. 제가 사이드 프로젝트를 운영하며 마주한 문제, 혹은 CS 스터디를 하며 깊게 탐구한 부분 등 다양한 것들을 글의 주제로 삼고 글을 작성했습니다. 이걸 왜 이렇게 풀어야 하는지에 대해서 생각하면서 풀기
반복 숙달을 통해 문제를 봤을 때 어떻게 풀어야 할 지 감을 잡기
카테고리화되는 문제들에 대해서 분석하고, 이러한 문제들이 어떤 데이터 구조를 가지고 데이터를 어떻게 도출해내는가에 대해서 생각하기
문제를 풀 때는 최대한 풀이를 보지 않고 풀기
분류는 절대 보지 않기! 답지를 보는 것과 차이 없음 내가 지금까지 해왔던 자기 개발 경험을 전부 나열해봅니다.
이렇게 정리한 항목들에서 '나의 어떤 역량'을 담고 있는지를 정리해봅니다. 계속해서 세분화 해보기 이 소재들을 활용하여 나의 역량을 설명할 수 있는 한문단의 글로 작성해보세요 '내가 왜 이것을 문제라고 생각했는지(문제 파악 능력)'
'나는 이 문제의 원인을 어떻게 분석 했는지(문제 분석 능력)'
'문제 원인을 기반으로 어떤 해결방식을 생각해냈는지(문제 해결 능력)'
'문제 해결 결과 어떤 것을 배우고 깨달았는지(문제 극복을 통한 성장 내역)' 직장에서 우리가 하는 일은 결국 '코드를 통해' 혹은 '코드로 인해' 주어진 '문제'를 해결하는 것!
그렇기 때문에 전달받은 일을 얼마나 잘 해결해 나가야 하는 것인지에 대해 고민해봐야 하는 것 흔히들 기술 블로그나 이력서를 보다보면, 단순히 기술을 사용하는 방법만 작성하는 글이 보입니다.
이것은 가진 문제 해결 역량을 담아내는 글이 아닙니다. 단순히 정보의 나열일 뿐입니다.
가능하면 글 안에서 '본인'의 생각을 담을 수 있도록 노력해보세요 나는 왜 이 기술을 사용했는가? / 나는 왜 이 문제를 해결해야 했는가?
나는 이 기술을 해결하기 위해 어떤 생각을 했는가?
어떤 실패를 거쳤는가? 등등등... 이렇게 만든 한 문단의 글을 '자시고새거 컴포넌트'처럼 사용하면서 필요한 곳에 적절히 조합하기
내 색깔을 담은 글이 보다 근거있고 좋은 평가를 받을 수 있음 '모른다'고 답변하거나 억지로 답을 찾기 보다는, 내가 왜 모르는지를 한번 분석해보기
만일 모르는 이유가 특정 정보가 부족해서라면, 그 부분을 면접관께 여쭤보며 대화의 티키타카 시도해보기 특정 정보에 대한 힌트를 부탁해서 된다면 힌트를 받고 이를 기반으로 모르는 문제에 접근해보기
모르는 주제가 나왔을 때 다음에 ~해보겠습니다 보다는 처음 들어봤는데 ~를 알려주시면 다시 고려해본 후 말씀드리겠습니다라는 식으로 힌트 요청
다른 원리들도 많이 알아야 이를 끌어와 면접에 대한 답변을 하는 과정에서 끌어올 수 있음 '개발이란 무엇일까?'에 대한 모두의 답은 다 다를 것입니다.
면접에서 확고한 '나의 개발 철학'을 가지고 이에 따라 말할 수 있다면, 다른 지원자보다 더 두드러진 모습을 보여줄수 있습니다.
무엇보다, 이러한 개발 철학을 통해 나 자신이 보다 발전할 수 있음 내가 뭘 할까에 대한 지침서가 생기는 것과 같음
내가 공부하는 방향을 잡고 계획을 세우는 과정에서 큰 도움이 됨
이를 정리해서 인성면접에서 애매한 한줄소개 하는 것보다 나의 개발철학을 말하는 것이 훨씬 좋은 점수를 받을 수 있음 '개발이란 무엇일까?', '개발 공부는 왜 하는가?'에 대해서 스스로 계속 생각해보고 자신만의 답을 찾아나가기 스타트업도 규모가 작다고 하더라도 성장 가능성이 있기 때문에 아이템에 따라서 이 스타트업이 좋은 스타트업인지 알 수 있다
좋은 사업 아이디어를 가지고 온 스타트업은 규모 수가 작아도 200명 이상 지원하는 현실
결국 좋은 스타트업을 가기 위해서도 학습이 필요하다
생각보다 스타트업에서 시작하는 것도 실무를 경험하긴 하지만 이력으로 제대로 못 쓸 가능성이 있음 당장 기능 개발이 최우선적이기 때문에 코드 퀄리티 등을 제대로 신경 쓸 시간이 없어 어렵다 스타트업은 웬만하면 갈 수 있다고 오만하게 생각하지 말자
]]></description><link>부스트캠프/멤버십/8주차/커피챗-새겨둬야-할-것들.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/커피챗 - 새겨둬야 할 것들.md</guid><pubDate>Sat, 21 Dec 2024 08:07:29 GMT</pubDate></item><item><title><![CDATA[[백준 9251] LCS]]></title><description><![CDATA[
해를 분석해서 부문제로 분할하기 부문제의 해로 큰 문제의 해를 표현(점화식)
부문제들의 해를 가지고 있는 dp table을 채우기 table에서 해를 계산하여 알고리즘의 correctness 검증
stringA : ACAYKP
stringB: CAPCAKAn과 Bm의 최장길이 공통 부문자열의 길이를 구해야 함
이를 어떻게 작은 문제들로 쪼갤 수 있을까?
LCS(i,j) =&gt; Ai과 Bj의 LCS 길이
Ai와 Bj가 서로 같다면 최장길이 공통 문자열에 추가된다.
이는 곧 이 두 문자열을 비교했을 때, 두 문자열이 서로 같다면 길이가 1 증가한다는 뜻이다.
나머지는 A1,A2,...Ai-1
B1,B2,...Bj-1
로 나뉘어 질 수 있다.
그렇다면 이 문자열들에 대해서도 계속 공통 문자열을 비교하면서 나아가면 되지 않을까?
마지막 두 문자열이 같을 때 : LCS(i,j) = LCS(i-1,j-1) + 1
라고 볼 수 있다. 하지만 마지막 두 문자열이 다를 때는 간단하게 LCS(i,j) = LCS(i-1,j-1)라고만 생각하면 안된다. 왜냐면 나중에 A의 마지막 문자열이 포함되어 있지만 B의 마지막 문자열은 포함되어 있지 않을 수 있고, B의 마지막 문자열이 포함되어 있지만 A의 마지막 문자열을 포함되어 있지 않을 수 있기 때문이다. (여기서 A,B문자열이 모두 같은 경우는 이미 아니기 때문에 제외한다)
그렇기 때문에 우리가 원하는 LCS는 LCS(i,j-1) 과 LCS(i-1,j) 중 더 길이가 긴 것으로 선택해야 한다.
그렇다면 이 LCS(i,j-1)과 LCS(i-1,j)를 미리 구해놔야 한단 소리기 때문에 dp 테이블을 만들어서 이에 대한 값을 메모이제이션 해놓으면 된다.]]></description><link>알고리즘/[백준-9251]-lcs.html</link><guid isPermaLink="false">알고리즘/[백준 9251] LCS.md</guid><pubDate>Wed, 18 Dec 2024 08:54:21 GMT</pubDate></item><item><title><![CDATA[이력서 특강]]></title><description><![CDATA[<img src="https://i.imgur.com/mgbMpzH.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/pMrIOg3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이력서와 경력 기술서의 차이
이력서
내 이력과 경험 요약
경력기술서
이력서를 보다 상세히
포트폴리오(UI가 있는 사람들)
사실 거의 비슷하지만 정확한 어원을 따라가면 위와 같은 차이<br>
<img src="https://i.imgur.com/mIjdYOj.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
향로, 원희님 등 잘 쓴 이력서를 보고 따라하기
가져온 템플릿에 내가 한 것들을 쓰기
스스로 이력서를 다듬기
원클릭 채용 플래솜에서 수백개의 서류 제출
<br><img src="https://i.imgur.com/3oKmEwB.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
아웃라이어 -&gt; 평균 기준치가 아닌 오버스펙을 가진 사람들의 이력서를 보게 됨
타인의 경험과 나의 경험의 편차가 크기 때문에 자신의 경험을 녹여내기 어려움
결과에만 집중한 방식으로는 문제점이 될 수 있음
스스로의 경험에 메타인지가 안돼있음
-&gt; 밋밋한 이력서가 되어있음
원클릭 채영 -&gt; 타게팅이 제대로 이뤄지지 않은 서류 제출 -&gt; 낮은 합격률
정확한 타게팅을 하자. 회사가 요구하는 인재가 상품의 구매, 우리는 상품. 나는 이러한 상품이예요 하는 이력서를 제출
적합성이 떨어지는 서류가 될 수밖에 없음<br><img src="https://i.imgur.com/KkYjUpj.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">가독성이 좋고 직관적인 이력서가 좋은 이력서
가독성 좋은?
글자에 대한 폰트, 간격, 폰트 처리 등 -&gt; 나의 입장
직관적인
서류검토자의 입장에서 사고의 과정을 거치냐
사고의 과정을 많이 거치면 직관적인서류가 아님
어떤 서류, 어떤 강점, 가치관 등에 대해서 바로 알 수 없으면 안됨
추상적 표현이 없고 사고가 필요없는 이력서 쓰기
<br><img src="https://i.imgur.com/KJty4H3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
자신의 역량을 핵심적으로, 객관적으로 잘한 이력서
역량 + 경험을 기준으로 서술
자신에 대한 메타인지가 너무 뛰어나서 자신의 역량을 한 페이지 안에 전부 녹여냄
<br><img src="https://i.imgur.com/6QUllIS.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
처음부터 완벽하게 쓰려고 해서
기술 블로그의 글을 처음부터 잘 쓰기 ? = 이력서와 동일
자료 조사, 내용 이해, 글 작성, 글 다듬기
많은 지원자들은 모든 과정을 생략하고 작성부터 시작
처음부터 천천히 과정에 집중해서 진행
즉각적인 피드백 -&gt; 함정
처음부터 잘 써야 하기 때문에 기술블로그를 잘 쓰려고 함
<br><img src="https://i.imgur.com/hjJxBqi.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
어디서 작성하느냐에 따라 크게 다름
템빨 -&gt; 이력서의 아이템
명확한 기준
디자인, 접슨성, 러닝커브, 버저닝, PDF추출
디자인 역량이 없는 경우가 대부분
디자인이 필요 없음 -&gt; 노션(폰트 잘돼있음)
워드 -&gt; 러닝커브
한글 쓰지마라
구글 독스 -&gt; 구글 드라이브에서 지원하는 웹페이지인데 난이도는 워드와 같음
채용 플랫폼 (랠릿,원티드, 프로그래머스) -&gt; 기능 자체가 제한적(대외활동, 구조 등)
디자인을 독창적으로 가쟈가고 싶다 -&gt; 워드, 피그마 좋지만 힘듦
노션이 심심하면 워드나 구글 독스, 노션 좀 손에 익었으면 워드와 구글독스
pdf지원이 안되면 무조건 드랍
대부분 기업에선 pdf 요구
노션 -&gt; pdf 개열받음
pdf 추출했을 때 안이쁜 플랫폼 바꾸기
keynote와 pptx도 좋지만 가로 사이즈 말고 세로 사이즈 a4로 만들기 -&gt; 출력할 때 글자가 짤리거나 작게 나오는 경우가 많음버저닝 -&gt; 아까 앞에서 타겟팅하는 것처럼 난사하지 말고 각각 요구하는 역량을 보고 각각 기업에 맞는 이력서 관리하기(네이버용, 카카오용 등)<br><img src="https://i.imgur.com/tehqc2N.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/Mcws61W.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
브레인스토밍 하둣이 내가 했던 경험 나열하기
자기 자신을 스스로가 모르는데 서류 검토자가 어케앎
결국 나 자신을 알라를 선행하기
이력서 작성 중 가장 중요
대충하게 되면 2,3,4,5단계도 어디선가 무너지게 됨
브레인스토밍하듯이 내가 했던 경험 나열
실무자라면 일일보고, 주간 보고를 찾는 것도 꿀팁
만약 일일기록을 하지 않고 있다면 지금이라도 시작하기
과거의 성과 등 모든 것들을 적기
이쁘게 할 필요가 없다
러프하고 나이브하게 A-Z까지 작성
<br><img src="https://i.imgur.com/FHD5RQ4.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내가 했던 것들을 하나하나 다 적기
모든 것들을 적기
사생활적인 것들도 다 적기
작성하면서 경험을 계속 물음표 던지면서 기억해내고 구체화하기
KPT 회고 방식 이용하기
잘했냐 못했냐가 중요한 것이 아닌 나의 경험을 작성한다는 것에만 집중
면접을 대비해서 경험을 구체화하기<br><img src="https://i.imgur.com/LW43JwM.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
추상적인 표현 한번 더 검증하기
성과. 수치, 결과를 추가
2단계에서 작성
성과가 없는 신입 ? -&gt; 서오가와 실적은 다름
성과 -&gt; 문제해결역량, 주관적인 것 내가 여기서 뭘 배웠고 뭘 이뤄냈는지 실적 -&gt; 매출, KPI 등 사용자 증가추세 등등..
상대적 수치화 -&gt; 구체적 수치화 보통 퍼센티지를 이야기 비즈니스 임팩트 기술 + 경험 + 비즈니스적인 가치를 함께 적기 <br><img src="https://i.imgur.com/34LliH6.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
50% -&gt; 퍼센티지는 추상적임
이게 어느 정도의 개선?
4초에서 2초 -&gt; 조금 더 구체적
유저 이탈율 감소 -&gt; 비즈니스적 가치
집착하지 않기
결과가 본인에게 의미 있었다면 자신있게 작성
%가 높고 낮음으로 역량을 판단하지 않음 -&gt; 궁금한 것은 문제 해결 역량
높고 낮음으로 기죽지 말기<br><img src="https://i.imgur.com/lbV4FDX.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
프로젝트 -&gt; 필수는 아님
프로젝트는 경력직인 경우에는 굳이 쓰지 않고 합침
중복되는 경우가 많기 때문 -&gt; 경력에다 합쳐버리기
경력이 없으면 프로젝트만 적기
한줄 자기소개는 마지막에 작성
강점을 정하고 경험을 작성하기
경험에서 강점을 도출하기 일단 작성하고 자기소개 작성 추천
나중에 실제 내 강점이 아닐 확률이 높음 <br><img src="https://i.imgur.com/H5J9Vq3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
최근의 경력부터 최신순 나열하기
서류검토자들은 수백장들을 보면서 익숙해져 있는데 반대로 읽히게 되면 경험이 좋지 않음
회사가 망한건데 경력이 짧아서 걱정 -&gt; 간단히 작성
아무도 뭐라하지 않음. 대신 핑계가 되게 하지 말 것
이 안에서 뭘 했는지가 중요
감안해서 볼 것임<br><img src="https://i.imgur.com/zQn24A2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
자신이 없다고 하더라도 신뢰할 수 있을까? -&gt; 주관적인 생각
지원공고에 요구하는 스택에 맞게 작성하기
자바를 원하는데 메인 스택이 파이썬이고 자바 찍먹이더라도 일단 쓰기
레벨(숙련도) ? -&gt; 요구하는 것이 아니면 먼저 작성 X 어차피 안 믿음
어차피 깊게 물어보면서 검증함 그럼에도 깊게 작성하고 ㄱ싶으면 말리진 않음
소거시킬 수도 있음
<br><img src="https://i.imgur.com/1byPaAs.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
문제 해결 역량 위주 작성
내가 여기서 어떤 문제에 부딪혔고 어떤 것을 배웠는지
단순 경험만 나열 -&gt; 이해하기 어려움
~해서 구현? -&gt; 어느 정도로 정확성 있게? 어느정도로 했길래 구현했다고 했을까 가장 추상적인 레벨
밋밋한 이력서가 되는 방법 프로젝트 설명 -&gt; 사바사 히스토리가 진짜 궁금하면 면접에서 물어봄
기술적인 핏함과 소프트스킬을 물어봄 기술적 역량과 문제 해결 역량 강조
제3자가 봐도 직관적이게 별다른 사고과정을 거치지 않아도 이해할 수 있게끔
고객관리플랫폼(제우스 프로젝트) 처럼 별칭은 괄호안에
주로 기여한 것들
<br><img src="https://i.imgur.com/kxSz6Qg.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
컨퍼런스, 오픈소스, 스터디, 자격증, 수상내역, 외부활동, 교육 등..
스터디 경험 대충 쓰지 말기
엄청난 강점으로 살릴 수 있음
<br><img src="https://i.imgur.com/h7aWFmq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
스터디를 통해 뭘 배웠고 이걸 어떻게 응용했는지
스터디만 했어도 개발에 대한 역량과 성장가능성을 많이 봄
이거를 가지고 응용력까지 가면 벽이 있음. 벽을 넘기
~학습했습니다. 이를 바탕으로 ~ 이 지원자는 단순 책을 따라한게 아니라 진짜 적용을 했네? 깃헙 레포 확인
일단 조금 먹고 들어가기 <br><img src="https://i.imgur.com/gyVyP4D.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
서술형 -&gt; 명사 종결
~향상시킴, ~을 실천,~을 담당, ~을 구현
이력서는 결국 나의 경험을 압축해서 빠르게 전달
강조가 필요한 곳에만 볼드 처리하고 명사종결로 빠르게 파악할 수 있도록 하기
볼드 -&gt; 전체 다 볼드처리하지 말기
진짜 중요한 문장, 핵심 문장, 핵심 강점 등 여기저기 다 하면 의미 퇴색
뭘 강조하고 싶은데?를 버리고 가기
<br><img src="https://i.imgur.com/06CRP6o.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
나중에 계속 경험이 쌓이면 10페이지도 넘음
신선도가 떨어진 경험은 제거 또는 함축(3~4년 이내)
지원 공고에서 요구하는 역량에 맞게 경험 선별 프레임워크에 대한 역량
프론트엔드인데 백엔드, 인프라 등 상관 없는 경험 굳이 적지 말기
진짜 궁금해할 내용인지 자문해보기 애매하면 검토자가 봐도 애매함
얼마나 많은 플젝 경험 -&gt; 지원공고와 적합한 인재인지 결국 검토자의 입장은 지원공고와 적합한 인재인가가 중요
커뮤니케이션 맞추기 <br><img src="https://i.imgur.com/LIeycXh.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
브레인스토밍 꼭꼭 하기
비즈니스 가치 -&gt; 정의하기 나름 생산성이 될 수도 있음 문제 해결 역량 -&gt; 능력치
조건문 급하게 달아서 막는 사람과 근본적인 문제를 막는 사람의 차이실제 서비스까지 오래 했던 프로젝트가 있어서 프로젝트 경험에 넣고 싶은 프로젝트가 있습니다. 이 프로젝트가 좋은 경험이기도 하지만 문제 해결 등이 제가 생각했을 때 개발을 시작한 지 얼마 안됐을 때 했던 프로젝트라 초보적인 문제 해결이나 경험들이 많아서 쓰기가 어려워지는 것 같습니다.. 이러한 프로젝트를 잘 녹여낼 수 있는 방법이 있을까요?현재 그리팅이나 나인하이어 등 간편하게 이력서를 제출하는 플랫폼이 있는 회사에 지원할 때 자소서 제출칸이 없어도 자기소개 위에 지원동기를 간단하게 적어서 제출하고 있는데 괜찮은 전략일까요??
-&gt; 지원동기를 꼭 작성하자!
작은 기업이라도 엄청 많이 지원함
인사채용하는 사람의 입장에선 얼마나 오래 있을건지에 대해서 어떻게 검증할까가 지원동기와 연결됨
지원동기가 personal하게 만들어져 있으면 호감이 생김 링크 첨부 -&gt; hooking이 되는가?가 확실해야 됨굉장히 튀는 자기소개가 아니라면 간단하게 쓰고, 절약한 공간을 나만의 장점으로 채우자 따른 사람 이름으로 바꾸었을 떄 이상하지 않으면 평범한 자기소개서
<br><img src="https://i.imgur.com/YQyS369.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Programming Language
Frontend Technologies
Database
Productivity Tools 면접에서 질문 나오면 솔직히 말하기 <br><img src="https://i.imgur.com/3wcKvgY.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
기술을 바로 위에
커버 레터 필요하면 작성
관련 없는 과거 경력 이력서에 쓸게 없으면 써야함
물경력이라고 생각한다면 다시금 생각해봐야함 면접관에게 할 수 있는 질문
<br><img src="https://i.imgur.com/tOo9whG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">문제 정의 잘하기
뜨는 기술 꼭 알아야 한다고 생각하기 보다는 나에게 맞는 업무를 성공을 하고 결과지향적으로 사는 것이 좋음
좋은 평판 -&gt; 지인 추천 형태로 기여<br>
<img src="https://i.imgur.com/34T621k.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/4IiSZgB.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
문제해결의 난이도가 작은 것 같다 -&gt; 왜 좋은 경험인지 검토자에게 설득할 수 있다면 그 관점을 기준으로 설명하기<br><img src="https://i.imgur.com/wkbfdxQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">링크로 모두 제출하기 보다는 하지 않기
대외활동 한 이유 -&gt; 내가 실무하게 되더라도 개발욕구를 해소할 수 없다고 생각해서 사이드프로젝트라는 창구를 통해 실무 협업에 필요한 새로운 기술 스택 시도
지원동기 적으면 좋음 -&gt; 왜 이 회사의 이 팀에 들어가고 싶은지문제해결
기술스택 교체 업그레이드
바꿀 수 없는 환경에서 개선을 한 케이스
캐싱 -&gt; 누구나 할 수 있음
바꿀 수 없는 환경에서 개선을 한 것이 진짜 역량이 보임
캐시를 바꾸는 것은 구글링하면 당연히 됨
캐시 이전에 다른 대안이 있지 않을까
문제 해결 과정을 좀 더 넣기
<br><img src="https://i.imgur.com/2vGpXqi.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/sVIIuda.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>부스트캠프/멤버십/8주차/이력서-특강.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/이력서 특강.md</guid><pubDate>Mon, 16 Dec 2024 11:07:15 GMT</pubDate><enclosure url="https://i.imgur.com/mgbMpzH.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/mgbMpzH.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[lambda]]></title><description><![CDATA[
서버 없이 코드를 실행해주는 서비스 사용한 시간만큼 요금 지불 다양한 언어 지원 ms 단위로 요금 부과 CPU를 장기간 사용하는 응용에는 적합하지 않음 데이터를 저장하기 위해서 별도의 DB 필요 (Dynamo, RDS, ...) Event source (Push) : S3, API GW, Cloud Watch Events Lambda Invocation (Pull) : DynamoDB, Kinesis, ... Direct Execution S3 버킷에 올라온 이미지의 썸네일 자동 작성 API GW를 통한 REST API 제공 클라우드 워치 이벤트를 통해 주기적으로 인스턴스 등의 리소스 정리 IAM Role을 이용해서 부여 Execution Permission: 람다가 사용할 수 있는 리소스에 대한 권한 Invocation Permission: 해당 리소스가 람다를 실행할 수 있는 권한 콘솔, IDE, CLI를 통해 배포 가능 ALIAS를 이용한 버전 관리 가능 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/aliases-intro.html" target="_self">https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/aliases-intro.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/with-s3-example.html" target="_self">https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/with-s3-example.html</a> 쉽게 람다 체험 가능 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://aws.amazon.com/ko/solutions/case-studies/localytics/" target="_self">https://aws.amazon.com/ko/solutions/case-studies/localytics/</a> 람다와의 조합으로 간단히 REST 서버 구축 가능 Layer 기능을 통해서 추가 콘텐츠와 기능을 쉽게 개발할 수 있음 사용자 정의 AMI 지원을 통해 필요하다면 다양한 언어 및 라이브러리 프레임워크를 사용할 수 있음 (ex: Swift Lambda, Rust Lambda, ...) Application 기능을 통해 서버리스 어플리케이션을 쉽게 구축할 수 있음 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/awslabs/aws-serverless-java-container/wiki/Quick-start---Spring-Boot" target="_self">https://github.com/awslabs/aws-serverless-java-container/wiki/Quick-start---Spring-Boot</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://epsagon.com/blog/aws-lambda-and-java-spring-boot-getting-started/" target="_self">https://epsagon.com/blog/aws-lambda-and-java-spring-boot-getting-started/</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/welcome.html" target="_self">https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/welcome.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.qwiklabs.com/focuses/10541?parent=catalog" target="_self">https://www.qwiklabs.com/focuses/10541?parent=catalog</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.qwiklabs.com/focuses/10176?parent=catalog" target="_self">https://www.qwiklabs.com/focuses/10176?parent=catalog</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://aws.amazon.com/ko/lambda/" target="_self">https://aws.amazon.com/ko/lambda/</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/welcome.html" target="_self">https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/welcome.html</a>
]]></description><link>부스트캠프/멤버십/8주차/lambda.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/lambda.md</guid><pubDate>Sun, 15 Dec 2024 17:55:52 GMT</pubDate></item><item><title><![CDATA[루카스 백업]]></title><description><![CDATA[<a data-href="상태관리 - props &amp; Context API" href="부스트캠프/멤버십/8주차/상태관리-props-&amp;-context-api.html#_0" class="internal-link" target="_self" rel="noopener nofollow">상태관리 - props &amp; Context API</a><br>
<a data-href="컴포넌트 단위 개발" href="부스트캠프/멤버십/8주차/컴포넌트-단위-개발.html#_0" class="internal-link" target="_self" rel="noopener nofollow">컴포넌트 단위 개발</a><br>
<a data-href="프레임워크 렌더링 과정" href="부스트캠프/멤버십/8주차/프레임워크-렌더링-과정.html#_0" class="internal-link" target="_self" rel="noopener nofollow">프레임워크 렌더링 과정</a><br>
<a data-href="리액트 만들기 프로젝트를 위한 문법과 패턴" href="부스트캠프/멤버십/8주차/리액트-만들기-프로젝트를-위한-문법과-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">리액트 만들기 프로젝트를 위한 문법과 패턴</a><br>
<a data-href="JS에서의 OOP" href="부스트캠프/멤버십/8주차/js에서의-oop.html#_0" class="internal-link" target="_self" rel="noopener nofollow">JS에서의 OOP</a><br>
<a data-href="history API와 리액트 라우팅" href="부스트캠프/멤버십/8주차/history-api와-리액트-라우팅.html#_0" class="internal-link" target="_self" rel="noopener nofollow">history API와 리액트 라우팅</a><br>
<a data-href="리액트 커스텀 훅" href="부스트캠프/멤버십/8주차/리액트-커스텀-훅.html#_0" class="internal-link" target="_self" rel="noopener nofollow">리액트 커스텀 훅</a><br>
<a data-href="flux &amp; useReducer" href="부스트캠프/멤버십/8주차/flux-&amp;-usereducer.html#_0" class="internal-link" target="_self" rel="noopener nofollow">flux &amp; useReducer</a><br>
<a data-href="리액트 재사용 컴포넌트" href="부스트캠프/멤버십/8주차/리액트-재사용-컴포넌트.html#_0" class="internal-link" target="_self" rel="noopener nofollow">리액트 재사용 컴포넌트</a><br>
<a data-href="리액트 테스트" href="부스트캠프/멤버십/8주차/리액트-테스트.html#_0" class="internal-link" target="_self" rel="noopener nofollow">리액트 테스트</a><br>
<a data-href="데이터 페칭과 서버 상태 관리" href="부스트캠프/멤버십/8주차/데이터-페칭과-서버-상태-관리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">데이터 페칭과 서버 상태 관리</a><br>
<a data-href="웹소켓" href="부스트캠프/멤버십/8주차/웹소켓.html#_0" class="internal-link" target="_self" rel="noopener nofollow">웹소켓</a><br>
<a data-href="리액트 최적화" href="부스트캠프/멤버십/8주차/리액트-최적화.html#_0" class="internal-link" target="_self" rel="noopener nofollow">리액트 최적화</a><br>
<a data-href="vpc" href="부스트캠프/멤버십/8주차/vpc.html#_0" class="internal-link" target="_self" rel="noopener nofollow">vpc</a><br>
<a data-href="트랜잭션" href="부스트캠프/멤버십/8주차/트랜잭션.html#_0" class="internal-link" target="_self" rel="noopener nofollow">트랜잭션</a><br>
<a data-href="오토스케일링" href="부스트캠프/멤버십/8주차/오토스케일링.html#_0" class="internal-link" target="_self" rel="noopener nofollow">오토스케일링</a><br>
<a data-href="lambda" href="부스트캠프/멤버십/8주차/lambda.html#_0" class="internal-link" target="_self" rel="noopener nofollow">lambda</a>]]></description><link>부스트캠프/멤버십/8주차/루카스-백업.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/루카스 백업.md</guid><pubDate>Sun, 15 Dec 2024 17:55:50 GMT</pubDate></item><item><title><![CDATA[오토스케일링]]></title><description><![CDATA[(1) IAM 아이디를 이용해서 AWS관리 콘솔에 로그인한다.(1) 기존 VPC에 public subnet이 두개 이하라면 추가 생성한다.subnet 이름: 아이디-pub2
AZ: 두번째 AZ 선택
CIDR 주소: 10.100.11.0/24
(2) 생성후 라우팅 테이블 탭에서&nbsp;Edit클릭 public routing table과 연결해야 한다. (1) Services- EC2 - Security Groups 선택 , Create Security Group 클릭(2) 아래와 같이 입력name: 아이디elbsg
Description: 아이디 elb sg
vpc:아이디vpc
Inbound: Add Rule 클릭 후 HTTP 선택
Create&nbsp;클릭(3) 위와 같은 방법으로 아이디websg 추가 생성, 규칙은 동일하게 생성한다.(1) EC2 - Load Balancers 선택(2) Create Load Balancer 클릭(3) Classic Load Balancer 선택, Continue 클릭(4) 다음과 같이 입력Load Balancer name: 아이디elb
Create LB Inside: 아이디vpc 선택
Internal load balancer에는 체크하지 않는다!!(5) Select Subnets 이 생기면 2개의 public subent 옆에 있는 + 단추를 클릭한다.<img src="http://public.codesquad.kr/honux/images/elb-subnet.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">(6) 보안 그룹 선택: elbsg 선택, next 두 번 클릭, Step 4로(7) Step 4에서 아래와 같이 값 입력<br><img src="http://public.codesquad.kr/honux/images/elb-health.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">(8) Step 5에서는 인스턴스를 선택하지 않는다.(9) 계속 Next 등을 눌러 Close까지 클릭.(1) 시작 템플릿을 생성한다.
(2) 우분투 리눅스, t2.micro 로 생성한다.
(3) 아래와 같이 입력Name: 아이디LC
Monitoring: Enable Cloudwatch ... 체크박스 체크
(6) Advanced Details 클릭(7) User data 아래와 같이 입력.잘 안 되면 해당 스크립트를 실행해서 웹서버가 설치된 AMI를 만들어서 사용하자.#!/bin/sh
apt -y install apache2 php unzip
cd /tmp
wget http://public.codesquad.kr/files/asg-web.zip
unzip asg-web.zip
rm /var/www/html/index.html
mv asg-web/* /var/www/html
systemctl restart apache2
IP Address: Assign a public IP address to every instances 체크(8) Next: Add Storage 클릭(9) Next: Configure security group 클릭, select an existing security group 체크후 web sg. 선택, continue 클릭(10) 시작 구성 생성을 완료한다.(1) 이어서 ASG 생성을 계속한다.name: 아이디asg
Network: 아이디vpc
Subnet: 퍼블릭 서브넷 2 추가 (2) Advanced Details 클릭 아래와 같이 선택후 next 클릭Receive traffic from load balancer 체크 Classic Load Balancers: 아이디elb 선택
(3) Use scaling polices 선택 , Scale betwwen 1 and 4 instances 선택(4) Increate Group Size 에서 Add new alarm 선택, 이후 대화상자에서 아래처림 입력후 Create Alarm 선택Send a notification checkbox 해제
Is &gt;= 60 For at : 1, 1 Minutes 선택 Name of alarm: 아이디-cpu-high 선택
<br><img src="http://public.codesquad.kr/honux/images/asg-alarm.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">(5) Create a simple scaling policy 클릭, Add 1 instances 입력한다. And then wait 값은 90으로 수정한다.(6) 같은 방식으로 Decrease Group Size 입력<br>
<img src="http://public.codesquad.kr/honux/images/asg-low.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="http://public.codesquad.kr/honux/images/asg-all.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">(7) next 등을 눌러 생성 완료(1) Auto Scaling Groups의 아이디asg 선택, 아래쪽의 Activity History를 주기적으로 관찰(2) 인스턴스 생성후 ELB의 주소로 웹 브라우져 접속(3)&nbsp;generate load를 클릭한다.(4) 1 ~ 2 분이 지난 후에 인스턴스가 추가로 생성되는지 확인한다.(5) 생성 후 잠시 더 기다리면 인스턴스가 자동으로 종료되는지도 확인한다.]]></description><link>부스트캠프/멤버십/8주차/오토스케일링.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/오토스케일링.md</guid><pubDate>Sun, 15 Dec 2024 17:55:15 GMT</pubDate><enclosure url="http://public.codesquad.kr/honux/images/elb-subnet.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;http://public.codesquad.kr/honux/images/elb-subnet.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[트랜잭션]]></title><description><![CDATA[
최종수정: 2024년 2월 14일 <img src="http://www.allthingsdistributed.com/images/jimgray.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
세계 최초의 관계형 데이터베이스 System-R 개발 트랜잭션 개념 제안 2 Phase Locking Granularity Locking 튜링상과 찰스배비지상 수상 InnoDB는 레코드 기반 저장구조
cf. column store (Amazon Redshift) RID (page #, slot #)를 통해 레코드 접근 B-tree 기반 클러스터링 인덱스 Secondary Index는 PK를 참조함 레코드 기반 잠금을 지원하지만 실제 물리적 잠금은 인덱스에 걸림 A: Atomicity
C: Consistency
I: Isolation
D: DurabilityC: Consistency
A: Availability
P: Partition Tolerence셋 모두 만족시키는 시스템은 구현할 수 없다.
(트랜잭션의 일관성과 의미가 다소 다름)많은 NoSQL은 일관성을 포기함미래의 언젠가 일관성이 보장되긴 하는데 그 시점은 정해지지 않았을 경우S3, DynamoDB등 많은 AWS 제품군이 이를 지원BA: Basically Available
S: Soft State
E: Eventual Consistency산 VS 염기??
가장 쉽게 ACID를 지원하는 방법은? 한 번에 하나씩의 트랜잭션만 실행 세 트랜잭션 A, B, C가 있을 때 한 번에 하나씩 실행했을 때 가능한 결과들의 집합
3!
실제 데이터베이스의 트랜잭션 결과가 Serial Schedule의 부분집합인 경우 Serializable이라고 함
Optimistic Concurrency Control VS Pessimistic Lock <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_self">https://en.wikipedia.org/wiki/Optimistic_concurrency_control</a> 두 개의 트랜잭션이 동시에 한 아이템의 데이터를 변경했을 때 발생하는 문제점 트랜잭션을 지원하는 데이터베이스에서는 발생하면 안 됨 한 트랜잭션에서 변경한 값을 다른 트랜잭션에서 읽을 때 발생하는 문제 <br><img src="http://public.codesquad.kr/honux/images/201707261242.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
한 트랜잭션에서 같은 값을 두 번 읽었을 때 각각 다른 값이 읽히는 경우 <br><img src="http://public.codesquad.kr/honux/images/201707261243.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
주로 통계나 분석, aggregation function 등을 수행하는 쿼리에서 잘못된 값이 들어오는 경우 <br><img src="http://public.codesquad.kr/honux/images/201707261246.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="http://public.codesquad.kr/honux/images/201707261251.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
데이터베이스마다 지원하는 레벨이 다름 MySQL과 MS-SQL은 4가지 모두 지원 MySQL default: Repeatable Read SHOW VARIABLES LIKE 'tx_isolation';
SET TRANSACTION ISOLATION LEVEL 레벨;
START TRANSACTION;
-- QUERY START
COMMIT | ROLLBACK;
READ UNCOMMITTED
READ COMMITTED
REPEATABLE READ
SERIALIZABLE
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html" target="_self">https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html</a>SELECT @@GLOBAL.transaction_isolation, @@transaction_isolation;
SET GLOBAL transaction_isolation='REPEATABLE-READ';
SET SESSION transaction_isolation='SERIALIZABLE';
READ-UNCOMMITTED
READ-COMMITTED
REPEATABLE-READ
SERIALIZABLE
MySQL의 InnoDB는 오라클과 같이 MVCC를 내부적으로 사용
업데이트 중에도 읽기가 블록되지 않는다. 읽기 내용은 격리 수준에 따라 달라질 수 있다. 업데이트시 X락이 인덱스에 걸린다. 업데이트시 락의 대상이 실제 업데이트 아이템보다 더 클 수 있다. 동시 업데이트를 수행시 나중 트랜잭샌은 블록된다. 일정 시간 지나면 Lock Timeout이 발생한다. 업데이트시 이전 값을 Undo Log로 롤백 세그먼트에 유지한다. 이 값은 롤백시와 격리 수준에 따라 다른 값을 읽기 위해 사용된다. MySQL의 기본 동작 모드 첫 번째 읽기에 스냅샷을 생성함 이후 동일 트랜잭션에서는 스냅샷에서부터 값을 읽음 잠금의 대상은 unique index, secoendary index의 유무에 따라 달라짐 커밋된 아이템을 읽을 수 있는 모드 커밋되지 않은 값은 읽을 수 없다. 같은 트랜잭션에서는 최근의 스냅샷을 읽는다. 다른 트랜잭션에서 바꾼 값이 트랜잭션 중간에도 반영된다. Read Committed와는 다른 값이 읽힐 수 있다. 일반적으로 그냥 최신 업데이트 값을 읽는다. 상당히 위험하다! MySQL에서는 모든 SELECT문에 S락이 걸린다. Repeatable Read에서도 Phantom 문제가 발생하지 않으므로 많이 사용하지 않는다. 역시나 매우 위험하다! MySQL에서는 트랜잭션 레벨에 따라 binlog 형태가 바뀐다. 이전 버전에서는 row 레벨이 용량과 성능문제가 있어서 주로 mixed나 statement를 사용했는데 5.7부터 row 레벨에 많은 개선이 있었다고 함 분산 환경에서 트랜잭션의 롤백과 커밋을 결정하는데 사용되는 프로토콜 오라클 등에서 지원 MySQL 5.7 부터 XA 트랜잭션을 지원함 추천하지는 않는다고 함 낙관적 잠금과 비관적 잠금의 동작 원리 CRDT 란 무엇인가? 분산 트랜잭션 스프링과 낙관적 잠금 WAL 프로토콜 언두 로그, 리두 로그, 체크포인트 autocommit을 끄자 (특히 JDBC 등에서 주의) 긴 트랜잭션은 데드락의 원인 배치 작업 중간에 커밋을 하자 아무것도 하지 않은 트랜잭션 및 커넥션의 주의! 트랜잭션 중간에 사용자 입력이 존재하면 안됨! 서버 모니터링은 주기적으로
]]></description><link>부스트캠프/멤버십/8주차/트랜잭션.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/트랜잭션.md</guid><pubDate>Sun, 15 Dec 2024 17:54:56 GMT</pubDate><enclosure url="http://www.allthingsdistributed.com/images/jimgray.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;http://www.allthingsdistributed.com/images/jimgray.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[vpc]]></title><description><![CDATA[2024년 11월 7일
사용자 전용의 가상 네트워크 다른 사용자 네트워크와 논리적으로 완전히 분리됨 EC2와 같은 다양한 AWS 리소스를 VPC 내에서 실행함 VPC를 더 작은 범위의 subnet으로 나눌 수 있음 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://aws.amazon.com/ko/documentation/vpc/" target="_self">https://aws.amazon.com/ko/documentation/vpc/</a> VPC가 생기기전 사용하던 단일 네트워크 망 2013년 12월 4일 이후에 만든 계정에서는 사용할 수 없음 VPC에 비해 성능 / 보안상 좋지 않으므로 migration 권장 사용자가 루트 계정을 생성하면 자동으로 각 리전당 하나씩 VPC가 생김 EC2의 경우 VPC를 지정하지 않을 경우 기본 VPC에서 인스턴스가 시작됨 기본 VPC도 삭제 가능 이전에는 사용자가 직접 생성할 수 없었으나 현재는 가능 리전 기반 서비스 subnet, ec2, eni: AZ 기반 서비스 최초 생성시 외부 통신은 완벽히 차단됨 인터넷 게이트웨이 VPC 피어링 VPG 연결 VPC Service Endpoint VPC 내부에 subnet을 가질 수 있음 리전 선택: VPC는 리전 서비스 VPC 생성 CIDR 지정: VPC에서 사용할 사설 IP 지정 VPC 이름: 구분하기 좋은 명확한 이름 인터넷 게이트웨이 생성 및 VPC에 연결 Classless Inter-Domain Routing 클래스 기반 주소의 한계를 극복하기 위해 제안 IP를 지정된 범위로 나누고 묶을 수 있음 xxx.xxx.xxx.xxx/n
xxx: IPv4 상위 n 비트: 네트워크 인식 하위 n 비트: 호스트 인식 상위 n 비트는 고정, 하위 비트는 가변적 하위 비트의 값은 0을 가져야 함 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_self">https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://docs.cloud.toast.com/ko/Infrastructure/Compute/CIDR%20Guide/" target="_self">http://docs.cloud.toast.com/ko/Infrastructure/Compute/CIDR%20Guide/</a> 56.3.26.84/32 - IP 1 개
0.0.0.0/0 - any address
10.1.0.0/16 - 65536
10.1.1.0/24 - 256
10.1.16.0/20 - 2048 vpc: 16 ~ 28 bit prefix subnet: vpc의 부분집합으로 지정 가능 subnet 사용가능 IP: 전체 범위 - 5 aws에서 앞4, 마지막 1주소를 사용함 xxx.xxx.xxx.0: 네트워크 주소
xxx.xxx.xxx.1: 게이트웨이 주소
xxx.xxx.xxx.2: 예약
xxx.xxx.xxx.3: 예약
xxx.xxx.xxx.255: 브로드캐스팅 용도 서브넷은 반드시 한 AZ에 속해야 함 서브넷은 반드시 하나의 Routing 테이블과 연결되어야 함 EC2 등의 서비스는 서브넷에 연결됨 서브넷은 VPC CIDR의 부분집합 같은 VPC 내의 서브넷끼리 CIDR 중첩 불가 서브넷마다 고유한 NACL을 가짐 서브넷에서 트래픽 플로우에 대한 규칙 지정 Destination 및 target 지정 VPC 생성시에는 기본 Route table이 생성됨 추가로 라우팅 테이블을 생성해서 subnet에 할당 가능 인터넷 게이트웨이 VGW NAT Gatewy NAT Instance VPC peering 라우팅 테이블 규칙 중&nbsp;트래픽과 일치하는 가장 구체적인 라우팅을 사용해 트래픽의 라우팅 방법을 결정 인터넷으로 연결되는 서브넷 subnet은 기본적으로 동일하나 라우팅 테이블에 의해 기능이 구분됨 <br><img src="http://public.codesquad.kr/honux/images/lec-vpc1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
인터넷으로부터의 직접 액세스가 불가능 NAT 인스턴스 또는 NAT 게이트웨어를 통해 간접적으로 인터넷 가능 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_NAT_Instance.html" target="_self">https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/VPC_NAT_Instance.html</a> 보안그룹 설정 확인 내부 방화벽 규칙 변경 (IP masquarade) EC2 인스턴스 SrcDestCheck 비활성화 private 라우팅 테이블 규칙 수정 <br><img src="http://public.codesquad.kr/honux/images/vpc-nat.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
VPN 전용 서브넷이라고도 함 인터넷 망과 완벽하게 분리됨 주로 민감 정보 저장용으로 사용 인터넷망과의 통신은 VPN을 이용해서 연결 같은 리전의 VPC끼리 직접 연결 다른 계정의 VPC와도 연결 가능 쉽고 간단<br>
<img src="http://public.codesquad.kr/honux/images/vpc-peering.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> peering 연결 생성
라우팅 테이블 수정
연결 테스트
A - peering - B
B - peering - C이 상태에서 A - C는 서로간에 통신 불가
직접 A - peering - C 연결 필요
AWS hardware VPN AWS Direct Connect AWS VPN CloudHub 소프트웨어 VPN 기타 <br><img src="http://public.codesquad.kr/honux/images/aws-vpn.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Best Practice: 라우팅 테이블, NACL, 보안그룹 모두를 사용하는 것이 좋다. 서브넷의 트래픽을 allow / deny 할 수 있음 간단한 규칙은 NACL을 통해 인스턴스의 inbound/outbound 트래픽 제어에 사용 기존 방화벽과 유사한 용도 왜 사용할까? <br><img src="http://public.codesquad.kr/honux/images/vpc-s3-end.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
서비스별로 따로 운영 테스트 환경별로 따로 운영 기능별로 VPC를 나눈다면? 웹서버 VPC, 디비 VPC, ... <br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.e-infomax.com/ipmasq/howto-trans/kr/IP-Masquerade-HOWTO-2.html" target="_self">http://www.e-infomax.com/ipmasq/howto-trans/kr/IP-Masquerade-HOWTO-2.html</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=gmIsI1PhOK4" target="_self">https://www.youtube.com/watch?v=gmIsI1PhOK4</a>]]></description><link>부스트캠프/멤버십/8주차/vpc.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/vpc.md</guid><pubDate>Sun, 15 Dec 2024 17:54:03 GMT</pubDate><enclosure url="http://public.codesquad.kr/honux/images/lec-vpc1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;http://public.codesquad.kr/honux/images/lec-vpc1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[리액트 최적화]]></title><description><![CDATA[만약 useState 의 변경으로 상태가 변경된다면, 상태에 관련있는 컴포넌트로 구성/분리한다.참고 :&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://overreacted.io/before-you-memo/" target="_self">https://overreacted.io/before-you-memo/</a>다음 코드의 문제점은?export default function App() { let [color, setColor] = useState('red'); return ( &lt;div&gt; &lt;input value={color} onChange={(e) =&gt; setColor(e.target.value)} /&gt; &lt;p style={{ color }}&gt;Hello, world!&lt;/p&gt; &lt;ExpensiveTree /&gt; &lt;/div&gt; );
} [after]export default function App() { return ( &lt;&gt; &lt;Form /&gt; &lt;ExpensiveTree /&gt; &lt;/&gt; );
} function Form() { let [color, setColor] = useState('red'); return ( &lt;&gt; &lt;input value={color} onChange={(e) =&gt; setColor(e.target.value)} /&gt; &lt;p style={{ color }}&gt;Hello, world!&lt;/p&gt; &lt;/&gt; );
}
렌더링 역할을 하는 return 안에 참조가 되는 타입(함수, 객체, 배열) 을 직접 선언하지 않는다.이렇게 되면 업데이트 될 때 값을 비교하는 코드가 있다면, 그 결과는 매번 다르다고 판단할 것이다. 따라서 다시 렌더링이 된다.return ( &lt;&gt; &lt;Title&gt;{title is..}&lt;/Title&gt; &lt;ShowPost postClick={()=&gt;{console.log('click handler')}} /&gt; &lt;/&gt;
)
위코드의 postClick은 동일한 함수임에도 매번 생성되고 있다.
postClick의 인자로 들어가는 함수를 jsx 밖에 선언하고, 함수 캐시의 활용 기회를 만들자.함수를 props로 전달할때 매번 새로운 함수가 전달될 수 있다.
매번 새로운 함수를 생성할 필요는 없기 때문에 이를 재사용하도록 구현할 수 있음.props로 함수를 전달받는 하위 컴포넌트는 새로운 props가 전달됐기 때문에 다시 렌더링 할 수 있다.새로운 함수를 계속 생성하지 않고 기존 함수를 기억해서 사용하고, 이를 props로 전달하는 것이 React에서는 권장되는 방법이다.const memoizedCallback = useCallback( () =&gt; { doSomething(a, b); }, [a, b],
);
여기서도&nbsp;두번째 인자([a,b])가 함수 재사용을 할지에 대한 조건역할을 한다.
의존성배열을 설정하지 않으면 캐시되지 않음.참고)
과연 모든 컴포넌트에 전달되는 함수를 캐시해야 하는가? 🤔
캐시된 함수를 하위컴포넌트에 전달해도 해당 컴포넌트는 렌더링을 하려고 한다. (리액트 특징)useEffect(() =&gt; { document.title = `You clicked ${count} times`;
}, [count]); // Only re-run the effect if count changes
두 번째 인자는 아래 다른 Hook에서도 콜백함수의 실행에 대한 조건으로 활용된다.=&gt;&nbsp;useEffect, useMemo, useCallback불필요하게 자기 자신을 렌더링 하지 않게 하기.아래 코드에서 ShowCountInfoMemo에 전달되는 props값은 대부분 동일하다. ShowCountInfo 컴포넌트는 매번 동일한 렌더링 결과를 만들고 있는 것으로 보인다.[App.jsx]//ShowCountInfo.jsx
const ShowCountInfo = ({postCount, pickedCount}) =&gt; { return ( &lt;div&gt; &lt;span&gt;총 {postCount}의 post 중 {pickedCount}개가 선택됐습니다.&lt;/span&gt; &lt;/div&gt; )
} //[App.jsx]
const App = () =&gt; { return ( &lt;div&gt; &lt;h1&gt; Main Page ^^ &lt;/h1&gt; &lt;ShowCountInfo postCount={posts.length} pickedCount={pickedCount}/&gt; &lt;div onClick={rerender}&gt;re-render&lt;/div&gt; &lt;div&gt;{reloadCount}&lt;/div&gt; &lt;/div&gt; ) }
} 개선이 필요하다.
React.memo 메서드를 통해서 컴포넌트 렌더링 결과를 캐시하도록 할 수 있다.[ShowCountInfoMemo.jsx]const ShowCountInfo = ({postCount, pickedCount}) =&gt; { return ( &lt;div&gt; &lt;span&gt;총 {postCount}의 post 중 {pickedCount}개가 선택됐습니다.&lt;/span&gt; &lt;/div&gt; )
} const ShowCountInfoMemo = React.memo(ShowCountInfo);
참고) 조건상황을 통해서 re-rendering을 결정할 수 있음.const PressItemMemo = React.memo(PressItem, (prev, next) =&gt; { return (prev.newsData === next.newsData)
})
먼저 props로 function을 전달하고 싶은경우에는, useCallack을 통해 한번 감싼 function을 전달한다.
전달받은 컴포넌트는 React.memo를 통해서 감싼다.
React.memo는 props가 동일하다면 다시 렌더링되지 않도록 한다.
따라서 useCallback을 통해서 동일한 props를 전달받았다면 컴포넌트가 다시 렌더링 되지 않고, 렌더링 결과를 재사용하게 된다<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://codesandbox.io/s/react-react-memo-usecallback-problem-mrrqn" target="_self">https://codesandbox.io/s/react-react-memo-usecallback-problem-mrrqn</a>
Child 컴포넌트의 불필요한 Re-rendering 확인
Child 컴포넌트에 React.memo 적용
useCallback 을 사용해보기 (의존성 배열 필요, [])
아래 코드는 무엇이 문제인가?import React, { useState, useMemo } from 'react'; const Child = ({ items }) =&gt; { const [count, setCount] = useState(0); const selectedItem = items.find((item) =&gt; { console.log('finding value'); return item === 9; }); return ( &lt;&gt; &lt;h1&gt;Count: {count} &lt;/h1&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;h1&gt;selectedItem : {selectedItem}&lt;/h1&gt; &lt;/&gt; );
}; const App = () =&gt; { const items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; return &lt;Child items={items}&gt;&lt;/Child&gt;; }; export default App; 리렌더링시 불필요한 중복계산이 일어나지 않도록 dependency 설정을 해서 캐시를 하도록 할 수 있음.
즉, 반복적인 리액트 렌더링 과정에서, 동일한 계산이 일어나는 문제를 막을 수가 있음.const selectedItem = useMemo(() =&gt; { return items.find((item) =&gt; { console.log('finding value'); return item === 9; });
}, [items]);
개발자도구-React의 Profiler 패널을 확인한다.'profiling버튼'을 눌러서 렌더링과정을 녹화한다.
몇번 실제 렌더링(commit)이 발생했는지 살펴본다. 예상과 달리 많은 렌더링이 일어나고 있지 않는지 확인한다. 매번 렌더링이 발생할때마다 동일한 렌더링이 일어나는 것은 없는지 확인한다. React.memo를 사용할때 같은 렌더링이 일어나지 않는 것도 확인할 수 있다. 특별히 오래 걸리는 컴포넌트 렌더링은 없는가? 병목이 되는 지점을 찾고 원인을 찾아본다. Profiler 중에 불필요한 component tree가 많이 보인다면 설정버튼을 눌러서, 필터링을 할 수 있다. (Context, forwardRef 등을 제거해보자)<br><img src="https://lucas-image.codesquad.kr/1716528071180react-server-components.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
서버에서 처리 가능한 부분은 서버에서 처리하되, React 문법을 사용. 서버에서 처리한 코드는 클라이언트에 내려줄 필요가 없음 -&gt; 번들링 사이즈 감소 비즈니스 로직이 많은 경우 서버컴포넌트 활용이 유리함 예시코드// Server Component
import Expandable from './Expandable'; async function Notes() { const notes = await db.notes.getAll(); return ( &lt;div&gt; {notes.map(note =&gt; ( &lt;Expandable key={note.id}&gt; &lt;p note={note} /&gt; &lt;/Expandable&gt; ))} &lt;/div&gt; )
}
서버컴포넌트의 결과(RSC Payload) 는 아래의 형식으로 전송됨<br><img alt="196c2c6dffdb1bad35a70a369c9a05d0e92e316b-1540x578" src="https://lucas-image.codesquad.kr/1716528102225196c2c6dffdb1bad35a70a369c9a05d0e92e316b-1540x578.webp" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>React.lazy 를 활용한 dynamic import (<a data-tooltip-position="top" aria-label="https://github.com/tc39/proposal-dynamic-import" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/tc39/proposal-dynamic-import" target="_self">ES Modules 스펙</a>)
TC39 stage 4( Finished ) React.lazy로 선언된 컴포넌트는 production build에서 별도 파일로 분리됨(code - splitting).
비동기 요청이 오기 전 pending상태에서 효과적으로 fallback UI(loading~~)를 효과적으로 노출 할 수 있음. 렌더링 이후 fetch가 아닌, fetch와 동시에 렌더링이 가능한 기술 <br>참고:&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://react.dev/reference/react/Suspense" target="_self">https://react.dev/reference/react/Suspense</a> 오리지날 코드import './App.css';
import { NewsListCount } from './NewsList';
import { PressNameList } from './PressNameList';
import React, { Suspense } from 'react';
import { TestComponent } from './TestComponent.jsx';
import PressDetail from './PressDetail'; function App() { return ( &lt;div className="App"&gt; &lt;TestComponent /&gt; &lt;Suspense fallback="loading..."&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;NewsListCount /&gt; &lt;PressNameList /&gt; &lt;PressDetail /&gt; &lt;/Suspense&gt; &lt;/div&gt; );
} export default App; import './App.css';
import { NewsListCount } from './NewsList';
import { PressNameList } from './PressNameList';
import React, { Suspense } from 'react';
import { TestComponent } from './TestComponent.jsx'; //lazy로 감싸주기
const PressDetailLazy = React.lazy(() =&gt; import('./PressDetail')); function App() { return ( &lt;div className="App"&gt; &lt;TestComponent /&gt; &lt;Suspense fallback="loading..."&gt; &lt;h1&gt; hello world &lt;/h1&gt; &lt;NewsListCount /&gt; &lt;PressNameList /&gt; &lt;Suspense fallback="loading..."&gt; &lt;PressDetailLazy /&gt; &lt;/Suspense&gt; &lt;/Suspense&gt; &lt;/div&gt; );
} export default App; import './App.css';
import { NewsListCount } from './NewsList';
import { PressNameList } from './PressNameList';
import React, { Suspense } from 'react';
import { useRecoilValue } from 'recoil';
import { currentDetailPressIDAtom } from './Store';
import {TestComponent} from './TestComponent.jsx';
const PressDetailLazy = React.lazy(() =&gt; import('./PressDetail')); function App() { const currentPressId = useRecoilValue(currentDetailPressIDAtom); return ( &lt;div className="App"&gt; &lt;TestComponent /&gt; &lt;Suspense fallback="loading..."&gt; &lt;h1&gt;recoil fetch test&lt;/h1&gt; &lt;NewsListCount /&gt; &lt;PressNameList /&gt; {currentPressId &amp;&amp; ( &lt;Suspense fallback="loading..."&gt; &lt;PressDetailLazy /&gt; &lt;/Suspense&gt; )} &lt;/Suspense&gt; &lt;/div&gt; );
} export default App; function App() { const [bNewFormView, toggleNewFormView] = useState(false); const MileStoneViewLazy = React.lazy(() =&gt; import('./views/MileStoneView/MileStoneView')); const GNBLazy = React.lazy(() =&gt; import('./views/GNB.js')); return ( &lt;Router&gt; &lt;Main&gt; &lt;GlobalStyle /&gt; &lt;Suspense fallback={&lt;div&gt;Loading...GNB&lt;/div&gt;}&gt; &lt;GNBLazy {...{ toggleNewFormView }} /&gt; &lt;/Suspense&gt; &lt;Route path="/labels"&gt; &lt;Content bNewFormView={bNewFormView} toggleNewFormView={toggleNewFormView} &gt;&lt;/Content&gt; &lt;/Route&gt; &lt;Route path="/milestone"&gt; &lt;Suspense fallback={&lt;div&gt;Loading...GNB&lt;/div&gt;}&gt; &lt;MileStoneViewLazy&gt;&lt;/MileStoneViewLazy&gt; &lt;/Suspense&gt; &lt;/Route&gt; &lt;/Main&gt; &lt;/Router&gt; );
} 상태 업데이트를 "transition"으로 처리하여, 우선순위가 낮은 업데이트로 처리되도록 함 끊김없는 UX가능(Interruptible ) 사용자 인터페이스가 즉각적인 응답성을 유지하면서도, 배경에서 상태 업데이트가 처리. 언제 사용하지? 다른 UX에게 양보하고 싶을때. 불필요한 loading indicator 를 노출하지 않고 싶을때 특정 상태의 업데이트를 지연시켜서 자식 컴포넌트에 전달. 이로 인해 고빈도 상태 업데이트가 UI 렌더링에 미치는 영향을 줄임. 반복적인 상태 업데이트시 최종상태만 반영. 예를 들어, 입력창의 반복적인 빠른 업데이트가 다른 복잡한 컴포넌트의 렌더링을 방해하지 않도록 할 때 유용. 언제 사용하지? 빈번한 업데이트가 많아서 UX에 방해가 될때. 렌더링을 아예 지연시켜 버린다. 이런점에서 transition 보다 더 성능상 유리하게 동작할 수 있음. 베스트 : 아무것도 하지 않는다. 현실적인 선택 : 덜 일한다. 첫 페이지 왜 이렇게 느림? Core Web Vitals First Contentful Paint Lagest Contentful Paint <br><a data-tooltip-position="top" aria-label="https://web.dev/static/articles/cls/video/web-dev-assets/layout-instability-api/layout-instability2.webm?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://web.dev/static/articles/cls/video/web-dev-assets/layout-instability-api/layout-instability2.webm?hl=ko" target="_self">Cumulative Layout Shift</a> 왜 이렇게 늦게 반응함? Core Web Vitals <br><a data-tooltip-position="top" aria-label="https://web.dev/static/articles/inp/video/jL3OLOhcWUQDnR4XjewLBx4e3PC3/WSmcjiQC4lyLxGoES4dd.mp4?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://web.dev/static/articles/inp/video/jL3OLOhcWUQDnR4XjewLBx4e3PC3/WSmcjiQC4lyLxGoES4dd.mp4?hl=ko" target="_self">Interaction to Next Paint</a> 왜 이렇게 끊김? 애니메이션 **- 첫 페이지 로딩을 빠르게 하기
훌륭한 반응 부드럽게 이어져보이기 ** 진단 &gt; 개선 &gt; 테스트 &gt; 진단
진단 어디가 왜 얼마큼 느린가? 어느 인터랙션이 사용자에게 중요한 가치를 주는가? 정량적인 지표는 얼마인가? 어떻게 진단하는가? 크롬 개발자도구 - lighthouse 크롬 개발자도구 - performance, memory(누수는 없나?) pagespeed insights 개선 테스트 side effect는 없는가? 진단 어디가 얼마큼 빨라졌는가? 바닐라 JavaScript나 Framework 기반 프로젝트에서 성능 개선의 원리는 유사함
SPA에서는 로딩 지연, 반응 지연, 애니메이션 문제는 Framework와 관계없이 발생 가능Framework는 개발 생산성을 높이는 데 초점이 맞춰져 있으므로 내부 최적화 로직이 포함되어 있음
그러나 최적화에 대한 구체적인 책임은 여전히 개발자에게 있음불필요한 코드와 의존성을 줄이는 것이 기본
성능 병목 구간을 지속적으로 모니터링하고, 적절한 도구와 전략을 활용하여 개선
HTML Parsing 방해하지 않기 script&nbsp;위치 조정 (body 끝으로 이동) defer/async&nbsp;속성 활용 Build를 통한 코드 최적화 코드 압축 (minification) 및 번들링 코드 스플리팅 (Code Splitting) Vite,&nbsp;ESBuild와 같은 최신 빌드 도구 활용 클라이언트 동적 렌더링 피하기 Server-Side Rendering (SSR) <br>Pre-Rendering (예:&nbsp;<a data-tooltip-position="top" aria-label="https://www.npmjs.com/package/prerender-loader" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.npmjs.com/package/prerender-loader" target="_self">prerender-loader</a>) Static Site Generation (SSG)&nbsp;활용 가능 여부 확인 Lazy Loading Lazy Component Loading (Dynamic JS Loading) Image Lazy Loading (loading="lazy") IntersectionObserver API&nbsp;활용 HTTP Header의 속성 활용 Cache-Control (max-age,&nbsp;no-cache,&nbsp;no-store) Expires (캐시 만료 시간) Last-Modified / If-Modified-Since (마지막 갱신 시간) ETag&nbsp;활용: 리소스 변경 여부를 서버에서 판단 서버가 리소스를 제공할 때 ETag 값을 생성해 응답 헤더에 포함 (ETag: "abc123") 브라우저는 이후 요청에서 If-None-Match 헤더에 ETag 값을 포함 (If-None-Match: "abc123") 서버는 ETag를 비교 (값이 같으면 리소스가 변경되지 않았으므로 304 Not Modified를 반환) 이미지 최적화 WebP, AVIF 포맷으로 이미지 변환 WOFF2 폰트 활용: WOFF보다 더 작은 크기로 압축 가능 기존 폰트 파일을 WOFF2로 변환하여 로딩 속도 개선 메인 스레드 Blocking 방지 DOM 수정 최소화 (Reflow와 Repaint 단계 제거 노력) Reflow 줄이기 Composite 단계에서 동작하도록 GPU 가속 속성 사용 3D Transform (translate3d) Video/Canvas 요소 활용 transform/opacity&nbsp;기반 CSS 애니메이션 (Keyframes, Transition) will-change&nbsp;속성 적용 중복 계산 줄이기 Memoization (useMemo) 네트워크 요청 캐시 전략 Service Worker 및 PWA를 활용한 캐싱 <br><a data-tooltip-position="top" aria-label="https://developers.google.com/web/fundamentals/primers/service-workers#%EC%9A%94%EC%B2%AD_%EC%BA%90%EC%8B%9C_%EB%B0%8F_%EB%B0%98%ED%99%98" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/web/fundamentals/primers/service-workers#%EC%9A%94%EC%B2%AD_%EC%BA%90%EC%8B%9C_%EB%B0%8F_%EB%B0%98%ED%99%98" target="_self">참고</a> Cache Header 전략 Prefetch 및 Preload 활용 Preload 사용&nbsp;: 특정 리소스가 사용될 것을 확실히 알고 있을 때, 브라우저가 이를 우선적으로 다운로드 &lt;link rel="preload" href="/styles/main.css" as="style"&gt;
&lt;link rel="preload" href="/scripts/main.js" as="script"&gt; Prefetch 사용&nbsp;: 예측 로딩이나 사용자가 다음에 필요할 리소스를 미리 로드할 때 사용. &lt;link rel="prefetch" href="/images/background.jpg"&gt; TLS 암호화 통신 Keep-Alive 기본 제공 (TCP 연결 재사용) XMLHttpRequest 리소스 우선순위 없이 다운로드 헤더 크기 증가 동시성을 위해 여러 개의 연결(connection) 필요 HTTP/2.0의 스트림-프레임 관계 여러 개의 스트림을 동시에 전송 가능 각 스트림은 다수의 프레임으로 구성 예: 스트림 1 → 프레임 A, B, C 스트림 2 → 프레임 X, Y, Z 프레임은 독립적으로 전송되며 고유 ID를 가짐 스트림과 프레임의 독립적 처리를 통해 병렬 데이터 전송 가능 기능 개선 다중 요청/응답 처리 (Multiplexing) 헤더 필드 압축 (HPACK) Server Push 지원 QUIC 프로토콜 기반 UDP 위에서 동작하며 TCP의 오버헤드를 제거 3-way Handshake 생략 패킷 손실 복구를 위해&nbsp;패킷 재전송 및 일련번호 지정 병렬 처리 강화 여러 개의 요청과 응답이 하나의 연결에서 동시에 처리 프레임 단위로 분리된 UDP 패킷 사용 HTTP/3 적용 사례 주요 CDN 제공자들이 HTTP/3 지원 (Cloudflare, AWS CloudFront 등) ]]></description><link>부스트캠프/멤버십/8주차/리액트-최적화.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/리액트 최적화.md</guid><pubDate>Sun, 15 Dec 2024 17:51:22 GMT</pubDate><enclosure url="https://lucas-image.codesquad.kr/1716528071180react-server-components.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://lucas-image.codesquad.kr/1716528071180react-server-components.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[웹소켓]]></title><description><![CDATA[
IP (Internet Protocol): 데이터를 목적지까지 전달하는 역할. TCP는 IP 위에서 작동하며, 데이터를 패킷으로 나누어 전송한 후 수신 측에서 이를 재조립. TCP (Transmission Control Protocol): 데이터 전송의 신뢰성을 보장. HTTP (Hypertext Transfer Protocol): 요청-응답 기반의 단방향 통신 프로토콜. 클라이언트가 요청을 보내면 서버가 응답하는 구조로, 정적 콘텐츠 로드, 폼 데이터 전송, API 호출 등 일회성 요청에 적합. 요청-응답 구조: 클라이언트가 요청을 보내고 서버가 응답하는 방식으로, 요청마다 새 연결을 설정하고 데이터를 주고받음. 무상태성: HTTP는 기본적으로 각 요청이 독립적. 상태를 유지하려면 세션이나 쿠키와 같은 추가 작업이 필요. 실시간 통신의 필요성이 커지면서 2011년에 WebSocket이 표준화. WebSocket은 이 TCP를 기반으로 작동하며, 데이터가 순서대로 전송되도록 하고 오류가 발생할 경우 자동으로 복구. HTTP 핸드셰이크로 연결을 시작하고, 이후 TCP 소켓을 통해 연결을 지속하며 양방향 데이터 전송. 실시간 데이터 교환이 중요한 애플리케이션에 적합. <img src="https://assets.apidog.com/blog/2023/05/websocket-vs-http.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
실시간 채팅 애플리케이션 실시간 게임 실시간 협업 도구 (예: 공동 문서 편집) 실시간 데이터 스트리밍 (예: 라이브 스포츠 중계) 장점 낮은 지연 시간, 실시간 데이터 교환에 최적화됨 효율적인 데이터 전송, 헤더 오버헤드 감소 클라이언트와 서버가 동시에 데이터를 주고받을 수 있음 단점 지속적인 연결로 인한 서버 자원 소모 구현 복잡성 증가 일부 방화벽이나 프록시에서 차단될 수 있음 const socket = new WebSocket('ws://192.168.55.28:8080'); form.addEventListener('submit', function (e) { e.preventDefault(); if (input.value) { const message = { clientId: clientId, message: input.value } socket.send(JSON.stringify(message)); input.value = ''; } });
<br><img src="https://lucas-image.codesquad.kr/1730971296773socket-debug-overview.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
클라이언트가 서버로 요청 전송 Sec-WebSocket-Key와 함께 WebSocket 연결 요청을 보냄. 서버가 Sec-WebSocket-Accept 생성 후 응답 서버는 클라이언트가 보낸 키를 이용해 Sec-WebSocket-Accept 헤더 값을 생성하고 응답 클라이언트의 검증: 클라이언트는 서버의 응답 값을 확인하고 일치하면 WebSocket 연결이 성립 EIO=4: Socket.IO 프로토콜 버전( 4.x 프로토콜 사용) transport=websocket: 현재 전송 방식을 지정. sid=1kbDBngrZ9P44RmsAAAl: 세션 ID로, 서버에서 각 클라이언트를 식별하기 위해 부여하는 고유 ID socket.onmessage = function (event) { const item = document.createElement('li'); event.data.text().then((text) =&gt; { let {clientId, message}= JSON.parse(text) if(clientId === myId) { item.classList.add('mine'); } else { message = `${clientId}: ${message}`; } item.textContent = message; messages.appendChild(item); window.scrollTo(0, document.body.scrollHeight); }); };
const WebSocket = require('ws');
const express = require('express');
const app = express();
const server = require('http').createServer(app); const wsServer = new WebSocket.Server({ server }); wsServer.on('connection', function connection(ws) { ws.on('message', function incoming(message) { // 받은 메시지를 모든 클라이언트에게 전송 console.log('received: %s', message); wsServer.clients.forEach(function each(client) { if (client.readyState === WebSocket.OPEN) { client.send(message); } }); });
}); app.use(express.static('public')); const PORT = process.env.PORT || 8080;
server.listen(PORT, () =&gt; console.log(`Server is running on http://localhost:${PORT}`)); import React, { useEffect, useRef } from 'react'; const Canvas = () =&gt; { const canvasRef = useRef(null); const socketRef = useRef(null); useEffect(() =&gt; { socketRef.current = new WebSocket('ws://localhost:8080'); socketRef.current.onmessage = (event) =&gt; { const { x, y } = JSON.parse(event.data); draw(x, y); }; return () =&gt; socketRef.current.close(); }, []); const draw = (x, y) =&gt; { const canvas = canvasRef.current; const ctx = canvas.getContext('2d'); ctx.fillStyle = 'black'; ctx.fillRect(x, y, 2, 2); }; const handleMouseMove = (event) =&gt; { const x = event.clientX; const y = event.clientY; draw(x, y); socketRef.current.send(JSON.stringify({ x, y })); }; return &lt;canvas ref={canvasRef} width={800} height={600} onMouseMove={handleMouseMove} /&gt;;
}; export default Canvas; 네트워크 탭 활용: 브라우저 개발자 도구의 네트워크 탭에서 WebSocket 연결 상태와 전송되는 데이터를 실시간으로 모니터링할 수 있음. WebSocket 프레임(Frame) 탭에서 주고받는 메시지를 확인하여 데이터 흐름을 파악 콘솔 로그: 클라이언트와 서버의 소켓 연결, 송수신 이벤트를 콘솔에 출력해 통신이 정상적으로 이루어지는지 확인. <br><img alt="Vite___React" src="https://lucas-image.codesquad.kr/1731240987864Vite___React.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
WebSocket 통신에서도 CORS 오류가 발생할 수 있음. 특히 클라이언트와 서버가 다른 도메인에 있을 경우 브라우저에서 WebSocket 연결을 차단할 수 있음. socket.io에서는 서버에서 CORS 옵션을 추가하여 해결할 수 있음. const io = require('socket.io')(3000, {
cors: { origin: "http://localhost:3001", methods: ["GET", "POST"]
}
});
보안이 필요한 WebSocket 통신에서는&nbsp;wss://&nbsp;프로토콜을 사용해 TLS 암호화를 적용할 수 있음.
애플리케이션 코드에서 TLS 설정:&nbsp;wss://를 지원하려면 애플리케이션 코드에서 HTTPS 서버를 설정하고 WebSocket 서버를 그 위에 구성. const https = require('https');
const WebSocket = require('ws');
const server = https.createServer({ cert: fs.readFileSync('path/to/cert.pem'), key: fs.readFileSync('path/to/key.pem')
});
const wss = new WebSocket.Server({ server }); 프록시 서버 이용 (대안) Nginx와 같은 웹 서버에서 TLS를 설정해 WebSocket을&nbsp;wss://로 보호할 수도 있음. WebSocket은 HTTP 핸드셰이크를 통해 연결을 설정하므로, 이 과정에서 JWT 토큰을 함께 전송하여 서버가 클라이언트를 식별. WebSocket의&nbsp;URL 쿼리 파라미터나&nbsp;헤더에 JWT 토큰을 포함하여 전송. 서버는 핸드셰이크 요청에 포함된 JWT 토큰을 확인하고, 유효한 경우 WebSocket 연결을 허용. 서버는 JWT 토큰을 검증하여 해당 사용자의 식별 정보(예: user ID)를 추출하고, 이후 클라이언트와의 통신에 사용. const jwtToken = "your-jwt-token"; //대충 클라에서 저장중인 토큰 // WebSocket 연결 시 토큰을 쿼리 파라미터로 포함하여 전송
const socket = new WebSocket(`ws://localhost:8080/chat?token=${jwtToken}`); 클라이언트는 WebSocket 연결 시 JWT 토큰을 쿼리 파라미터로 전송. 서버는 WebSocket 핸드셰이크 요청에서 쿼리 파라미터로 전달된 JWT 토큰을 추출 &amp; 검증 토큰이 유효하면 해당 사용자 정보(userId)를 활용하여 메시지를 주고받을 수 있음. WebSocket 프로토콜은 연결 상태를 유지하기 위해&nbsp;Ping/Pong&nbsp;프레임을 주고받기.
Ping: 클라이언트나 서버에서 주기적으로 보내는 연결 체크 메시지 Pong: Ping에 대한 응답으로, 연결이 여전히 유효하다는 것을 확인하는 데 사용. 사용 시점: Ping 메시지를 주기적으로 보내고, 일정 시간 내에 Pong 응답을 받지 못하면 연결이 끊어진 것으로 간주. WebSocket 연결이 끊어졌을 때,&nbsp;클라이언트가 일정 시간 간격으로 자동으로 재연결을 시도하여 복구. 보통 재연결 간격을 점차 늘려가는 방식을 사용해 서버에 과도한 재연결 요청이 가지 않도록 구현 브라우저 여러개의 탭에서 서버와 통신하려고 할때는 여러개의 중복 소켓연결이 필요함. 단일 소켓통신 연결을 유지하는 방법은? Web Workers의 Shared Worker를 사용해서 구현 가능. Worker Thread에서 통신을 담당하고 브라우저 탭과 통신을 하면 데이터(메시지) 공유 <br><img alt="ws_sw_bc" src="https://lucas-image.codesquad.kr/1731289291333ws_sw_bc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
참고 :&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://pike96.com/posts/websocket-sharedworker-broadcastchannel/" target="_self">https://pike96.com/posts/websocket-sharedworker-broadcastchannel/</a>Shared Worker코드const socket = new WebSocket('wss://example.com/socket');
const clients = []; //브라우저 탭들 // WebSocket 메시지 수신 시 연결된 모든 클라이언트에게 전송
socket.onmessage = (event) =&gt; { clients.forEach((port) =&gt; port.postMessage(event.data));
}; // 새 클라이언트(탭) 연결 시
onconnect = (event) =&gt; { const port = event.ports[0]; clients.push(port); // 클라이언트로부터 메시지를 수신해 WebSocket으로 전송 port.onmessage = (e) =&gt; { socket.send(e.data); }; // 클라이언트 연결이 종료되면 배열에서 제거 port.onclose = () =&gt; { clients.splice(clients.indexOf(port), 1); };
}; 메인쓰레드(브라우저 탭)// SharedWorker에 연결
const worker = new SharedWorker('sharedWorker.js');
worker.port.start(); // 포트 활성화 // SharedWorker로부터 메시지를 수신해 출력
worker.port.onmessage = (event) =&gt; { console.log('서버로부터 받은 메시지:', event.data);
}; // 메시지를 SharedWorker로 전송 (SharedWorker가 WebSocket을 통해 서버로 전달)
function sendMessage(message) { worker.port.postMessage(message);
} 브라우저 호환성 이슈 대안 필요 통신 시간 측정 비교 필요 탭이 하나일때 는 일반 소켓연결, 탭이 여러개일때는 Shared Worker로 구현? socket.io를 사용하면 바닐라 WebSocket 코드보다 간결하게 구현할 수 있음. 다음은 동일한 기능을&nbsp;socket.io로 구현한 예. const io = require('socket.io')(3000, { cors: { origin: "http://localhost:3001", methods: ["GET", "POST"] }
}); io.on('connection', (socket) =&gt; { socket.on('draw', (data) =&gt; { socket.broadcast.emit('draw', data); });
}); import React, { useEffect, useRef } from 'react';
import io from 'socket.io-client'; const Canvas = () =&gt; { const canvasRef = useRef(null); const socketRef = useRef(null); useEffect(() =&gt; { socketRef.current = io('http://localhost:3000'); socketRef.current.on('draw', ({ x, y }) =&gt; { draw(x, y); }); return () =&gt; socketRef.current.disconnect(); }, []); const draw = (x, y) =&gt; { const canvas = canvasRef.current; const ctx = canvas.getContext('2d'); ctx.fillStyle = 'black'; ctx.fillRect(x, y, 2, 2); }; const handleMouseMove = (event) =&gt; { const x = event.clientX; const y = event.clientY; draw(x, y); socketRef.current.emit('draw', { x, y }); }; return &lt;canvas ref={canvasRef} width={800} height={600} onMouseMove={handleMouseMove} /&gt;;
}; export default Canvas;
]]></description><link>부스트캠프/멤버십/8주차/웹소켓.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/웹소켓.md</guid><pubDate>Sun, 15 Dec 2024 17:49:13 GMT</pubDate><enclosure url="https://assets.apidog.com/blog/2023/05/websocket-vs-http.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://assets.apidog.com/blog/2023/05/websocket-vs-http.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[리액트 테스트]]></title><description><![CDATA[npm install -D vitest export function sum(a, b) { return a + b
} import { expect, test } from 'vitest'
import { sum } from './sum' describe('기본연산', () =&gt; { test('adds 1 + 2 to equal 3', () =&gt; { expect(sum(1, 2)).toBe(3) })
}) describe :&nbsp;test suites it :&nbsp;test cases expert.toBe :&nbsp;assertions { "scripts": { "test": "vitest", "coverage": "vitest run --coverage" }
}
이후에&nbsp;npm run test&nbsp;또는&nbsp;yarn test&nbsp;실행.vitest 가 DOM 테스트를 가능하게 jsdom 설치(jsdom 이외에도 있음)npm install --save-dev jsdom
vitest 환경 설정을 통해서 다양한 테스트 방법을 설정할 수 있음.
참고 :&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://vitest.dev/config/" target="_self">https://vitest.dev/config/</a>import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite' export default defineConfig({ plugins: [react()], test: { environment: 'jsdom' },
})
React DOM 요소를 선택하고 상호작용하는 것을 쉽게 만들어, 테스트가 실제 사용자의 행동을 더 잘 반영하게 하는 역할npm install --save-dev @testing-library/jest-dom @testing-library/react @testing-library/user-event globals 설정을 true 해서, expect, describe, it 등의 테스트 함수를 수동으로 import 하지 않아도 됨. setupFiles 을 설정해서 반복적인 수행을 미리 지정. import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite' export default defineConfig({ plugins: [react()], test: { globals: true, environment: 'jsdom', setupFiles: './src/test/setup.ts', },
})
//다양한 것을 import
import { afterEach } from 'vitest'
import { cleanup } from '@testing-library/react'
import '@testing-library/jest-dom/vitest' // afterEach 와 같이 각 테스트 실행 후에 반복적으로 해야할 것을 설정.
afterEach(() =&gt; { cleanup();
}) <br>학습팁 :&nbsp;<a data-tooltip-position="top" aria-label="https://testing-library.com/docs/react-testing-library/example-intro" rel="noopener nofollow" class="external-link is-unresolved" href="https://testing-library.com/docs/react-testing-library/example-intro" target="_self">react testing library</a>&nbsp;공홈의 예제를 참고하는것이 좋음 <br><a data-tooltip-position="top" aria-label="https://stackblitz.com/edit/vitejs-vite-zoa9jv?file=package.json,vite.config.js,src%2Ftest%2Fsetup.ts,src%2FApp.jsx&amp;terminal=dev" rel="noopener nofollow" class="external-link is-unresolved" href="https://stackblitz.com/edit/vitejs-vite-zoa9jv?file=package.json,vite.config.js,src%2Ftest%2Fsetup.ts,src%2FApp.jsx&amp;terminal=dev" target="_self">시작코드</a> App.test.jsx 테스트 파일 생성 렌더링 결과에&nbsp;hello vite&nbsp;문자열이 있는지 확인하기 App을 렌더링 시키고, assertion으로 렌더링 결과에 원하는 문자열이 포함되어 있는지 확인 npm run test 로 테스트 코드 실행 힌트 : testing-library/react 에 있는 다양한 함수를 활용 새로운 테스트 케이스 함수 작성 button 엘리먼트를 클릭하면 count 값 렌더링 결과가 '1'이 된다. 어떻게 이벤트를 발생 시킬 것인가 힌트 : testing-library/react 에 있는 다양한 함수를 활용 테스트 코드 (/src/hooks/useCounter.test.js) 파일 생성 커스텀훅을 테스트 할 수 있는 방법을 찾아보자. 테스트 시나리오 예시) count 초기값을 확인 increment 함수 호출 count값이 2인지 확인 DataFromServer 컴포넌트를 App.jsx에서 호출해서 사용한다. return ( &lt;&gt; &lt;h1&gt;Hello Vite + React&lt;/h1&gt; &lt;div className="card"&gt; &lt;button onClick={increment} data-testid="increment"&gt; count is {count} &lt;/button&gt; &lt;/div&gt; &lt;DataFromServer todoId={count}&gt;&lt;/DataFromServer&gt; &lt;/&gt; ); DataFromServer.test.jsx 테스트 파일 생성 async/await, waitFor API 등을 활용해 테스트 진행 fetch 통신을 실제로 하지 않고 테스트 하는 방법은? import { test, expect, vi } from 'vitest'
import { fetchData } from './api' // 실제 fetchData 함수 (예시)
export async function fetchData() { const response = await fetch('https://jsonplaceholder.typicode.com/todos/1') const data = await response.json() return data
} // Mocking fetch 함수
global.fetch = vi.fn(() =&gt; Promise.resolve({ json: () =&gt; Promise.resolve({ userId: 1, id: 1, title: 'mocked title', completed: false })
})) test('fetchData 함수 호출 테스트 - Mocking fetch 사용', async () =&gt; { const data = await fetchData() expect(fetch).toHaveBeenCalledWith('https://jsonplaceholder.typicode.com/todos/1') expect(data).toEqual({ userId: 1, id: 1, title: 'mocked title', completed: false })
}) 테스트가 코드의 얼마나 많은 부분을 실행하고 검증하는지를 측정하는 지표.
높은 커버리지는 코드의 많은 부분이 테스트되고 있음을 의미하며, 잠재적인 버그나 결함을 줄이는 데 도움이 됨. 하지만 커버리지가 높다고 해서 모든 오류가 잡힌다는 보장은 없으며, 테스트의 양뿐만 아니라 테스트의 질도 중요함.
vitest.config.js 수정 예시) export default defineConfig({ plugins: [react()], test: { globals: true, environment: 'jsdom', setupFiles: './src/test/setup.ts', coverage: { provider: 'v8', reporter: ['text', 'html'], exclude: [ 'node_modules/', 'src/test/setup.ts', ] } },
}); Vitest에서 커버리지를 확인하려면 package.json에 커버리지 스크립트를 추가. { "scripts": { "test": "vitest", "coverage": "vitest run --coverage" }
} 이후&nbsp;npm run coverage&nbsp;를 실행하면 커버리지 리포트를 확인할 수 있음. 생성된 커버리지 리포트에는 다음과 같은 정보들이 포함됨:
Statements: 테스트된 모든 코드 구문 비율 Branches: 조건문에서 분기가 테스트된 비율 Functions: 함수가 테스트된 비율 Lines: 실제 코드 라인이 테스트된 비율 Snapshot Testing은 컴포넌트의 UI가 예상대로 유지되는지를 확인하는 방법.
컴포넌트의 출력 결과를 스냅샷으로 저장하고, 이후 변경된 스냅샷과 비교하여 UI의 예기치 않은 변경을 방지함.
이를 통해 UI가 의도치 않게 변경되는 것을 쉽게 감지할 수 있음.Vitest에서 Snapshot Testing을 사용하려면 테스트 파일에서 expect().toMatchSnapshot()을 사용하면 됨.
예)import { test, expect } from 'vitest'
import { render } from '@testing-library/react'
import MyComponent from './MyComponent' test('MyComponent snapshot', () =&gt; { const { container } = render(&lt;MyComponent /&gt;) expect(container).toMatchSnapshot()
})
이렇게 하면 MyComponent의 현재 출력 결과가 스냅샷으로 저장되고,
이후 테스트 시 스냅샷과 비교하여 변경 여부를 확인할 수 있음.<br><a data-tooltip-position="top" aria-label="https://stackblitz.com/edit/vitejs-vite-gps4by?file=src%2Fcomponents%2FDataFromServer.jsx" rel="noopener nofollow" class="external-link is-unresolved" href="https://stackblitz.com/edit/vitejs-vite-gps4by?file=src%2Fcomponents%2FDataFromServer.jsx" target="_self">참고코드</a>software test에는 unit test를 포함해서 여러가지 테스트 개념이 있다.아래 링크의 4가지 레벨이 일반적인 테스트 종류로 본다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.seguetech.com/the-four-levels-of-software-testing/" target="_self">http://www.seguetech.com/the-four-levels-of-software-testing/</a>
unit test : 소프트웨어의 최소단위, 보통 함수를 가리킴 Integration test : 단위 기능이 합쳐진 기능에 대한 테스트 System test : 위 내용보다 더 큰 개념, 전체 시스템에 대한 동작 테스트 Acceptance(인수) Test : 고객이 ok할 수 있는지 판단하기 위한 테스트 그리고,
UI test : FE에서 존재하는 개념으로, UI 기능 단위로 진행하는 테스트. 보통 Unit test와 system test 사이라고 볼 수 있음. E2E test : End-to-end 테스트. 이 역시 UI 테스트와 같이 말하는 경우도 있고, 전체 시스템관점에서의 테스트로 보는 경우도 있음. 그냥 잘 돌아가는지 보기 위해서? 지속가능함을 유지하기 위해서 테스트는 중요한 장치임. 지속가능한 소프트웨어란? 즉시성 : 필요한 업데이트를 즉시에 할 수 있어야 함 건강함 : 지속적으로 건강한 모습 프로그래밍의 최소단위를 테스트 하는 것. 그 대상은 보통 함수.사람이 직접 모든 함수를 호출하는 것은 불가능.
특정 함수를 호출하도록 테스트 코드를 구현하고, 이를 자동화해서 그 결과를 확인.function print(arg) { return 'result' + arg;
} const expected = "result yes";
console.log(expected === print('yes')); // 성공(success)
console.log(expected === print('no')); // 실패(fail)
반환값이 명확히 존재하고, 다른 함수를 호출하지 않는 함수부터 테스트 한다.즉, dependency 가 없는 함수.
어떤 함수를 테스트 할 것인가? 그 함수는 어떤 상황에서 어떻게 동작해야 하는가? (should be 표현..)
ex) 좌측 메뉴에서 아이템을 선택하면 선택한 아이템은 하이라이트 된다. 현재 함수가 테스트 가능하지 못하면 테스트 가능한 함수로 변경. 일관된 방식의 테스트 코드 구현을 위해서given(테스트에 필요한 값 셋팅) -&gt; when(실행) -&gt; then(테스트)방식으로 테스트 수행. 이 방법이 정답은 아니지만 가장 많이 쓰임.describe('array test', function() { it('equal dummy test', function() { //given var arr = []; //when arr.push(1,2,'3'); //then assert.equal(arr.length, 3); });
})
참고 : given(테스트에 필요한 값 셋팅) -&gt; when(실행) -&gt; then(테스트)<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://martinfowler.com/bliki/GivenWhenThen.html" target="_self">https://martinfowler.com/bliki/GivenWhenThen.html</a>많은 테스트 코드의 결과를 쉽게 확인하기 위해서 추가적인 장치가 필요.
Qunit, Mocha, Jest 와 같은&nbsp;테스트 프레임워크를 사용하면 편리.
(앞으로는 Jest 를 기반으로 테스트 한다)개발 -&gt; 테스트코드 작성이라는 순서가 아니고 그 반대.함수단위&nbsp;테스트코드 구현 -&gt; fail -&gt; 함수구현 -&gt; pass -&gt; refactoring.=&gt; TDD는 단순한 테스트 코드 구현방식보다, 프로그래밍 설계 방법론에 가까움.참고로, 비슷한 용어로 BDD(Behavior driven development)가 있음BDD는 함수단위라기 보다는 하나의 인터랙션(시나리오)단위로 테스트 코드를 구현하는 방식.TDD를 BDD형태로 구현할 수 있음. TDD가 함수단위라 그런 점의 차이점은 있으나, 두 개가 반대 개념은 아님.<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0b/TDD_Global_Lifecycle.png/2560px-TDD_Global_Lifecycle.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>부스트캠프/멤버십/8주차/리액트-테스트.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/리액트 테스트.md</guid><pubDate>Sun, 15 Dec 2024 17:48:32 GMT</pubDate><enclosure url="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0b/TDD_Global_Lifecycle.png/2560px-TDD_Global_Lifecycle.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/0/0b/TDD_Global_Lifecycle.png/2560px-TDD_Global_Lifecycle.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터 페칭과 서버 상태 관리]]></title><description><![CDATA[HTTP 캐싱 표준의 하나로, 서버가 응답 헤더를 통해 브라우저 캐시나 프록시 서버가 데이터를 먼저 캐시에서 제공하도록 하고, 백그라운드에서 최신 데이터를 요청하여 자동으로 갱신하는 방식.HTTP에서 SWR을 설정할 때는&nbsp;Cache-Control&nbsp;헤더에&nbsp;stale-while-revalidate&nbsp;지시어를 추가하여 사용함.예시 설정.Cache-Control: max-age=60, stale-while-revalidate=120
이 설정은:
max-age=60: 데이터가 캐시에 저장된 후 60초 동안 신선한 상태를 유지. stale-while-revalidate=120: 60초 이후에도 120초 동안 캐시 데이터를 사용할 수 있으며, 동시에 백그라운드에서 최신 데이터를 요청. Nginx에서 SWR을 설정하려면&nbsp;Cache-Control&nbsp;헤더를 다음과 같이 추가.location /api { add_header Cache-Control "max-age=60, stale-while-revalidate=120";
}
이 설정으로&nbsp;/api&nbsp;경로에 대한 데이터는 60초 동안 신선하게 유지되며,이후 120초 동안 캐시 데이터를 제공하고 백그라운드에서 갱신 요청.프론트엔드 라이브러리에서 SWR 패턴을 구현할 때는 유효 시간(staleTime)과 캐시 유지 시간(cacheTime)을 설정하여 캐시 데이터를 최적화하고 필요할 때만 서버로 요청을 보냄.아래와 같은 단계로 작동:
0~staleTime&nbsp;동안: 캐시된 데이터를 바로 표시해 사용자가 빠르게 볼 수 있도록 함.
staleTime&nbsp;이후&nbsp;cacheTime&nbsp;내: 캐시된 데이터를 유지하면서 백그라운드에서 새로운 데이터 요청으로 최신 상태로 갱신.
cacheTime&nbsp;이후: 캐시가 만료되며 새 데이터를 요청해&nbsp;loading&nbsp;상태를 표시함.
Next.js의 useSWR,&nbsp;React Query&nbsp;등이 SWR 개념을 활용 중.const { data, isLoading } = useQuery({ queryKey: ['todos'], queryFn: fetchTodos, staleTime: 1000 * 60, // 유효 시간 (1분) cacheTime: 1000 * 60 * 5, // 캐시 유지 시간 (5분)
});
(feat. React Query)
props 로 전달. Context API 활용. Redux 등 외부 상태관리 라이브러리. React Query는 queryKey를 기반으로 데이터를 캐싱. 동일한&nbsp;queryKey를 사용하는 컴포넌트들끼리는 상태를 자동으로 공유하고 최신 상태로 동기화. useQuery는 구독을 의미. 처음 실행할때는 옵저버 생성하는 개념. const { data, error, isLoading, isFetching, refetch } = useQuery( ['todos'], fetchTodos ); 옵저버는 쿼리 객체를 구독하고, 쿼리의 상태 변화를 감시. 컴포넌트는 옵저버를 구독하여 쿼리의 상태 변화를 반영하고, 필요할 때 재렌더링. queryKey 배열의 두번째 요소는 해당 데이터의 의존성. 이값이 변경되면 queryFn이 다시 실행되어 리패칭 함. useQuery({ queryKey: ['todos', state], queryFn: () =&gt; fetchTodos(state), }); useQuery를 한 결과를 다시 클라상태(useState)로 보관할 필요 없음. (업데이트 즉시 안될 수 있음) 예시)
import { useQuery, useMutation, useQueryClient } from 'react-query'; //구독하는 TodoList
function TodoList() { const { data: todos } = useQuery(['todos'], fetchTodos); return ( &lt;ul&gt; {todos?.map((todo) =&gt; ( &lt;li key={todo.id}&gt;{todo.title}&lt;/li&gt; ))} &lt;/ul&gt; );
} //TodoApp
function TodoApp() { const queryClient = useQueryClient(); const mutation = useMutation(addTodo, { onSuccess: () =&gt; { queryClient.invalidateQueries(['todos']); // 'todos' 키를 가진 쿼리들 무효화 }, }); const handleAddTodo = () =&gt; { mutation.mutate({ title: 'New Todo' }); }; return &lt;button onClick={handleAddTodo}&gt;Add Todo&lt;/button&gt;;
} 서버에 반복적으로 데이터를 요청하면 네트워크 리소스가 불필요하게 소비되고, 성능이 저하될 수 있음.동일한 데이터가 자주 필요한 경우, 캐싱을 사용하면 성능을 개선하고 네트워크 비용을 절약할 수 있음.실제로 대부분의 성능개선은 캐싱기법.
리액트의 데이터 통신 결과를 어떻게 캐시할 수 있지? 캐싱을 구현하기 위해&nbsp;useEffect와&nbsp;useState를 조합하여 데이터를 가져온 후 상태로 저장함. const cache = {}; function useCachedData(key, fetchFunction) { const [data, setData] = useState(cache[key] || null); const [loading, setLoading] = useState(!cache[key]); useEffect(() =&gt; { if (!cache[key]) { setLoading(true); fetchFunction() .then(result =&gt; { cache[key] = result; setData(result); }) .finally(() =&gt; setLoading(false)); } }, [key, fetchFunction]); return { data, loading };
} 컴포넌트의 언마운트 시 데이터를 캐시에 저장하고, 컴포넌트가 다시 마운트되면 캐시에서 데이터를 가져오도록 코드로 관리. timestamp 를 추가해서 시간값을 활용해 캐시타임을 설정도 가능. React Query는&nbsp;queryKey를 기반으로 데이터를 자동으로 캐싱하고,&nbsp;staleTime&nbsp;옵션을 통해 캐시 유효 시간을 설정 관리.useQuery({ queryKey: ['todos'], queryFn: fetchTodos, staleTime: 1000 * 60, // 1분 동안 데이터를 fresh 상태로 유지 cacheTime: 1000 * 60 * 5, // 5분 동안 캐시 유지
});
비동기 요청에서는 로딩 중, 성공, 실패 등의 상태를 수동으로 관리해야 함.번거롭고 코드가 길어질 수 있으나, seamless 한 UX측면에서 중요함.데이터를 요청할 때&nbsp;useState로 로딩 및 오류 상태를 관리하고, 요청 성공 시 데이터를 업데이트함.const [data, setData] = useState(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null); useEffect(() =&gt; { setLoading(true); fetch('/api/data') .then((res) =&gt; res.json()) .then((result) =&gt; setData(result)) .catch((err) =&gt; setError(err)) .finally(() =&gt; setLoading(false));
}, []);
useFetch 와 같은 커스텀 훅으로 개발해서 재사용.const { data, isLoading, isError, error } = useQuery({ queryKey: ['todos'], queryFn: fetchTodos,
});
useActionState 폼처리를 용이하게 하면서, 비동기 상태를 쉽게 지원.function ChangeName({ name, setName }) { const [error, submitAction, isPending] = useActionState( updateNameAction, null ); ... ...... } 비동기 처리과정에서 에러핸들링은 필수이나, 컴포넌트를 복잡하게 만들 수도 있음.useState로 에러 상태를 설정.const [error, setError] = useState(null); useEffect(() =&gt; { fetch('/api/data') .then((res) =&gt; res.json()) .catch((err) =&gt; setError(err));
}, []); if (error) { return &lt;p&gt;Error: {error.message}&lt;/p&gt;;
}
일반적으로 라이브러리 표준처럼 사용.import { ErrorBoundary } from 'react-error-boundary'; //에러핸들링
function ErrorFallback({ error, resetErrorBoundary }) { return ( &lt;div role="alert"&gt; &lt;p&gt;에러가 발생했군요:&lt;/p&gt; &lt;pre&gt;{error.message}&lt;/pre&gt; &lt;button onClick={resetErrorBoundary}&gt;재시도?&lt;/button&gt; &lt;/div&gt; );
} //App 컴포넌트
function App() { return ( &lt;ErrorBoundary FallbackComponent={ErrorFallback} onReset={() =&gt; { // 필요시 에러 후 초기화 로직 작성 가능 }} &gt; &lt;DataComponent /&gt; &lt;/ErrorBoundary&gt; );
} //View 컴포넌트.
import { useState, useEffect } from 'react'; function DataComponent() { const [data, setData] = useState(null); const [error, setError] = useState(null); useEffect(() =&gt; { const fetchData = async () =&gt; { try { const response = await fetch('/api/data'); if (!response.ok) throw new Error('Failed to fetch data'); const result = await response.json(); setData(result); } catch (err) { setError(err); } }; fetchData(); }, []); if (error) { throw error; // ErrorBoundary로 전달 } return &lt;div&gt;Data: {data}&lt;/div&gt;;
} ErrorBoundary 를 사용 했을 때 장점은?? error&nbsp;필드와&nbsp;onError&nbsp;옵션.useQuery({ queryKey: ['todos'], queryFn: fetchTodos, onError: (error) =&gt; { console.error("Query error:", error); },
});
const { data } = useQuery(['todos'], fetchTodos, { suspense: true, throwOnError: true, // 에러 발생 시 ErrorBoundary로 전달
}); ... // App 컴포넌트에서 ErrorBoundary 적용
function App() { return ( &lt;QueryClientProvider client={new QueryClient()}&gt; &lt;ErrorBoundary FallbackComponent={ErrorFallback}&gt; &lt;React.Suspense fallback={&lt;p&gt;Loading...&lt;/p&gt;}&gt; &lt;Todos /&gt; &lt;/React.Suspense&gt; &lt;/ErrorBoundary&gt; &lt;/QueryClientProvider&gt; );
} 최신 데이터가 아니면 사용자 경험에 문제가 발생할 수 있으므로 특정 조건에서 자동으로 데이터를 리페칭이 필요한 경우가 있음. 뉴스사이트의 새로운 뉴스, 인스타그램의 피드내용...등 그밖에 네트워크 상태나 브라우저 focus 변화로 인해&nbsp;데이터를 갱신할 필요도 있음. 포커스가 변경되거나 네트워크가 재연결될 때(?)마다 데이터를 수동으로 갱신하도록 설정.const [data, setData] = useState(null); function fetchData() { fetch('/api/data') .then(response =&gt; response.json()) .then(data =&gt; setData(data));
} useEffect(() =&gt; { fetchData(); window.addEventListener('focus', fetchData); window.addEventListener('online', fetchData); return () =&gt; { window.removeEventListener('focus', fetchData); window.removeEventListener('online', fetchData); };
}, []);
refetchOnWindowFocus와&nbsp;refetchOnReconnect&nbsp;옵션 제공.useQuery({ queryKey: ['todos'], queryFn: fetchTodos, refetchOnWindowFocus: true, retry: 3, // 요청 실패 시 최대 3번 재시도 refetchOnReconnect: true, // 네트워크 재연결 시 리페칭
});
대량의 데이터를 한꺼번에 가져오는 것은 성능을 저하시킬 수 있음.페이징 및 무한 스크롤 등과 같은 UX를 통해 필요한 데이터만 부분적으로 불러오는 것이 중요함.현재 페이지 상태를 관리하고, 페이지가 스크롤이나 페이징에 따라 변경되면 새로운 데이터를 가져와 이전 데이터에 추가.예)..... const observerRef = useRef(null); useEffect(() =&gt; { const observer = new IntersectionObserver((entries) =&gt; { // element 보일때 페이지 증가 if (entries[0].isIntersecting) { setPage((prev) =&gt; prev + 1); } }); observer.observe(observerRef.current); return () =&gt; observer.disconnect();
}, []); ....
관련 추가 키워드.
IntersectionObserver Throttling (스크롤이벤트 제어) useInfiniteQuery&nbsp;훅 제공.fetchNextPage를 호출하여 데이터를 추가로 호출.const { data, fetchNextPage, hasNextPage } = useInfiniteQuery({ queryKey: ['todos'], queryFn: ({ pageParam = 1 }) =&gt; fetchTodos(pageParam), getNextPageParam: (lastPage) =&gt; lastPage.nextPage,
});
클라이언트에서 데이터를 추가/삭제 등 수정할 경우, 서버와의 동기화 필요.데이터 변경 후 수동으로 서버 상태를 업데이트하기 위해 새로고침을 하거나, 컴포넌트 내에서 추가적인 로직을 작성.function addTodo() { fetch('/api/addTodo', { method: 'POST', body: JSON.stringify(newTodo) }) .then(() =&gt; { // 데이터가 갱신되었으므로 수동으로 새 데이터를 요청 fetchTodos(); });
}
React Query는&nbsp;invalidateQueries를 통해 특정 쿼리를 무효화하여 서버 상태와 동기화.const mutation = useMutation({ mutationFn: addTodo, onSuccess: () =&gt; { queryClient.invalidateQueries(['todos']); },
});
사용자가 데이터를 필요로 하기 전에 미리 불러와 네트워크 대기 시간을 줄일 수 있음.사용자가 페이지를 전환할 때 데이터를 사전에 가져와 빠르게 화면을 렌더링할 수 있음.페이지 이동이나 특정 이벤트 발생 시 데이터를 미리 요청하고, 요청이 완료되면 캐시에 저장하여 다음 사용 시 이를 활용함.const [cachedData, setCachedData] = useState(null); useEffect(() =&gt; { // 페이지 로드 시 데이터를 미리 가져와 캐시에 저장 fetch('/api/data') .then((res) =&gt; res.json()) .then((result) =&gt; setCachedData(result));
}, []); ... const getData = async () =&gt; { // 캐시에 데이터가 있는지 확인 if (cachedData) { return cachedData; } else { const response = await fetch('/api/data'); const data = await response.json(); setCachedData(data); return data; }
};
React Query의&nbsp;prefetchQuery&nbsp;메서드를 사용하면 특정 쿼리를 사전에 패칭하여, 이후 사용 시 빠르게 데이터를 제공할 수 있음.const App = () =&gt; { useEffect(() =&gt; { // 페이지 로드와 동시에 데이터를 미리 가져옴 queryClient.prefetchQuery({ queryKey: ['todos'], queryFn: fetchTodos, }); }, []); return &lt;HomePage /&gt;;
};
이후에 같은 queryKey를 사용해서 프리페칭된 캐시데이터를 활용.React 19에서는&nbsp;useActionState&nbsp;등의 훅이 새롭게 추가서버와 직접적으로 상호작용하는 폼 데이터를 클라이언트 컴포넌트 내에서 효율적으로 처리할 수 있음.이 방법을 통해 fetch 호출 없이 폼 제출과 서버 액션을 간단히 연동가능.
예제: 'use server'; export async function submitForm(previousState, formData) { return await updateData(formData);
}
import { useActionState } from "react";
import { submitForm } from "./serverActions"; function MyForm() { const [state, formAction, isPending] = useActionState(submitForm, null); return ( &lt;form&gt; &lt;button formAction={formAction} disabled={isPending}&gt; {isPending ? "Submitting..." : "Submit"} &lt;/button&gt; &lt;/form&gt; );
} export default MyForm;
Zustand는 경량 상태 관리 라이브러리.컴포넌트 간의 상태를 중앙에서 관리. 컴포넌트가 필요시 상태를 직접 구독.
create&nbsp;함수 내부에서 비동기호출. 데이터 로드 이후&nbsp;set&nbsp;메서드를 통해 상태를 업데이트 상태를 정의하고 비동기 데이터를 받아오는 함수를 Zustand 스토어에 설정
import create from "zustand"; const useStore = create((set) =&gt; ({ count: 0, increment: () =&gt; set((state) =&gt; ({ count: state.count + 1 })),
})); 상태를 구독하는 컴포넌트에서는&nbsp;useStore를 호출.
function CounterDisplay() { const count = useStore((state) =&gt; state.count); // 상태 구독 return &lt;p&gt;Count: {count}&lt;/p&gt;;
} function IncrementButton() { const increment = useStore((state) =&gt; state.increment); // 액션 구독 return &lt;button onClick={increment}&gt;Increment&lt;/button&gt;;
}
]]></description><link>부스트캠프/멤버십/8주차/데이터-페칭과-서버-상태-관리.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/데이터 페칭과 서버 상태 관리.md</guid><pubDate>Sun, 15 Dec 2024 17:47:31 GMT</pubDate></item><item><title><![CDATA[리액트 재사용 컴포넌트]]></title><description><![CDATA[
컴포넌트는 무엇인가? 의미있는 요소. (modal, calendar, navigation, slider, UI의 독립적인 화면단위 등) React 컴포넌트 재사용을 해야하는가? 반복 또는 중복인가? 현실은? 화면은 조금만 달라도 재사용은&nbsp;어렵다.&nbsp;😣 동작, 스타일 등 스타일 의존성 제거 간단한 동작으로만 동작, 나머지는 옵션으로 제공 동작 전후로 동작하는 훅(hook) API제공 여러군데 사용하면서 발전 시키기 컴포넌트 중심의 제약조건 만들기 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://codesandbox.io/p/sandbox/reusable-modal-j6e6g" target="_self">https://codesandbox.io/p/sandbox/reusable-modal-j6e6g</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://naver.github.io/egjs-infinitegrid/#layouts" target="_self">https://naver.github.io/egjs-infinitegrid/#layouts</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://naver.github.io/egjs-infinitegrid/#components" target="_self">https://naver.github.io/egjs-infinitegrid/#components</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.npmjs.com/package/@datepicker-react/styled" target="_self">https://www.npmjs.com/package/@datepicker-react/styled</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/airbnb/react-dates" target="_self">https://github.com/airbnb/react-dates</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/majapw/react-dates-demo/blob/master/src/App.js" target="_self">https://github.com/majapw/react-dates-demo/blob/master/src/App.js</a>]]></description><link>부스트캠프/멤버십/8주차/리액트-재사용-컴포넌트.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/리액트 재사용 컴포넌트.md</guid><pubDate>Sun, 15 Dec 2024 17:43:41 GMT</pubDate></item><item><title><![CDATA[flux & useReducer]]></title><description><![CDATA[
unidirection data flow action 을 전달 store에서 데이터 변경 관리 view는 store를 구독하는 방식 <img src="https://krasimir.gitbooks.io/react-in-patterns/content/chapter-08/fluxiny_basic_flux_architecture.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
image:&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://krasimir.gitbooks.io/react-in-patterns/content/chapter-08/fluxiny_basic_flux_architecture.jpg" target="_self">https://krasimir.gitbooks.io/react-in-patterns/content/chapter-08/fluxiny_basic_flux_architecture.jpg</a>
<br><img src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
image:&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" target="_self">https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif</a>
//view에서
dispatch({ type: 'deposit', payload: 10
}) //reducer에서 switch (action.type) { case "deposit": return { action.payload } .... .....
복잡한 상태관리에서 useState보다 유리하다.
구체적인 상태변경을 감추고, reducer에 맡길 수 있다.
또한 콜백(setState 등)을 계속 하위component 에 전달해줘야 하는 불편함을 줄일 수 있다. 대신 dispatch라는 매개체 역할의 함수를 전달해준다.<br>참고 :&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://react.dev/reference/react/useReducer" target="_self">https://react.dev/reference/react/useReducer</a>const initialState = {count: 0}; function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; default: throw new Error(); }
} function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt; &lt;/&gt; );
} Hooks API에서도 Flux architecture 를 따르며 개발 가능. view 에서 상태변경 로직도 분리. "그렇다면 Redux를 어느정도 대체가능?" Context API 조합으로 같이 사용하면 어떨까? const postReducer = (posts, { type, payload }) =&gt; { switch (type) { case 'SET_INITIAL': return [...payload]; case 'ADD_POST': return [...posts, { title: payload, id: posts.length + 1, picked: false }]; case 'TOGGLE_PICKED': return posts.map(post =&gt; post.id === payload ? { ...post, picked: !post.picked } : post ); default: return posts; }
}; export const PostsContext = React.createContext(); const App = () =&gt; { const [posts, dispatch] = React.useReducer(postReducer, []); const addItemHandler = () =&gt; { const newTitle = prompt("Enter new post title"); if (newTitle) { dispatch({ type: 'ADD_POST', payload: newTitle }); } }; return ( &lt;PostsContext.Provider value={{ posts, dispatch }}&gt; &lt;PickedItems posts={posts} /&gt; &lt;button onClick={addItemHandler}&gt;ADD&lt;/button&gt; &lt;Items posts={posts} /&gt; &lt;/PostsContext.Provider&gt; );
};
]]></description><link>부스트캠프/멤버십/8주차/flux-&amp;-usereducer.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/flux &amp; useReducer.md</guid><pubDate>Sun, 15 Dec 2024 17:43:00 GMT</pubDate><enclosure url="https://krasimir.gitbooks.io/react-in-patterns/content/chapter-08/fluxiny_basic_flux_architecture.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://krasimir.gitbooks.io/react-in-patterns/content/chapter-08/fluxiny_basic_flux_architecture.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[리액트 커스텀 훅]]></title><description><![CDATA[
React Component 는 View 렌더링의 역할이 중요하다 Component는 다음과 같은 로직을 중복적으로 담고 있을 수 있다. 데이터 필터링 또는 파싱작업 데이터 요청 / 응답 처리 인증 처리 이런 로직을 분리 한다면 View 그 차제 역할로 순수해지고, 간결해진다. 다만 저런 로직은 re-rendering과정에서 필요한 상태를 가지고 있을 수 있다. React는 커스텀 훅을 통해서 View와 통합해서 렌더링 할 수 있는 방법을 제시한다. import React, { useState, useEffect } from "react"; const MyComponent = () =&gt; { const [data, setData] = useState([]); const [loading, setLoading] = useState(true); useEffect(() =&gt; { const fetchData = async () =&gt; { const url = "https://jsonplaceholder.typicode.com/todos"; const res = await fetch(url); if (res.ok) { const list = await res.json(); setData(list); } else { console.error("Network response was not ok"); } setLoading(false); }; fetchData(); }, []); if (loading) { return &lt;p&gt;Loading...&lt;/p&gt;; } return ( &lt;div&gt; &lt;h1&gt;Data from API&lt;/h1&gt; &lt;ul&gt; {data.map((item) =&gt; ( &lt;li key={item.id}&gt;{item.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; );
}; useFetch 라는 커스텀훅을 만들어서 분리시킴import React from 'react'; const MyComponent = () =&gt; { const { data, loading } = useFetch({ url: "https://jsonplaceholder.typicode.com/posts", }); if (loading) { return &lt;p&gt;Loading...&lt;/p&gt;; } return ( &lt;div&gt; &lt;h1&gt;Data from API&lt;/h1&gt; &lt;ul&gt; {data.map((item) =&gt; ( &lt;li key={item.id}&gt;{item.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; );
};
단일책임원칙에 따라 구현
서비스 로직 불포함
특정 뷰 의존성없이 재사용 가능한 컴포넌트 개발import React, { useState, useEffect } from "react"; const useFetch = ({ url }) =&gt; { const [data, setData] = useState([]); const [loading, setLoading] = useState(true); useEffect(() =&gt; { const fetchData = async () =&gt; { const res = await fetch(url); const list = await res.json(); setData(list); setLoading(false); }; fetchData(); }, [url]); return { data, loading };
};
async 함수에서는 비동기 로직을 포함해서, try-catch-finally 처리가 가능하다.(async function () { try { const res = await fetch(`http://localhost:3001/milestone2`); } catch (e) { console.error('exeception occured!!', e.message); } finally { ... }
} 3가지를 결과로 반환 fetch 결과 error 메시지 결과 loading 상태 response 값이 false라면 response.staus 값을 error 메시지에 담아서 반환 그외 오류에 대해서 catch 로 잡아서, error 메시지를 반환. import { useState, useEffect } from 'react'; const useFetch = ({ url }) =&gt; { const [data, setData] = useState([]); const [errorMsg, setErrorMsg] = useState(''); // 에러 메시지 상태 추가 const [loading, setLoading] = useState(true); useEffect(() =&gt; { const fetchData = async () =&gt; { try { const res = await fetch(url); // HTTP 응답 상태 확인 if (!res.ok) { setErrorMsg(`Response error. Status code: ${res.status}`); return; } const list = await res.json(); setData(list); } catch (e) { console.error('Exception occurred!!', e.message); setErrorMsg(e.message); // 예외 발생 시 에러 메시지 설정 } finally { setLoading(false); // 요청 완료 후 로딩 상태 해제 } }; fetchData(); }, [url]); return { data, errorMsg, loading }; // 에러 메시지 반환
}; export default useFetch; 예시)
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://usehooks.com/" target="_self">https://usehooks.com/</a>]]></description><link>부스트캠프/멤버십/8주차/리액트-커스텀-훅.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/리액트 커스텀 훅.md</guid><pubDate>Sun, 15 Dec 2024 17:42:15 GMT</pubDate></item><item><title><![CDATA[history API와 리액트 라우팅]]></title><description><![CDATA[
지도 서비스와 라우팅 URL: 브라우저 주소창에 보이는 주소. 웹 애플리케이션에서 라우팅의 주요 진입점이 됨. Location: 브라우저의 현재 위치를 나타내며, JavaScript의&nbsp;window.location과 유사함. 예시:&nbsp;window.location.pathname;은 현재 경로를 반환함. URLSearchParams: 이 API를 사용하면 URL의 쿼리 파라미터 정보를 쉽게 얻을 수 있음.
const params = new URLSearchParams(window.location.search);
const color = params.get("color"); 사용자가 브라우저에서 이동한 기록을 담는 스택. 사용자가 페이지를 탐색할 때마다 브라우저는 현재 URL을 히스토리 스택에 저장함. History API: JavaScript의 History API를 사용하면 이 스택을 조작할 수 있으며, 이를 통해 페이지를 다시 로드하지 않고도 URL을 업데이트할 수 있음. history.pushState(): 새로운 URL을 히스토리 스택에 추가.
window.history.pushState({color: 'blue'}, "", "?color=blue"); history.replaceState(): 히스토리 스택의 현재 항목을 새로운 값으로 대체. popstate&nbsp;이벤트: 사용자가 '뒤로가기' 또는 '앞으로가기' 버튼을 눌렀을 때 발생하는 이벤트. 이 이벤트를 활용해 이전 또는 다음 상태로 화면을 렌더링할 수 있음.
window.addEventListener("popstate", (event) =&gt; { if (event.state) { document.body.style.backgroundColor = event.state.color; }
}); 클라이언트 측 JavaScript를 사용해 브라우저의 히스토리 스택을 제어하는 방식. SPA (단일 페이지 애플리케이션)&nbsp;구조에서는 전체 페이지를 새로 로드하지 않고, 필요한 부분만 다시 렌더링함. 브라우저는 이를 통해 사용자가 '뒤로가기' 또는 '앞으로가기' 버튼을 눌러 이전 화면으로 돌아가거나 다음 화면으로 이동할 수 있게 함. const newUrl = '/new-page';
const newState = { additionalInformation: 'Some data' };
const newTitle = 'New Page'; history.pushState(newState, newTitle, newUrl);
위 코드를 통해 브라우저 히스토리에 새로운 상태를 추가할 수 있으며, 페이지를 새로 로드하지 않음.또한&nbsp;popstate&nbsp;이벤트를 사용해 뒤로가기 또는 앞으로가기를 처리할 수 있음:window.addEventListener('popstate', (event) =&gt; { document.querySelector("div").innerHTML = JSON.stringify(event.state);
}); 1단계: 첫 페이지 로딩 시 라우터 호출 2단계: 라우트 정의 및 기본적인 라우터 함수 만들기 3단계: 링크 클릭 시 페이지 전환 처리 4단계: popstate 이벤트 핸들링 추가하기 &lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Simple Router Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt; &lt;nav&gt; &lt;a href="/"&gt;Home&lt;/a&gt; &lt;a href="/about"&gt;About&lt;/a&gt; &lt;a href="/contact"&gt;Contact&lt;/a&gt; &lt;/nav&gt; &lt;div class="content"&gt; &lt;!-- 여기에 라우터에 의해 동적으로 내용이 변경될 예정 --&gt; &lt;h1&gt;Welcome!&lt;/h1&gt; &lt;/div&gt; &lt;script src="router.js"&gt;&lt;/script&gt; &lt;!-- 여기에 자바스크립트 라우터 코드를 연결 --&gt;
&lt;/body&gt;
&lt;/html&gt; 페이지가 처음 로드될 때 현재 URL에 맞는 페이지가 보이도록 설정.router(); // 첫 페이지 로딩 시 라우터 호출 브라우저가 처음 로딩될 때, 현재 URL에 맞는 페이지를 바로 렌더링하기 위해&nbsp;router&nbsp;함수를 호출함. 먼저, 간단한 경로와 그에 대한 처리를 정의한 후,
경로에 따라 적절한 페이지를 처리하는 기본적인 라우터 함수를 작성.const routes = { '/': () =&gt; '&lt;h1&gt;Home Page&lt;/h1&gt;', '/about': () =&gt; '&lt;h1&gt;About Page&lt;/h1&gt;', '/contact': () =&gt; '&lt;h1&gt;Contact Page&lt;/h1&gt;',
}; function router() { const path = window.location.pathname; const route = routes[path]; const contentDiv = document.querySelector('.content'); contentDiv.innerHTML = route(); // 해당 경로에 맞는 HTML을 렌더링
} window.addEventListener('popstate', router); document.querySelectorAll('a').forEach(anchor =&gt; { anchor.addEventListener('click', (event) =&gt; { event.preventDefault(); const href = event.target.getAttribute('href'); window.history.pushState({}, '', href); router(); });
}); router(); // 첫 페이지 로딩 시 라우터 호출 routes 객체: 경로를 키로, 해당 경로에서 실행할 함수를 값으로 가짐. 각 페이지에서 보여줄 내용을 함수로 정의했음. router 함수: 현재 경로(window.location.pathname)를 확인하고, routes 객체에서 해당 경로에 맞는 함수를 찾아 실행함. 경로가 없으면 "404 Not Found" 메시지를 출력함. 404 페이지는 경로가 없는 경우 어떻게 처리할 수 있을지 ? HTML&nbsp;&lt;a&gt;&nbsp;태그를 클릭할 때 페이지가 새로고침 없이 전환되도록 처리해보자.
이 부분은 라우팅의 핵심적인 기능.document.querySelectorAll('a').forEach(anchor =&gt; { anchor.addEventListener('click', (event) =&gt; { event.preventDefault(); const href = event.target.getAttribute('href'); window.history.pushState({}, '', href); router(); });
}); event.preventDefault():&nbsp;&lt;a&gt;&nbsp;태그의 기본 동작인 페이지 리로드를 막음. window.history.pushState(): 새로운 경로를 히스토리 스택에 추가하면서 URL을 변경하지만, 페이지는 새로 로드되지 않음. router 호출: URL이 변경된 후, 해당 경로에 맞는 페이지가 즉시 렌더링되도록&nbsp;router&nbsp;함수를 호출함. 클릭 시 URL은 변경되지만, 새로고침 없이 페이지가 변경되는 이유 생각해보기. pushState와&nbsp;router&nbsp;함수의 관계를 이해하는 것이 중요. 브라우저의 '뒤로가기/앞으로가기' 버튼을 눌렀을 때도 올바른 페이지가 렌더링되도록&nbsp;popstate&nbsp;이벤트 리스너를 추가.window.addEventListener('popstate', router); popstate 이벤트: 사용자가 '뒤로가기' 또는 '앞으로가기' 버튼을 클릭할 때 발생하는 이벤트. 이 이벤트가 발생할 때마다&nbsp;router&nbsp;함수를 호출해, 현재 경로에 맞는 페이지가 표시되도록 함. 이제 각 부분을 단계적으로 이해했으니, 코드를 통합해서 전체적인 흐름을 다시 보자:const routes = { '/': () =&gt; console.log('Home Page'), '/about': () =&gt; console.log('About Page'), '/contact': () =&gt; console.log('Contact Page'),
}; function router() { const path = window.location.pathname; const route = routes[path]; if (route) { route(); } else { console.log('404 Not Found'); }
} window.addEventListener('popstate', router); document.querySelectorAll('a').forEach(anchor =&gt; { anchor.addEventListener('click', (event) =&gt; { event.preventDefault(); const href = event.target.getAttribute('href'); window.history.pushState({}, '', href); router(); });
}); router(); // 첫 페이지 로딩 시 라우터 호출
리액트 라우터는 SPA에서 클라이언트 측 라우팅을 쉽게 관리할 수 있도록 도와줌.
간단히 react rounter에 대해서 배워보자.import { BrowserRouter, Routes, Route } from "react-router-dom"; function App() { return ( &lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path="/" element={&lt;Home /&gt;} /&gt; &lt;Route path="about" element={&lt;About /&gt;} /&gt; &lt;Route path="contact" element={&lt;Contact /&gt;} /&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt; );
} function Home() { return &lt;h1&gt;Home Page&lt;/h1&gt;;
} function About() { return &lt;h1&gt;About Page&lt;/h1&gt;;
} function Contact() { return &lt;h1&gt;Contact Page&lt;/h1&gt;;
}
Next.js는&nbsp;파일 기반 라우팅을 사용해서, 디렉토리 구조만으로도 라우팅을 쉽게 설정할 수 있음.
특별한 설정 없이도 폴더와 파일 이름에 따라 페이지가 자동으로 매핑되기 때문에, 간단하면서도 강력한 라우팅 시스템을 제공.
pages&nbsp;디렉토리:&nbsp;pages&nbsp;폴더 안에 파일을 추가하면 해당 파일 이름이 바로 URL 경로가 됨. 예를 들어,&nbsp;pages/about.js&nbsp;파일을 추가하면&nbsp;/about&nbsp;경로에서 이 페이지가 렌더링됨.// pages/about.js
export default function About() { return &lt;h1&gt;About Page&lt;/h1&gt;;
} 동적 라우팅: 대괄호를 사용하여 동적 경로를 생성할 수 있음. 예를 들어,&nbsp;pages/[id].js는&nbsp;/post/1과 같은 URL에서 데이터를 받아 처리할 수 있음. // pages/[id].js
import { useRouter } from 'next/router'; export default function Post() { const router = useRouter(); const { id } = router.query; return &lt;h1&gt;Post ID: {id}&lt;/h1&gt;;
}
Next.js에서는 페이지 간 이동을 위해&nbsp;Link&nbsp;컴포넌트를 사용함. 이 컴포넌트는 클라이언트 사이드 네비게이션을 처리하여 페이지를 새로 고침하지 않고 URL을 변경할 수 있음.import Link from 'next/link'; export default function Home() { return ( &lt;div&gt; &lt;h1&gt;Home Page&lt;/h1&gt; &lt;Link href="/about"&gt;Go to About&lt;/Link&gt; &lt;/div&gt; );
}
Next.js에서 제공하는&nbsp;useRouter&nbsp;훅을 사용하면 현재 경로 정보에 접근하고, 프로그래밍적으로 페이지를 이동할 수 있음.import { useRouter } from 'next/router'; export default function Home() { const router = useRouter(); const goToAbout = () =&gt; { router.push('/about'); }; return ( &lt;div&gt; &lt;h1&gt;Home Page&lt;/h1&gt; &lt;button onClick={goToAbout}&gt;Go to About&lt;/button&gt; &lt;/div&gt; );
}
]]></description><link>부스트캠프/멤버십/8주차/history-api와-리액트-라우팅.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/history API와 리액트 라우팅.md</guid><pubDate>Sun, 15 Dec 2024 17:40:51 GMT</pubDate></item><item><title><![CDATA[JS에서의 OOP]]></title><description><![CDATA[모든 것이 객체다!?어떠한 사물 === Object.현실세계를 인지하면서 프로그래밍을 하자!에서 출발=&gt; 상상하고,볼 수 있고,만질 수 있는 것들은 모두 객체이다.모든 객체는 속성(property)과 행위(method)를 가질 수 있음.
속성 : 사람의 키,나이,몸무게 행위 : 움직이다, 먹다, 자다, 공부하다 people.eat();
people.getAddress(); //method~~~~
people.address; //property
업계에서 현실적으로 사용되는 용어
속성,필드,property는 같은말. 함수,메서드도 같은말. <img src="https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1602139788399oopconceptimage15345345.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.miltonmarketing.com/wp-content/uploads/2018/04/oopconceptimage15345345.png" target="_self">https://www.miltonmarketing.com/wp-content/uploads/2018/04/oopconceptimage15345345.png</a>
어떠한 객체를 표현하기 위해, 일반화된 형태로 만든 것.어떠한&nbsp;집합이나 분류에 가깝다.(사람, 동물, 자동차 등)
추상적.class를 통해서 얻을 수 있는 개별객체.유일한 사물.실체에 가깝다(crong, 사자, 벤츠)
구체적.# OOP가 없었다면? 비슷한 형태의 자동차를 만드는 코드가 반복적으로 표현됐을것임. 객체지향을 통해서 이를 간단하고 효과적으로 표현.<br><img src="https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1602420061378%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">객체지향 프로그래밍 언어에서 강조된 개념들.
Class 캡슐화(Encapsulation) 상속(Inheritance) 다형성(polymorphism) 추상화(abstraction) JavaScript는 class 없이 프로그래밍이 가능하다.
ES Classes는 ECMAScript 2015에서나 표준으로 등장. 그전에는 TypeScript 의 도움으로 사용.
생성자 함수와 prototype 속성을 통해서 클래스 형태를 구성할 수 있음.내부에서만 알고 있으면 될 것을, 외부에 공개하지 않는다. 필요한 것은 외부에 접근을 허용한다.private, public 개념.
JavaScript도 이를 지원하고 있음.module pattern을 통해서 이를 구현할 수도 있긴함.공통부분을 분리해서 재사용하려는 목적.상위클래스와 하위클래스간에 연결을 짓는다.
동동-&gt;사람, BMW -&gt; 자동차, 포크레인-&gt;중장비,&nbsp;아들 -&gt; 아빠(X) kind of 관계. prototype기반의 객체간 연결 chain을 통해 상속구조를 만들 수 있음.child.prototype = Object.create(parent.prototype);
ES6 Class의 extends 키워드 역시 내부적으로는 결국 prototype을 통한 상속구조임.다양한 성질로 동작하는 것.overriding을 통한 재정의, overloading을 통한 메서드 중복정의.JavaScript는 prototype chain내에 동일한 메서드를 두고 overriding구현은 가능.하지만, interface가 없고, method overloading을 공식지원하지 않음(다만,어떠한 타입을 체크해서, 다른 메서드를 호출해서 실행하도록 구현할 수는 있음)JavaScript에 다형성이 존재하냐?는 중요한 논쟁거리는 아님.
오버로딩은 같은 클래스 내에서 메소드 이름은 같지만 매개변수가 다른 여러 메소드를 정의하는 것이고,
오버라이딩은 상속 관계에 있는 클래스에서 상위 클래스의 메소드를 하위 클래스가 재정의하는 것.
필요한 부분만을 선택해서 클래스를 만드는 것.'차'는 '버스'클래스와 '중장비'클래스로 구분지을 수 있는데, 버스와 중장비는 서로 다른 속성과 행위가 필요하다. 이렇게 필요한 부분을 선택해서 클래스를 만들 수 있고, 이를 추상화라고 함.JavaScript에서도 이를 표현하는건 당연히 가능!class없이 바로 object로 표현가능(singleton)var healthObj = { name : "달리기", lastTime : "PM10:12", showHealth : function() { console.log(this.name + "님, 오늘은 " + this.lastTime + "에 운동을 하셨네요"); }
} healthObj.showHealth();
class를 에서 제공하는 constructor라는 생성자가 주어짐. class를 호출하면 constructor가 자동호출 됨.constructor는 instance를 만들어서 반환. 다시말해 객체(instance)를 생성해서 반환.class Health{ constructor(name,healthTime) { this.name = name; this.healthTime = healthTime; } showHealth(){ console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요"); } } const ho = new Health("crong", "12:12");
ho.showHealth();
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://caniuse.com/#feat=es6-class" target="_self">https://caniuse.com/#feat=es6-class</a>function을 new 키워드로 호출하면, 그 함수는 constructor가 됨.const Health = function(name,healthTime) { this.name = name; this.healthTime = healthTime; this.showHealth = function() { console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요"); }
} const ho = new Health("crong", "12:12");
ho.showHealth();
function Health(name, healthTime) { this.name = name; this.healthTime = healthTime;
} Health.prototype.showHealth = function() { console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요");
} const ho = new Health("crong", "12:12");
ho.showHealth();
Object.create는 직접적으로 prototype키워드를 사용하진 않지만, Prototype object를 만드는 것과 동일.const healthObj = { showHealth : function() { console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요"); }
} const ho = Object.create(healthObj, { name: { value: "crong" }, healthTime: { value: "12:22" } }) ho.showHealth();
Object.create는 prototype기반 상속을 좀더 매끄럽게 사용하기 위해 탄생했다고 이해할 수 있음.Object.create를 사용하면 상속구조가 잘 만들어짐. 하지만 ES6 Classes의 extend를 사용해서 이제 보다 쉽게 클래스간 상속 구조를 만들 수 있게 됨.여러개의 객체를 만들어서 생성할 필요가 없을때, 즉 일반화할 필요가 없는 경우에는 단순히 object literal로 객체를 표현.하나 이상으로 개별적인 객체를 생성해야 할 때.]]></description><link>부스트캠프/멤버십/8주차/js에서의-oop.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/JS에서의 OOP.md</guid><pubDate>Sun, 15 Dec 2024 17:40:08 GMT</pubDate><enclosure url="https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1602139788399oopconceptimage15345345.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1602139788399oopconceptimage15345345.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[리액트 만들기 프로젝트를 위한 문법과 패턴]]></title><description><![CDATA[클로저는 자바스크립트에서 매우 중요한 개념 중 하나.React의 상태 관리 시스템은 클로저를 많이 활용함.클로저는 함수가 외부 변수에 접근할 수 있게 해주며, React의 상태 업데이트에서 이러한 개념이 사용.예시:
function createCounter() { let count = 0; return function() { count += 1; return count; };
} const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
이처럼 상태를 함수 내부에서 유지하면서 외부에서 접근하는 패턴은 React의 상태 관리 방식과 유사함.디버깅 도구로 스코프를 확인하는 것을 추천.React는 함수형 프로그래밍 패러다임을 많이 차용.순수 함수(pure function),&nbsp;불변성(immutability),&nbsp;고차 함수(higher-order function)&nbsp;등이 중요한 역할.
순수 함수: 입력에 의해서만 출력이 결정되고, 외부 상태를 변경하지 않는 함수. 불변성: 상태 변경 시 객체를 직접 변경하는 대신, 새로운 객체를 반환함으로써 원본을 유지함. 고차 함수: 함수를 인자로 받거나 함수를 반환하는 함수. 예시 (순수 함수와 불변성):const increment = (count) =&gt; count + 1;
console.log(increment(0)); // 1
예시 (고차 함수):
//아래처럼 동작하는 withLogging 을 만들어보세요.
const add = (a, b) =&gt; a + b;
const addWithLogging = withLogging(add);
console.log(addWithLogging(2, 3)); //입력받은 arguments를 배열형태로 출력
//Arguments: [2, 3]
function withLogging(fn) { return function(...args) { console.log('Arguments:', args); return fn(...args); };
}
Observer 패턴은 상태가 변경되었을 때 해당 변경을 구독하고 있는 객체들에게 자동으로 알려주는 패턴.React의 상태 관리 시스템이나 Redux와 같은 상태 관리 라이브러리는 이 패턴을 사용.이는&nbsp;상태 변화에 따른 UI 업데이트를 처리하는데 핵심적임.예시 (간단한 Observer 패턴):
class Observable { constructor() { this.subscribers = []; } subscribe(callback) { this.subscribers.push(callback); } notify(data) { this.subscribers.forEach((callback) =&gt; callback(data)); }
} const observable = new Observable();
observable.subscribe((data) =&gt; console.log('Subscriber 1:', data));
observable.subscribe((data) =&gt; console.log('Subscriber 2:', data)); observable.notify('State changed'); // Subscriber 1: State changed
// Subscriber 2: State changed
상태 변경을 감지하고 이에 따라 UI를 자동으로 업데이트해야 하는 방법이 유용,이러한 상태 변화를 추적하는 데&nbsp;Proxy&nbsp;또는&nbsp;Object.defineProperty가 사용될 수 있음.Proxy 예시:프록시는 객체의 동작을 가로채고 수정할 수 있는 기능을 제공함.const target = { message: "Hello, World!"
}; const handler = { get: function(target, prop) { return prop in target ? target[prop] : "Property does not exist"; }, set: function(target, prop, value) { console.log(`Setting value ${value} to ${prop}`); target[prop] = value; }
}; const proxy = new Proxy(target, handler); // 접근 시
console.log(proxy.message); // "Hello, World!"
console.log(proxy.nonexistent); // "Property does not exist" // 값 설정 시
proxy.message = "Hello, Proxy!"; // "Setting value Hello, Proxy! to message"
console.log(proxy.message); // "Hello, Proxy!" 음,사용자가 입력한 값을 모델의 속성에 반영하고,모델이 업데이트되면 뷰를 자동으로 갱신하도록 할 때,Proxy를 활용할 수 있을까? 🤔
target 이라는 부분이 모델?이 될 수도 있고, setter 에서 뷰를 렌더링하도록 하면?
Object.defineProperty 예시:기존 객체의 속성에 대해 getter와 setter를 설정하여, 해당 속성에 접근하거나 수정할 때 동작을 제어할 수 있음.const obj = {};
let value = 0; Object.defineProperty(obj, 'count', { get() { return value; }, set(newValue) { console.log(`Setting count to ${newValue}`); value = newValue; }
}); // 접근 시
console.log(obj.count); // 0 // 값 설정 시
obj.count = 5; // "Setting count to 5"
console.log(obj.count); // 5
]]></description><link>부스트캠프/멤버십/8주차/리액트-만들기-프로젝트를-위한-문법과-패턴.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/리액트 만들기 프로젝트를 위한 문법과 패턴.md</guid><pubDate>Sun, 15 Dec 2024 17:39:50 GMT</pubDate></item><item><title><![CDATA[프레임워크 렌더링 과정]]></title><description><![CDATA[
DOM 노드 생성 및 관리: 주어진 태그, 속성, 자식 요소들을 조합하여 새로운 DOM 노드 또는 가상 DOM(Virtual DOM) 노드를 생성. 컴포넌트 구조화: 함수형 컴포넌트와 클래스형 컴포넌트와 같이 다양한 컴포넌트를 일관된 인터페이스로 제공. 노드 타입 확인:&nbsp;div,&nbsp;span&nbsp;같은 문자열은 기본 HTML 요소로, 함수나 클래스는 사용자 정의 컴포넌트로 인식.
속성(Props) 처리: 전달된 속성(props)들을 파싱하여 노드에 필요한 속성을 설정.
자식 노드 처리: 자식 요소들을 재귀적으로 처리하여 노드 트리를 구성.
Virtual DOM 객체 반환: DOM 노드 그 자체를 반환하는 것이 아니라, 노드의 정보(타입, 속성, 자식)를 담은 Virtual DOM 객체를 반환.
createElement가 반환하는 형태?const element = { type: 'div', props: { id: 'container', children: [ { type: 'h1', props: { children: [{ type: 'TEXT_ELEMENT', props: { nodeValue: '안녕! 코드스쿼드' } }] } }, { type: 'p', props: { children: [{ type: 'TEXT_ELEMENT', props: { nodeValue: '궁시렁 궁시렁' } }] } } ] }
}; &lt;개념 코드&gt;function createElement(type, props, ...children) { // 주어진 타입과 속성, 자식 요소들을 기반으로 가상 DOM 객체를 생성.
} function createTextElement(text) { // 텍스트 노드를 위한 가상 DOM 객체를 생성.
} // 사용 예
const element = createElement( 'div', { id: 'container' }, createElement('h1', null, 'Hello, World!'), createElement('p', null, 'This is a paragraph.')
); 동일한 입력이 오면 또 동일한 V DOM 객체를 반환해야할까? 절대 변경이 안되는(?) 노드도 가상DOM에 있어야 하나? list 의 변화를 쉽게 파악하는 방법은? 실제 DOM을 직접 조작하는 대신, 가상의 DOM을 메모리에 유지하고 상태가 변경될 때마다 가상의 DOM 트리와 이전의 트리를 비교(Diffing)하여 변경된 부분만 실제 DOM에 반영.전체 DOM을 다시 그리지 않고 필요한 부분만 효율적으로 업데이트.
먼저 리액트 프레임워크의 주요 목표? 🤔 DOM 조작의 비용 DOM 조작은 브라우저의 렌더링 엔진에서 많은 리소스를 소비함. 예를 들어, 페이지 전체를 새로 그리는 데 많은 시간이 소요될 수 있음. 효율적인 업데이트 가상 DOM을 사용하면 변경된 부분만 찾아내어 업데이트하므로 불필요한 DOM 조작을 피하고 성능을 최적화할 수 있음. React의 Diff 알고리즘은 두 개의 Virtual DOM 트리 간의 변화를 찾는 과정에서 노드의 타입과 속성(Props)을 비교.그 결과, React는 DOM을 효율적으로 갱신할 수 있음. 노드 타입 비교: 노드의 타입이 다르면, 해당 노드를 완전히 교체함. 예를 들어,&nbsp;&lt;div&gt;가&nbsp;&lt;span&gt;으로 바뀌면, React는 기존&nbsp;&lt;div&gt;를 삭제하고 새로&nbsp;&lt;span&gt;을 생성함. 속성(Props) 비교: 노드의 타입이 동일한 경우, 그 노드의 속성을 비교하여 달라진 부분만 수정함. 예를 들어,&nbsp;&lt;div id="header"&gt;에서&nbsp;&lt;div id="footer"&gt;로 바뀌면, id 속성만 변경함. 자식 노드 비교: 각 노드의 자식들 역시 순서대로 비교하여, 자식 노드에서 변화가 생긴 경우에만 업데이트함. 자식노드를 탐색하는 방법은?
리스트 노드를 쉽게 비교하는 방법은? function diff(oldNode, newNode) { // 1. 노드 타입 비교 if (oldNode.type !== newNode.type) { console.log(`Replace ${oldNode.type} with ${newNode.type}`); return newNode; } // 2. 속성(Props) 비교 if (oldNode.props.id !== newNode.props.id) { console.log(`Update id from ${oldNode.props.id} to ${newNode.props.id}`); } // 3. 자식 노드 비교 - 재귀적..? if (oldNode.children &amp;&amp; newNode.children) { ... } return newNode;
} // 예시 가상 DOM
const oldNode = { type: 'div', props: { id: 'header' }, children: [{ type: 'span', props: { id: 'text1' }}] };
const newNode = { type: 'div', props: { id: 'footer' }, children: [{ type: 'span', props: { id: 'text2' }}] }; // Virtual DOM 비교
const updatedNode = diff(oldNode, newNode);
V DOM을 활용한 화면 갱신 절차는? 🤔 새로운 Virtual DOM 생성 상태(state)나 props가 변경되면, React는 새로운 Virtual DOM을 생성함. 이 새로운 Virtual DOM은 변경된 상태를 반영하는 트리 구조를 가짐. 기존 Virtual DOM과 비교 새로운 Virtual DOM과 기존의 Virtual DOM을 비교하여 차이점을 찾음. 이 비교 과정이 React의&nbsp;Diff 알고리즘임. 이 과정에서는 노드의 타입, 속성, 자식 노드 등을 비교하여 변경된 부분을 파악함. 차이점을 기반으로 실제 DOM 업데이트 Diff 알고리즘이 발견한 차이점(변경 사항)을 실제 DOM에 반영함. 이때, React는 필요한 부분만 실제 DOM에 업데이트하므로, 전체 DOM을 다시 그리지 않아서 성능이 효율적으로 유지됨. 현재 Virtual DOM을 새로운 Virtual DOM으로 교체 실제 DOM이 업데이트된 후, 새로운 Virtual DOM이 현재 Virtual DOM으로 교체됨. 즉, React는 이 새로운 Virtual DOM을 기준으로 다음 상태 변화가 발생했을 때 또 다른 새로운 Virtual DOM을 생성하고, 다시 비교하는 과정을 반복함. 그런데 바로 업데이트 하면 안되나? 🤔 비교와 동시에 업데이트 방법: 변경 사항을 감지할 때마다 즉시 실제 DOM을 업데이트함. 장점: 간단하고 구현이 쉬움. 바로 업데이트되므로 빠르게 반응하는 것처럼 보일 수 있음. 단점: 작은 변경 사항이 많을 경우, 각 변경마다 DOM을 조작하게 되어 성능 저하가 발생할 수 있음. 불필요한 리플로우와 리페인트가 빈번하게 발생함. 모아서 업데이트 (배치 처리) 방법: 변경 사항을 모아서, 한 번에 실제 DOM에 반영함. React는 이 방식을 사용함. 장점: 변경 사항을 모아서 한 번에 처리하면 DOM 조작을 최소화할 수 있어 성능이 향상됨. 리플로우와 리페인트를 줄여 브라우저 성능에 유리함. 단점: 변경 사항이 많아질 경우, 초기 계산 비용이 증가할 수 있음. 즉각적인 반응성을 요구하는 경우 적합하지 않을 수 있음. 변경 사항 수집:&nbsp;collectChanges&nbsp;함수는 두 개의 Virtual DOM을 비교하여 변경 사항을 수집함. 새 노드를 생성하거나 속성을 업데이트할지, 자식 노드를 비교할지 결정함.
DOM 변경 적용:&nbsp;updateDOM&nbsp;함수는 수집된 변경 사항을 한 번에 실제 DOM에 반영함.&nbsp;replaceChild를 사용하여 부모 노드의 자식을 새로운 노드로 교체함.
function updateDOM(changes) { //change 를 반복하면서, replace 타입이 발견되면, 노드를 교체. ...
} function collectChanges(oldNode, newNode, changes = [], parentElement = null) {
// 노드 비교해서 변경사항이 발견되면 changes 항목에 객체형태로 저장. /* ...어쩌구 저꺼구 비교하고나서.. changes.push({ type: 'updateProp', oldElement: parentElement.querySelector(`#${oldNode.props.id}`), newProps: newNode.props }); */ } return changes;
} // 가상 DOM 비교 후 변경 사항 수집
const changes = collectChanges(oldNode, newNode); // 수집한 변경 사항을 실제 DOM에 반영
updateDOM(changes);
리스트 항목을 다룰 때, Keyed Diffing은 성능 최적화를 위한 중요한 전략 중 하나임.각 리스트 항목에 고유한&nbsp;key를 부여해, React가 항목을 추적하고 변화를 쉽게 파악할 수 있음. 이를 통해 항목의 추가나 삭제 시에도 불필요한 DOM 업데이트를 최소화할 수 있음.
key는 React가 각 리스트 항목을 구분하고, 변경이 발생했을 때 정확하게 그 위치를 추적할 수 있도록 도와줌. key가 없거나 잘못 설정되었을 때, 성능 저하나 잘못된 업데이트가 발생할 수 있음. 그렇다면,&nbsp;key를 어떻게 설정해야 성능이 최적화될까? // 잘못된 key 예시
const items = ['Apple', 'Banana', 'Cherry'];
items.map((item, index) =&gt; &lt;div key={index}&gt;{item}&lt;/div&gt;); // 올바른 key 예시
const items = [{ id: 1, name: 'Apple' }, { id: 2, name: 'Banana' }, { id: 3, name: 'Cherry' }];
items.map((item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;);
Svelte는&nbsp;컴파일 단계에서 상태가 변경될 때&nbsp;어떤 DOM 조작이 필요할지 미리 결정하고, 그에 맞춰&nbsp;최적화된 JavaScript 코드를 생성함.&lt;script&gt; let items = ['Item 1', 'Item 2', 'Item 3']; function addItem() { items = [...items, `Item ${items.length + 1}`]; }
&lt;/script&gt; &lt;ul&gt; {#each items as item} &lt;li&gt;{item}&lt;/li&gt; {/each}
&lt;/ul&gt; &lt;button on:click={addItem}&gt;Add Item&lt;/button&gt;
let items = ['Item 1', 'Item 2', 'Item 3']; // 리스트 데이터 DOM에 추가
const ul = document.createElement('ul');
items.forEach(item =&gt; { const li = document.createElement('li'); li.textContent = item; ul.appendChild(li);
});
document.body.appendChild(ul); // 버튼 생성
const button = document.createElement('button');
button.textContent = 'Add Item';
document.body.appendChild(button); // 클릭 핸들러
button.addEventListener('click', () =&gt; { items.push(`Item ${items.length + 1}`); const li = document.createElement('li'); li.textContent = `Item ${items.length}`; ul.appendChild(li); // 새 항목만 추가함
});
]]></description><link>부스트캠프/멤버십/8주차/프레임워크-렌더링-과정.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/프레임워크 렌더링 과정.md</guid><pubDate>Sun, 15 Dec 2024 17:39:27 GMT</pubDate></item><item><title><![CDATA[컴포넌트 단위 개발]]></title><description><![CDATA[컴포넌트 기반 개발은 현대 프론트엔드에서 중요한 개념임. UI를 작은 단위로 나누어 관리하는 것이 핵심.
재사용성: 한 번 만든 컴포넌트를 여러 곳에서 재사용 가능. 같은 코드를 반복해서 작성할 필요 없게 됨.
유지보수성: 각 컴포넌트는 독립적으로 관리되므로, 특정 기능만 수정해도 다른 부분에 영향을 주지 않음.
덕분에 버그 수정이나 기능 추가가 훨씬 수월해짐.
모듈화: 작은 단위로 나눠 코드 가독성이 높아지고, 각 컴포넌트의 역할이 명확해짐. 대규모 프로젝트에서도 효율적으로 관리 가능.
현대 프레임워크들은 모두 컴포넌트를 중심으로 개발이 이뤄짐.React, Vue, Svelte는 각기 다른 방식으로 컴포넌트를 처리하지만, 기본 원리는 동일.React는 페이스북이 2013년에 발표한 라이브러리임. Virtual DOM과 JSX를 사용해 UI를 관리.상태 변화에 따라 컴포넌트가 다시 렌더링됨.
function Button({ label, onClick }) { return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;
}
Vue는 2014년에 에반 유(Evan You)가 만든 프레임워크템플릿 기반 UI 정의가 특징.하나의&nbsp;.vue&nbsp;파일에 HTML 템플릿, 로직, 스타일을 모두 작성.React보다 직관적이고 간단함.
&lt;template&gt; &lt;button @click="handleClick"&gt;{{ label }}&lt;/button&gt;
&lt;/template&gt; &lt;script&gt;
export default { props: ['label'], methods: { handleClick() { alert('Clicked!') } }
}
&lt;/script&gt;
Svelte는 2016년에 리치 해리스(Rich Harris)가 발표한 프레임워크.다른 프레임워크와 달리&nbsp;Virtual DOM을 사용하지 않고, 빌드 타임에 UI 업데이트를 컴파일하여 성능을 최적화.즉, 상태 변경 시 직접 DOM을 업데이트함.
&lt;script&gt; let count = 0; function increment() { count += 1; }
&lt;/script&gt; &lt;button on:click={increment}&gt;Clicked {count} times&lt;/button&gt;
Svelte는 컴파일러 기반이기 때문에 런타임 오버헤드가 적고, 더 빠른 성능을 제공함.컴포넌트 기반 개발의 중요한 원칙 중 하나는 **UI와 비즈니스 로직을 분리하는 것.UI는 화면에 보이는 부분, 로직은 데이터 처리나 상태 관리 등을 담당함.
UI는 사용자에게 보여지는 부분으로, 컴포넌트 단위로 나누어 관리됨. 이렇게 하면 코드가 더 직관적이고 유지보수가 쉬워짐. 비즈니스 로직은 컴포넌트의 상태나 동작을 관리하는 역할을 함. 이를 독립된 함수나 모듈로 분리해, UI와 로직이 서로 독립적으로 동작하게 만듦. React와 같은 프레임워크에서는 상태 관리와 UI를 쉽게 분리할 수 있음.예를 들어, 상태 관리 로직과 UI 렌더링 로직을 각각 나누어 코드를 관리할 수 있음.
// 상태 관리 로직 분리
function useCounter() { const [count, setCount] = useState(0); const increment = () =&gt; setCount(count + 1); return { count, increment };
} // UI 로직 분리
function Counter() { const { count, increment } = useCounter(); return ( &lt;div&gt; &lt;p&gt;{count}&lt;/p&gt; &lt;button onClick={increment}&gt;Increment&lt;/button&gt; &lt;/div&gt; );
} Svelte도 비슷하게 로직을 컴포넌트와 분리해 관리할 수 있음. 데이터와 UI를 간결하게 처리할 수 있으며,상태 변화에 따라 빠르게 DOM을 업데이트할 수 있음.
&lt;script&gt; let count = 0; function increment() { count += 1; }
&lt;/script&gt; &lt;button on:click={increment}&gt;Clicked {count} times&lt;/button&gt;
이처럼 UI와 로직을 분리하면, 코드의 가독성과 유지보수성이 높아지고, 확장 가능성이 커짐.컴포넌트 기반 개발에서는&nbsp;컴포넌트 간의 계층 구조와&nbsp;데이터 흐름이 중요한 역할을 함.&nbsp;상위 컴포넌트는 상태를 관리하고,&nbsp;하위 컴포넌트에 데이터를 전달하여 화면을 구성함. 이때, 각 컴포넌트는 독립적으로 동작할 수 있으며, 재사용 가능하게 설계됨.컴포넌트는 상위(Parent)와 하위(Child) 관계로 구성되며,&nbsp;트리 구조로 구성된다고 볼 수 있음.&nbsp;상위 컴포넌트는 하위 컴포넌트를 포함하여 데이터를 주고받음.
App 컴포넌트&nbsp;(상위 컴포넌트) Header 컴포넌트&nbsp;(하위 컴포넌트) Main 컴포넌트 Sidebar 컴포넌트 Content 컴포넌트 React 같은 라이브러리에서는&nbsp;단방향 데이터 흐름이 일반적임. 즉, 상위 컴포넌트가 데이터를 하위 컴포넌트에 전달하고, 하위 컴포넌트는 이벤트를 발생시켜 상위 컴포넌트의 상태를 변경함.
상위 컴포넌트가 상태 관리: 상위 컴포넌트는&nbsp;state와 같은 데이터를 관리하며, 이 데이터를 하위 컴포넌트에&nbsp;props로 전달함. 하위 컴포넌트에서 이벤트 처리: 하위 컴포넌트는 상위에서 받은 데이터를 기반으로 UI를 렌더링하고, 이벤트가 발생하면 상위 컴포넌트로&nbsp;콜백 함수를 호출하여 상태를 변경함. 이러한&nbsp;단방향 흐름은 데이터의 흐름을 명확하게 하고, 디버깅을 쉽게 만들어줌.React와 같은 라이브러리를 사용하지 않고, 바닐라 JavaScript에서 컴포넌트 계층 구조와 상호작용을 구현할 수도 있음. 이때, 각 컴포넌트를 함수로 만들어 관리하고, DOM 조작을 통해 상태를 관리하고 UI를 업데이트함.아래와 같이 부모와 자식을 계층적으로 구조화 시킬수 있다.&lt;div id="app"&gt;&lt;/div&gt; &lt;script&gt; // 하위 컴포넌트 정의 (ChildComponent) function ChildComponent(count, onIncrement) { const container = document.createElement("div"); const countDisplay = document.createElement("p"); const button = document.createElement("button"); countDisplay.textContent = count; button.textContent = "Increment"; button.addEventListener("click", onIncrement); container.appendChild(countDisplay); container.appendChild(button); return container; } // 상위 컴포넌트 정의 (ParentComponent) function ParentComponent() { let count = 0; function increment() { count += 1; update(); } function update() { const app = document.getElementById("app"); app.innerHTML = ""; // 기존 DOM 초기화 // ChildComponent 호출하여 count와 increment 전달 const child = ChildComponent(count, increment); app.appendChild(child); } // 초기 렌더링 update(); } // ParentComponent 렌더링 ParentComponent();
&lt;/script&gt; 컴포넌트 계층 구조는 상위-하위 관계로 구성되며, 상위 컴포넌트는 상태를 관리하고 하위 컴포넌트에 데이터를 전달함. 바닐라 JavaScript에서도 함수형 컴포넌트 방식을 사용해, 상위-하위 컴포넌트 간 상호작용을 구현할 수 있음. 이를 통해 React와 유사한 데이터 흐름과 상태 관리를 흉내낼 수 있음.
]]></description><link>부스트캠프/멤버십/8주차/컴포넌트-단위-개발.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/컴포넌트 단위 개발.md</guid><pubDate>Sun, 15 Dec 2024 17:38:58 GMT</pubDate></item><item><title><![CDATA[상태관리 - props & Context API]]></title><description><![CDATA[
SPAs구조에서는 다양한 화면 렌더링이 필요함. 화면 렌더링은 다양한 state 변경에 의해서 발생. 다수의 state가 있으며 각 state는 변경될 수 있고, 어떤 state는 서버와 동기화 돼야 한다. 하나의 컴포넌트 안에서의 변경 지역변수의 변경과 비슷 const [data, setData] = useState(""); 컴포넌트 간에 상태를 공유하는 경우가 많고, 대부분은 global state 수준으로 관리한다.
상태를 자식에게 전달 props 로 전달 자식 컴포넌트는 props속성을 통해서 필요한 상태를 받아서 렌더링 상태를 자식이 아닌 다른 node 계층에 전달 상위 어딘가 state를 만들어서 컴포넌트간의 공유가 되도록 하기. 아래 그림처럼 공통의 부모 영역에 state를 만들고, 각각 state를 내려받아서 활용. <img src="https://user.oc-static.com/upload/2021/05/06/16202866148021_P3C3-2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
Image:&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://user.oc-static.com/upload/2021/05/06/16202866148021_P3C3-2.png" target="_self">https://user.oc-static.com/upload/2021/05/06/16202866148021_P3C3-2.png</a> props 를 통해서 계속 전달해줘야 하는 단점 존재 (props drilling) 왼쪽은 Props drilling, 오른쪽은&nbsp;Context API 사용 Provider 와 Consumer 개념으로 제공/소비 하는 개념 props 를 계속 전달해줄 필요가 없음. React 가 컴포넌트 계층을 분석해서 props로 전달시킴 <br><img src="https://miro.medium.com/max/2000/1*Ha2vNB0ILaYKPXk6oyTZSQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
image:&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://miro.medium.com/max/2000/1*Ha2vNB0ILaYKPXk6oyTZSQ.png" target="_self">https://miro.medium.com/max/2000/1*Ha2vNB0ILaYKPXk6oyTZSQ.png</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://milddev.com/global-state-management-with-react-usestate-usecontext-hooks-and-context-api" target="_self">https://milddev.com/global-state-management-with-react-usestate-usecontext-hooks-and-context-api</a>import { createStore} from 'redux';
import { Provider } from 'react-redux'; //Provider
const store = createStore(rootReducer)
ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')
) //Consumer
import React from 'react'
import { useSelector } from 'react-redux' export const CounterComponent = () =&gt; { const counter = useSelector((state) =&gt; state.counter) return &lt;div&gt;{counter}&lt;/div&gt;
}
<br><img src="https://css-tricks.com/wp-content/uploads/2016/03/redux-article-3-03.svg?w=640" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
image:&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://css-tricks.com/wp-content/uploads/2016/03/redux-article-3-03.svg?w=640" target="_self">https://css-tricks.com/wp-content/uploads/2016/03/redux-article-3-03.svg?w=640</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://reactjs.org/docs/composition-vs-inheritance.html" target="_self">https://reactjs.org/docs/composition-vs-inheritance.html</a><br>
참고 :&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://javascript.plainenglish.io/how-to-avoid-prop-drilling-in-react-using-component-composition-c42adfcdde1b" target="_self">https://javascript.plainenglish.io/how-to-avoid-prop-drilling-in-react-using-component-composition-c42adfcdde1b</a> export default function App() { return ( &lt;div className="App"&gt; &lt;FirstComponent content="Who needs me?" /&gt; &lt;/div&gt; );
} function FirstComponent({ content }) { return ( &lt;div&gt; &lt;h3&gt;I am the first component&lt;/h3&gt;; &lt;SecondComponent content={content} /&gt;| &lt;/div&gt; );
} function SecondComponent({ content }) { return ( &lt;div&gt; &lt;h3&gt;I am the second component&lt;/h3&gt;; &lt;ThirdComponent content={content} /&gt; &lt;/div&gt; );
} function ThirdComponent({ content }) { return ( &lt;div&gt; &lt;h3&gt;I am the third component&lt;/h3&gt;; &lt;ComponentNeedingProps content={content} /&gt; &lt;/div&gt; );
} function ComponentNeedingProps({ content }) { return &lt;h3&gt;{content}&lt;/h3&gt;;
}
function FirstComponent({ children }) { return ( &lt;div&gt; &lt;h3&gt;I am the first component&lt;/h3&gt;; { children } &lt;/div&gt; );
} function SecondComponent({ children }) { return ( &lt;div&gt; &lt;h3&gt;I am the second component&lt;/h3&gt;; {children} &lt;/div&gt; );
} function ThirdComponent({ children }) { return ( &lt;div&gt; &lt;h3&gt;I am the third component&lt;/h3&gt; {children} &lt;/div&gt; );
} function ComponentNeedingProps({ content }) { return &lt;h3&gt;{content}&lt;/h3&gt;
} export default function App() { const content = "Who needs me?"; return ( &lt;div className="App"&gt; &lt;FirstComponent&gt; &lt;SecondComponent&gt; &lt;ThirdComponent&gt; &lt;ComponentNeedingProps content={content} /&gt; &lt;/ThirdComponent&gt; &lt;/SecondComponent&gt; &lt;/FirstComponent&gt; &lt;/div&gt; );
}
]]></description><link>부스트캠프/멤버십/8주차/상태관리-props-&amp;-context-api.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/상태관리 - props &amp; Context API.md</guid><pubDate>Sun, 15 Dec 2024 17:38:25 GMT</pubDate><enclosure url="https://user.oc-static.com/upload/2021/05/06/16202866148021_P3C3-2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://user.oc-static.com/upload/2021/05/06/16202866148021_P3C3-2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[부스트캠프]]></title><link>부스트캠프/베이직/부스트캠프.html</link><guid isPermaLink="false">부스트캠프/베이직/부스트캠프.md</guid><pubDate>Sun, 15 Dec 2024 17:37:51 GMT</pubDate></item><item><title><![CDATA[부스트캠프 회고]]></title><description><![CDATA[<img src="https://i.imgur.com/ueLbsul.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
부스트캠프 멤버십을 수료했다.
살면서 개발을 이렇게 열심히 해본 적은 처음이었던 것 같다(개발시작 1.5년차)
매일 슬랙에 체크인아웃을 하던게 엊그제같은데 이제는 평일에 체크인아웃이 없으니 뭔가 허전한 느낌이 들기도 한다.아무튼 부스트캠프가 끝나고 헐레벌떡 바로 어제 리눅스 마스터 시험이 있어서 급하게 준비하고 보고 이제는 조금 여유가 생겨 회고를 쓰기로 했다.
그냥 깨달은 것들을 중점적으로 생각나는 대로 두서없이 쓸 예정이니 의식의 흐름 주의,,,이번 회고에서는 특히 내가 성장한 경험을 위주로 작성할 예정이다.솔직히 냉정하게 말하자면.. 내가 이전까지 했던 프로젝트나 동아리 활동 모두 프론트엔드 개발에 있어서는 크게 동료에게 받는 깨달음 내지 배움은 거의 없었다고 생각한다.항상 내가 주도적으로 말하면 동료들이 어찌저찌 따라오기만 할 뿐, 기술적인 인사이트를 얻거나 코드에 대한 생산적인 리뷰 하나 받아보지 못했다. 물론 다들 인간적으로 너무 좋은 사람들이지만 이런 부분에 대해서는 항상 아쉬움을 느꼈던 것 같다.<br>
<img src="https://i.imgur.com/4he9qEP.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
물론 제대로 된 PR을 올리지도 못했던 내 잘못도 있다고 생각한다.
하지만 이런 LGTM 남발만 받다보니 내 스스로도 이게 좋은 코드인지에 대해서 의구심이 들었지만 물어볼 사람조차 없었다. 그렇기 때문에 더더욱 스터디 그룹별로 계속해서 코드리뷰를 받는다는 부스트캠프의 운영방식이 괜찮을까? 생각했었다.하지만 부스트캠프에 들어오면서 동료 피드백에 대한 많은 생각이 바뀌게 되었다.
예상 외로 부스트캠프에 함께 하는 사람들은 정말 열심히 코드를 리뷰해주었으며, 내가 생전 처음 들어보는 키워드나 기능들을 말씀하시는걸 캐치하여 학습하면서 많은 것들을 새롭게 알아낼 수 있었다.
더불어 나도 다른 분들이 정성들여 해주시는 만큼 나도 열심히 해야겠다고 생각하다보니 열심히 다른 분들의 코드를 읽게 되고, 자연스럽게 남들의 코드를 읽는 능력 또한 많이 늘었다.프로젝트에서는 매일 평균적으로 14시간정도를 코딩을 하는데 쓰면서 심적으로나 육체적으로 많이 약해졌었다. 그러다보니 나도 모르게 예민했던 적이 많았던 것 같다.<br> <img src="https://i.imgur.com/YKj0zpS.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그럼에도 불구하고 좋은 동료가 있었기에 제대로 프로젝트를 끝낼 수 있었다고 생각한다.
트러블이 생길 수도 있을 뻔한 일이 있었다. 하지만 그렇다고 서로가 감정이 끝나는 상태에서 끝내지 않고, 솔직하게 서로의 감정을 털어내고 진심으로 사과하면서 모두가 다시 힘낼 수 있었다. 성숙한 태도를 가지는 동료들을 만난게 정말 행운이라고 생각한다.<br><img src="https://i.imgur.com/71VG8i8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그리고 무엇보다 다같이 힘들면 더 끈끈해진다고 하지 않는가.
다같이 힘들다보니 서로 배려해주고 응원해주면서 동료와의 끈끈한 우정을 통해 함께 프로젝트까지 야무지게 끝낼 수 있었다.<br><img src="https://i.imgur.com/HHqg3Se.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">무엇보다 부스트캠프를 통해 가장 많이 얻어간 것은 학습 방법과 다양한 학습 키워드라고 생각한다.
부스트캠프에 들어오기 이전까지는 뭘 해야할 지 몰라서 제대로 학습을 못했었다면, 부스트캠프에서는 너무 공부하고 싶은 것들도 많았고 공부해야 하는 것들도 많았다.생전 처음 들어보는 키워드들이 난무했다. 하지만 부스트캠프에서는 이를 무조건 A부터 Z까지 알려주는 것이 아닌 스스로 학습하고 깨달아야 한다. 결국 이를 어떻게 학습해서 소화시키냐는 온전히 학습하는 사람의 몫인 것이다.<br><img src="https://i.imgur.com/Bzw1VfA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">나 또한 그렇게 던져주는 학습 키워드들을 모두 흡수하지는 못했다고 생각한다. 부스트캠프가 끝난 지금까지도 학습 부채는 있기 때문에 시간이 날 때마다 틈틈히 정리해둘 예정이다.<br><img src="https://i.imgur.com/31FM193.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">아무튼 이렇게 던져주는 학습 키워드들을 줍고 이 학습 키워드에 대해서 직접 처음부터 정리해가며 문서화해나가는 과정을 통해 어떻게 '학습'해야 하는지에 대해 나름 나에게 가장 잘 맞는 학습 방식을 정립해 나갔다고 생각한다. 이러한 과정을 체험하길 장려했던 부스트캠프가 정말 개발자의 기본을 가르치는 곳이구나 깨달았다.부스트캠프에서는 모든 활동에 대해서 기록, 즉 문서화를 강조한다.
나 또한 문서화는 조금씩 하고 있었지만 사실 이 문서화가 정말 중요한 걸까에 대해서는 스스로도 제대로 답을 내리지 못했다. 비록 기술 블로그는 조금씩 정리하고 있다고는 해도 부스트캠프가 강조하는 정도를 보면 이정도는 살짝 광기인 것 같은데.. 라는 생각이 들고는 했다.하지만 요즘 들어서는 문서화의 중요성을 깨달아가고있다.
가장 기본적으로 문서화 과정은 나의 경험이나 학습을 글로 정리하는 과정인데, 사실 한번에 제대로 완벽한 문서를 만들기 쉽지 않다. 결국 일반 글쓰기와 다름 없이 몇 번의 퇴고를 통해서 비로소 온전한 문서 하나가 완성된다. 이 과정에서 내가 어떻게 이 경험, 학습을 기억해야 할 지 정리하면서 글을 써내려가다보니 머릿속에서도 자연스럽게 정리되는 느낌이 들었다. 그러다보니 비단 문서뿐만 아니라 머리에서도 이 글의 맥락을 모두 이해할 수 있었기에 이를 다시 말로 풀 때면 술술 나오는 느낌을 받았다. 또한 학습 과정에서 연관된 키워드 중에 까먹는 경우도 있기 때문에 이게 뭐였더라 싶은게 꽤 있었는데 내 문서를 찾아보면 내가 이해하기 쉽게 정리해놓은 문서가 있는 경우가 있었다. 이를 다시 읽고 개념을 다시금 이해하는 과정을 통해서 보다 장기적으로 기억이 저장되는 느낌을 받을 수 있었다.결국 이러한 문서화를 하는 일련의 과정 자체가 전부 나에게 알게모르게 영향을 끼치고 있었음을 깨닫고 아 이래서 문서화가 중요했구나를 깨닫게 되었다.<br><img src="https://i.imgur.com/apguQFZ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">문서화의 중요성을 깨달은 만큼 이제는 문서화를 귀찮아 하지 않고 열심히 퀄리티 좋은 문서를 만들기 위해서 노력할 생각이다.위에서도 말했다시피 부스트캠프가 끝난 후 나는 바로 리눅스마스터 시험을 준비하고 보고 왔다.<br><img src="https://i.imgur.com/z1TX6hP.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">솔직히 부스트캠프 전까지는 내가 리눅스를 공부하게 될 줄은 꿈에도 상상하지 못했다. 프론트엔드 개발자가 리눅스를? 이라는 생각이 들었기 때문이다.하지만 부스트캠프 과정에서 백엔드, 프론트엔드를 모두 경험하며 내가 내린 결론은 프론트엔드 개발자, 백엔드 개발자는 모두 개발자이다 였다.<br>
<img src="https://i.imgur.com/LQTjYbM.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
무슨 당연한 소리냐고 물어볼 수도 있다.
내가 생각하는 프론트엔드 개발자나 백엔드 개발자는 자신이 조금 더 특화되어있는 분야가 앞에 붙을 뿐이지 이들은 모두 개발자로 추상화된다. 따라서 프백 상관없이 개발자로서 서로의 코드를 어느정도는 알고 있어야 하며 이를 위한 배경지식은 '개발자'에게의 공통사항이라고 생각한다. 물론 각자가 공부해야 하는 것들은 엄청 다르기 때문에 차이는 날 수 있더라도 이를 완전히 프백이 서로 완전히 독립적인 객체라고 생각하고 학습하게 되면 시야의 폭이 좁아질 수밖에 없다고 생각한다. 부캠 전의 나처럼아무튼 나는 그래서 부스트캠프가 끝난 후 프백을 가리지 않고 다양하게 학습할 계획이다. 기본적인 CS지식을 다시금 탄탄하게 잡고, 이를 기반으로 프론트엔드 개발을 하면서도 백엔드의 아키텍처와 객체 지향 프로그래밍 등등 폭넓게 학습할 것이다.<br>
<img src="https://i.imgur.com/ioFEXUX.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
벌써부터 공부해야 할 것들이 태산이라 잘 할 수 있을까 걱정도 되지만서도 나름 부캠도 잘 끝냈는데 앞으로도 잘 되겠지! 하는 마음으로 열심히 해보려고 한다.<br><img src="https://i.imgur.com/9KbOMTr.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>부스트캠프/멤버십/8주차/부스트캠프-회고.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/부스트캠프 회고.md</guid><pubDate>Sun, 15 Dec 2024 16:19:23 GMT</pubDate><enclosure url="https://i.imgur.com/ueLbsul.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/ueLbsul.jpeg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[IMG_0231 1]]></title><description><![CDATA[<img src="부스트캠프/멤버십/8주차/img_0231-1.jpg" target="_self">]]></description><link>부스트캠프/멤버십/8주차/img_0231-1.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/IMG_0231 1.jpg</guid><pubDate>Sun, 15 Dec 2024 04:11:11 GMT</pubDate><enclosure url="부스트캠프/멤버십/8주차/img_0231-1.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/멤버십/8주차/img_0231-1.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[IMG_0231]]></title><description><![CDATA[<img src="부스트캠프/멤버십/8주차/img_0231.jpg" target="_self">]]></description><link>부스트캠프/멤버십/8주차/img_0231.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/IMG_0231.jpg</guid><pubDate>Sun, 15 Dec 2024 04:10:55 GMT</pubDate><enclosure url="부스트캠프/멤버십/8주차/img_0231.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/멤버십/8주차/img_0231.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십 과정]]></title><description><![CDATA[<a data-href="멤버십_1주차" href="부스트캠프/멤버십/1주차/멤버십_1주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_1주차</a><br>
<a data-href="멤버십_2주차" href="부스트캠프/멤버십/1주차/멤버십_2주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_2주차</a><br>
<a data-href="멤버십_3주차" href="부스트캠프/멤버십/3주차/멤버십_3주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_3주차</a><br>
<a data-href="멤버십_4주차" href="부스트캠프/멤버십/4주차/멤버십_4주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_4주차</a><br><a data-href="멤버십_5주차" href="부스트캠프/멤버십/5주차/멤버십_5주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_5주차</a><br>
<a data-href="멤버십_6주차" href="부스트캠프/멤버십/6주차/멤버십_6주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_6주차</a><br>
<a data-href="멤버십_7주차" href="부스트캠프/멤버십/7주차/멤버십_7주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_7주차</a><br>
<a data-href="멤버십_8주차" href="부스트캠프/멤버십/8주차/멤버십_8주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_8주차</a><br><a data-href="PR" href="부스트캠프/멤버십/8주차/pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">PR</a><br><a data-href="그룹 프로젝트_1주차" href="부스트캠프/멤버십/그룹프로젝트-1주차/그룹-프로젝트_1주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹 프로젝트_1주차</a><br>
<a data-href="그룹 프로젝트_2주차" href="부스트캠프/멤버십/2주차/그룹-프로젝트_2주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹 프로젝트_2주차</a><br>
<a data-href="그룹 프로젝트_3주차" href="부스트캠프/멤버십/3주차/그룹-프로젝트_3주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹 프로젝트_3주차</a><br><a data-href="그룹 프로젝트_리드미" href="부스트캠프/멤버십/8주차/그룹-프로젝트_리드미.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹 프로젝트_리드미</a><br>
<a data-href="학습 정리" href="부스트캠프/챌린지/학습-정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">학습 정리</a><br>
<a data-href="특강" href="부스트캠프/멤버십/그룹프로젝트-1주차/특강.html#_0" class="internal-link" target="_self" rel="noopener nofollow">특강</a><br>
<a data-href="NCP 후기" href="부스트캠프/멤버십/8주차/ncp-후기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">NCP 후기</a><br><a data-href="그룹 프로젝트_정리본" href=".html" class="internal-link" target="_self" rel="noopener nofollow">그룹 프로젝트_정리본</a><br>
<a data-href="그룹프로젝트_협업전략" href="부스트캠프/멤버십/8주차/그룹프로젝트_협업전략.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹프로젝트_협업전략</a><br>
<a data-href="그룹프로젝트_사이드바" href="부스트캠프/멤버십/8주차/그룹프로젝트_사이드바.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹프로젝트_사이드바</a><br><a data-href="vpc미션" href="부스트캠프/멤버십/8주차/vpc미션.html#_0" class="internal-link" target="_self" rel="noopener nofollow">vpc미션</a><br><a data-href="2024년 회고" href=".html" class="internal-link" target="_self" rel="noopener nofollow">2024년 회고</a><br>
<a data-href="부스트캠프 회고" href="부스트캠프/멤버십/8주차/부스트캠프-회고.html#_0" class="internal-link" target="_self" rel="noopener nofollow">부스트캠프 회고</a>]]></description><link>부스트캠프/멤버십-과정.html</link><guid isPermaLink="false">부스트캠프/멤버십 과정.md</guid><pubDate>Sun, 15 Dec 2024 04:06:20 GMT</pubDate></item><item><title><![CDATA[리눅스 마스터 정리]]></title><description><![CDATA[
lp : 프린트 요청
lpstat : 프린트 상태 조회
cancel 작업 취소 lpr : 프린트 요청
lpc(Line Printer Control) : 프린트 제어 및 관리
lpq : 인쇄 대기열 확인
lprm : 프린트 요청 삭제
각 패키지 상세내용 확인 필수 !프린터 : LPRng(버클리, BSD계열) / CUPS(애플)
사운드 : ALSA(리눅스 커널요소) / OSS
스캐너 : SANE / XSANE
SCSI 스캐너 : /dev/sg0, /dev/scanner USB 스캐너 : /dev/usb/scanner, /dev/usbscanner
[소유권]
chown : 그룹 및 개인 소유권 설정 및 변경
chgrp : 그룹 소유권 변경[허가권]
umask : 허가권 지정
chmod : 파일이나 디렉터리의 허가권 값을 변경읽기4(r) 쓰기2(w) 실행1(x)
chown : 파일이나 디렉토리의 소유권 및 그룹 소유권을 변경하는 명령어파일의 소유자는 posein, 소유 그룹은 jhkim으로 설정한다.
chown posein:jhkim test.txtBLOG 파일의 그룹 소유권을 root로 변경한다.
chown :root BLOGchgrp : 파일이나 디렉토리의 소유 그룹을 바꾸는 명령어
umask : 새로 만들어진 파일에 대한 소유권한 지정명령test.txt 파일의 그룹 소유권을 jhkim으로 변경한다.
chgrp jhkim test.txt특수권한
Set-UID(d,4): 해당 파일 소유자의 권한을 잠시 사용
Set-GID(s,2): 해당 파일의 그룹 권한을 잠시 사용
Sticky-Bit(t,1): 특정 디렉토리를 누구나 자유롭게 사용할 수 있게 하기 위해서 사용 RAID - 0 은 스트라이핑 즉 , 안정성 보단 성능을 위해 사용한다.
RAID - 1 은 미러링 / 복구 가능 / 비용 많이듬
RAID - 5 최소 3개 이상 디스크 은 한개의 패리티 사용
RAID - 6 최소 4 개 이상 디스크, 여러디스크 장애도 가능
RAID - 10 미러링 하고 스트라이핑 하는 방식
<a data-tooltip-position="top" aria-label="https://greencloud33.tistory.com/41" rel="noopener nofollow" class="external-link is-unresolved" href="https://greencloud33.tistory.com/41" target="_self">LVM</a>
LVM(Logical Volume Manager) : 리눅스의&nbsp;저장 공간을 효율적이고 유연하게 관리하기 위한 커널의 한 부분장점
유연한 용량 조절
크기 조절이 가능한 storage pool
편의에 따른 장치 이름 지정
disk striping, mirror volume 등 제공
그림 보면서 개념 숙지 필수
PV : Physical Volume, 디스크를 LVM에서 사용할 수 있게 변환하는 작업 VG : Volume Group, PV가 모여 만들어진 그룹
VG는 다시 LV로 할당할 수 있는 공간이기도 함. PE : Physical Extent, PV에서 나누어 사용하는 블록. 4MB 단위 LV : Logical Volume, VG에서 사용자가 필요한 만큼 할당돼서 만들어지는 공간 LE : Logical Extent, LV가 나누어진 일정한 크기의 블록. PE와 서로 1:1 대응
PV VG LV
LVM : 논리 볼륨 관리자라는 의미로 여러 개의 물리적인 하드디스크를 논리적인 디스크로 할당
PV : 물리적 볼륨이라는 의미로 각각의 파티션을 LVM으로 사용하기 위해 형식을 변환 시킨 것이다.
VG : 볼륨 그룹으로 PV로 되어 있는 파티션을 하나의 물리적인 그룹으로 만든다.
LV : 논리적 볼륨으로 마운트포인터로 사용할 실질적인 파티션이다 yum list: 전체 패키지에 대한 정보 출력
yum history : 패키지 설치, 삭제 등 작업 이력 확인
yum remove 패키지명: 지정한 패키지 제거
yum search 문자열: 해당 문자열이 포함된 패키지 검색
yum groupinstall 패키지명: 지정한 패키지 그룹 설치
yum install 패키지명: 의존성을 고려하며 패키지 설치
yum list update: 업데이트시 필요한 패키지 정보
yum info: 패키지 정보 출력
yum check-update: 업데이트가 가능한 패키지 목록 확인
yum grouplist : 설치된 패키지의 그룹별 정보//groupinfo 낚시 주의
yum groupinfo : 해당 패키지 그룹명과 관련된 패키지의 정보를 보여준다. rpm -i 패키지명 : 설치
rpm -qa 패키지명 : 확인
rpm -e 패키지명 : 제거
옵션 -q : 패키지 설치 여부 확인
-a : 모든 패키지 확인
-i : 패키지 설치
-U : 설치 + 업데이트
-F : 설치 compress, uncompress (압축명: .Z) xz, unxz (압축명: .xz), 옵션 '-d'(압축해제) gzip, gunzip (압축명: .gz) bzip, bunzip (압축명: .bz2) 압축률 순위: Z(compress) &lt; gzip(gz) &lt; bz2(bzip) &lt; xz(xz)압축해제
tar : Tape Archive
tar gzip - .zxvf
tar jxvf - .bzip2
tar Jxvf - .xz
tar 옵션 a 옵션 : (append) 파일 내의 기록에 다른 파일 내용을 추가로 묶음 c 옵션 : (create) 새 파일을 만듦 x 옵션 : (extract) 기록에서 파일을 발췌 t 옵션 : (list) 압축된 파일 안에 있는 구성 파일 출력 configure - make - make install
configure 했을 때 Makefile이라는 파일이 나옴 alien : 래드햇 패키지(.rpm)을 데비안 패키지(.deb)로 변환해주는 패키지 관리 도구(Debian) pico -&gt; nano 순서대로 자주 나옴
vi 1976 빌조이
emacs 1984 리차드 스톨만
pico 1989 아보일카사르
VIM 1991 브람 무레나르
nano 1999 크리스 알레그레타
gedit 2001 파올로 매기
kate 2001 크리스토프 컬만
Sublime Text 2008 존 스키너
Atom 2014 크리스트 완스트라스, 네이선 소보, 벤자민 오글 가장 많이 쓰이는 편집기로써 1976년 빌 조이가 만듦
단축키 a 커서 뒤부터 입력
A 줄의 마지막에 입력
i 현재 문자 앞에 입력
I 줄의 시작 부분에 입력
o 현재 줄 다음 줄에 입력
O 커서가 있는 줄 위에 입력
:% s/^linux/Linux/ : 파일 전체의 linux로 시작하는 줄을 Linux로 치환 (줄의 첫부분)
&lt;&gt;는 완벽하게 같은 경우에만 바꾸라는 것(문자 단위) 설정 set nu : 숫자 표기
set ai : 자동 들여쓰기 옵션 윗 라인에 맞춰 같이 자동으로 들여쓰기 set ic : 검색 패턴 사용 시 대소문자 구별 X set sm : 소스 코딩 작성 중 괄호를 닫을 때 어디에 있는 열기 괄호와 연관 되어 있는지 표시 set list : 눈에 보이지 않는 특수문자를 표시 브람 무레나르
편집시 다양한 색상을 이용하여 가시성을 높일 수 있다. 리차드 스톨만
[Ctrl]+[x] - [Ctrl]+[s] : 파일 저장
[Ctrl]+[x] - [s] : 현재 열려있는 버퍼 저장
[Ctrl]+[b] : 이전(뒤) 칸으로 이동
[Ctrl]+[f] : 다음(앞) 칸으로 이동
[Ctrl]+[p] : 이전 줄로 이동
[Ctrl]+[n] : 다음 줄로 이동
[Ctrl]+[a] : 줄의 시작으로 이동
[Ctrl]+[e] : 줄의 끝으로 이동 GNU 프로젝트
Ctrl + A 줄의 처음으로 이동
Ctrl + E 줄의 끝으로 이동 (End)
Ctrl + P 커서를 윗줄로 이동 (Previous)
Ctrl + N 커서를 아랫줄로 이동 (Next)
Ctrl + Y 이전 페이지로 이동
Ctrl + V 다음 페이지로 이동
Ctrl + K 한줄 삭제 (Kill)
Ctrl + U 붙여넣기
Ctrl + O 저장
Ctrl + X 종료
<br><img src="https://i.imgur.com/bTZdYbF.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">0 7 1 1-10/2 * /bin/vipcheck.sh
매년 1월부터 10월까지 두달 주기로 1일날 오전7시 /bin/vipcheck.sh 스크립트를 실행
[분 시 일 월 요일] ps : 현재 실행 중인 프로세스의 상태를 출력하는 명령어
pstree : 실행 중인 프로세스를 트리(tree) 구조로 출력하는 명령어
top : 프로세스 상태를 실시간으로 확인하거나, 모니터링 하는 명령어
nohup : 프로세스를 중단하지 않고, 백그라운드(background) 작업을 수행 명령어
ss : 소켓 통계, 네트워크 연결, 프로토콜 사용 현황 등을 확인하는 명령어
netstat : 네트워크 상태와 관련된 통계. 네트워크 연결, 라우팅 테이블, 인터페이스 등을 확인하는 명령어
ethtool : 네트워크 인터페이스 카드의 조회 및 설정
mii-tool : 랜카드의 속도, duplex모드, 네트워크 점검 등에 사용하는 명령어
jobs : 백그라운드로 실행중인 프로세스를 확인하는 명령어
fg : 프로그램을 포그라운드(foreground)로 전환하는 명령어
bg : 프로그램을 백그라운드(background)로 전환하는 명령어
nice : 실행할 프로그램의 우선순위를 지정하고, 우선순위 설정값을 확인하는 명령어
renice : 이미 실행 중인 프로세스의 우선순위를 변경하는 명령어
kill : 프로세스에 특정한 시그널(signal)을 보내는 명령어
killall : 프로세스 번호가 아닌 프로세스 명으로 종료시키는 명령어
PS(process status)명령어 : 실행중인 프로세스 상태를 보여줌 System V계열: 대시 "-" 사용 BSD 계열:대시 사용 안함 GNU 계열: 대시 두개 "--" 사용 옵션(BSD계열)
a: 현재 실행중인 모든 프로세스 출력 u: 사용자 이름과 프로세스 시작 시간 출력 x: 접속된 터미널뿐만 아니라 사용되고 있는 모든 프로세스들 출력
옵션(System V 계열)
A(System V 계열):모든 프로세스 출력 e:모든 프로세스를 출력 (-A 옵션과 같음) a:세션 리더(로그인 셸)를 제외하고 터미널에 종속되지 않는 모든 프로세스를 출력
1. init (런레벨) : 재부팅과 종료레벨 있음 0~6까지 7단계 구분
2. inetd (internet service daemon의 약자) : 다른 데몬들을 제어, 연결하는 역할을 하는 데몬
3. standalone :백그라운드 요청 기다렸다가 요청이오면, 혼자 처리하는 방식
4. daemon : 프로세스로 메모리에 상주해 있다가 사용자 요청이 오면 응답하는 프로세스
5. top : 실시간으로 CPU 사용량을 확인할 때 이용하는 명령어
6. pgrep : 실행 중인 프로그램의 프로세스 ID를 찾을 수 있는 명령줄 유틸리티
7. nohup : 프로세스를 중단하지 않고, 백그라운드 작업을 수행할 수 있게 하는 명령어
8. free : 시스템에서 사용하지 않는 메모리와 이미 사용하고 있는 메모리의 전체 용량 등
--nodeps : 의존성 관계를 무시하고 설치
--force : 기존에 설치된 패키지와 관계없이 강제로 설치
필드 1 : 사용자명
필드 2 : 패스워드
필드 3 : 사용자 uid
필드 4 : 사용자 gid
필드 5 : 사용자 이름
필드 6 : 사용자 홈 디렉토리
필드 7 : 사용자 로그인 쉘
/etc/shells
사용 가능한 셸 목록을 저장하고 있는 파일
/etc/bashrc
별칭(alias)과 bash가 수행될 때 실행되는 함수 제어와 관련된 설정 값을 저장하고 있는 파일
/etc/passwd
리눅스 계정 정보를 저장하고 있는 파일
필드 필드 1 : 사용자명 필드 2 : 패스워드 필드 3 : 사용자 uid 필드 4 : 사용자 gid 필드 5 : 사용자 이름 필드 6 : 사용자 홈 디렉토리 필드 7 : 사용자 로그인 쉘 /etc/profile
시스템 전역(모든 사용자)에 대한 환경설정 파일. 로그인시 설정 내용을 읽어들임. 시스템 전반적인 환경값들을 설정.
/etc/resolv.conf
DNS(nameserver)
/etc/bash_profile
bash 쉘로 로그인 되었을 경우에만 적용
/etc/mtab
현재 마운트된 정보를 담는 파일
/etc/fstab
부팅 시에 자동으로 마운트 될 정보를 담는 파일
fstab에 입력하고 mount -a하면 마운트됨
~/.bash_profile
개인 사용자에 대한 환경설정 파일. 로그인시 설정 내용을 읽어들임. 각 사용자 환경에 맞는 설정
~/.bashrc
별칭(alias)과 bash가 수행될 때 실행되는 함수를 제어하는 지역적인 시스템 설정과 관련된 파일이다. 이들 별칭과 함수들은 오직 해당 사용자에게만 한정되며, 그 이외의 다른 사용자에게는 영향을 미치지 않는다.
~/.bash_logout
개인 사용자가 로그아웃을 수행하는 설정을 지정하는 파일
기본값 10 / -20 ~ 19
값이 작을수록 우선순위 높음 (1) # nice --10 bash [감소]
(2) # renice -10 1222 [바로설정]
※ renice 명령에서 우선순위를 높이기 위해서는 --10이 아닌 -10을 입력해야합니다. *renice -10 7847 = 현재 값에서 -10이 계산되는게 아니라 그냥 -10
* 리눅스에서 지정 가능한 NI 값중 순위가 가장 높은 것은?
-21, [-19], 0, 19 사파리 - 애플
오페라 - 노르웨이
크롬 - 구글
파이어폭스 - 모질라 Libreoffice Writer 문서 작성기
Libreoffice Impress 파워포인트
Libreoffice Calc 스프레드 시트, 엑셀
Libreoffice Draw 그림판
[응용 계층 프로토콜]
FTP - 20, 21
SSH - 22
Telnet - 23
SMTP - 25
DHCP - 67, 68
TFTP - 69
HTTP - 80
POP3 - 110
IMAP - 143
SNMP - 161, 162
[네트워크 계층 프로토콜]
IP, ICMP, IGMP, ARP, RARP[전송 계층 프로토콜]
TCP, UDP[응용 계층 프로토콜]
FTP, SSH, Telnet, SMTP, DHCP, TFTP, HTTP, POP3, IMAP, SNMP
SCP(Secure Copy Protocol) SSH를 사용하여 파일을 안전하게 전송 RSH(Remote Shell) 원격 시스템에서 명령어 실행 SFTP(SSH File Transfer Protocol) SSH를 사용한 파일 전송 프로토콜 TCP
- 연결지향
- 3-way handshaking 연결 방식
- 전송신뢰 가능
- 빠르지만 UDP보다 느림
- 부하 낮지만 UDP보다 높음 UDP
- 비 연결
- 전송을 신뢰할 수 없다.
- 속도 매우 빠르다
- 부하 매우 낮음
① ifconfig : IP 주소를 설정하거나, 활성화/비활성화, 인터페이스 정보를 출력하는 명령어
② route : 패킷을 전송할 수 있도록 목적지까지 경로를 설정 및 관리하는 명령어
③ ping : 네트워크 또는 호스트들의 연결 상태를 확인하는 명령어
④ traceroute : 특정 네트워크 및 호스트까지 도달하는 경로를 출력하는 명령어
⑤ netstat : 현재 시스템의 네트워크 연결 상태를 확인하는 명령어
⑥ arp : ARP 테이블을 설정하고 확인하는 명령어
⑦ ethtool : 네트워크 인터페이스의 물리적 연결 상태를 확인하는 명령어 디폴트 게이트웨이 추가: route add default gw x.x.x.x 네트워크 경로 추가: route add -net x.x.x.x netmask x.x.x.x gw x.x.x.x 호스트 경로 추가: route add -host x.x.x.x dev [인터페이스명]
xhost IP나 도메인명을 이용해서 서버 접속 요청 형식: xhost [+][-][ip|도메인명] xauth .Xauthority 파일의 쿠키 내용을 추가, 삭제, 리스트를 출력하는 유틸리티 형식: xauth [옵션] 데스크톱 환경: GUI 환경을 이용하기 위해 사용자에게 제공되는 인터페이스 스타일 윈도 매니저: X-윈도우상에서 윈도우의 배치와 표현을 담당하는 시스템 프로그램
도크(Dock), 태스크 바(Task bar), 프로그램 런처(Program launcher), 데스크톱아이콘(Desktop Icon),
바탕화면(Wallpaper) 등과 같은 다양한 유틸리티 제공 디스플레이 매니저: X-윈도우 구성요소 중 사용자 로그인 및 세션 관리 역할 수행 프로그램
그래픽 모드에서 실행되는 것으로 XDM, GDM, KDM 등이 있음 유저 인터페이스 : 사람들이 컴퓨터와 상호 작용하는 시스템
SaaS: 클라우드 환경에서 동작하는 응용 프로그램들을 서비스
IaaS:서버와 스토리지 같은 IT 하드웨어 자원을 빌려주는 클라우드 서비스
DaaS: 사용자에게 가상화된 데스크톱을 아웃소싱 형태로 전달하는 서비스
PaaS: 소프트웨어 서비스를 개발하기 위한 플랫폼을 제공하는 클라우드 서비스
ICANN : IP 주소 할당 및 도메인
IEEE : LAN,MAN
ISO : OSI7계층
EIA : RS-232C, T568B케이블 배열 표준화기구
IANA : 인터넷 주소 할당 번호 관리기관
&nbsp;- webOS - 리눅스 커널 기반 모바일 OS Tizen - 리눅스 커널 기반 OS QNX - 유닉스 계열 서버 OS GENIVI - 리눅스 커널 기반 OS / 오픈소스 기반의 차량 멀티미디어 플랫폼 표준 Ansible : 구성 관리, 애플리케이션 배포 및 작업 자동화에 사용되는 오픈 소스 자동화 도구
OpenStack : 프라이빗 및 퍼블릭 클라우드 구축하고 관리. 오픈 소스 클라우드 컴퓨팅 플랫폼
Kubernetes : 컨테이너화된 애플리케이션의 배포. 확장 및 관리를 자동화하도록 설계된 오픈 소스 컨테이너 오케스트레이션 플랫폼. 구글에 의해 설계되었고 현재는 리눅스 재단에서 관리
Docker : 경량화된 가상화 기술. 하이퍼바이저나 게스트OS 없이 서버 운영에 필요한 프로그램과 라이브러리 만 격리해서 설치 및 운용 가능
totem : 동영상 플레이어
evolution : 메일, 주소록, 일정 등 개인 정보 관리
evince : PDF 뷰어 (영단어로 '분명히 나타내다')
Eog : 그래픽뷰어
GIMP : 그래픽 편집
SMTP = Simple Mail Transfer Protocol = 이메일 전송에 사용되는 프로토콜 IMAP = Internet Message Access Protocol
이메일 서버와 클라이언트 간의 효율적인 이메일 동기화 및 공유를 위한 프로토콜 POP3 = Post Office Protocol 3 = 이메일 수신에 사용되는 프로토콜
전자 우편 서비스를 제공하기 위해서는 설명한 세 개의 프로토콜을 함께 사용해야함.
기능: 디스크의 파티션 생성, 삭제, 보기 등 파티션을 관리한다.
형식: -b 크기 → 섹터 크기를 지정한다. -ㅣ → 파티션 테이블을 출력한다.
내부 명령
a -파티션의 부트 가능 플래그를 전환합니다.
c -파티션의 DOS 호환성 플래그를 전환합니다.
d -파티션을 삭제합니다.
l -fdisk에 알려진 파티션 유형을 나열합니다.
m -모든 사용 가능한 메뉴 목록을 표시합니다.
n -새 파티션을 추가합니다.
p -현재 디스크에 대한 파티션 테이블을 출력합니다.
q -변경사항을 저장하지 않고 종료합니다.
t -파티션에 대한 파일 시스템 유형을 변경합니다.
u -표시/항목 단위를 변경합니다.
v -파티션 테이블을 검증합니다.
w -파티션 정보 저장 후 종료합니다.
x -다음의 전문가용 추가 기능을 나열합니다.
fork
- 새로운 프로세스를 위해 메모리를 할당받아 복사본 형태의 프로세스를 실행하는 형태로
- 기존의 프로세스는 그대로 실행되어 있다. exec
기본 프로세스가 교체되면서 새로운 프로세스로 할당하는 명령
KDE : 유닉스 워크스테이션을 위한 강력한 오픈소스 GUI 데스크톱 환경 Qt(C++ 확장 라이브러리) 기반으로 만들어짐 쉬운 사용법, 유닉스 운영체제의 기술력을 바탕 Xfce : 다양한 유닉스 운영체제들을 위한 가벼운 데스크톱 환경 생산성 높은 디자인, 높은 프로그램 실행 속도, 낮은 시스템 리소스 점유율 등이 강점 LXDE : 컴퓨터 사양에 상관없이 사용할 수 있도록 설계된 데스크톱 환경 GNOME : 리눅스 등 유닉스 계열 운영 체제를 위한 그래픽 사용자 인터페이스(GUI) 기반
1. IRC : 실시간 채팅 프로토콜 / 파일 전송기능도 제공
2. NFS : 네트워크상에서 다른 컴퓨터의 파일 시스템을 마운트하고 공유하여 상대방의 파일 시스템 일부를 자기 자신의 디렉터리인것처럼 사용
3. SAMBA : 리눅스, 유닉스 계열의 OS와 윈도의 OS간 자료 공유 및 하드웨어를 공유
4. Usenet : 텍스트 형태의 기사들을 주고 받을 수 있는 게시판
[ KVM ]
- 전가상화 기술을 지원
- QEMU라는 CPU 에뮬레이터 사용
- 전용 하이퍼 바이저가 아닌 Linux 자체를 호스트 OS로 이용 [ XEN ]
- 전가상화 기술과 반가상화 기술을 모두 지원
- 베어메탈 방식의 하이퍼 바이저이므로 호스트 OS가 존재하지 않는다.
- Domain 0이라는 특수한 Domain이 존재. 각 도메인을 제어한다. [VirtualBox]
- 이노테크(InnoTek)가 개발 현재는 오라클이 개발 중인 상용, 사유 소프트웨어(제한된 GPL 버전)
- 가상머신 생성시 기본 확장자: vdi
1. quota : 현재 사용자 단위 쿼터 정보를 출력한다
2. edquota : 편집기(editor)를 사용하여 그룹에 디스크 사용량 할당, 실행시 vi 편집기 실행됨
3. repquota : 시스템 단위 쿼터 정보를 요약하여 출력한다
4. xfs_quota : CentOs 7에서 사용자의 디스크 사용량을 제한할 때 사용하는 명령어 edquota -a
-특정 사용자의 쿼터를 다른 사용자에게 동일하게 설정 edquota -p 이름1 이름2
- 이름1에게 설정된 쿼터를 이름2에게도 적용 1) quotaon : 쿼터를 활성화하는 명령어
2) quotaoff : 파일시스템에 적용된 쿼터의 사용을 중지하는 명령어
3) quotacheck : 모든 파일 시스템을 점검하고, 쿼터 설정 및 기록 파일 갱신하는 명령어 [개념 보충 _ 쿼터를 설정하는 과정]
quotacheck → edquota → quotaon → repquota
1. 고계산용 클러스터 : 베어울프, 슈퍼컴퓨터
2. 부하분산 클러스터 : LVS, 로드밸런서, 대규모 서비스
3. 고가용성 클러스터 : 연속적인 서비스 제공을 위하여 사용 부하 분산기와 백업 서버 사이에서 주기적으로 통신 LAN Ethernet,token ring,FDDI
- Token Ring : IBM에 의해 개발, 데이터 전송을 위해 네트워크 채널을 사용하려면 일종의 사용권을 획득해야 한다 - Ethernet : 데이터 전송을 위해 네트워크 채널을 사용하려면 일종의 사용권을 획득해야 한다 MAC 주소를 기반으로 상호간에 데이터를 주고받을 수 있도록 설계되었다. - X.25 : WAN 상에서 널리 쓰이는 프로토콜. 최근에는 X.25를 기반으로 하는 프레임릴레이(Frame Relay)가 나왔다 패킷망에서 DCE(회선 종단 장치)와 DTE(데이터 단말 장치) 사이에 이루어지는 상호 작용을 규정한 프로토콜 - FDDI : 광섬유 케이블을 사용하여 설계된 링 구조의 통신망. 엑세스 제어는 토큰 패싱 방법 채택
MAN DQDB
WAN 회선교환망 PPP,HDLC 패킷교환망 X.25,ATM,Frame-Realy
리피터 : 전송신호를 증폭, 재생하여 전달(OSI1)
브리지 : 두개의 근거리통신망(LAN)을 상호 접속해 주는 연결장치(OSI2)
라우터 : LAN을 연결해주는 장치 / 가장 적절한 통신 통로를 이용(OSI3)
게이트웨이 : 프로토콜이 다른 통신망을 상호 접속하기 위한 장치 (OSI4)
1. 물리계층
네트워크의 전기적, 물리적 연결 담당
관련장비 : 허브, 리피터 2. 데이터 링크 계층
신호 충돌 현상이 발생하지 않도록 회선 제어 기능
오류검출, 오류제어
각 노드는 식별가능한 MAC주소를 가지고 있다.
2개의 노드가 직접 연결돼있을때 프레임단위 데이터 전송 수행
관련장비 : 브리지, 스위치 3. 네트워크 계층
노드간 경로 설정하는 라우팅 기능
데이터를 패킷 단위로 분할 / 논리주소를 설정해 전송
관련장비 : 라우터 4. 전송계층
송수신 프로세스 연결 제공, 신뢰성 있는 통신 도움
주소 및 포트지정, 연결제어, 오류복구, 흐름제어
TCP/IP 5. 세션계층
세션 설정 및 유지, 동기, 대화기능
노드간 메세지 단위로 데이터 전송 6. 표현 계층
송수신자가 동일한 표현 방식을 사용할 수 있도록 기능 제공
데이터 암호화와 해독, 압축 해제 기능 제공 7. 응용 계층
사용자에게 편리항 응용 환경 제공
SMTP,FTF,HTTP 등 <br><img src="https://i.imgur.com/xoWOX22.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">1. 스타
중앙 노드와 사용자 노드가 point-to-point방식으로 연결
중앙 노드가 고장나면 전체 네트워크가 고장 2. 버스
단일 회선에 사용자노드가 T자모양으로 연결됨
하나의 회선에 연결되어 설치 비용 저렴
노드 증가시 네트워크 성능 저하 3. 링
노드가 원형으로 연결됨
하나의 회선에 연결되어 설치 비용 저렴
한 노드에 장애 발생시 전체 네트워크 중단 4. 망
서로 그물처럼 연결된 네트워크
특정 노드에 장애가 발생해도 다른 경로로 전송 가능
설치 관리 재구성이 어렵고 비싸다
① A Class : IP 주소 첫 번째 부분의 1비트가 0인 경우이다. : 0.0.0.0 ~ 127.0.0.0 [/8]
② B Class : IP 주소 첫 번째 부분의 2비트가 10인 경우이다. : 128.0.0.0 ~ 191.255.0.0 [/16]
③ C Class : IP 주소 첫 번째 부분의 3비트가 110인 경우이다. : 192.0.0.0 ~ 223.255.255.0 [/24]
④ D Class : IP 주소 첫 번째 부분의 4비트가 1110인 경우이다. : 224.0.0.0 ~ 239.255.255.255 [N/A]
⑤ E Class : IP 주소 첫 번째 부분의 4비트가 1111인 경우이다. : 240.0.0.0 ~ 247.255.255.255 [N/A]
디스크에 기록되는 데이터의 복구 기능을 강화한 것
데이터를 디스크에 기록하기 전에 먼저 저널에 수정 사항을 기록
저널은 쉽게 말해 로그 기록 같은 것
따라서 디스크에 데이터를 기록하기 전에 갑자기 전원이 나가거나 시스템에 충돌이 발생할 경우, 이 저널의 기록을 보고 빠르게 복구 가능 강제 종료: SIGKILL (9), 중단 불가능.
중지/재개: SIGTSTP (20), SIGSTOP (19), SIGCONT (18).
프로세스 제어: SIGHUP 재시작 (1), SIGINT Ctrl+C (2), SIGTERM (15).
디버그 및 오류: SIGSEGV (11), SIGILL (4), SIGBUS (7), SIGFPE (8)
SIGSTOP Ctrl + Z
SIGTSTP Ctrl + z
]]></description><link>부스트캠프/멤버십/8주차/리눅스-마스터-정리.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/리눅스 마스터 정리.md</guid><pubDate>Sat, 14 Dec 2024 03:30:13 GMT</pubDate><enclosure url="https://i.imgur.com/bTZdYbF.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/bTZdYbF.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[민형 이력서 브레인스토밍]]></title><description><![CDATA[2월
개발 시작(2월)
3월
멋사 들어감
멋사 세션 활동
스터디(알고리즘과 자료구조)
9월
중앙해커톤 뉴스 사이트
sns같은 형식으로 뉴스 모아보기 11월
돔토리 시작
간지톤 세피로트 앱테크
매일매일 광고 보고 포인트쌓아서 나무 심기
레벨형으로 점점 캐릭터 성장 1월
멋사 회장 활동 시작
멋사 세션 운영
3월
돔토리 리빌딩 알림 안 돼서 바꿈
react native, zustand
안드로이드 앱스토어 출시
동서울관과 협력하여 가입 안내
식단 안내, 커뮤니티, 공지사항, 외박 신청 등 서비스 제공 6월 ~ 11월
부스트캠프
onion하세요 중앙해커톤
앱테크 형식으로 야채 모아서 실제 상품으로 교환해주는 앱테크
react native, zustand, 11월 그룹 프로젝트(boomap) ai를 통한 브레인스토밍 마인드맵 저작도구
react, zustand, react-konva ]]></description><link>부스트캠프/멤버십/8주차/민형-이력서-브레인스토밍.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/민형 이력서 브레인스토밍.md</guid><pubDate>Wed, 11 Dec 2024 12:14:32 GMT</pubDate></item><item><title><![CDATA[커리어 특강]]></title><description><![CDATA[
서울대학교 컴공 학석사 → 삼성전자 → 실리콘밸리 → 야후(리더) 중간에 결혼, 자녀분 육아 등 여러 일이 겹치면서 바쁘셨음
성취하고 승진하는 경험 → 행복했냐고 물어보면 뒤쳐지는 느낌
나에 대한 확신 부족과 조바심, 불안감
커리어 후반기에는 어떤 걸 해야 될 지 고민 → 큰 꿈이 필요한게 아니고 살아있는 느낌이 드는 환경이 필요하다!
삼성전자, 야후? → 큰 회사는 나와는 맞지 않다라고 느낌 안식년을 거치고 작은 회사 위주로 참여 유데미, 폴리보어 조인
엔젤투자
어드바이저
비영리 단체
기존에는 회사와 집만 다녔다면, 의도해서가 아닌 외부에서 기회를 주다 보니 그걸 잡고 오래하니 잘 되었음 잠깐 해서 잘 하는 사람은 없음! 일인기업 + SJSU 강사(석사과정 겸임 교수)
전반기는 실패를 경험하면서 어떤 역량을 해야 행복한 지 찾았다면 후반기에는 더 행복한 사람이 된 것 같음 남하고 비교하지 않기! 인간 그대로 나 스스로를 받아들이기
어느 정도의 선택과 집중은 필요함 커리어 사다리 → 평생 직장 계속해서 위로 올라갈 수 있음 → 방향성이 위
하지만 이런 경우 첫 직장이 중요함
IMF를 계기로 평생 직장이라는 개념이 사라진 것 같다. 커리어 정글짐 → 요즘은 이제 다양한 회사를 다니게 됨 다수의 직장
방향성이 위만 있는게 아니라 아래 위를 왔다갔다 하게 됨
어디에서 시작 했냐 보다는 여정과 마지막이 더 중요하다
노동시장의 유연성과 나이에 대한 개념을 덜 따지면서 해고와 채용을 조금 더 가볍게 하게 됨 <img src="https://i.imgur.com/BOSWFnU.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
멤버십 과정도 좋았겠지만 계속해서 이렇게 배우면 어느 시점에 답답함을 느낄 수 있음
어떻게 하냐가 중요한가? 가장 중요한 것은 버티는 힘 내가 뭘 모르는지를 생각해봐야 함 잘하는 사람 보고 기죽지 않기 나보다 잘하는 사람을 보고 기죽을 수 있음
나보다 잘하는 사람을 보는 방법은 직접적인 비교 보다는 롤 모델 형식으로 보는 게 좋다. 저 사람은 나보다 더 일찍 어떻게 시작을 했을까?
저 사람은 어떻게 해서 저만큼 잘하게 되었을까?
위와 같은 질문을 던지기 평정심을 가지는 것? 놀라지 않는 것 새로운 개념과 친해지기(반갑다!) 이번 과정에서 배운 개념들을 계속해서 재사용할 가능성이 높다!
마음을 더 편하게 먹을 수 있도록 하자 굉장히 많은 한국 사람들은 선행학습에 많이 익숙해져 있음
한국 사람들은 그래서 배움에 많이 집중하는 경향이 있음
커리어는 뭐가 다를까? 정답이 정해져 있지 않음
커리큘럼이 정해져 있지 않음 학교에 익숙해져 있는 사람은 학교의 학년 처럼 연차를 생각하게 됨 “이거 다음은 뭘 하면 되나요” 처럼 이런 방향을 찾아서 다니게 됨 나에게 맞는 환경 찾아가서 배우고 성장하면 된다.
한큐에 대기업을 가겠다는 정답이 되기 어려움
커리어는 하나만 다니고 끝나지 않음 기용님의 첫째 자녀분에게도 기업의 규모 크기를 보기 보다 일단 일을 할 수 있는 환경에 가보는게 중요하다
작은 회사라도 사람이 좋으면 성장을 할 수 있고, 외향적인 것 보다 내부적인 요소가 더 중요하다 대학보다 커리어가 훨씬 더 오래 지속된다는 점 대학 길어야 10년 vs 커리어는 50년
나이에 대한 압박 받지 않기: 각자 자기의 인생을 사는 것
결국 본인이 깨달아야 되는 것 → 나이가 많다고 생각하는 사람에게 얘기해도 듣지 않으면 조언이 의미가 없다 이런 나이 얘기도 결국 듣는 당사자는 본인 나이만 경험하기 때문에 많다고 느끼는 것
인생은 80년이 넘고 도전적으로 살 수 있는 시기가 20대가 아닐까?. 경기에 영향을 많이 받음 경기는 사이클임
결국 언젠가는 좋아지게 될 것
어디가 되었건 사람 좋고 환경 좋은 곳으로 가기 위해 미리 준비하자 작은 스타트업에 가신 분들이 자주하는 질문 내가 하는게 도움이 될까?
정말 경험에 도움이 될까? 이런 분들이 자주하는 생각 “대기업에 가면 해결 되지 않을까?” 오히려 반대의 이야기를 함
큰 기대를 하고 들어온 것에 비해 대기업도 마냥 좋진 않다 생각보다 커리어 적으로 쌓을 수 있는게 적을 수도
오히려 대기업을 가면 나보다 똑똑한 사람이 많음 → 경쟁이 잘 안됨
대기업이라 속도가 느림
상당히 속도가 느릴 수 있음
대기업을 적은 노력으로 가서 경험해볼 수 있다면 좋지만 간다고 해서 꼭 좋은 것은 아님
어느 환경에 있건 좋은 점이 있으면 안 좋은 점이 있다는 것 회사를 선택하는 기준 → 성장 하는 회사인 지를 고민해보자
사람이 좋은지 안 좋은 지 보자
매니저가 좋은 곳에서 일하는 게 좋음 국비만 해도 나이가 많은 상태로 들어오시는 분들이 많음 기본기가 탄탄한 사람 의사소통 능력이 좋은 → 경청하고 질문을 잘하는 것이 중요함
과정을 잘 이해해야 한다. 코칭이 가능한가? 처음에는 몰라도 뭘 하나를 배우면 숙지 하는 사람 다음 단계로 올라가려면? 문제 해결 능력 갖기
좋은 평판을 유지하기 → 결국 사람과 일을 하는 것 → 지인 추천
개인기를 부리는 것이 아니라 그룹에서 일을 하는 것에 익숙해지기 커리어 발전? → 소프트웨어 개발 방법
커리어에 평생 직장이라는 것이 존재하는 세상에서는 워터폴
이제는 계속해서 배우고 변해야 되는 스크럼으로 발전 내 자신을 사랑하기
내 과거를 아쉬웠던 것만 보지 말고 잘했던 것도 균형있게 보기
내가 잘한 것의 크기와 아쉬운 것의 크기가 비슷해야 더 잘 볼 수 있음
나의 장점 50개 작성해보기
나의 현재를 긴호흡으로 바로보고 생각지 못한 기회가 오면 손을 들자, 너무 걱정 하지 말자 그리고 주변에 나를 응원해줄 수 있는 서포터를 두고 꼭 업이 아니라 가족과 함께 하는 시간을 가지면서 페이스 조절을 하자. 그리고 주변 사람들과 잘 지내며 좋은 평판을 유지하면서 주변에게 좋은 영향을 주는 사람이 되도록. 결국 지금 중요한 건 나를 사랑하는 것
당근 마켓 채용 공고 기준 이런 일을 해요
이런 분을 찾고 있어요
이런 분이라면 좋아요 → 가장 중요한 건 이런 분을 찾고 있어요를 보는 것, 추가 적인 정보를 보고 겁내서 지원을 못하는 경우가 많음 이런 분을 찾고 있어요! 원하는 사람의 태도
하나의 이상의 프로그래밍 언어를 깊게 탐구하신 분 깊게 탐구 했나? 고민하면 이력서를 못냄 더 좋아요? 추가 적인 요구 사항에 대해서 집중하게 되면 엉뚱한 공부를 많이 하게 됨 문화권에 따른 자신 감이 너무 다름 산호세 대학에서 점수에 대해서 의문이 있다면 와라 동아시아권은 오지 않고 인도 사람들만 옴
기본적으로 권위에 대한 도전을 함
회사 생활을 할 때도 원하는 것이 무엇인지 명확하게 얘기를 함 지원 → 이력서 스크리닝 → 면접 → 평가 → 오퍼 → 종료
하나의 깔때기 형식으로 진행됨 숫자가 점점 적어진다는 것
확률 싸움이라는 것
한 두군데 내고 잘 되기를 바라는 것은 도둑놈 심보 전화 화상 면접 → 직무/대면 면접 → 컬처핏 면접 순으로 보게 됨
많이 해볼 수록 잘하게 되는 부분 면접을 해본 적이 없으면 해매게 된다.
가고 싶은 곳이 있더라도 더 많이 내야 된다.
어떤 사람들이 있는 지 경험하고 배워보겠다가 중요한 것. 이력서를 내야 뭐라도 취업이 가능하다 겁을 내면 내지도 못한다.
필수 역량 50프로면 매칭을 목표로 하자
면접 기회가 오면 일단 최선을 다해 경험을 쌓ㄷ자
생각이 없더라도 사람이 좋으면 내보자 이력서를 덜 겸손하게 첫번째 장에 집중해서 쓰자 자기 검열 하지 않기 이력서 스크리닝을 넘어가야 기회가 생김
덜 겸손하자 이력서 가독성의 중요성 첫 페이지가 가장 중요하다
공간 관리를 잘할 수 있도록 하자
스킬셋을 정리해서 한눈에 보이게 하자
프로젝트 경험은 문제 해결 중심으로 기술할 수 있도록 하자 조금 더 구체적으로 내용을 풀어서 작성하자 너무 많은 내용을 포함하려기 보다는 간결하고 필요한 내용 중심으로 작성 STAR 방식으로
모르는 사람이 봤을 때도 이해하기 쉽게 (간략한) 자기 소개 채용 담당자에게는 자기소개서가 크게 도움이 안 될 수 있음
튀는 자기소개서, 나만의 자기소개가 아니라면 간단하게 작성할 수 있도록 하자
지원자만의 강점과 차별성이 강조
다른 사람 이름으로 바꿔도 어색하지 않으면 의미 없음 기술 기술을 카테고리화 해서 작성 경력/업무 경험 최신 순으로 작성 겸손하고 가독성이 떨어짐
애매하게 스킬셋을 적기 보다 써본 걸 다 적어보도록 하자 면접 할 때 기술들에 대해서 구체적인 질문이 들어오면? → 사실 대로 얘기하면 됨
해봤는지가 중요하다고 생각하는 포인트 전체적인 레이아웃 변경 전체적인 레이아웃을 잘 잡아야 한다.
자기소개를 간단하게
스킬을 앞단으로 올리고
경력은 의미 있는 프로젝트를 중심으로 작성을 하기 커버 레터가 필요한가?
현재 지원하려는 업무와 관련 없는 과거 경력 물 경력이라면 생각해볼 필요가 있음 실제 면접관으로 활동을 해보면 기억에 남는 질문을 하는 경우가 있음
지금 사용 중인 기술 스택에 대해서 설명해주세요
조인 하게 되면 처음에 어떤 일을 하게 되나요?
어떤 프로젝트를 진행하나요?
회사에서 잘 하는 사람들은 어떤 특징을 갖고 있나요?
회사에서 좋았던 점과 안 좋았던 점 얘는 좀 당돌하다고 생각한 질문 어떻게 돈을 벌고, 작년 매출은 얼마였고 올해는 얼마 정도를 예상하는 지
약간의 수고를 하더라도 채용 공고에 나오는 내용을 이력서에 넣어보자 중요한 일일 수록 판단을 잘하려면 잘 듣고 얘기를 나눠야 된다 → 의사 소통
문제에 대한 정의가 잘못되면 아무리 열심히 해도 인정을 받기가 어려움 → 문제정의 원인에 대해서 안물어보고 해결책을 찾는 것 → 방향이 틀림 나에게 맞는 방향을 찾고 좋은 결과를 낼 수 있는 쪽을 찾아보자 → 결과 지향적 이게 안되면 집에 가서도 공부를 더해야 됨 본인이 맡은 일을 성공으로 이끌고 잘 해나가는 모습을 보이고 같이 일하고 싶은 사람이 되자 → 좋은 평판
위의 내용을 바탕으로 좋은 영향을 주변에 주도록 → 영향 커리어는 사다리가 아닌 정글짐
안전해 보이는 선택이 안전한 선택은 아님
인공지능을 멀리하기 보다는 도구로써 최대한 활용하기
준비된 자에게 기회가 온다 경기는 돌아온다
기회는 꼭 잡도록 하자 평점심이 오히려 자기합리화가 되지 않을까? 커리어가 길어질 수록 안 좋은 경험을 많이 하게 됨
꼭 모든 경험이 좋을 거라고 볼 수 없음
실패를 실패로 보느냐와 더 나아질 수 있는 기회라고 생각하는 것은 다르다
롤 모델로 바라보고 저 사람 처럼 잘 할 수 있을 지를 고민할 것 같음
리더 역할을 많이 한 입장에서 봤을 때? → 나보다 똑똑한 사람은 어디는 있음, 어떻게 하면 그런 사람들과 일을 잘할 수 있을 지 고민해보기 평정심을 유지하기 위한 별도의 노력? 항상 놀랄 준비를 하는 것
실패하지 않고 꽃길만 걷겠다가 아니라 실패를 할 수 있다고 생각하자
중요한 건 시간 → 어떻게 하면 시간을 줄일 수 있을 지를 고민해보자
평정심의 상당수는 사람 관계에서 시작하는 것 어떤 사람이 어떤 활동을 하더라도 너무 놀라지 않는 것 기대 수준을 낮게 가져 가는 것이라고도 보면 될듯 해외 취업을 위해 관심있게 살펴 보면 좋을 것 + 어떻게 해외에서 일할 수 있을지? 주변에 많이 얘기하기 → 어디서 연락이 올 지 모름
가장 전통적인 방법 → 석사 혹은 학사 진학 + 취업 하지만 돈이 쉽지 않음
평균 적으로 4~5만 불 이상, 년 8000만원 이상 사용하고 비자 받을 확률 10프로
취업을 위해서 진학하는 건 도박에 가까울 수 있음 점점 리모트로 일하는 곳도 많기 때문에길게 보기
꼭 미국이 아니더라도 호주나 캐나다 같은 곳도 보기
듣기가 안되면 말하기도 안됨 잡 플래닛의 2점대 기업을 통해서 커리어를 시작해도 될까요? 다른 곳에 갈 수 있으면 가기
면접이 된다면 면접은 봐서 나쁠께 없다.
첫 직장이 끝직장이 아니기 때문에 길게 보기
지금 처럼 경기가 나쁠 때는 첫직장을 가지는 것 자체로 중요할 수 있음 학력이 개발자의 커리어에 영향을 끼칠까요? 요즘 세상은 크게 의미가 없다고 생각함.
석사가 엄청나게 도움이 되진 않음
석사를 진학하는 사람의 퍼센티지가 점점 줌 → 죽어있는 지식을 배우기 때문에 석사는 호기심이나 분명한 목적이 없다면 가지 말기 사람마다 뒷받침 안되는 현실이나 환경에 놓여있을 것 같음 본인에게 맞지 않는 회사에 들어가서 오래 일한 분들이 그럼
자신감을 완전히 잃어버린 경우
본인이 선택해서 거기 있었던 것
내가 여기서 도망가면 탈락한다고 생각해서
내가 정말로 원하는 게 뭔지 고민해보기! 신입의 기본기를 어떻게 알 수 있을까요? 인턴으로 근무를 하면서 알게 됨, 2~3개월 프로젝트를 한 걸 보면서
실제로 이사람이 어떻게 문제를 풀었는 지를 꾸준한 과정을 통해서 볼 수 있음. 스킬셋 나열 보다는 활용 수준에 대한 설명 이걸 하게 되면 결국 자기 검열을 또 하게 되는 것
안쓰는 것과 크게 차이가 없음 그냥 다 쓰는 것과 차이가 없음것 소소한 행복 자녀분들의 취업
내년 여름 부터는 뭐하고 놀지 하고 싶은 일이 너무 많은 것 같음 지금 아니면 못할 게 뭔지 고민해보자!
커리어에 꽂혀서 다른 일을 놓칠 수도 있으니 잘 생각해보자 누군가와 일 떄문에 결혼을 미루는 게 맞을까?
내 앞에 시간이 많이 남았다는 것
뭔가 하나를 깊게 파서 전문성을 가지는 것 보다는 한 분야를 넓게 파는 것도 좋은 방법 연애를 많이 해봐야 누구와 맞는지 알 수 있는 것과 똑같은 것 창업을 하려면 어떤 시작을 하는 게 좋을지 창업 하는 회사에 들어가서 경험을 해보는 것 추천
아직 시간이 많으니까 신입 입장에서 본인을 강조할 수 있는 부분은 프로젝트 프로젝트 경험 중에 본인이 무언가 얻었다면? 결과적으로 부정적으로 끝났던 프로젝트도 적어야 될까? 이 프로젝트에서 본인이 실제로 한 것이 무엇이고 결정을 내린 것은 무엇인가?
전체적으로 무엇을 배웠고 좋았던 점 아쉬웠던 점은 무엇인지
위의 두 가지 질문을 많이 물어봄 물경력 나에게 도움이 안되는 경험은 없다
처음 부터 잘하는 사람은 없음 권위에 대한 도전은 어떤게 있을까요? 본인의 욕망을 잘 얘기함
인도 친구들 같은 경우에는 나의 장점과 단점에 대해서 얘기 해달라 등 직접적으로 얘기를 부탁함 동아시아? → 열심히 해서 성과를 낸다음에 승진 요구를 하겠다 → 이건 거꾸로 가는 것
결국 위에서 보고 판단하는 것이기 때문에 그걸 본인이 판단하지 않도록 하자 프로젝트 경험이 많지 않은 상태 입니다. 이력서를 한 두개만 적어도 될까요? 스킬 작성을 꼭 하고 프로젝트를 병행 하는 것이 좋다(부족하닥 느끼면)
연락 오면 면접도 봐보고 질문도 많이 하기 공부를 할 수 있는 기회와 취업 준비 호기심과 본인의 확실한 목표가 있다면 하기
이런 것이 없다면 불필요한 투자일 수도 있음. ]]></description><link>부스트캠프/멤버십/8주차/커리어-특강.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/커리어 특강.md</guid><pubDate>Tue, 10 Dec 2024 06:08:30 GMT</pubDate><enclosure url="https://i.imgur.com/BOSWFnU.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/BOSWFnU.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[특강]]></title><description><![CDATA[<a data-href="현업에서 말하는 좋은 프로젝트 - 자문위원님들" href="부스트캠프/멤버십/그룹프로젝트-1주차/현업에서-말하는-좋은-프로젝트-자문위원님들.html#_0" class="internal-link" target="_self" rel="noopener nofollow">현업에서 말하는 좋은 프로젝트 - 자문위원님들</a><br>
<a data-href="프로젝트 관련 수료생 밋업" href="부스트캠프/멤버십/그룹프로젝트-1주차/프로젝트-관련-수료생-밋업.html#_0" class="internal-link" target="_self" rel="noopener nofollow">프로젝트 관련 수료생 밋업</a><br>
<a data-href="면접 및 취업 특강" href="부스트캠프/멤버십/8주차/면접-및-취업-특강.html#_0" class="internal-link" target="_self" rel="noopener nofollow">면접 및 취업 특강</a><br>
<a data-href="이력서 특강" href="부스트캠프/멤버십/8주차/이력서-특강.html#_0" class="internal-link" target="_self" rel="noopener nofollow">이력서 특강</a><br>
<a data-href="커리어 특강" href="부스트캠프/멤버십/8주차/커리어-특강.html#_0" class="internal-link" target="_self" rel="noopener nofollow">커리어 특강</a>]]></description><link>부스트캠프/멤버십/그룹프로젝트-1주차/특강.html</link><guid isPermaLink="false">부스트캠프/멤버십/그룹프로젝트 1주차/특강.md</guid><pubDate>Tue, 10 Dec 2024 06:07:57 GMT</pubDate></item><item><title><![CDATA[NCP 후기]]></title><description><![CDATA[🧭 당신의 프로젝트에 길잡이가 되어줄게요 🧭AI 기반 마인드맵 자동화 서비스✨ 당신의 아이디어를 연결하는 가장 스마트한 방법, BooMap! ✨회의록 기반으로 마인드맵을 자동 생성해요. 시각화된 캔버스에서 수정과 삭제가 가능해요. 만들어진 마인드맵을 팀원들과 쉽게 공유할 수 있어요.GitHub : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/boostcampwm-2024/web32-BooMap" target="_self">https://github.com/boostcampwm-2024/web32-BooMap</a> Team Notion : <a data-tooltip-position="top" aria-label="https://www.notion.so/BooMap-1287725fa9ac80dd87d9c5fbad711b3d?pvs=21" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.notion.so/BooMap-1287725fa9ac80dd87d9c5fbad711b3d?pvs=21" target="_self"></a><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.notion.so/BooMap-1287725fa9ac80dd87d9c5fbad711b3d" target="_self">https://www.notion.so/BooMap-1287725fa9ac80dd87d9c5fbad711b3d</a>
server instance
VPC
CLOVA X
CLOVA SPEECH 우리는 프로젝트에서 CLOVA speech, Public IP, Server(VPC)를 사용했다. 사용자가 회의록을 음성 파일로 업로드하게 되면 해당 파일을 form-data형식으로 서버에 post 요청을 보내고, CLOVA speech에서 텍스트를 일차적으로 추출하였다. 추출한 텍스트의 경우 openapi를 한번 더 거쳐 우리가 프롬프팅을 해 놓은 대로 마인드맵 데이터 형식을 뽑아낼 수 있었고, 이를 기반으로 소켓 서버에 브로드캐스트하여 만들어진 마인드맵을 해당 마인드맵에 들어와있는 모든 사용자에게 전개시킬 수 있도록 하였다.
Q. 프로젝트를 소개해 주세요. (100자 이상)
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.boomap.site/" target="_self">https://www.boomap.site/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/boostcampwm-2024/web32-BooMap" target="_self">https://github.com/boostcampwm-2024/web32-BooMap</a>
저희의 프로젝트는 저희의 문제의식으로부터 출발되었습니다. 프로젝트 주제회의를 하는 과정에서 계속 나왔던 아이디어를 꺼내고, 기각하고, 까먹고 다시 전에 이야기 했던 아이디어를 꺼내는 과정이 계속해서 반복됨에 따라 ‘브레인스토밍을 도와줄 수 있는 서비스를 만들면 어떨까?’ 생각했습니다.
그래서 텍스트로 기록해놓거나 혹은 음성파일을 기반으로 이야기한 내용을 마인드맵화 해서 보여도록 하는 기능을 제공해 줍니다.
Q. Ncloud에서 어떤 서비스를 활용하셨나요?
우리는 프로젝트에서 CLOVA speech, Public IP, Server(VPC)를 사용했다.
Q. Ncloud 서비스를 어떻게 적용 하였나요? (100자 이상)<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/40979108-659a-4cae-9c59-5ed9e2917354/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
private VPC와 public VPC로 나눠 각각 db 서버 인스턴스, nest 서버 인스턴스로 활용했어요.
음성 회의록을 텍스트로 변환하기 위해 CLOVA SPEECH 서비스를 이용했어요.
글자를 요약하고 키워드를 추출해 연관 관계로 묶어주기 위해 CLOVA X STUDIO를 사용했어요
Q. Ncloud 사용 중 특히 만족했던 점과, 아쉬웠던 점은 무엇인가요? (100자 이상)
Ncloud에서 제공해주는 서버의 사양이 좋아서 너무 만족스러웠습니다. 하지만 금액적으로 비싸다고 느껴져 학생들에게는 조금 아쉬웠습니다.
서버 모니터링을 간편하게 할 수 있는 점이 좋았습니다.
서버 인스턴스 생성시 발급 할 수 있는 pem 키가 ssh 접속 키가 아니라 비밀번호 확인을 위한 키였던 것이 조금 아쉬웠습니다
프로젝트를 진행하면서 CLOVA studio에서 처음에는 CLOVA X를 통해 줄글을 키워드별로 요약하고, 이를 마인드맵처럼 부모와 자식 구조처럼 구조화하도록 하였는데, 생각보다 프롬프팅이 어려웠다. 같은 프롬프트라도 실행하는 타이밍마다 다른 경우가 있었고, 이에 따라 신뢰된 정보를 받기 어렵다고 판단하여 빠르게 교체했지만 조금 더 프롬프팅을 잘했으면 어땠을까 하는 마음과 알잘딱깔센이 안되는 CLOVA X의 성능이 살짝 아쉬웠던 마음이 공존하는 것 같다.
공식 문서가 잘 작성 되어 있었지만 이리저리 왔다갔다 하면 금방 탭을5~6개 열어놓고 어떤 문서를 보고 있었는지 헷갈렸습니다.
Q. Green Developers 프로그램 참여 소감 말씀 부탁 드립니다. (50자 이상)
Green Developers 프로그램에 참여하기 전에는 aws밖에 아는 클라우드 플랫폼이 없었기에 거의 aws의 기능들에만 의존했었다. 또 이런 클라우드 플랫폼이 있을까 생각했는데 생각보다 STT를 알아보는 과정에서 CLOVA speech와 이런저런 기능들을 리서치하며 정말 많은 서비스가 있음을 알게 되었고 유용한 AI 및 서비스가 많았다.
앞으로도 기회가 된다면 Naver Cloud Platform 내의 여러 기능들을 사용하여 국내 서비스에 특화된 애플리케이션을 만들기 좋을 것 같다는 생각이 들었다.
Q. 마지막 한 말씀 부탁 드립니다.프로젝트를 진행하며 흥미롭거나 어려웠던 기억, 향후 Ncloud 활용 계획, Green Developers 프로그램에 대한 피드백 등 여러분의 생각을 공유해 주세요.
프로젝트를 진행하면서 CLOVA SPeech를 통해서 음성 파일을 텍스트로 변환하는 기능을 도입하게 되었는데, 생각보다 타임 라인, 발표자 등 클로바 노트에서만 보았던 기능들이 API 설정에 따라 모두 받을 수 있다는 사실이 흥미로웠고 이를 통해서도 많은 서비스에 대한 아이디어를 얻을 수 있겠다는 생각이 들었다.
]]></description><link>부스트캠프/멤버십/8주차/ncp-후기.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/NCP 후기.md</guid><pubDate>Sat, 07 Dec 2024 08:01:01 GMT</pubDate><enclosure url="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/40979108-659a-4cae-9c59-5ed9e2917354/image.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/40979108-659a-4cae-9c59-5ed9e2917354/image.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그룹프로젝트_사이드바]]></title><description><![CDATA[
🛠️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1417725fa9ac8060944ec3769d9056a8?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1417725fa9ac8060944ec3769d9056a8?pvs=4" target="_self"> 노드들을 그랩 q날리기</a>
<br>🎯 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1377725fa9ac80b1af7fe19ee08a1110?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1377725fa9ac80b1af7fe19ee08a1110?pvs=4" target="_self"> 드래그 시 노드를 따라가는 선 구현하기</a>
<br>📸 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1427725fa9ac8043a27ceffd0d387cdb?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1427725fa9ac8043a27ceffd0d387cdb?pvs=4" target="_self">마인드맵 이미지 다운로드하기</a>
<br>🔄 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/canvas-Ctrl-z-1cf4b1e309814aea859ea9b27e3ec82b?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/canvas-Ctrl-z-1cf4b1e309814aea859ea9b27e3ec82b?pvs=4" target="_self">undo와 redo 구현하기</a>
<br>⚠️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/13a7725fa9ac80e8b96af725dbf70ba0?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/13a7725fa9ac80e8b96af725dbf70ba0?pvs=4" target="_self">노드들의 충돌 감지 및 회피</a>
<br>🚀 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/13d7725fa9ac800798f5f44af7c4939f?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/13d7725fa9ac800798f5f44af7c4939f?pvs=4" target="_self">충돌 방지의 렌더링 성능 최적화</a>
<br>↔️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/526ef2f7e76c4a67bb7f40a8452104bb?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/526ef2f7e76c4a67bb7f40a8452104bb?pvs=4" target="_self">사이드바 드래그로 사이즈 조절하기</a>
<br>🔐 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/14e7725fa9ac80eba893d0986a81e605?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/14e7725fa9ac80eba893d0986a81e605?pvs=4" target="_self">권한 관리와 전역 상태 슬라이스 패턴화</a> <br><a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1337725fa9ac819ebc7ecac6b0b6e66a?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1337725fa9ac819ebc7ecac6b0b6e66a?pvs=4" target="_self">🤔유저가 그리는 캔버스 데이터의 저장 시점에 대한 고민</a>
<br><a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/0fdbf4395f344508a1f90fab3cdb3a2d?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/0fdbf4395f344508a1f90fab3cdb3a2d?pvs=4" target="_self">🤔클라우드 아키텍처에 대한 고민</a>
<br><a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/DB-13bbf0cde7d741ea825c19cff4dd6687?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/DB-13bbf0cde7d741ea825c19cff4dd6687?pvs=4" target="_self">🤔계층 데이터 구조를 DB에 어떻게 저장할까?</a> <br>⚙️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/9fd89710fbe147ce83b22adcadd462da?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/9fd89710fbe147ce83b22adcadd462da?pvs=4" target="_self">타입스크립트 빌드에러</a>
<br>🌐 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/404-cb75047ad36644eba2e52dcf89525e55?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/404-cb75047ad36644eba2e52dcf89525e55?pvs=4" target="_self">빌드된 파일에서 404가 뜬다...?!</a>
<br>🔍 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/overflow-scroll-7b3aac837a1049989ab9d95ec7c71ea1?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/overflow-scroll-7b3aac837a1049989ab9d95ec7c71ea1?pvs=4" target="_self">overflow-scroll의 인식 오류</a>
<br>🐳 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/e8878aa4827949a8917c2121628797ba?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/e8878aa4827949a8917c2121628797ba?pvs=4" target="_self">로컬에서 도커를 띄우다가 일어난 오류..</a>
<br>🚨 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/map-key-Error-97fce1d071cb438dbb330c087e98ee97?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/map-key-Error-97fce1d071cb438dbb330c087e98ee97?pvs=4" target="_self">리액트의 map에 key를 제대로 넣어줬는데 key warning이 일어난다..?!</a>
<br>😱 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/e0451420b8c946e3b2cb9c8086197d7a?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/e0451420b8c946e3b2cb9c8086197d7a?pvs=4" target="_self">양식을 삭제했는데 화면에 양식이 살아있는 것에 대하여…</a>
<br>🖼️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/223e0029efef4945ae4073b3340324ad?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/223e0029efef4945ae4073b3340324ad?pvs=4" target="_self">소켓 연결을 했더니 캔버스가 마비되다…</a>
<br>🛠️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/git-conflict-10000-0bbd38bf08174a00be56075950277565?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/git-conflict-10000-0bbd38bf08174a00be56075950277565?pvs=4" target="_self">git Conflict가 10000개가 나버린 건에 대하여</a>
<br>🔧 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/cb17937f9c05446e827aecd5fabb5df0?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/cb17937f9c05446e827aecd5fabb5df0?pvs=4" target="_self">소켓 에러 때려잡기</a>
<br>🕰️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/historyState-9b2516f7d33f4ccab8dc600c45c1f846?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/historyState-9b2516f7d33f4ccab8dc600c45c1f846?pvs=4" target="_self">historyState 에러 때려잡기</a>
<br>📚 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/14a7725fa9ac8065b906fc9af6b94d1c?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/14a7725fa9ac8065b906fc9af6b94d1c?pvs=4" target="_self">실수한 김에 이벤트 버블링 다시 공부하기</a>
<br>🖋️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/tiptap-style-8aa203f6a67148999cfc1b3f7369da52?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/tiptap-style-8aa203f6a67148999cfc1b3f7369da52?pvs=4" target="_self">tiptap 라이브러리의 스타일이 늦게 적용됨...사실은</a>
<br>✂️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/tiptap-a7a4818fb7be413eab03b9493000429b?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/tiptap-a7a4818fb7be413eab03b9493000429b?pvs=4" target="_self">tiptap 드래그한 요소가 취소되지 않는 현상</a>
<br>🕒 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/14e7725fa9ac8070aff8cd82157ca616?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/14e7725fa9ac8070aff8cd82157ca616?pvs=4" target="_self">대시보드야 좀 늦게 나와</a> <br>🧠 <a data-tooltip-position="top" aria-label="https://github.com/boostcampwm-2024/web32-BooMap/wiki/%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EB%A3%B0" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/boostcampwm-2024/web32-BooMap/wiki/%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EB%A3%B0" target="_self">그라운드 룰</a>
<br>🧠 <a data-tooltip-position="top" aria-label="https://github.com/boostcampwm-2024/web32-BooMap/wiki/%ED%98%91%EC%97%85-%EC%A0%84%EB%9E%B5" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/boostcampwm-2024/web32-BooMap/wiki/%ED%98%91%EC%97%85-%EC%A0%84%EB%9E%B5" target="_self">협업 전략</a>
<br>📄 <a data-tooltip-position="top" aria-label="https://www.figma.com/design/INWr8TnEOtAcwV7qahNmT3/Boomap?node-id=0-1&amp;node-type=canvas&amp;t=2QxAHKOIlvAqiRTH-0" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.figma.com/design/INWr8TnEOtAcwV7qahNmT3/Boomap?node-id=0-1&amp;node-type=canvas&amp;t=2QxAHKOIlvAqiRTH-0" target="_self">Figma</a>
<br>📄 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1337725fa9ac80709774ce580b1c6549?pvs=74" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1337725fa9ac80709774ce580b1c6549?pvs=74" target="_self">6주간의 회의록</a>
<br>📄 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1337725fa9ac80ba8e22f26ac8073223" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1337725fa9ac80ba8e22f26ac8073223" target="_self">데일리 스크럼</a>
<br>📄 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1337725fa9ac8082945ddc51ef5acc24" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1337725fa9ac8082945ddc51ef5acc24" target="_self">그룹 회고</a>
]]></description><link>부스트캠프/멤버십/8주차/그룹프로젝트_사이드바.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/그룹프로젝트_사이드바.md</guid><pubDate>Thu, 05 Dec 2024 16:29:45 GMT</pubDate><enclosure url="https://img.shields.io/badge/BOOMAP-0A84FF?style=for-the-badge&amp;logo=googlegemini&amp;logoColor=white" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://img.shields.io/badge/BOOMAP-0A84FF?style=for-the-badge&amp;logo=googlegemini&amp;logoColor=white&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SEO]]></title><description><![CDATA[<img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/d1ee97ec-857a-44cb-8841-02db3f6b8dd9/d47668e3-7383-45a7-af54-84d11f8d2ddf.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
사용자가 입력한 키워드에 맞는 검색 결과를 제공하는 프로그램 또는 웹 서비스.
주요 검색 엔진: Google, Naver, Daum, Bing, Yahoo 등.
<br><img alt="how-search-engines-find-and-rank-results.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/ecf077bd-d412-4ce3-94af-1cb9c08dc100/how-search-engines-find-and-rank-results.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">검색 엔진은 크롤링 → 인덱싱 → 랭킹 단계를 거쳐 검색 결과를 생성합니다.
크롤링 (Crawling) 정의: 검색 엔진이 웹페이지 내용을 수집하는 과정.
방법: 검색 엔진 로봇(크롤러 또는 스파이더)이 링크를 따라 새 페이지를 발견하고 기존 페이지 변경 사항을 확인.
예시: 사서가 새 책을 찾아 도서관에 등록하는 것과 유사. 인덱싱 (Indexing) 정의: 수집한 정보를 분석해 데이터베이스에 저장하고 분류하는 과정.
내용: 웹페이지의 텍스트, 이미지, 비디오 등을 주제별로 분류.
예시: 사서가 책을 주제별로 분류하고 도서 목록을 만드는 과정. 랭킹 (Ranking) 정의: 검색어와 가장 관련성 높은 결과를 상위에 노출하는 과정.
기준: 알고리즘에 따라 수백 가지 요소를 평가해 순위를 결정.
예시: 사서가 방문객의 질문에 가장 적합한 책을 추천하는 과정. 요약검색 엔진은 크롤링으로 데이터를 수집하고, 인덱싱으로 데이터를 분류하며, 랭킹을 통해 사용자가 입력한 검색어에 가장 적합한 결과를 제공하는 시스템입니다.
SEO(Search Engine Optimization) 웹사이트가 크롤링 → 인덱싱 → 랭킹 과정에서 더 잘 발견되고 높은 순위에 노출되도록 최적화하는 작업. 목적 웹 페이지를 검색 엔진 결과에서 상위에 노출시키는 것. 비유 우리의 웹사이트(책)를 도서관에서 가장 눈에 띄는 곳에 배치하도록 돕는 작업. 요약검색 엔진의 작동 원리를 이해하고, 이를 기반으로 웹사이트를 최적화해 더 많은 사용자에게 도달하는 것이 SEO의 핵심입니다.<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/4680ec46-86d5-4473-ad12-3c0d3912880c/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
웹사이트 가시성 향상 검색 결과 상위에 노출되면 더 많은 방문자를 유도할 수 있으며, 이는 잠재 고객 증가로 이어집니다. 타겟 고객 직접 도달 특정 키워드를 검색하는 사용자는 이미 해당 제품이나 서비스에 관심이 있는 잠재 고객입니다.
검색 상위 노출은 높은 전환율로 연결됩니다. 비용 효율성 SEO는 초기 투자 이후 지속적인 광고비가 필요하지 않습니다.
유기적 노출로 검색 광고 비용 없이도 장기적인 마케팅 효과를 얻을 수 있어, 특히 예산이 제한된 기업에 유리합니다. 요약SEO는 가시성, 고객 접근성, 비용 효율성의 측면에서 효과적인 디지털 마케팅 전략입니다.매우 다양한 방법들이 있다. 밑의 것들은 일부!1. 크롤링 최적화검색 엔진이 웹사이트를 효율적으로 탐색하도록 돕는 작업.
사이트맵 설정 XML 형식으로 모든 페이지를 제공해 사이트 구조를 쉽게 이해.
/sitemap.xml 파일에서 &lt;loc&gt; 태그로 경로 지정.
네이버와 구글에 제출해 효율적 크롤링 지원. robots.txt 설정 크롤러에게 특정 페이지 크롤링 허용/제한 지시.
검색 엔진 크롤링 효율화. 적절한 오류 페이지 제공 깨진 링크를 방지하고 사용자와 검색 엔진에 품질 높은 오류 페이지 제공. 2. 인덱싱 최적화검색 엔진이 콘텐츠를 제대로 분석하고 데이터베이스에 저장하도록 돕는 작업.
타이틀과 메타 데이터 설정 &lt;title&gt;: 페이지 핵심 주제를 명확히 전달.
&lt;meta&gt;: 페이지에 대한 추가 정보 제공. 시맨틱 태그 사용 콘텐츠 구조를 명확히 정의해 검색 엔진이 정보의 중요도를 파악.
예: &lt;article&gt;, &lt;section&gt;, &lt;header&gt; 등. 3. 랭킹 최적화검색 결과 상위 노출을 위한 신뢰도와 사용자 경험 개선.
HTTPS 사용 HTTPS 사이트는 구글에서 가산점을 받음.
사용자에게 안전하다는 신뢰를 제공. 모바일 최적화 모바일 우선 인덱싱 적용.
모바일 기기에서 잘 작동하는 웹사이트가 검색 순위에서 유리. 페이지 로딩 속도 최적화 로딩 속도가 빠를수록 사용자 경험과 순위가 향상. SSR 사용 SSR(Server-Side Rendering)은 검색 엔진 크롤링과 SEO에 유리.
CSR(Client-Side Rendering)은 크롤링 효율이 낮음. 요약SEO는 크롤링, 인덱싱, 랭킹 단계에서 각각 최적화를 통해 웹사이트의 가시성을 높이고, 검색 엔진에서 상위 노출될 수 있도록 돕는 작업입니다.
SEO는 좋지만 퍼포먼스 측정이 어렵다 SEO를 개선했더라도 실제 퍼포먼스를 정량적으로 확인하는 것이 중요하다. 검색 엔진 최적화 가이드라인 Google과 같은 주요 검색 엔진의 공식 가이드라인을 참고해 SEO를 점검한다. Lighthouse 구글에서 제공하는 오픈 소스 도구로 웹사이트의 성능, 접근성, SEO 등을 자동으로 분석 가능.
주요 점수 항목: Performance (성능)
Accessibility (접근성)
Best Practices (최적화)
SEO (검색 엔진 최적화) Google Search Console 구글이 내 페이지를 어떻게 인덱싱하는지 확인 가능.
검색 엔진에서 내 페이지가 잘 노출되고 있는지 확인하고, 문제를 진단할 수 있는 유용한 도구. <br><img alt="6571e57ff2a4ea837bf83219_seo + react-p-1080.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/3a8982d2-e2fb-44d7-aae8-b303a5c496ee/c5086d23-8535-4195-be13-ba7dc1cb2c1a.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
크롤링 봇과 HTML 구조 크롤링 봇은 HTML 본문과 메타 정보를 분석하여 페이지 주제, 구조, 연관된 페이지, 스팸 여부 등을 판단합니다.
React는 SPA(Single Page Application) 방식으로, 모든 페이지가 하나의 HTML 파일만을 사용하고 JavaScript로 동적 콘텐츠를 렌더링합니다. → 이로 인해 검색 엔진 최적화(SEO)에 불리합니다. SPA와 SEO 문제점 크롤러는 JavaScript를 실행하지 못하거나, 실행이 제한적인 경우가 많습니다. → CSR(Client-Side Rendering) 환경에서는 초기 HTML만 읽고, 동적 콘텐츠는 인식하지 못해 SEO 점수가 낮아질 가능성이 높습니다. SEO 문제 해결 방법 SSR/SSG (Pre-rendering) SSR (Server-Side Rendering): 요청 시 서버에서 HTML을 생성하여 제공 (예: Next.js).
SSG (Static Site Generation): 빌드 시점에 정적 HTML 파일을 생성.
라이브러리 사용: react-snap 등으로 빌드 시점에 미리 렌더링. 동적 메타 정보 관리 React는 DOM의 body만 조작하지만, 검색 엔진은 head 태그의 정보도 참고합니다.
React-Helmet-Async를 사용해 head 내부의 메타 정보를 동적으로 변경하고 SEO 점수를 향상. 결론 React의 SPA 방식은 SEO에 불리하지만, SSR/SSG 방식으로 정적 HTML 파일을 생성하거나 React-Helmet-Async로 메타 정보를 동적으로 관리하면 SEO 문제를 해결할 수 있습니다. <br><img alt="img1.daumcdn.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/b6d84d26-6f07-40c4-9b76-c8b04e39f780/2a04106e-d2ac-4a71-811f-ef232e7cbb15.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">1. Meta 태그란?웹페이지의 요약 정보를 제공하며, SEO(검색 엔진 최적화), 소셜 미디어 공유, 브라우저 동작 등에 중요한 역할을 합니다.주요 Meta 태그로 Title, Description, Viewport 등이 있습니다. 주요 메타 태그 Meta Title 페이지의 제목을 정의. 저희들이 흔히 쓰던 &lt;title&gt;내 웹사이트 제목&lt;/title&gt; 이 부분이 Meta Title 태그입니다. 다른 메타 태그들처럼 이렇게 쓰이지는 않네요 ㅎㅎ
&lt;title&gt;내 웹사이트 제목&lt;/title&gt; Meta Description 웹페이지 요약 정보를 제공.
구글 검색 결과에서 URL 아래 표시. &lt;meta name="description" content="귀여운 영재의 팬클럽 사이트입니다."&gt; Meta Keywords (거의 사용되지 않음) 과거에 사용되던 키워드 태그. 현재는 SEO에 영향 없음. &lt;meta name="keywords" content="HTML, 메타 태그, SEO"&gt; Robots Meta 태그 검색 엔진 크롤러의 동작을 제어.
예: 페이지를 인덱싱하지 않고 링크만 크롤링
값 index: 페이지를 인덱싱 허용 (기본값). noindex: 페이지 인덱싱 금지. follow: 페이지 내 링크를 크롤링 허용 (기본값). nofollow: 페이지 내 링크 크롤링 금지. noarchive: 검색 결과에서 캐시 페이지 표시 금지. 페이지를 인덱싱하지 않고 링크를 따라가도록 설정
&lt;meta name="robots" content="noindex, follow"&gt; 페이지와 링크 모두 크롤링하지 않음
&lt;meta name="robots" content="noindex, nofollow"&gt; 페이지를 인덱싱하고 링크도 크롤링 (기본값)
&lt;meta name="robots" content="index, follow"&gt; 특정 검색 엔진에만 적용 (예: Googlebot)
&lt;meta name="googlebot" content="noindex, nofollow"&gt; Open Graph 메타 태그 소셜 미디어에서 링크 공유 시 제목, 이미지, 설명 등을 설정.
<br><a data-tooltip-position="top" aria-label="https://www.notion.so/open-graph-14777ba9a1b6806ca1c0f79c4827e72c?pvs=21" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.notion.so/open-graph-14777ba9a1b6806ca1c0f79c4827e72c?pvs=21" target="_self">🍀 open graph</a> → 밑의 이 부분에 따로 적었으므로, 자세한 설명은 생략! f. Twitter 메타 태그
&lt;meta name="twitter:card" content="summary_large_image"&gt;
&lt;meta name="twitter:title" content="페이지 제목"&gt;
&lt;meta name="twitter:description" content="페이지 설명"&gt;
&lt;meta name="twitter:image" content="&lt;https://example.com/image.png&gt;"&gt; 트위터에 최적화된 링크 공유 태그.
twitter:card: 카드 스타일 (summary, summary_large_image 등). g. Viewport 메타 태그 반응형 웹에서 화면 크기에 맞게 콘텐츠를 조정. 이 태그가 없으면 모바일 브라우저가 페이지를 기본 크기로 렌더링하여 사용자가 확대/축소해야 할 수 있다.
&lt;meta name="viewport" content="속성1=값1, 속성2=값2"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 속성과 값 width: 페이지의 너비 device-width: 디바이스의 화면 너비와 동일하게 설정 height: 페이지의 높이 이 속성은 드물게 사용되며, 대부분 디바이스 높이는 자동 조정된다 initial-scale: 페이지의 초기 확대/축소 비율을 설정 1.0은 100% 크기, 2.0은 200% 확대 maximum-scale: 사용자가 페이지를 확대할 수 있는 최대 비율 1.0은 100% 크기로 확대 불가 maximum-scale: 사용자가 페이지를 축소할 수 있는 최소 비율 0.5는 50% 축소 가능 user-scalable: 사용자가 페이지를 확대/축소할 수 있는지 여부 결정 yes 가능, no 불가능 항상 width=device-width와 initial-scale=1.0을 포함하자. 이는 반응형 웹디자인의 기본 설정이다. h. Charset 메타 태그 문서의 문자 인코딩 방식을 정의한다. UTF-8은 전 세계 언어를 지원하는 표준 인코딩이다.
&lt;meta charset="UTF-8"&gt; i. Author 및 기타 정보 Author: 페이지 작성자 정보를 정의한다.
&lt;meta name="author" content="존잘경일"&gt; Theme-Color: 모바일 브라우저에서 주소 표시줄 색상을 지정한다.
&lt;meta name="theme-color" content="#ffffff"&gt; <br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/f7af7a40-10cf-4899-8954-85e47428e7d0/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">요약Meta 태그는 SEO와 사용자 경험을 최적화하는 데 필수적입니다. Title과 Description을 비롯해, Open Graph와 Viewport 태그는 웹페이지의 검색 및 공유 가시성을 크게 향상시킵니다.<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/140a092d-8544-4010-9d25-032693b88a27/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
콘텐츠 링크를 SNS에서 미리보기 형태로 제공하는 프로토콜. 2010년 페이스북이 발표했으며, 트위터, 링크드인 등에서도 채택해 소셜 미디어 UX를 개선. → 링크 공유 시 나타나는 제목, 설명, 이미지 등이 Open Graph 태그로 생성됩니다. Open Graph 태그의 특징
소셜 미디어에 특화된 프로토콜 웹페이지 링크 공유 시 미리보기를 생성.
사용자 유입과 전환율을 증가시켜 SEO에 간접적인 효과를 제공. SEO와의 관계 SEO 점수에 직접 영향을 주지는 않지만, 웹사이트의 가시성과 사용자 클릭률을 높이는 데 기여. 주요 Open Graph 태그
og:title: 페이지 제목
og:description: 페이지 요약 설명
og:url: 페이지 URL
og:image: 공유될 이미지 URL
og:image:alt: 이미지에 대한 설명
og:site_name: 웹사이트 이름
og:type: 콘텐츠 유형 (예: article, website 등)
article:author: 작성자 정보
article:section: 카테고리 정보
article:tag: 태그 정보
사용 예시
오픈 그래프 태그의 종류는 매우 많다. og:title og:description og:url og:image og:type … property 속성에다가 넣는다. (일반 meta 태그는 name 속성에 값을 준다)
&lt;!-- 일반 meta 태그 --&gt;
&lt;meta name="description" content="Easy and convenient way to check real-time cryptocurrency price change along with the live charts"
/&gt; &lt;!-- 오픈 그래프 태그 --&gt;
&lt;meta property="og:description" content="Easy and convenient way to check real-time cryptocurrency price change along with the live charts"
/&gt; &lt;head&gt; &lt;meta property="og:title" content="My Awesome Page" /&gt; &lt;meta property="og:description" content="This is the best page ever!" /&gt; &lt;meta property="og:url" content="&lt;https://www.example.com/page&gt;" /&gt; &lt;meta property="og:image" content="&lt;https://www.example.com/image.jpg&gt;" /&gt; &lt;meta property="og:image:alt" content="An awesome example image" /&gt; &lt;meta property="og:site_name" content="Example Site" /&gt; &lt;meta property="og:type" content="article" /&gt; &lt;meta property="article:author" content="&lt;https://www.example.com/author/john-doe&gt;" /&gt; &lt;meta property="article:section" content="Technology" /&gt; &lt;meta property="article:tag" content="Open Graph, SEO, React" /&gt;
&lt;/head&gt; 요약Open Graph는 소셜 미디어에서 링크 공유 시 가시성과 전환율을 높여주는 태그입니다. 주요 태그를 활용해 링크의 제목, 설명, 이미지 등을 적절히 설정하면 사용자 경험을 대폭 개선할 수 있습니다.1. react-helmet-async란?
&lt;head&gt; 내의 title, meta 태그 등을 동적으로 관리할 수 있는 라이브러리.
react-helmet의 비동기 문제를 해결한 포크 버전으로, 서버 사이드 렌더링(SSR) 환경에서도 안정적으로 작동.
2. 사용 이유
React의 SPA 특성:각 페이지별로 &lt;title&gt;과 &lt;meta&gt; 태그를 설정하기 어려워 SEO에 불리.→ react-helmet-async로 페이지별 title과 meta 태그 관리.
SEO 강화:검색 엔진이 각 페이지 정보를 정확히 크롤링할 수 있도록 지원.
3. 사용 방법 HelmetProvider로 앱 감싸기
index.js 또는 main.js에서 &lt;HelmetProvider&gt;로 앱을 감싼다.
import { HelmetProvider } from "react-helmet-async"; root.render( &lt;HelmetProvider&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/HelmetProvider&gt;
); 페이지별 Helmet 사용 각 페이지에서 &lt;Helmet&gt;으로 title과 meta 태그 설정.
import { Helmet } from 'react-helmet-async'; const HomePage = () =&gt; ( &lt;div&gt; &lt;Helmet&gt; &lt;title&gt;Home - My Website&lt;/title&gt; &lt;meta name="description" content="Welcome to My Website" /&gt; &lt;meta property="og:title" content="Home - My Website" /&gt; &lt;meta property="og:description" content="This is the home page" /&gt; &lt;meta property="og:url" content="&lt;https://www.mywebsite.com/&gt;" /&gt; &lt;meta property="og:type" content="website" /&gt; &lt;/Helmet&gt; &lt;h1&gt;Home Page&lt;/h1&gt; &lt;/div&gt;
); export default HomePage; SSR 환경에서 사용 (예: Express) 서버에서 &lt;title&gt;과 &lt;meta&gt; 태그를 미리 렌더링하여 SEO 강화.
const helmetContext = {}; // Helmet 컨텍스트 생성
const html = renderToString( &lt;HelmetProvider context={helmetContext}&gt; &lt;App /&gt; &lt;/HelmetProvider&gt;
); const { helmet } = helmetContext; res.send(` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ${helmet.title.toString()} &lt;!-- Title 렌더링 --&gt; ${helmet.meta.toString()} &lt;!-- Meta 태그 렌더링 --&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;${html}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
`); 4. 특징
SEO 강화: 크롤러가 페이지 정보를 정확히 가져갈 수 있도록 지원.
SSR 친화적: 서버에서 메타 태그를 렌더링하여 크롤러와의 호환성을 보장.
SPA와 SSR 모두 적합: React SPA 및 Next.js 등 다양한 환경에서 사용 가능.
요약react-helmet-async는 React SPA와 SSR 환경에서 SEO를 강화하기 위한 필수 도구로, 페이지별 title과 meta 태그를 동적으로 관리할 수 있어 검색 엔진 크롤링과 사용자 경험을 동시에 개선합니다.Google Search Console은 웹사이트의 검색 성능을 모니터링하고 개선할 수 있는 무료 도구입니다.장점
검색 성능 확인: 클릭수, 노출수, 검색 순위 등 분석 가능.
문제 해결: 크롤링 오류, 색인 문제, 모바일 사용성 점검 및 수정.
링크 분석: 외부 및 내부 링크 데이터 제공.
구조화 데이터 확인: 검색 결과에 리치 콘텐츠 표시 가능.
무료 서비스: SEO 최적화에 필수적.
단점
실시간 데이터 부족: 데이터 1~2일 지연.
경쟁사 정보 부재: 외부 도구로 보완 필요.
초보자 진입 장벽: 기술적 이해 필요.
구글 검색에 관한 정보들이 정리되어있다.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/search/docs/fundamentals/seo-starter-guide?hl=ko" target="_self">https://developers.google.com/search/docs/fundamentals/seo-starter-guide?hl=ko</a>
단계별 활용 예시Step 1: 계정 설정 및 사이트 등록
Google Search Console 계정을 생성.
사이트 속성 추가 후 소유권 확인 (HTML 태그, DNS 설정 등 활용).
Step 2: 초기 데이터 확인
색인된 페이지와 크롤링 오류를 점검.
기존 성능 데이터를 검토하여 클릭률이 낮은 페이지 확인.
Step 3: 성능 분석
특정 키워드의 순위 변화를 확인.
클릭수가 높은 페이지와 낮은 페이지를 비교하여 문제 식별.
Step 4: 오류 수정
404 오류 페이지를 리디렉션하거나 삭제.
모바일 사용성 문제를 수정하여 SEO 점수 개선.
Step 5: 최적화 작업
메타 태그 수정, 키워드 조정 등으로 콘텐츠 최적화.
내부 링크 추가로 페이지 연결성 강화.
Step 6: 지속적인 모니터링
정기적으로 Search Console 데이터를 검토하여 새로운 문제를 식별.
크롤링 및 색인 요청으로 최신 콘텐츠 업데이트를 Google에 반영.
해당 링크로 들어간 후 본인 웹사이트의 도메인을 입력하면된다.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://search.google.com/search-console/welcome" target="_self">https://search.google.com/search-console/welcome</a>
<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/0ebd9e5b-6b8a-46d5-80ad-19f1599f5cae/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/23ef6501-9d14-4c9b-8812-4459b6605118/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
도메인 주소가 아닌, IP 주소를 등록시 안된다… 그러므로 BooLock 도메인은 등록부터 안된다 ㅋㅋ 도메인만 지원하고 IP 주소를 지원하지 않는 이유 DNS 기반 인증으로 소유권 확인. 도메인의 안정성과 IP의 가변성. SEO 최적화 및 사용자 경험 강화. HTTPS/SSL 표준 지원. 구글 서치 콘솔의 검색 엔진 친화적 설계. GPT 4o 답변 DNS 인증 사용 구글 서치 콘솔의 도메인 속성은 DNS 인증(TXT 레코드)을 사용합니다. 이는 도메인의 소유권을 검증하기 위한 안전하고 표준적인 방법입니다. IP 주소는 DNS 기반 소유권 인증을 지원하지 않으므로 DNS 레코드(TXT, CNAME 등)를 등록할 수 없습니다.
따라서, IP 주소는 소유권 인증 과정에 적합하지 않습니다. 멀티플 도메인 관리 지원 도메인 속성을 사용하면 하나의 도메인과 그 하위 도메인 전체를 관리할 수 있습니다(예: example.com, www.example.com, sub.example.com). 하지만 IP 주소는 특정한 하위 URL만 관리할 수 있어 구글의 관리 표준에 부합하지 않습니다. IP 주소는 변할 수 있다 IP 주소는 서버가 변경되거나 호스팅 제공업체를 변경할 때 변경될 가능성이 높습니다.
반면, 도메인은 고정된 이름으로 IP가 변경되어도 계속 동일한 도메인으로 유지됩니다. 구글 서치 콘솔은 이러한 안정성을 중요시합니다. IP 주소 기반 서비스는 임시적 IP 주소만 사용하는 서비스는 일반적으로 임시적이거나 개발/테스트용으로 사용되는 경우가 많습니다.
구글은 정식 웹사이트의 관리와 최적화를 위해 설계된 플랫폼이기 때문에, 도메인 주소를 기준으로 사이트를 등록하도록 제한합니다. IP 주소는 SEO에 불리 도메인 주소는 사용자에게 친숙하고, 구글 검색 엔진이 페이지를 크롤링할 때 더 유리합니다.
IP 주소 기반 웹사이트는 신뢰성이 낮거나 정식 서비스가 아니라는 신호로 간주될 수 있습니다.
구글은 서치 콘솔을 통해 SEO를 개선하려는 웹사이트를 지원하기 때문에, 도메인 기반 운영을 요구합니다. 브랜드 정체성 도메인은 브랜드를 나타내는 중요한 요소입니다. 구글 서치 콘솔은 도메인 기반으로 작업함으로써 브랜드 인식과 신뢰도를 강화하려는 사이트를 지원합니다. 대부분의 SSL/TLS 인증서는 도메인 이름 기반으로 발급됩니다. IP 주소로 HTTPS를 지원하는 경우가 드물며, 지원되더라도 비용이 비싸고 관리가 복잡합니다.
구글은 HTTPS를 강력히 권장하고 있으며, 이를 위해 도메인 기반 URL만 지원하는 방식을 채택합니다. 광범위한 도메인 관리를 지원 도메인 속성을 통해 사이트 전체 및 모든 하위 도메인에서 발생하는 데이터를 통합적으로 관리할 수 있습니다. IP 주소로는 이러한 기능을 제공하기 어렵습니다. 검색 엔진 친화적 설계 구글 서치 콘솔은 검색 엔진 최적화를 위한 도구로 설계되었습니다. 검색 엔진은 도메인을 기반으로 색인을 생성하며, IP 주소 기반 웹사이트는 일반적으로 색인 생성에서 제외되거나 낮은 순위를 받을 가능성이 있습니다. <br>이후에 가비아에서 구매 후 <a data-tooltip-position="top" aria-label="http://boolock.site/" rel="noopener nofollow" class="external-link is-unresolved" href="http://boolock.site/" target="_self"><code></code></a>http://boolock.site/ 연동한 뒤 boolock.site 도메인 등록하였다.<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/26cd9edf-bbab-4e38-b6b6-da11887a0420/854cd5d3-4a54-4884-9047-7b6ef4047f75.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/c7e7f0d2-d8c7-49bb-a341-77c1c284ee9f/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
도메인 등록 후 가비아에서 DNS 설정을 해주면 왼쪽화면이 된다.
등록 직후에는 검색된 파일이 없어서 구글 서치 콘솔 데이터에 아무것도 안뜬다.
요약Google Search Console은 웹사이트 성능 분석과 SEO 최적화를 위한 필수 도구입니다. 도메인 기반 설정이 요구되며, 지속적인 모니터링과 최적화로 검색 순위를 개선할 수 있습니다.
img의 alt 적용
<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/57b41e79-88d4-4860-9ae7-653e24b8a044/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
문제: 이미지에 alt 속성이 없어서 SEO 점수가 하락.
개선: alt 속성을 추가해 검색 엔진이 이미지를 이해하도록 지원하고, 접근성을 개선.
2. index.html meta 태그 수정
수정 전: 기본 meta 태그만 사용. SEO와 Open Graph 정보 부족.
수정 후: 기본 meta 태그: description, robots, author 추가.
Open Graph: 페이지 제목, 설명, URL, 이미지 추가.
Twitter Cards: 트위터 공유를 위한 meta 태그 추가. before
&lt;!doctype html&gt;
&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;link rel="icon" type="image/svg+xml" href="/images/boolock_logo.png" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;BooLock&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script type="module" src="src/app/main.tsx"&gt;&lt;/script&gt; &lt;/body&gt;
&lt;/html&gt; after
&lt;!doctype html&gt;
&lt;html lang="ko"&gt; &lt;head&gt; &lt;!-- 기본 meta 태그 및 link --&gt; &lt;meta charset="UTF-8" /&gt; &lt;link rel="icon" type="image/svg+xml" href="/images/boolock_logo.png" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;BooLock&lt;/title&gt; &lt;meta name="description" content="코딩 입문자들이 html과 css를 블록으로 쉽고 재밌게 배울 수 있는 플랫폼입니다." /&gt; &lt;meta name="robots" content="index, follow" /&gt; &lt;meta name="author" content="부스트캠프 9기 Web31팀" /&gt; &lt;!-- Open Graph --&gt; &lt;meta property="og:title" content="BooLock" /&gt; &lt;meta property="og:description" content="코딩 입문자들이 html과 css를 블록으로 쉽고 재밌게 배울 수 있는 플랫폼입니다." /&gt; &lt;meta property="og:url" content="&lt;https://boolock.site/&gt;" /&gt; &lt;meta property="og:image" content="/images/boolock_thumnail.png" /&gt; &lt;meta property="og:image:alt" content="블록코딩 플랫폼 BooLock의 썸네일" /&gt; &lt;meta property="og:image:width" content="1200" /&gt; &lt;meta property="og:image:height" content="600" /&gt; &lt;meta property="og:site_name" content="BooLock" /&gt; &lt;meta property="og:type" content="website" /&gt; &lt;!-- Twitter Cards --&gt; &lt;meta name="twitter:card" content="summary_large_image" /&gt; &lt;meta name="twitter:title" content="BooLock: 쉽게 배우는 블록 코딩" /&gt; &lt;meta name="twitter:description" content="HTML과 CSS를 블록으로 쉽고 재미있게 배우세요!" /&gt; &lt;meta name="twitter:image" content="/images/twitter_thumbnail.png" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root" aria-label="BooLock 플랫폼"&gt;&lt;/div&gt; &lt;script type="module" src="src/app/main.tsx" defer&gt;&lt;/script&gt; &lt;/body&gt;
&lt;/html&gt;
3. 공유 링크 미리보기 개선
<br>미리보기 이미지 등록 (가로세로 2:1) <img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/dfc52f8d-39f2-4e2b-bb4d-c12e725a4c3e/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 공유 링크 미리보기 before → after <br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/9d35e1fd-38a1-4bce-b2b3-04dfc1f862ae/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/101cee61-26b0-41ed-81f4-1547a1c46083/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
왼쪽의 밋밋한 미리보기 링크가 보이시나요?
반면에 Open Graph를 적용하면 오른쪽처럼 신뢰감 있고 가독성 좋은 미리보기 링크를 확인할 수 있습니다. react-helmet-async 적용
root.render( &lt;StrictMode&gt; &lt;QueryClientProvider client={queryClient}&gt; &lt;HelmetProvider&gt; &lt;App /&gt; &lt;/HelmetProvider&gt; &lt;/QueryClientProvider&gt; &lt;/StrictMode&gt;
); main.tsx에서 이렇게 App을 HelmetProvider로 감싸준다.
이후 각 페이지 상단에 Helmet태그안에 meta 태그를 설정해주면 된다. return ( &lt;&gt; &lt;Helmet&gt; &lt;title&gt;BooLock - 홈&lt;/title&gt; &lt;meta name="description" content="코딩 입문자들이 HTML과 CSS를 블록으로 배우는 BooLock의 메인 페이지입니다." /&gt; &lt;/Helmet&gt; {isPending &amp;&amp; &lt;Loading /&gt;} &lt;div className="flex h-full w-full flex-col items-center"&gt; &lt;HomeHeader isBlack={true} /&gt; &lt;GuidesBox /&gt; &lt;WorkspaceContainer /&gt; &lt;WorkspaceModal /&gt; &lt;/div&gt; &lt;/&gt; ); robots.txt 적용
# 모든 크롤러에게 전체 사이트 크롤링 허용
User-agent: *
Disallow: # 사이트맵 위치 지정
Sitemap: &lt;http://www.boolock.site/sitemap.xml&gt; 설정 내용 모든 검색 엔진 크롤러가 전체 사이트를 크롤링하도록 허용.
사이트맵 경로 명시: http://www.boolock.site/sitemap.xml 라이트하우스 before -&gt; after <br><img alt="390542208-95edc32c-5fea-4811-97e0-f85734475035.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/551c778e-64a4-41b8-a4f1-67cd11d8816f/390542208-95edc32c-5fea-4811-97e0-f85734475035.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img alt="390541022-c7a93bc1-d454-4193-bb78-5e62d3706794.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/a0d2f958-4342-45f0-81ff-55c15dcc41cb/390541022-c7a93bc1-d454-4193-bb78-5e62d3706794.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">요약
alt 속성 추가로 접근성 및 SEO 개선.
meta 태그 및 Open Graph 추가로 공유 링크와 SEO 강화.
react-helmet-async를 활용해 동적 meta 태그 관리.
robots.txt와 사이트맵 설정으로 검색 엔진 크롤링 최적화.
라이트하우스 점수를 개선해 성능과 SEO 완성도 향상.
BooLock은 이러한 작업을 통해 검색 엔진 및 사용자 경험을 크게 개선했습니다.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=giCR2IneTPw&amp;list=PLxP1MBEv1X4zNAFpq7Ku2L33_V9QkRFEt&amp;index=23" target="_self">https://www.youtube.com/watch?v=giCR2IneTPw&amp;list=PLxP1MBEv1X4zNAFpq7Ku2L33_V9QkRFEt&amp;index=23</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=JiFPTlEMrAs&amp;list=PLxP1MBEv1X4zNAFpq7Ku2L33_V9QkRFEt&amp;index=22" target="_self">https://www.youtube.com/watch?v=JiFPTlEMrAs&amp;list=PLxP1MBEv1X4zNAFpq7Ku2L33_V9QkRFEt&amp;index=22</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://1point.kr/blog/insights/seo-search-engine-optimization/" target="_self">https://1point.kr/blog/insights/seo-search-engine-optimization/</a>
<br><a data-tooltip-position="top" aria-label="https://velog.io/@lhj5924/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%B9%9C%ED%99%94-%EC%9B%B9-React%EC%97%90%EC%84%9C-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-%EC%B5%9C%EC%A0%81%ED%99%94SEO%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EB%93%A4" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@lhj5924/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%B9%9C%ED%99%94-%EC%9B%B9-React%EC%97%90%EC%84%9C-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-%EC%B5%9C%EC%A0%81%ED%99%94SEO%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EB%93%A4" target="_self">https://velog.io/@lhj5924/사용자-친화-웹-React에서-검색엔진-최적화SEO하는-방법들</a>
<br><a data-tooltip-position="top" aria-label="https://velog.io/@parallelkim/%EB%A6%AC%EC%95%A1%ED%8A%B8-SEO%EC%97%90-%EA%B4%80%ED%95%9C-%EB%AA%A8%EB%93%A0-%EA%B2%83" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@parallelkim/%EB%A6%AC%EC%95%A1%ED%8A%B8-SEO%EC%97%90-%EA%B4%80%ED%95%9C-%EB%AA%A8%EB%93%A0-%EA%B2%83" target="_self">https://velog.io/@parallelkim/리액트-SEO에-관한-모든-것</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.npmjs.com/package/react-helmet-async" target="_self">https://www.npmjs.com/package/react-helmet-async</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@miyoni/noSSRyesSEO" target="_self">https://velog.io/@miyoni/noSSRyesSEO</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://jeonghwan-kim.github.io/dev/2020/08/15/react-helmet.html" target="_self">https://jeonghwan-kim.github.io/dev/2020/08/15/react-helmet.html</a>
<br><a data-tooltip-position="top" aria-label="https://homebody-coder.tistory.com/entry/React%EC%9D%98-SEO-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95-React-Helmet-Async-Prerender" rel="noopener nofollow" class="external-link is-unresolved" href="https://homebody-coder.tistory.com/entry/React%EC%9D%98-SEO-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95-React-Helmet-Async-Prerender" target="_self">https://homebody-coder.tistory.com/entry/React의-SEO-최적화-방법-React-Helmet-Async-Prerender</a>
]]></description><link>부스트캠프/멤버십/8주차/seo.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/SEO.md</guid><pubDate>Thu, 05 Dec 2024 04:13:12 GMT</pubDate><enclosure url="https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/d1ee97ec-857a-44cb-8841-02db3f6b8dd9/d47668e3-7383-45a7-af54-84d11f8d2ddf.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://prod-files-secure.s3.us-west-2.amazonaws.com/53787a23-833d-4223-97ad-45d76b4d684c/d1ee97ec-857a-44cb-8841-02db3f6b8dd9/d47668e3-7383-45a7-af54-84d11f8d2ddf.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[면접 및 취업 특강]]></title><description><![CDATA[꾸준히 이력서 작성하기
이력서 피드백 받는 느낌도 알게 되고 면접도 볼 수 있음
면접은 보면 무조건 좋다!
알고리즘 CS | 어플리케이션을 잘 만듦
두 가지 부류가 있는데 둘 중 하나는 있어야 함학벌도 보지만 선을 그어 보지는 않음
어떤 일을 했는가? 어떤 역할을 했는가? 기술적인 깊이있는 도전과 경험이 있는가? 어떠한 상황에서 어떤 고민을 했는가 기초지식 (CS, FE)은 튼튼한가? 함께 일할 수 있는 사람인가? 도전적인가? 성실하고 믿고 맡길 수 있는 사람인가? 회사업무를 잘 할 수 있을까? 회사는 주로 유지보수에 심혈을 기울이고 있음 테스트 코드, 빌드 타임 등
어떤 프로젝트를 만든 것은 메리트가 없음
문제를 보았을 때, 어떻게 해결하였는가?
주요 기술 문제들을 이력서에 넣기 깊이있는 경험을 한 적이 있는가?
배움을 통해&nbsp;성장가능성이 있는가? 요즘은 경력 같은 신입을 좋아함(중고신입)
중고신입들이 지원하는 것을 뽑지 말아야 할 이유가 있는지?
알려주면 얼마나 잘할까를 기대
질문 많이하기, 이를 통해 성장하기 기초지식 (CS, FE)은 튼튼한가?
함께 일할 수 있는 사람인가? 도전적인가?
마인드, 태도, 열정 강점/아쉬운점 정리 -&gt; 계획 세우기 -&gt; 실천 내가 잘하는것 못하는 것 정리하고 채워보기
리얼월드와 같은 상황을 주고 과정을 리얼월드와 같이 진행 경력 만들기 프로젝트 가지고 놀기 혼자 하지 않기 어떤 회사를 가지? B2C &lt;서비스&gt; vs. B2B &lt;서비스, 솔루션&gt; SI -&gt; 퀄리티 보단 시간 스타트업 vs. 중소기업 vs. 대기업
스타트업 투자 못받으면 바로 나가리 중소기업 고정 비용을 받음 B2B가 많아서 대기업 네카라쿠배... '직원은 회사를 대표한다'
나를 대하는 태도 응답 속도
말투
이메일 매너
약속 지키기
면접시 인사
질문의 과정 나를 몰아부치는가?
나를 돕는가? 회사의 문화 복지제도 들여다보기
복장
표정
휴게실 느낌
책상의 배치
휴게공간의 크기
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.wanted.co.kr/" target="_self">https://www.wanted.co.kr/</a> 대표의 메시지 오너가 젤 중요 CTO도
그들의 인터뷰, 메시지 등 비전공자?
나의 열정과 관심, 도전을 그대로 표현어떤 지식을 학습했고, 어떤 경험을 했으니까,&nbsp;어떤 기술을 할 수 있다마스터즈에서 어떤 미션을 해결했는데, 그 과정에서 이런걸 고민하고 시도하고 결과적으로 이런 구조가 됐다
문제정의 1차시도, 2차시도, 3차시도 화면 결과 아키 텍쳐 느낀점 '나는 왜 이곳에서 나의 개발자 삶을 시작하려고 하는가? ' 이 회사의 비전과 가치는 ? 개발자가 면접에서 개발실력을 어떻게 평가받고, 어떻게 증명할 수 있지? 아는 것을 조리있게 말 못한다면? 커뮤니케이션 면접과정은 질문/답변의 시간이 아니다. 대회의 시간
모르더라도 혼자 끙끙대지 말고 물어보기 맞아 신입이니까! 열정, 도전정신, 영향력 질문 있어요? 연봉 얼마에요? X
~부분에 대해 답을 못했는데 혹시 현업에서는 어떻게 하냐요?
없습니다. <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.bokziri.com/" target="_self">https://www.bokziri.com/</a> 끊임없이 공부하기 능동적 태도, 일을 만들어서 하기. 일과 학습은 때개선하기. 우물안 개구리 되지 않기. 그리고 함께 하기
]]></description><link>부스트캠프/멤버십/8주차/면접-및-취업-특강.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/면접 및 취업 특강.md</guid><pubDate>Wed, 04 Dec 2024 05:11:48 GMT</pubDate></item><item><title><![CDATA[그룹 프로젝트_리드미]]></title><description><![CDATA[<img src="https://github.com/user-attachments/assets/43132cc1-bad7-482b-885f-b8d5e3a01103" alt="스크린샷 2024-12-02 오전 2 11 50" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="width: 1722px; max-width: 100%;">
<img src="https://i.imgur.com/fiAwuJA.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
<img src="https://github.com/user-attachments/assets/cee80201-0d26-40e5-9e1f-0ab1fc5edae3" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
<img src="https://i.imgur.com/CXmg6H0.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
<img src="https://github.com/user-attachments/assets/f60e5d7a-7ab1-4449-90a7-df186ba66d2e" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
<img src="https://github.com/user-attachments/assets/a318b955-ad4b-457f-b1c4-03ce4c6ccb2f" referrerpolicy="no-referrer" target="_self" class="is-unresolved">🧭 당신의 프로젝트에 길잡이가 되어줄게요 🧭AI 기반 마인드맵 자동화 서비스
✨ 당신의 아이디어를 연결하는 가장 스마트한 방법, BooMap! ✨ 회의록 기반으로 마인드맵을 자동 생성해요.
시각화된 캔버스에서 수정과 삭제가 가능해요.
만들어진 마인드맵을 팀원들과 쉽게 공유할 수 있어요. <br><a href="https://hits.seeyoufarm.com" target="_self" rel="noopener nofollow" class="is-unresolved"></a><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2Fboostcampwm-2024%2Fweb32-BooMap&amp;count_bg=%2360AEEF&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=hits&amp;edge_flat=false" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 저희 팀은 노드에 대한 동시편집을 가능하기 위해 socket.io에 도전해보았습니다.
동시 편집을 구현하는 과정에 있어서 어떤 문제와 고민들을 했을까요?
<br>🕒 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/io-HTTP-d4557100f7c24787b1e87f1c6318e66c?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/io-HTTP-d4557100f7c24787b1e87f1c6318e66c?pvs=4" target="_self">io 객체 생성 타이밍과 HTTP 요청</a>
<br>🤖 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/aiResponse-1507725fa9ac80c4afebe1c7ec044638?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/aiResponse-1507725fa9ac80c4afebe1c7ec044638?pvs=4" target="_self">aiResponse 이벤트 핸들러 중복 등록 문제</a>
<br>🛠️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/cb17937f9c05446e827aecd5fabb5df0?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/cb17937f9c05446e827aecd5fabb5df0?pvs=4" target="_self">소켓 에러 해결하기 총본집</a>
<br>🖥️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/223e0029efef4945ae4073b3340324ad?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/223e0029efef4945ae4073b3340324ad?pvs=4" target="_self">소켓을 연결했더니 캔버스가 마비된 건에 대하여..</a>
<br>😱 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/e0451420b8c946e3b2cb9c8086197d7a?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/e0451420b8c946e3b2cb9c8086197d7a?pvs=4" target="_self">노드의 텍스트을 삭제했는데 화면의 텍스트가 살아있는 것에 대하여…</a>
마인드맵은 캔버스 라이브러리를 이용하여 그려내지만, 노드들과 마인드맵을 만들어주는 로직은 처음부터 끝까지 저희 팀이 구현했습니다. 어떤 시도와 도전들이 있었는지 찾아보세요!옵시디언과 같은 메모 앱에서는 마인드맵 자식 요소들이 딸려오던데,, 우리도 한번 도전해볼까? <br>
-&gt; 🛠️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1417725fa9ac8060944ec3769d9056a8?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1417725fa9ac8060944ec3769d9056a8?pvs=4" target="_self">노드들을 끌고오게 하기</a>각 부모와 자식 간을 이어주는 선을 직접 위치까지 계산해서 넣어야 했는데,, 보이는 것보다 더 개선할 수 있을까에 대한 고민을 공유합니다 <br>
-&gt; 🎯 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1377725fa9ac80b1af7fe19ee08a1110?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1377725fa9ac80b1af7fe19ee08a1110?pvs=4" target="_self">드래그 시 노드를 따라가는 선 구현하기</a>사용자들이 브레인스토밍하면서 한 곳으로 관심사를 분류해놓긴 하지만, 텍스트를 보기 위해 겹쳐 놓지는 않을텐데,, 그럼 재미 요소로 노드들끼리 2D 물리엔진처럼 충돌이 되도록 구현해 볼까하는 생각에서 노드 충돌방지를 소개합니다. <br>
-&gt; ⚠️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/13a7725fa9ac80e8b96af725dbf70ba0?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/13a7725fa9ac80e8b96af725dbf70ba0?pvs=4" target="_self">노드들의 충돌 감지 및 회피</a>충돌 방지 기능을 넣었더니 노드가 많아졌을 때 프레임 드랍이 생겼습니다. 프레임 드랍을 해결하기 위한 문제 분석과 이를 해결하기 위한 시도를 공유합니다! <br>
-&gt; 🚀 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/13d7725fa9ac800798f5f44af7c4939f?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/13d7725fa9ac800798f5f44af7c4939f?pvs=4" target="_self">충돌 방지의 렌더링 성능 최적화</a>이미지의 export 기능을 구현한 과정을 소개합니다! <br>
-&gt; 💾 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/1427725fa9ac8043a27ceffd0d387cdb?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1427725fa9ac8043a27ceffd0d387cdb?pvs=4" target="_self">노드들의 이미지 다운로드하기</a>사용자가 나중에 노드가 많아졌을 때, 한번 노드들에 대해서 재정렬하거나 겹치지 않게끔 노드를 만들어주는 기능을 넣으면 사용자 경험에 좋은 영향을 끼칠 것이라 판단했습니다. 그렇다면 이를 어떻게 계산하여 반영했는지에 대한 과정을 소개합니다 <br>
-&gt; 📍 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/782eba067f814852a11208f249996cdf?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/782eba067f814852a11208f249996cdf?pvs=4" target="_self">노드들이 겹치지 않게 펼치기</a>회원과 비회원 전용 서비스를 만들면서 어떻게 소유권을 관리해야 할지 정말 많은 케이스들이 발견되었습니다. 이를 해결하기 위한 저희만의 돌파구를 소개합니다.
<br>🔑 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/14e7725fa9ac80eba893d0986a81e605?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/14e7725fa9ac80eba893d0986a81e605?pvs=4" target="_self">회원과 비회원의 소유권 관리하기</a>
<br>📡 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/14e7725fa9ac8070aff8cd82157ca616?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/14e7725fa9ac8070aff8cd82157ca616?pvs=4" target="_self">로그인 후 대시보드 API를 불러오도록 타이밍 조절하기</a>
모든 회의에서 대부분의 서기가 있다시피, 저희도 회의록을 두고 한 명이 이를 편집하면서 다른 사람들은 볼 수 있으면 좋겠다는 새로운 아이디어가 나와 회의록 기능을 추가했습니다. 에디터 라이브러리를 사용한 일지를 공유합니다.
<br>📝 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/tiptap-4f653362bcd34016a377fe4794b76455?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/tiptap-4f653362bcd34016a377fe4794b76455?pvs=4" target="_self">tiptap 에디터 도입하기</a>
팀원들이 순수 흥미와 호기심으로 했던 도전들과 직면했던 문제들을 해결하기 위한 시도들을 소개합니다!저작도구에서 중요했던 핵심 기능 중 하나는 '단축키'였습니다. 이와 함께 저희의 노드들의 상태를 되돌리기 할 수 있는 기능이 있다면 편집이 보다 쉬울 것이라 판단하여 시도했던 과정을 소개합니다. <br>
-&gt; 🔄 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/canvas-Ctrl-z-1cf4b1e309814aea859ea9b27e3ec82b?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/canvas-Ctrl-z-1cf4b1e309814aea859ea9b27e3ec82b?pvs=4" target="_self">canvas에서 Ctrl + z로 뒤로가기를 해보자</a>다양한 문제들을 해결했던 과정들을 소개합니다.
<br>⚙️ <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/14a7725fa9ac8065b906fc9af6b94d1c?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/14a7725fa9ac8065b906fc9af6b94d1c?pvs=4" target="_self">이벤트 리스너 조절하기</a>
<br>
<img src="https://github.com/user-attachments/assets/47f18052-b896-4c99-9b2b-6a18860de0aa" alt="image" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="width: 697px; max-width: 100%;">
<br><img src="https://i.imgur.com/JbkxCKa.png" alt="image" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="width: 697px; max-width: 100%;">저희 팀에 대해서 더 알고 싶거나 서비스를 체험하고싶으신 분은 아래 링크를 통해 이동해주세요 😉 <br><a data-tooltip-position="top" aria-label="https://boomap.site" rel="noopener nofollow" class="external-link is-unresolved" href="https://boomap.site" target="_self"></a><img alt="BOOMAP" src="https://img.shields.io/badge/BOOMAP-0A84FF?style=for-the-badge&amp;logo=googlegemini&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/BOOMAP-1287725fa9ac80dd87d9c5fbad711b3d?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/BOOMAP-1287725fa9ac80dd87d9c5fbad711b3d?pvs=4" target="_self"></a><img alt="TEAM NOTION" src="https://img.shields.io/badge/TEAM%20NOTION-0078D7?style=for-the-badge&amp;logo=notion&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <a data-tooltip-position="top" aria-label="https://github.com/boostcampwm-2024/web32-BooMap/wiki" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/boostcampwm-2024/web32-BooMap/wiki" target="_self"></a><img alt="Wiki" src="https://img.shields.io/badge/Wiki-181717?style=for-the-badge&amp;logo=github&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <br>
<img height="400/" src="https://i.imgur.com/nHeXf6r.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> ]]></description><link>부스트캠프/멤버십/8주차/그룹-프로젝트_리드미.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/그룹 프로젝트_리드미.md</guid><pubDate>Wed, 04 Dec 2024 02:04:29 GMT</pubDate><enclosure url="https://github.com/user-attachments/assets/43132cc1-bad7-482b-885f-b8d5e3a01103" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://github.com/user-attachments/assets/43132cc1-bad7-482b-885f-b8d5e3a01103&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[BOOMAP (2)]]></title><link>부스트캠프/멤버십/8주차/boomap-(2).html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/BOOMAP (2).pdf</guid><pubDate>Wed, 04 Dec 2024 01:47:21 GMT</pubDate></item><item><title><![CDATA[vpc미션]]></title><description><![CDATA[
NCloud 에 테스트용 VPC 작성
서브넷 * 2 작성 (퍼플릭, 프라이빗)
각 서브넷에 인스턴스 2 개 설치
private 인스턴스 접속
private 인스턴스 인터넷 업데이트 및 mysql 설치
스샷 제출!
<img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/35ce6f1d-b2bc-4162-85c7-3c908d743b22/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">VPC 생성<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/5c9f6a75-0ae2-4db6-8129-b2106f2c2a72/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">public subnet, private subnet, gateway subnet 생성
gateway 설정을 하지 않아도 mysql-server가 설치가 된다.
ping은 안된다.
뭔가 내부적으로 apt 패키지 설치는 접근할 수 있게 해주는 건가..?
gpt의 답변
<br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/0408b160-606f-4b0a-8cf7-76cbd99647ef/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img alt="image.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/9125a26b-97ac-4ec7-84c6-dffb8b2773b7/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">공인 IP 두개를 사용해서 public 서버에 하나, 공인 NGW Subnet에 하나 할당해서 해결.공인 NGW를 생성하고, route table에 가서 아웃바운드에 추가해주면 된다.뭔가 수업때는 공인 IP 하나만 사용하는 느낌이였는데 이게 맞나..?
사용한 리소스는 잊지 말고 꼭 정리해 준다!
]]></description><link>부스트캠프/멤버십/8주차/vpc미션.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/vpc미션.md</guid><pubDate>Tue, 03 Dec 2024 08:51:02 GMT</pubDate><enclosure url="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/35ce6f1d-b2bc-4162-85c7-3c908d743b22/image.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/35ce6f1d-b2bc-4162-85c7-3c908d743b22/image.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그룹프로젝트_협업전략]]></title><description><![CDATA[
온라인 커뮤니케이션 줌 회의: 발언 시 오디오 겹침 방지를 위해 손들기 기능을 사용해요.
코어 타임: 모두 게더타운에 접속해서 작업해요.
연장 활동 시간: 코어 타임 이후에도 작업을 더 할 사람은 게더타운에 남아서 작업해요.
긴급 소집: 메인 소통 채널은 슬랙입니다. 필요 시 카카오톡, 정말 급하면 전화로 연락해요.
자유롭게 소통: 눈치 보지 말고 자유롭게 의견을 나눠요! 🙏
일정 지연 시: 일정이 밀릴 것 같으면 최대한 빨리 알려 주세요. (걱정하지 말고 편하게 알려주세요😳) 진행 상황 점검 매일 스크럼을 통해 진행 상황을 점검해요.
진행 상황 업데이트: 작업을 시작하면 In Progress로, 작업 완료 후 머지 시 Complete로 GitHub Project에 상태를 업데이트합니다.
일정 지연 시: 빠르게 도움을 요청하고 필요한 지원을 받아요. 해당 사안에 대해 적합한 사람을 지정하여 도움을 요청해요. 페어프로그래밍을 적극 활용할 수 있습니다 !
도움 요청 시, 요청하는 사람은 작업 맥락과 현재 고민 사항을 충분히 설명해요.
진행 상황을 슬랙에 간단히 남겨 기록하고, 해결 이후 반드시 문서화 해요. 전체적으로 진행이 더딜 경우 진행이 느리다고 느껴지면 자유롭게, 솔직하게 얘기해요 (고민이나 어려운 부분 포함)
다함께 리프레쉬 하는 시간을 가질 것을 요청하는 것도 권장합니다 ! 리마인드: 일정을 상기시켜 주는 연락을 자유롭게 보낼 수 있어요. 코드 리뷰: 간단한 LGTM(Looks Good To Me)만 달기 지양 🚫
진지한 리뷰: 코드 리뷰는 정성껏 🙆‍♂️
팀 성장 지향: 리뷰는 평가가 아닌, 우리의 코드 품질 향상을 위한 하나의 소통 방식으료 여겨요. 함께 성장합시다! 🌱
<img src="https://i.imgur.com/MIIc3Dp.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
main 브랜치 하나의 배포 버전을 의미해요. 충분히 dev에서 디버깅을 거친 뒤, main으로 머지돼요 dev 브랜치 story 단위의 task들이 모두 완성되어 하나의 기능이 완성되면 충분히 디버깅을 거치고 main branch로 Pull Request를 보내요
dev 머지됐을 때 클라이언트, 서버 모두 테스트를 자동화하여 실행해요 feature 브랜치 노션에 있는 백로그에 설정한 feature-[story번호]-[task번호]-[fe/be]로 브랜치를 생성해요 task 단위로 되어있는 작업들 단위로 브랜치를 생성해요
task 기능 완료 후에 PR 날려 dev 브랜치에 머지해요
백로그에 없는 다른 기능을 추가하기 전에는 팀원과 상의 후 백로그에 task 번호를 추가하고 이슈를 생성한 뒤에 PR을 날려요
특정 기능에 대해 오류 수정의 경우 feature-[story번호]-[task번호]-[fe/be]-fix로 브랜치를 만들어요
이외의 필요한 브랜치는 팀원과 협의 후 결정해요 디폴트 포맷 : feat : 기능 완성
prefix : 커밋 메세지 + 본문 간략하게(선택)]]></description><link>부스트캠프/멤버십/8주차/그룹프로젝트_협업전략.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/그룹프로젝트_협업전략.md</guid><pubDate>Sat, 30 Nov 2024 17:44:15 GMT</pubDate><enclosure url="https://i.imgur.com/MIIc3Dp.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/MIIc3Dp.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[파일 시스템]]></title><description><![CDATA[70년대 Unix
벨 연구소에서 1969년 유닉스 탄생(켄 톰슨, 데니스 리치)
70년대 중반 벨 AT&amp;T에서 유닉스를 라이센스 형태로 배포
저렴한 가격, 소스 코드 공개로 인기를 얻음
버클리에서 BSD 개발
80년대 Unix
AT&amp;T에서 상업적으로 판매 시작하며 다양한 변종 등장
AT&amp;T System V
버클리 BSD
Sun SunOS (Solarris)
HP-UX
IBM AIX
Xenix
Posix의 등장
유닉스의 변종이 생기며 표준화의 필요성 대두
Portable Operationg system
리눅스의 등장
1991년 리누스 토르발즈에 의해 개발됨
오늘날 서버 운영체제의 90% 점유
안드로이드
수정된 리눅스 커널 기반
전원 관리, Binder IPC
ART와 프레임워크 추가
Kotlin 기반의 어플리케이션
Bionic libc 라이브러리 사용 IOS
2000년 개발된 Darwin 커널 기반(XNU커널)
XNU : Mach + FreeBSD
Mach: 마이크로 커널
Darwin: 하이브리드 커널
OS 복습
프로그램과 프로세스 프로그램 -&gt; 코드 뭉치
프로세스 -&gt; 메모리에 실행중인 프로그램
보통 2차 저장장치에 들어가있음 유저모드와 커널모드 유저모드 -&gt; 일반적인 프로세스의 실행
커널모드 -&gt; 커널이 돌아갈 떄. 시스템 자원을 사용할 때. 유저모드에서 시스템콜을 실행할 때. 커널은 RAM에 있음. 물리 메모리의 일부 영역을 할당받음. 위치는 CPU 아키텍처마다 다름. ARM은 가상 메모리 공간의 맨 앞, 가상 영역에 매핑이 되어있음. 내 프로세스가 있다면 일부 영역이 커널 영역으로 사용되고 있음
페이지 테이블이 가상 메모리를 물리 메모리로 매핑
변환을 하기 위해서 메모리를 읽으면 너무 느리기 때문에 TLB를 둠 커널 -&gt; 물리 메모리, 모든 프로세스가 매핑 참조변수를 가지고 있음. 모든 프로세스가 같은 물리 영역에 접근하기 위해 같으네 주소값을 가지고 있음. 같은 참조를 가지고 모두 같은 곳에 접근 시스템 콜과 라이브러리 함수
프로세스의 메모리 구조
페이징과 스왑
페이지 캐시와 버퍼 캐시
파일 시스템
IPC
<img src="https://i.imgur.com/BQKxA1o.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
운영체제의 역할
하드웨어에 대한 추상화와 보호<br>
<img src="https://i.imgur.com/0HeXudI.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
커널을 이용해 하드웨어에 접근
필요하다면 직접적으로 시스템콜을 호출해서 하드웨어에 접근할 수 있음
커널은 항상 메모리에 상주하고 있음
시스템 콜을 호출하는 순간 커널 모드가 되고 이후에는 사용자 프로그램으로 복귀
파일 시스템과 VPC
리눅스의 VFS 파일에 접근할 때 파일 시스템이 막아놓음
리눅스의 모든 장치는 파일로 되어있음
리눅스는 여러 개의 파일 시스템을 동시에 사용 가능
ext4, XFS, Btrfs, f2fs, vfat, ntfs
파이프도 vfs처럼 파일로 추상화해서 사용 리눅스 실행파일 포맷 : ELF
텍스트 세션 ]]></description><link>부스트캠프/멤버십/8주차/파일-시스템.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/파일 시스템.md</guid><pubDate>Wed, 27 Nov 2024 05:35:22 GMT</pubDate><enclosure url="https://i.imgur.com/BQKxA1o.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/BQKxA1o.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[React Next]]></title><description><![CDATA[크롱님 마스터클래스
첫 페이지 로딩은 중요최초 콘텐츠풀 페인트(FCP)는 브라우저가 DOM에서 첫 번째 콘텐츠 비트를 렌더링하여, 페이지가 실제로 로드되고 있다는 첫 번째 피드백을 사용자에게 제공하는 경우입니다. FCP 이후에 사용자는 웹 페이지가 로드되어 있다는 것을 느낄 수 있습니다.최초 콘텐츠풀 페인트 타임스탬프는 브라우저가 텍스트, 이미지(배경 이미지 포함), 비디오, 그려진 캔버스 또는 비어있지 않은 SVG를 처음 렌더링한 시점입니다. 이것은 iframe의 모든 콘텐츠를 제외하지만 보류 중인 웹 글꼴이 있는 텍스트를 포함합니다. 사용자가 페이지 콘텐츠를 소비하기 시작한 것은 이 시점이 처음입니다.LCP는 사용자가 페이지로 처음 이동한 시점을 기준으로 표시 영역에 표시되는 가장 큰&nbsp;이미지, 텍스트 블록 또는 동영상의 렌더링 시간을 보고합니다.방문자에게 콘텐츠가 얼마나‌ 불안정한 지 측정하는 사용자 경험 측정 항목 현재 보고 있는 페이지에 갑자기 발생하는 레이아웃의 변경은 시각적으로 거슬리며 사용자의 주의를 산만하게 함
또한 잘못된 클릭을 유도하여 실제 피해를 일으킬 수도 있고 아주 실망스러운 사용자 경험으로 이어질 수 있음CLS(Cumulative Layout Shift)&nbsp;측정은 사용자에게 발생하는 레이아웃 이동(layout shift) 빈도를 측정하여 이 문제를 해결하는 데 도움이 됩니다.<img src="https://wit.nts-corp.com/wp-content/uploads/2020/12/01.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://ui.toast.com/posts/ko_20220512" target="_self">https://ui.toast.com/posts/ko_20220512</a>
다음 페인트에 대한 상호작용(Interaction to Next Paint, INP)은&nbsp;응답성을 평가하는 실험적인 필드 메트릭
INP는 전체 페이지 라이프 사이클동안 일어난 모든 상호작용에 대한 지연을 기록한다. 이러한 상호작용은 가장 높은 값(또는 많은 상호 작용이 있는 페이지의 경우 가장 높은 값에 가까운 값)이 페이지의 INP로 기록된다. INP가 낮다면 해당 페이지가 항상 안정적으로 응답할 수 있다는 걸 보장한다.
첫 페이지 로딩을 빠르게 훌륭한 반응
부드럽게 이어져 보이기
**진단 &gt; 개선 &gt; 테스트 &gt; 진단**
진단 어디가 왜 얼마큼 느린가?
어느 인터랙션이 사용자에게 중요한 가치를 주는가?
정량적인 지표는 얼마인가?
어떻게 진단하는가? 크롬 개발자도구 - lighthouse
크롬 개발자도구 - performance, memory(누수는 없나?)
pagespeed insights 개선
테스트 side effect는 없는가? 진단 어디가 얼마큼 빨라졌는가? HTML Parsing 방해하지 않기 script&nbsp;위치 조정 (body 끝으로 이동)
defer/async&nbsp;속성 활용 Build를 통한 코드 최적화 코드 압축 (minification) 및 번들링 번들링을 안하면 파일 수가 많아지고, 서버에 그때마다 요청하기 때문에 비용이 큼. 번들링을 통해서 http request 수를 줄이기
배포하는 파일을 줄임으로써 관리 또한 쉬워짐 코드 스플리팅 (Code Splitting) 너무 큰 코드를 나누기. 실질적으로 사용하는 부분은 적은데 처음부터 많이 받으면 첫 렌더링 속도가 느려짐
적절한 코드 스플리팅을 통해 필요한 부분만 받고 캐시 효과를 보면서 최적화 난독화 Vite,&nbsp;ESBuild와 같은 최신 빌드 도구 활용 클라이언트 동적 렌더링 피하기 Server-Side Rendering (SSR) 동적으로 서버에서 렌더링 해서 주는 것들로 컴파일되는 효과
서버사이드 렌더링이 첫 렌더링 때는 훨씬 좋음
하지만 서버가 복잡해지고 view를 관리하기 어려움
초기 페이지는 서버사이드 렌더링 , 나머지는 클라이언트 사이드 렌더링이 이상적인데 서버에서는 이를 분리해서 관리하기 어려움 <br>Pre-Rendering (예:&nbsp;<a data-tooltip-position="top" aria-label="https://www.npmjs.com/package/prerender-loader" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.npmjs.com/package/prerender-loader" target="_self">prerender-loader</a>)
Static Site Generation (SSG)&nbsp;활용 가능 여부 확인
리액트에서 제공하는 API를 활용해서 해보기 Lazy Loading(지연로딩) 스크롤이 내려지는 시점에 단계적으로 가져올 수 있게 하는 것 Lazy Component Loading (Dynamic JS Loading)
Image Lazy Loading (loading="lazy") React.lazy를 통해 그때그때 컴포넌트 가져오기 IntersectionObserver API&nbsp;활용 HTTP Header의 속성 활용 Cache-Control (max-age,&nbsp;no-cache,&nbsp;no-store)
Expires (캐시 만료 시간)
Last-Modified / If-Modified-Since (마지막 갱신 시간)
ETag&nbsp;활용: 리소스 변경 여부를 서버에서 판단 서버가 리소스를 제공할 때 ETag 값을 생성해 응답 헤더에 포함 (ETag: "abc123")
브라우저는 이후 요청에서 If-None-Match 헤더에 ETag 값을 포함 (If-None-Match: "abc123")
서버는 ETag를 비교 (값이 같으면 리소스가 변경되지 않았으므로 304 Not Modified를 반환) 이미지 최적화 WebP, AVIF 포맷으로 이미지 변환
WOFF2 폰트 활용: WOFF보다 더 작은 크기로 압축 가능
기존 폰트 파일을 WOFF2로 변환하여 로딩 속도 개선 메인 스레드 Blocking 방지 DOM 수정 최소화 (Reflow와 Repaint 단계 제거 노력) reflow나 repaint가 최근들어서는 리액트에서 최적화를 시켜줌 Reflow 줄이기 Composite 단계에서 동작하도록 GPU 가속 속성 사용
3D Transform (translate3d)
Video/Canvas 요소 활용
transform/opacity&nbsp;기반 CSS 애니메이션 (Keyframes, Transition)
will-change&nbsp;속성 적용 중복 계산 줄이기 Memoization (useMemo) 같은 작업이 일어날 확률이 은 계산에 대해서 메모이제이션
훨씬 빠르게 캐시된 결과를 가져올 수 있도록 함
리렌더링마다 key value에 보관하고 있는 캐싱 방법 네트워크 요청 캐시 전략 Service Worker 및 PWA를 활용한 캐싱 <br><a data-tooltip-position="top" aria-label="https://developers.google.com/web/fundamentals/primers/service-workers#%EC%9A%94%EC%B2%AD_%EC%BA%90%EC%8B%9C_%EB%B0%8F_%EB%B0%98%ED%99%98" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/web/fundamentals/primers/service-workers#%EC%9A%94%EC%B2%AD_%EC%BA%90%EC%8B%9C_%EB%B0%8F_%EB%B0%98%ED%99%98" target="_self">참고</a> Cache Header 전략
Stale-while-Revalidate 어느 순간까지는 캐시에서 가져오고 그 뒤부터는 서버에서 가져올 수 있도록 함 Prefetch 및 Preload 활용 Preload 사용&nbsp;:
특정 리소스가 사용될 것을 확실히 알고 있을 때, 브라우저가 이를 우선적으로 다운로드 &lt;link rel="preload" href="/styles/main.css" as="style"&gt;
&lt;link rel="preload" href="/scripts/main.js" as="script"&gt; Prefetch 사용&nbsp;:
예측 로딩이나 사용자가 다음에 필요할 리소스를 미리 로드할 때 사용. react-helmet 등을 사용 &lt;link rel="prefetch" href="/images/background.jpg"&gt; TLS 암호화 통신
Keep-Alive 기본 제공 (TCP 연결 재사용)
XMLHttpRequest fetch -&gt; Promise패턴이 적용되어 있지만 XMLHttpRequest는 패턴이 안적용돼있음 리소스 우선순위 없이 다운로드
헤더 크기 증가
동시성을 위해 여러 개의 연결(connection) 필요 HTTP/2.0의 스트림-프레임 관계 여러 개의 스트림을 동시에 전송 가능
각 스트림은 다수의 프레임으로 구성 예: 스트림 1 → 프레임 A, B, C
스트림 2 → 프레임 X, Y, Z 프레임은 독립적으로 전송되며 고유 ID를 가짐
스트림과 프레임의 독립적 처리를 통해 병렬 데이터 전송 가능 기능 개선 다중 요청/응답 처리 (Multiplexing)
헤더 필드 압축 (HPACK) header packing Server Push 지원 QUIC 프로토콜 기반 UDP 위에서 동작하며 TCP의 오버헤드를 제거
3-way Handshake 생략 접속 정보를 캐싱(RTT) 등을 통해 신뢰성 확보 패킷 손실 복구를 위해&nbsp;패킷 재전송 및 일련번호 지정 병렬 처리 강화 여러 개의 요청과 응답이 하나의 연결에서 동시에 처리
프레임 단위로 분리된 UDP 패킷 사용 HTTP/3 적용 사례 주요 CDN 제공자들이 HTTP/3 지원 (Cloudflare, AWS CloudFront 등) ]]></description><link>부스트캠프/멤버십/8주차/react-next.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/React Next.md</guid><pubDate>Mon, 25 Nov 2024 05:54:45 GMT</pubDate><enclosure url="https://wit.nts-corp.com/wp-content/uploads/2020/12/01.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://wit.nts-corp.com/wp-content/uploads/2020/12/01.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[11.20 호눅스님 마스터클래스]]></title><description><![CDATA[c언어 입문자
열혈 c프로그래밍
The C Programming language<img src="https://i.imgur.com/zQ5swn0.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
1969 UNIX 탄생
1969 리누스 토르발즈 탄생
1972 C언어 탄생(데네스 리치)
1974년 최초의 RDB SYSTEM-R 등장 관계형 데이터베이스의 최초버전 1977 APPLE II 출시 프로그래머스 LV3
백준 골드 1정도 Introduction to Algorithm
Art of Programming
종만북(대회용)
알고리즘 인터뷰 시리즈
코딩 테스트 베스트 셀러 검색
알고리즘 인터뷰 완전분석
박상길
안경쓴 머시기
재귀
재귀가 필요한 이유 사고력 높이기 피보나치 수열
트리와 그래프
트리의 순회
트리 응용 자료구조
이진 트리
이진 검색 트리
Heap과 Heap Sort, 우선순위 큐
Spanning Tree
MST
Trie
백트래킹
완전탐색과 차이점 프로닝(필터링) 을 통해 모두다 탐색하지 않음 n-queens 문제
최단거리
Optimal Substructure 분할정복, DP가 되는 이유 다익스트라 최단거리
플로이드 알고리즘
동적 계획법
이름하고는 상관없다
메모이제이션
피보나치 수열
배날 문제
P-NP문제
P 문제와 NP 문제의 관계를 증명하는 것
]]></description><link>부스트캠프/멤버십/8주차/11.20-호눅스님-마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/11.20 호눅스님 마스터클래스.md</guid><pubDate>Wed, 20 Nov 2024 05:37:03 GMT</pubDate><enclosure url="https://i.imgur.com/zQ5swn0.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/zQ5swn0.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Error boundary와 Suspense]]></title><description><![CDATA[클라이언트에서 오류를 받게 되면 UI가 그대로 없어지는 현상을 많이 보았을 것이다.
하지만 이러한 현상은 사용자경험에 있어서는 치명적인 오류가 아닐 수 없다.
그렇기 때문에 Error boundary를 설정함으로써 깨진 컴포넌트 트리 대신 Fallback UI, 즉 대체할 수 있는 UI를 보여줄 수 있도록 해서 에러를 관리하는 패턴이다.리액트에서는 버전 16부터 이를 도입하여 렌더링 도중의 생명주기 / 하위 트리 에서 에러를 잡아낼 수 있도록 클래스형 컴포넌트에 두 가지 생명주기 메서드를 도입했다.
static getDerivedStateFromError()
componentDidCatch() 하지만 다음과 같은 에러는 잡지 못하니 주의하자. 이벤트 핸들러
비동기적 코드 (예: setTimeout 혹은 requestAnimationFrame 콜백)
서버 사이드 렌더링
자식에서가 아닌 에러 경계 자체에서 발생하는 에러 class ErrorBoundary extends React.Component { constructor(props) { super(props) this.state = { hasError: false } } static getDerivedStateFromError(error) { // 다음 렌더링에서 폴백 UI가 보이도록 상태를 업데이트 return { hasError: true } } componentDidCatch(error, errorInfo) { // 에러 로그 찍기 logErrorToMyService(error, errorInfo) } render() { if (this.state.hasError) { // 폴백 UI를 커스텀하여 렌더링시키기 return &lt;h1&gt;Something went wrong.&lt;/h1&gt; } return this.props.children }
}
이렇게 만들어진 클래스형 컴포넌트는 &lt;ErrorBoundary&gt; &lt;App /&gt;
&lt;/ErrorBoundary&gt;
이런 식으로 프로젝트 자체를 전부 래핑하여 오류를 발견하고, 에러가 보일 시에 다른 텍스트를 통해 UI로 돌아가게끔 할 수 있다.
하지만 위와 같이 제공해준 생명주기 메서드는 훅이 있는 함수형 컴포넌트에서는 사용이 불가능하다.그래서 클래스형으로 고차 컴포넌트를 만들고, 이를 감싸는 바운더리 컴포넌트를 통해 관리하는 것으로 보인다.import React from "react" type ErrorHandler = (error: Error, info: React.ErrorInfo) =&gt; void
type ErrorHandlingComponent&lt;Props&gt; = (props: Props, error?: Error) =&gt; React.ReactNode type ErrorState = { error?: Error } export default function withCatch&lt;Props extends {}&gt;( component: ErrorHandlingComponent&lt;Props&gt;, errorHandler?: ErrorHandler
): React.ComponentType&lt;Props&gt; { function Inner(props: { error?: Error, props: Props }) { return &lt;React.Fragment&gt;{component(props, error)}&lt;/React.Fragment&gt; } return class extends React.Component&lt;Props, ErrorState&gt; { state: ErrorState = { error: undefined } static getDerivedStateFromError(error: Error) { return { error } } componentDidCatch(error: Error, info: React.ErrorInfo) { if (errorHandler) { errorHandler(error, info) } } render() { return &lt;Inner error={this.state.error} props={this.props} /&gt; } }
}
해당 컴포넌트는 고차 컴포넌트(Higher-Order Component, HOC)로 만들어 졌으며, 자식 컴포넌트의 에러를 잡아내고 처리하는 기능을 추가한 버전이다. 함수형 컴포넌트처럼 생겼지만서도 내부에서는 클래스형 컴포넌트를 이용해서 구현하였다.
해당 컴포넌트는 children을 받는 것처럼 안쪽의 요소를 받아 그대로 컴포넌트로 에러 상태를 내려준다.Inner라는 함수형 컴포넌트를 통해 안쪽에 에러 바운더리를 설정하는데, 이를 에러의 상태를 잡아 캐치하게 되면 error에는 해당 에러의 내용이 담기게 되고, 에러가 있을 경우 getDerivedStateFromError에 에러가 담기게 되며, state가 업데이트 되고, componentDidCatch가 실행되어 해당 에러에 대해 처리를 하게 된다.따라서 에러 처리를 단계별로 나누어보자면
컴포넌트 생성: Catch 함수를 통해 에러 바운더리 역할을 하는 클래스형 컴포넌트를 반환
렌더링: 컴포넌트가 렌더링될 때, 자식 컴포넌트(Inner)가 호출되어 에러 또는 정상적인 props로 렌더링됩니다.
에러 발생 시: 자식 컴포넌트에서 에러가 발생하면, getDerivedStateFromError 메서드가 호출되어 state.error가 설정되고 이 상태에 따라 에러가 렌더링됩니다.
에러 후처리: 에러가 발생하면 componentDidCatch에서 에러 핸들러가 동작할 수 있습니다.
이러한 방식은 라이브러리인 react-error-boundary에서도 비슷한 방식으로 활용한다.import { isDevelopment } from "#is-development";
import { Component, createElement, ErrorInfo, isValidElement } from "react";
import { ErrorBoundaryContext } from "./ErrorBoundaryContext";
import { ErrorBoundaryProps, FallbackProps } from "./types"; type ErrorBoundaryState = | { didCatch: true; error: any; } | { didCatch: false; error: null; }; const initialState: ErrorBoundaryState = { didCatch: false, error: null,
}; export class ErrorBoundary extends Component&lt; ErrorBoundaryProps, ErrorBoundaryState
&gt; { constructor(props: ErrorBoundaryProps) { super(props); this.resetErrorBoundary = this.resetErrorBoundary.bind(this); this.state = initialState; } static getDerivedStateFromError(error: Error) { return { didCatch: true, error }; } resetErrorBoundary(...args: any[]) { const { error } = this.state; if (error !== null) { this.props.onReset?.({ args, reason: "imperative-api", }); this.setState(initialState); } } componentDidCatch(error: Error, info: ErrorInfo) { this.props.onError?.(error, info); } componentDidUpdate( prevProps: ErrorBoundaryProps, prevState: ErrorBoundaryState ) { const { didCatch } = this.state; const { resetKeys } = this.props; // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array, // we'd end up resetting the error boundary immediately. // This would likely trigger a second error to be thrown. // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set. if ( didCatch &amp;&amp; prevState.error !== null &amp;&amp; hasArrayChanged(prevProps.resetKeys, resetKeys) ) { this.props.onReset?.({ next: resetKeys, prev: prevProps.resetKeys, reason: "keys", }); this.setState(initialState); } } render() { const { children, fallbackRender, FallbackComponent, fallback } = this.props; const { didCatch, error } = this.state; let childToRender = children; if (didCatch) { const props: FallbackProps = { error, resetErrorBoundary: this.resetErrorBoundary, }; if (typeof fallbackRender === "function") { childToRender = fallbackRender(props); } else if (FallbackComponent) { childToRender = createElement(FallbackComponent, props); } else if (fallback === null || isValidElement(fallback)) { childToRender = fallback; } else { if (isDevelopment) { console.error( "react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop" ); } throw error; } } return createElement( ErrorBoundaryContext.Provider, { value: { didCatch, error, resetErrorBoundary: this.resetErrorBoundary, }, }, childToRender ); }
} function hasArrayChanged(a: any[] = [], b: any[] = []) { return ( a.length !== b.length || a.some((item, index) =&gt; !Object.is(item, b[index])) );
}
보다 리액트의 안쪽까지 들어가서 createElement를 통해 컴포넌트를 생성하고, Context를 이용해서 내려주는 방식을 사용하고 있다.아무튼 다시 위의 보다 간소화된 코드로 돌아가서,,import { Fragment } from "react/jsx-runtime";
import withCatch from "./withCatch"; type Props = { children: React.ReactNode;
}; const ErrorBoundary = withCatch(function ErrorBoundary( props: Props, error?: Error,
) { if (error) { return ( &lt;div&gt; &lt;h1&gt;{error.message}&lt;/h1&gt; &lt;/div&gt; ); } else { return &lt;Fragment&gt;{props.children}&lt;/Fragment&gt;; }
}); export default ErrorBoundary; 고차컴포넌트를 활용한 방식이다. 아까 만들어진 withCatch을 사용한다.해당 에러 바운더리 컴포넌트는 현재 withCatch 고차 컴포넌트 안에 컴포넌트가 들어가 있는 방식이다. function App() { return ( &lt;ErrorBoundary&gt; &lt;div className="flex w-[930px] flex-col gap-9"&gt; &lt;Header /&gt; &lt;ComponentA /&gt; &lt;ComponentB /&gt; &lt;/div&gt; &lt;/ErrorBoundary&gt; );
}
이런 식으로 Error Boundary 안에 children으로 안쪽 요소를 채워넣게 되는 형태가 되는데, 이 함수들의 흐름을 따라가면서 보다 자세하게 이해해보자.ErrorBoundary 컴포넌트의 props로는 children 속성으로 안에 들어가 있는 요소들이 들어가게 된다. container와 비슷한 느낌이라고 볼 수 있다.type Props = { children: React.ReactNode;
}; const ErrorBoundary = withCatch(function ErrorBoundary( props: Props, error?: Error,
) { if (error) { return ( &lt;div&gt; &lt;h1&gt;{error.message}&lt;/h1&gt; &lt;/div&gt; ); } else { return &lt;Fragment&gt;{props.children}&lt;/Fragment&gt;; }
});
ErroBoundary에는 컴포넌트를 withCatch가 감싸고 있다.
witchCatch로 넘어가보자export default function withCatch&lt;Props extends {}&gt;( component: ErrorHandlingComponent&lt;Props&gt;, errorHandler?: ErrorHandler
): React.ComponentType&lt;Props&gt;
withCatch는 에러를 핸들링하는 컴포넌트와 errorHandler를 가지게 된다.
이 component의 타입을 보자type ErrorHandlingComponent&lt;Props&gt; = ( props: Props, error?: Error,
) =&gt; React.ReactNode;
필요한 props를 제네릭을 통해 넘겨받고, 여기에 error까지 서비스로 받는다(없을 수도 있음).
그 error를 처리하는 로직을 담은 ErrorBoundary가 여기에 들어가는 것이다.type ErrorState = { error?: Error };
...
function Inner({ error, props }: { error?: Error; props: Props }) { return &lt;Fragment&gt;{component(props, error)}&lt;/Fragment&gt;; } return class extends Component&lt;Props, ErrorState&gt; { state: ErrorState = { error: undefined, }; static getDerivedStateFromError(error: Error) { return { error }; } componentDidCatch(error: Error, info: React.ErrorInfo) { if (errorHandler) { errorHandler(error, info); } } render() { return &lt;Inner error={this.state.error} props={this.props} /&gt;; } };
이렇게 Errorboundary를 넣었을 경우에, withCatch는 다시금 컴포넌트를 내뱉는다. 하지만 이번엔 ErrorState까지 상태로 가진 컴포넌트이다.클래스형 컴포넌트에서는 리액트의 생명주기가 있는데, 이 생명주기에서 getDerivedStateFromError를 통해 에러를 잡는다. 얘는 하위 컴포넌트에서 오류가 발생하면 호출되면서 해당 오류를 인자로 받는다.
에러가 발생한 뒤에 fallback UI를 렌더링 시키기 위해서는getDerivedStateFromError 를 통해 에러를 잡아야 한다. 얘는 하위 자식 컴포넌트에서 오류가 발생했을 때 render단계에서 호출된다.
호출이 되면서 state라는 프로퍼티에는 error가 들어가게 되고, 그 다음 Inner 컴포넌트를 리턴한다. 이 컴포넌트에서 받았던 props 속성 + error를 서비스로 받게 되는 것이다.function Inner({ error, props }: { error?: Error; props: Props }) { return &lt;Fragment&gt;{component(props, error)}&lt;/Fragment&gt;; }
그렇게 되면 해당 함수형 컴포넌트는 error와 props를 받아 Fragment 사이에 해당 컴포넌트 자체를 실행시켜 렌더링된 요소를 안쪽에 넣게 된다.const ErrorBoundary = withCatch(function ErrorBoundary( props: Props, error?: Error,
) { if (error) { return ( &lt;div&gt; &lt;h1&gt;{error.message}&lt;/h1&gt; &lt;/div&gt; ); } else { return &lt;Fragment&gt;{props.children}&lt;/Fragment&gt;; }
});
그렇게 안쪽으로 들어간 애가 얘다. 보면 서비스로 받은 error를 달고 있다.
그래서 얘는 하위 컴포넌트에서 에러가 발생했을 경우 error를 서비스로 받고 돌아오니까 이 error에 대해 처리를 해주기 위해 fallback UI를 띄우게 된다.
하지만 error가 없을 경우 정상적으로 실행되었다는 소리니 ErrorBoundary로 감쌌던 children들을 그대로 넣어준다.<img src="https://i.imgur.com/dhpGn7A.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이렇게 해서 만약 처음에 오류가 생기면 이와같이 에러를 받아 ErrorBoundary로 넘겨주고 Errorboundary가 이를 인지하고 해당 오류를 띄워주는 것이다!리액트에서는 throw에 대해서도 일반적으로 다 오류 취급하지 않는다.
만약 throw한 것이 Promise 객체라면 리액트는 이에 대해서 Pending상태인 Promise구나! 하고 해당 작업에 대해서 비동기적으로 실행시켜놓는다.
Promise는 resolve될 때해당 Promise에 대해서 실행한 결과를 const response = getHeadlines();
export default function ShortNews() {
...
}
...
//fetch하는 함수
export default function getHeadlines() { return fetchData&lt;Article[]&gt;(fetcher.get(HEADLINE_URI));
} 중요한 점은 컴포넌트의 밖에다가 선언해야 한다는 점이다
밖에다가 선언해놓지 않을 경우 리액트는 아무것도 모르는 상태에서 컴포넌트를 렌더링하려고 할 것이고, 그 과정에서 함수형 컴포넌트를 실행시키는데 fetch하게 된다면 이 때마다 Promise를 받고 다시금 요청하려고 하는데, 리렌더링이 무한히 되는 루프에 빠져버리고 만다.]]></description><link>부스트캠프/멤버십/8주차/error-boundary와-suspense.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/Error boundary와 Suspense.md</guid><pubDate>Tue, 19 Nov 2024 11:50:11 GMT</pubDate><enclosure url="https://i.imgur.com/dhpGn7A.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/dhpGn7A.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Oauth2.0]]></title><description><![CDATA[OAuth는 Open Authorization의 줄임말로, 액세스 위임을 위한 개방형 표준 인가 프로토콜이다.
해당 인증 바에식은 서비스 제공 업체(네이버, 깃허브 등)의 정보를 비밀번호 없이 정보에 대한 액세스 권한을 부여할 수 있는 안전한 방식으로, 현재 많이 사용하는 로그인 방식이다.<img src="https://i.imgur.com/YLNYO9t.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
위의 사진처럼 요즘 흔하게 볼 수 있는 로그인 방식이다.
어떠한 애플리케이션을 이용하고자 할 때, 구글, 카카오와 같은 제 3의 서비스에서 사용자가 가지고 있는 계정의 정보를 사용자가 허용하는 범위에 한해서 가져올 수 있다.Authentication(인증)과 Authorization(인가)의 개념에 대해서 잘 모르고 있는 경우가 많다. 크게 보면 둘 다 같은 단어 같지만, 두 개념을 세부적으로 알게 되면 큰 차이가 있기 때문에 이 점부터 짚고 넘어가야 할 필요성이 있다.Authentication(인증) : 해당 사용자가 자신이 주장하는 그 사람인지 확인을 하는 것
Authorization(인가) : 해당 사용자가 리소스에 접근할 수 있는 권한을 부여하는 것예를 들어 편의점에 술을 사러 간다고 생각해보자.
편의점에는 술을 사기 위해서는 성인이 되어야 한다. 그렇기에 편의점 알바는 손님에게 '민증 검사'를 요구한다. 민증을 통해 해당 손님이 자신이 주장하는 '성인'이 맞는지 민증을 통해 '인증'하고 알바생은 이를 확인한다. 이 과정이 인증이다.
민증을 통해 성인임이 확인 되면, 해당 손님에게는 술을 살 수 있는 권한 이 주어진다. 이것이 인가이다.따라서 다시금 OAuth의 풀 네임을 직역해보았을 때, 개방된 인가라고 생각할 수 있다. 특정 제 3의 서비스들은 인증이 완료되면, 해당 서비스에게 유저에 대한 정보를 넘겨주는 OAuth의 의미를 생각해볼 수 있다.OAuth에서의 주체는 크게 세가지, 작게 나누면 네 가지 정도로 나뉜다.
Resource Owner(or User) 리소스를 소유한 사용자로, 애플리케이션의 리소스 공유 요청을 허가
서비스를 이용하려는 사용자 Client(or Consumer) 사용자의 허가를 받아 사용자의 리소스에 접근할 수 있도록 요청하는 응용 애플리케이션
제공하려는 서비스 Server(or Provider) 사용자의 허가를 검증하고, 클라이언트에 응용 애플리케이션에 보유한 사용자의 리소스를 공유하는 서버
일반적으로 허가를 담당하는 검증 서버(Authorization Server)와 실제 사용자 리소스를 보유한 리소스 서버(Resource Server, or API Server)로 분리되어 있음
제3의 서비스(네이버, 카카오, 구글 등) +--------+ +---------------+ | |--(A)- Authorization Request -&gt;| Resource | | | | Owner | | |&lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --&gt;| Authorization | | Client | | Server | | |&lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------&gt;| Resource | | | | Server | | |&lt;-(F)--- Protected Resource ---| | +--------+ +---------------+
프로토콜 자체의 플로우는 이와 같이 구성된다.
클라이언트는 인증 요청을 보내고, 유저가 인증을 완료하면 클라이언트측에 인증이 제대로 완료되었음을 알린다.
인증이 제대로 완료되면 클라이언트는 인증 서버에 인증이 확인되었음을 알리고, 엑세스 토큰을 얻는다.
엑세스 토큰을 얻게 되면 클라이언트는 리소스, 즉 유저의 정보를 가지고 있는 서버에 엑세스 토큰을 보내 유저가 명시한 제한된 리소스를 가져올 수 있다.<br><img src="https://i.imgur.com/oCemxxw.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 리소스 소유자(이하 유저)가 클라이언트 서비스를 이용하고자 이용 요청을 보냄
클라이언트는 검증(Authorization) 서버에 액세스 토큰을 요청
검증 서버는 유저에게 인가(Authentication) 동의를 요청 여기에서 유저는 어느 정도의 범위를 해당 서비스(client)에게 제공할 지 직접 선택할 수 있다. 유저는 인가(Authentication) 동의를 응답
검증 서버는 리소스에 접근할 수 있는 액세스 토큰을 생성해 클라이언트로 전송
클라이언트는 액세스 토큰을 저장
클라이언트는 액세스 토큰을 가지고 리소스 서버에 요청
리소스 서버는 액세스 토큰의 유효성을 파악하고 나서, 요청한 리소스를 클라이언트에 응답
클라이언트는 유저에 서비스 이용을 응답
과 같이 이루어지는 것이다.<br><img src="https://i.imgur.com/03sHT3u.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
엑세스토큰의 경우 네 가지 방식을 통해 이루어진다.
현재 Implicit 방식과 Password Grant(Resource Owner Credentials) 방식의 경우 Deprecated 상태이며, 가장 많이 쓰이는 방식은 Authorization Code 방식이다. 비밀번호를 직접 넘겨주지 않으면서도 엑세스 토큰을 바로 클라이언트로 보내는 방식이 아닌 Code를 받아 다시 인증 서버로 보낸 후에 엑세스 토큰을 받아오는 방식이 한 단계를 더 거치면서 보안상으로 더욱 이점을 가지기 때문이다.<br><img src="https://i.imgur.com/S2eSA4H.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/0NICjKN.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
인증 서버로부터 받아오는 엑세스 토큰은 위와 같은 정보들을 담고 있다.그렇다면 현재 많이 사용되고 있는 Authorization Code방식에 대해 자세히 알아보자. +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ----&gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---&gt;| Server | | | | | | -+----(C)-- Authorization Code ---&lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |&gt;---(D)-- Authorization Code ---------' | | Client | &amp; Redirection URI | | | | | |&lt;---(E)----- Access Token -------------------' +---------+ (w/ Optional Refresh Token) Note: The lines illustrating steps (A), (B), and (C) are broken into two parts as they pass through the user-agent. Figure 3: Authorization Code Flow
Authorization Code의 방식은 클라이언트가 인증 서버에 자신의 서비스를 등록한 뒤, 해당 서비스의 코드와 redirect URI를 보내면서 시작된다.
여기서 redirect URI는 인증 서버에서 자체적인 로그인 페이지를 띄우기 때문에 유저가 로그인이 된 후 인증이 완료되었을 때 다시 redirect URI로 보내게 된다.
여기서 인증이 완료되었을 경우 redirect URI에서는 code를 URI에 붙여서 보내주는데, 이 code를 클라이언트가 인증 서버에 다시금 보내면서 엑세스 토큰을 받을 수 있다. 여기서 계속 엑세스 토큰을 클라이언트에서 들고 있는 것보다 리프레시 토큰을 통해 엑세스 토큰에는 만료 시간을 두고 만료되면 리프레시 토큰을 통해 엑세스토큰을 재발급 받는 방식이 보다 안전하기 떄문에 인증 서버에서도 이러한 방식을 사용한다. 따라서 리프레시 토큰 또한 함께 받을 수 있다.+--------+ +---------------+ | |--(A)------- Authorization Grant ---------&gt;| | | | | | | |&lt;-(B)----------- Access Token -------------| | | | &amp; Refresh Token | | | | | | | | +----------+ | | | |--(C)---- Access Token ----&gt;| | | | | | | | | | | |&lt;-(D)- Protected Resource --| Resource | | Authorization | | Client | | Server | | Server | | |--(E)---- Access Token ----&gt;| | | | | | | | | | | |&lt;-(F)- Invalid Token Error -| | | | | | +----------+ | | | | | | | |--(G)----------- Refresh Token -----------&gt;| | | | | | | |&lt;-(H)----------- Access Token -------------| | +--------+ &amp; Optional Refresh Token +---------------+ Figure 2: Refreshing an Expired Access Token
엑세스 토큰이 발급되면, 클라이언트는 이 엑세스토큰을 가지고 사용자의 정보를 담고 있는 리소스 서버에 엑세스 토큰과 함께 정보를 요청하는 API를 보낸다. 리소스 서버는 이에 응답하여 처음 유저가 인증할 때 서비스에 체크한 정보 제공의 범위까지의 정보를 담아 클라이언트에 보내준다.이렇게 엑세스 토큰을 보내다가 중간에 엑세스 토큰이 만료되면, 리프레시 토큰을 보내 새로운 엑세스 토큰을 발급받아 기존의 엑세스 토큰을 교환하는 방식으로 진행된다.PKCE(Proof Key for Code Exchange)는 Authorization Code Flow를 사용할 때 코드 교환 과정의 보안을 강화하기 위해 OAuth 2.1에서 필수적으로 사용하도록 지정되어 있는 기술이다. 기존 Authorization Code Flow보다 더 높은 보안성을 요구한다.PKCE는 다음과 같은 필드들을 추가적으로 가진다.
code_verifier: 앱으로부터 생성되는 임의의 랜덤 문자열이다.
code_challenge:&nbsp;code_verifier와 짝을 이루는 문자열 code_verifier를 그대로 사용하는 경우도 있지만 S256 해싱 알고리즘으로 암호화하는 것이 권장된다. OAuth 서버는 이 문자열을 복호화하여,&nbsp;code_verifier와 같은지 확인함으로써 클라이언트를 검증한다. code_challenge_method:&nbsp;code_verifier의 변환에 어떤 함수가 사용되는지(S256 또는 plain) 지정하는 필드이다. 기본값은 plain으로, 이 경우&nbsp;code_verifier와&nbsp;code_challenge는 같은 것으로 간주된다.
이 필드들을 통해 OAuth 서버는 인증 요청과 토큰 요청이 동일한 클라이언트로부터 온 것인지 확인할 수 있다.<br><img src="https://i.imgur.com/AchwHfm.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
PCKE의 동작 방식은 위 사진과 같이 유저가 로그인 링크를 클릭하면 앱 자체에서 인증 코드 요청을 보내기 전에 code_verifier와 code_challenge를 생성하는 과정이 기존의 code 방식에서 추가되었다.인증 코드 요청을 할 때 이 code_challenge와 함께 요청이 날아간다. 사용자가 로그인을 하고 사용자가 원하는 정보의 공개 제한 범위를 선택하고 로그인을 하게 되면 code를 담아 리다이렉트된다.이후에 code를 가지고 다시금 앱이 토큰을 얻기 위해 요청을 보내는 과정에서 아까 인증 서버로 보냈던 code_challenge와 비교할 대상 문자열인 code_verifier를 함께 보낸다. 비교 문자열이 서로 검증해서 맞아 떨어지게 되면 엑세스 토큰과 선택적으로 리프레시 토큰을 다시금 보내준다. 이후에는 유저가 받은 엑세스 토큰을 가지고 요청 및 응답을 하는 방식이다.OAuth가 다양한 소셜 로그인의 수단으로 사용된 이유는 사용자의 모든 계정 정보를 알지 않아도 회원의 정보에 접근할 수 있다는 사실이 보안에 도움이 되기 때문이다.추가적으로 로그인을 하는 과정에서 서비스에 제공할 수 있는 개인정보의 범위를 사용자가 직접 제한할 수 있기 때문에, 애플리케이션의 입장에서는 허용된 범위의 리소스에만 접근할 수 있다는 사실 또한 보안에 강하면서도 인증과 권한 부여를 동시에 할 수 있다는 장점 또한 가진다. 괜스레 모든 정보를 다른 애플리케이션에서도 가지고 있다가 악용될 가능성을 높이는 것보단 필요한 정보만 가져다 쓰는 것이 모두에게 이득이 될 수 있기 때문에 현재 사실상의 업계 표준으로 자리잡고 있다.]]></description><link>부스트캠프/멤버십/8주차/oauth2.0.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/Oauth2.0.md</guid><pubDate>Sat, 16 Nov 2024 16:15:51 GMT</pubDate><enclosure url="https://i.imgur.com/YLNYO9t.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/YLNYO9t.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그룹 프로젝트_3주차_회고]]></title><description><![CDATA[
마인드맵 생성( 초기 화면 ) 마인드맵이 겹치지 않도록 대분류, 중분류, 소분류관의 관계를 파악해 적절하게 위치를 계산합니다.
계산된 위치를 기반으로 화면에 그려줍니다.
화면에 그린 후 충돌방지 함수가 작동돼 영역 간의 사이를 벌려줍니다. 마인드맵 요소 이동 요소들이 이동할 때 주변에 있는 요소들과 겹치지 않게 충돌 방지 함수가 작동되며 옆으로 밀려납니다. 마인드맵 요소 추가 요소를 클릭하여 선택하고, 요소 추가 아이콘을 눌러 하위 요소를 추가할 수 있습니다. 마인드맵 요소 Text 수정 요소를 더블 클릭하면 텍스트가 input으로 변경되고, 엔터를 누르거나 요소 외부 영역을 눌러 변경 사항을 저장할 수 있습니다. 마인드맵 요소 삭제 요소를 클릭하면 해당 요소가 선택되고, 쓰레기통 아이콘을 눌러 삭제할 수 있습니다. 저번 주에는 문제 해결을 하는 방식에 대해서 고민을 많이 했었다. 문제를 해결하기 위해 어떤 개념을 계속해서 dfs 방식으로 찾아보고, 이 과정을 기록하기 때문에 생각보다 많은 시간이 걸려 이 시간 자체가 일정에 영향을 주는 것 아닐까? 라는 생각이 들었던 것 같다. 하지만 멘토님께서 말씀하시길 이 시간 자체가 어찌보면 프로젝트에서 고려해야 하는 시간 중 하나라고 말씀해주셨고, 나는 이를 토대로 내가 구현했던 기술 중에서 고민을 했었던 기술이나 에러에 대해서 이번 주에는 조금 더 공을 들여 쓰기 시작했다.기술에 대해서 쓸 때는 하나씩 기능을 완성했지만, 나름대로의 기준이나 인수 조건에 부합하지 않는 경우가 많이 나왔었고 이를 문서화 과정에 기록한 후에 이를 보완하기 위한 방법을 고민하여 작성하였다.트러블 슈팅의 경우에는 내가 어떤 문제를 겪고 있는지, 이 에러가 정확히 무엇 때문에 나오는 지에 대해서 문서에 꼭 포함하려고 했다. 문제의 원인을 자세하게 알려고 하다보니 자연스럽게 원인에 따라오는 해결방법이 있어 이를 적용하면서 문제들을 해결했고, 오히려 코드만을 보면서 하나하나 고쳐보는 것보다 훨씬 속도가 빨라졌음을 체감할 수 있었다.문서화를 전보다 철저히 하면서 느꼈던 추가적인 장점은 확실히 내가 무슨 문제에 집중하고 있는지 명확하게 인지하고 이를 통한 관련 개념들에 대해서 내가 약했던 부분을 보완할 수 있었다는 점이었다. 이를 통해 성장한다는 보람과 함께 쉽게만 생각했던 부분에 대해서 생겨난 학습적 구멍을 메울 수 있었다고 생각한다.이를 특히 느꼈던 순간은 zustand와 context api의 사용 과정이었다. 기존 context api를 활용했을 때 마인드맵에서 노드가 많아질 수록 성능이 좋지 않아짐을 느꼈다. 이를 해결하기 위해 zustand와 렌더링을 최적화 시켜주는 selector 패턴을 사용하여 리팩토링을 진행했었다. 하지만 결과는 context api가 더 좋은 성능을 보였고, zustand의 경우 프레임 드랍까지 이어졌다.기존에는 무조건 context api보다 zustand가 렌더링 성능 별로 좋다고 생각했지만, 실제로 해보니 예상과는 다른 점도 분석해 보면서 이를 기록하고 기존에는 몰랐던 새로운 지식 또한 알 수 있었다.동료와 공유하거나 의견을 묻고 싶은 부분을 정리해보세요.피어세션에서 나눈 이야기 중 나의 문제 해결 경험과 관련한 피드백과 새롭게 깨달은 점이 있다면 기록으로 남겨주세요.<a data-tooltip-position="top" aria-label="http://boomap.site" rel="noopener nofollow" class="external-link is-unresolved" href="http://boomap.site" target="_self">boomap</a>뭔가…뭔가 스타일이 좀 트렌디하지 않은 느낌인데 제 눈이 구려서 뭐가 문제인지 모르겠어요…..
마인드맵의 현재 Depth는 일정 depth로 제한하려고 하는데 이 점이 문제가 될까 고민중입니다. 성능 최적화의 도입 시점 성능 최적화는 가장 마지막에 리팩토링 기간에 하는 게 맞는 것 같다
현재는 문제가 없게끔 기능 작동을 시키는 것이 우선
성능 최적화를 하려고 하면 모든 팀원들이 최적화를 위해 블락된 상태가 되기 때문에 일정에 좋지 않은 영향을 끼친다.
기술적으로 성능을 최적화할 수 있겠지만, 기획적으로도 최고의 성능을 낼 수 있을 정도로 제한해도 문제될 것은 없어 보인다
기술적으로 성능을 최적화하는 것이 무조건 완료하지는 않아도 이를 고민해보았다는 것도 기록해놓으면 좋을 것 같다 테스트 코드 작성 개인적으로 멘토님은 프론트엔드에서의 테스트 코드는 어느정도 성향 차이가 있다고 생각하심
테스트 코드를 작성해야만 하는 이유가 명확한 부분만 테스트를 해봐도 좋을 듯하다
무의미한 테스트 코드는 딱히 필요가 없을 것 같다. ]]></description><link>부스트캠프/멤버십/3주차/그룹-프로젝트_3주차_회고.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/그룹 프로젝트_3주차_회고.md</guid><pubDate>Fri, 15 Nov 2024 05:00:04 GMT</pubDate></item><item><title><![CDATA[그룹 프로젝트_3주차]]></title><description><![CDATA[<a data-href="그룹 프로젝트_3주차_마스터클래스" href="부스트캠프/멤버십/3주차/그룹-프로젝트_3주차_마스터클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹 프로젝트_3주차_마스터클래스</a><br>
<a data-href="pr-요소 추가" href="부스트캠프/멤버십/8주차/pr-요소-추가.html#_0" class="internal-link" target="_self" rel="noopener nofollow">pr-요소 추가</a><br>
<a data-href="원래것들" href="부스트캠프/멤버십/8주차/원래것들.html#_0" class="internal-link" target="_self" rel="noopener nofollow">원래것들</a><br>
<a data-href="그룹 프로젝트_3주차_회고" href="부스트캠프/멤버십/3주차/그룹-프로젝트_3주차_회고.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹 프로젝트_3주차_회고</a>]]></description><link>부스트캠프/멤버십/3주차/그룹-프로젝트_3주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/그룹 프로젝트_3주차.md</guid><pubDate>Fri, 15 Nov 2024 04:59:00 GMT</pubDate></item><item><title><![CDATA[원래것들]]></title><description><![CDATA[import { Node, NodeData } from "@/types/Node";
import { ConnectedLine } from "@/konva_mindmap/ConnectedLine";
import { Circle, Group, Text } from "react-konva";
import { useNodeListContext } from "@/store/NodeListProvider"; type NodeProps = { parentNode?: Node; node: Node; depth: number; text: string;
}; function NodeComponent({ parentNode, node, depth, text }: NodeProps) { const { updateNode, selectNode, selectedNode } = useNodeListContext(); return ( &lt;&gt; &lt;Group name="node" id={node.id.toString()} onDragMove={(e) =&gt; { updateNode(node.id, { ...node, location: { x: e.target.x(), y: e.target.y(), }, }); }} onDragEnd={(e) =&gt; updateNode(node.id, { ...node, location: { x: e.target.x(), y: e.target.y(), }, }) } draggable x={node.location.x} y={node.location.y} onClick={() =&gt; selectNode({ nodeId: node.id, parentNodeId: parentNode ? parentNode.id : null })} &gt; &lt;Circle fill={selectedNode?.nodeId === node.id ? "orange" : "white"} width={100} height={100} radius={70 - depth * 10} stroke="black" strokeWidth={3} /&gt; &lt;Text name="text" text={text} /&gt; &lt;/Group&gt; {parentNode &amp;&amp; ( &lt;ConnectedLine from={parentNode.location} to={node.location} fromRadius={70 - (depth - 1) * 10 + 10} toRadius={70 - depth * 10 + 10} /&gt; )} &lt;/&gt; );
} type DrawNodeProps = { data: NodeData; root: Node; depth?: number; parentNode?: any; update?: (id: number, node: Node) =&gt; void;
}; export function DrawNodefromData({ data, root, depth = 0, parentNode }: DrawNodeProps) { return ( &lt;&gt; {/* from */} &lt;NodeComponent text={root.keyword} depth={depth} parentNode={parentNode} node={root} /&gt; {/* to */} {root.children?.map((childNode, index) =&gt; ( &lt;DrawNodefromData data={data} key={index} root={data[childNode]} depth={depth + 1} parentNode={root} /&gt; ))} &lt;/&gt; );
} import { NodeData } from "@/types/Node";
import { useState, useCallback } from "react"; export default function useHistoryState&lt;T&gt;(initialState: T) { const [history, setHistory] = useState([initialState]); const [pointer, setPointer] = useState(0); const saveHistory = useCallback( (data: T) =&gt; { const newHistory = [...history.slice(0, pointer + 1), data]; setPointer(newHistory.length - 1); setHistory(newHistory); }, [pointer, history], ); const undo = useCallback( (setData) =&gt; { if (pointer &lt;= 0) return; setPointer((p) =&gt; p - 1); setData(history[pointer - 1]); }, [history, pointer], ); const redo = useCallback( (setData) =&gt; { if (pointer &gt;= history.length - 1) return; setPointer((p) =&gt; p + 1); setData(history[pointer + 1]); }, [history, pointer], ); return { saveHistory, undo, redo };
} import { Button } from "@headlessui/react";
import { useEffect, useRef, useState } from "react";
import { Layer, Stage } from "react-konva";
import plusIcon from "@/assets/plus.png";
import minusIcon from "@/assets/minus.png";
import addElementIcon from "@/assets/addElement.png";
import deleteIcon from "@/assets/trash.png";
import { useNodeListContext } from "@/store/NodeListProvider";
import { DrawNodefromData } from "@/konva_mindmap/node";
import useWindowKeyEventListener from "@/hooks/useWindowKeyEventListener";
import { Node, NodeData } from "@/types/Node";
import { ratioSizing } from "@/konva_mindmap/events/ratioSizing";
import { addNode } from "@/konva_mindmap/events/addNode";
import Konva from "konva";
import { checkCollision } from "@/konva_mindmap/utils/collision"; export default function MindMapView() { const { data, undoData: undo, redoData: redo, updateNode, selectedNode, overrideNodeData } = useNodeListContext(); const divRef = useRef&lt;HTMLDivElement&gt;(null); const layer = useRef&lt;Konva.Layer&gt;(); useEffect(() =&gt; { checkCollision(layer, updateNode); }, [data]); // const layer = useLayerEvent([["dragmove", () =&gt; checkCollision(layer, updateNode)]]); const [dimensions, setDimensions] = useState({ scale: 1, width: 500, height: 500, x: 0, y: 0, }); const keyMap = { z: undo, y: redo, }; // const handleNodeDeleteRequest = () =&gt; { // if (selectedNode) { // setSelectedNode(null); // const newData = deleteNode({ ...data }, selectedNode); // updateNodeData(newData); // } // }; useWindowKeyEventListener("keydown", (e) =&gt; { if (e.ctrlKey &amp;&amp; keyMap[e.key]) { keyMap[e.key](); } }); const deleteNode = (nodeData: NodeData, nodeId: number) =&gt; { if (!nodeData[nodeId]) return; const { children } = nodeData[nodeId]; children.forEach((childId) =&gt; { deleteNode(nodeData, childId); }); Object.values(nodeData).forEach((node: Node) =&gt; { node.children = node.children.filter((childId) =&gt; childId !== nodeId); }); delete nodeData[nodeId]; return nodeData; }; function resizing() { if (divRef.current) { setDimensions((prevDimensions) =&gt; ({ ...prevDimensions, width: divRef.current.offsetWidth, height: divRef.current.offsetHeight, })); } } useEffect(() =&gt; { resizing(); const resizeObserver = new ResizeObserver(() =&gt; { resizing(); }); if (divRef.current) { resizeObserver.observe(divRef.current); } return () =&gt; resizeObserver.disconnect(); }, [divRef]); return ( &lt;div ref={divRef} className="relative h-full min-h-0 w-full min-w-0 rounded-xl bg-white"&gt; &lt;Stage className="cursor-pointer" width={dimensions.width} height={dimensions.height} scaleX={dimensions.scale} scaleY={dimensions.scale} x={dimensions.x} y={dimensions.y} draggable onWheel={(e) =&gt; ratioSizing(e, dimensions, setDimensions)} &gt; &lt;Layer ref={layer}&gt;{DrawNodefromData({ data: data, root: data[1], depth: data[1].depth })}&lt;/Layer&gt; &lt;/Stage&gt; &lt;div className="absolute bottom-2 left-1/2 flex -translate-x-2/4 -translate-y-2/4 items-center gap-3 rounded-full border px-10 py-2 shadow-md"&gt; &lt;div className="flex items-center gap-3 border-r-2 px-5"&gt; &lt;Button className="h-5 w-5"&gt; &lt;img src={plusIcon} alt="확대하기" /&gt; &lt;/Button&gt; &lt;span className="text-sm font-bold text-black"&gt;{Math.floor(dimensions.scale * 100)}%&lt;/span&gt; &lt;Button className="h-5 w-5"&gt; &lt;img src={minusIcon} alt="축소하기" /&gt; &lt;/Button&gt; &lt;/div&gt; &lt;Button className="w-8 border-r-2 pr-2"&gt; &lt;img src={addElementIcon} alt="요소 추가" onClick={() =&gt; addNode(data, selectedNode, overrideNodeData)} /&gt; &lt;/Button&gt; &lt;Button className="h-5 w-5"&gt; &lt;img src={deleteIcon} alt="요소 삭제" /&gt; &lt;/Button&gt; &lt;/div&gt; &lt;Button className="absolute right-0 top-[-50px] rounded-lg bg-grayscale-600 px-4 py-2 text-sm font-bold"&gt; 캔버스 비우기 &lt;/Button&gt; &lt;/div&gt; );
} import useHistoryState from "@/hooks/useHistoryState";
import { Node, NodeData } from "@/types/Node";
import { createContext, ReactNode, useContext, useEffect, useState } from "react"; export type NodeListContextType = { data: NodeData | null; selectedNode: { nodeId: number; parentNodeId: number } | null; updateNode: (id: number, node: Node) =&gt; void; overrideNodeData: (node: NodeData | ((newData: NodeData) =&gt; void)) =&gt; void; saveHistory: (newState: NodeData) =&gt; void; undoData: () =&gt; void; redoData: () =&gt; void; selectNode: ({ nodeId, parentNodeId }) =&gt; void;
}; const nodeData: NodeData = { 1: { id: 1, keyword: "점심메뉴", depth: 1, location: { x: 50, y: 50 }, children: [2, 3], }, 2: { id: 2, keyword: "양식", depth: 2, location: { x: 100, y: 100 }, children: [4, 5], }, 3: { id: 3, keyword: "한식", depth: 2, location: { x: 70, y: 70 }, children: [6, 7], }, 4: { id: 4, keyword: "면", depth: 3, location: { x: 80, y: 80 }, children: [], }, 5: { id: 5, keyword: "밥", depth: 3, location: { x: 90, y: 90 }, children: [], }, 6: { id: 6, keyword: "고기", depth: 3, location: { x: 30, y: 30 }, children: [], }, 7: { id: 7, keyword: "찌개", depth: 3, location: { x: 40, y: 40 }, children: [], },
}; const NodeListContext = createContext&lt;NodeListContextType | undefined&gt;(undefined);
export function useNodeListContext() { const context = useContext(NodeListContext); if (!context) { throw new Error("useNodeListContext must be used within a NodeListProvider"); } return context;
} export default function NodeListProvider({ children }: { children: ReactNode }) { const [data, setData] = useState(nodeData); const [selectedNode, setSelectedNode] = useState(null); const { saveHistory, undo, redo } = useHistoryState&lt;NodeData&gt;(nodeData); function updateNode(id: number, updatedNode: Node) { setData((prevData) =&gt; ({ ...prevData, [id]: { ...prevData[id], ...updatedNode }, })); } function overrideNodeData(newData) { setData(newData); } function undoData() { undo(setData); } function redoData() { redo(setData); } function selectNode({ nodeId, parentNodeId }: { nodeId: string; parentNodeId: string }) { setSelectedNode({ nodeId, parentNodeId, }); } return ( &lt;NodeListContext.Provider value={{ data, updateNode, overrideNodeData, undoData, redoData, saveHistory, selectNode, selectedNode }} &gt; {children} &lt;/NodeListContext.Provider&gt; );
} ]]></description><link>부스트캠프/멤버십/8주차/원래것들.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/원래것들.md</guid><pubDate>Wed, 13 Nov 2024 06:19:28 GMT</pubDate></item><item><title><![CDATA[pr-요소 추가]]></title><description><![CDATA[요소들의 추가와 관련된 로직의 설명은 <a data-tooltip-position="top" aria-label="https://luxurious-share-af6.notion.site/13c7725fa9ac808e91fecf1bd50e47c5?pvs=4" rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/13c7725fa9ac808e91fecf1bd50e47c5?pvs=4" target="_self">노션</a>에 있습니다
캔버스 요소들 겹치지 않게 추가 수직벡터 계산 로직 함수화
기존의 데이터를 가지고 계산 Context api로 캔버스 데이터를 받아 업데이트하도록 리팩토링
useEffect의 의존성 배열에 데이터를 넣어 충돌 방지가 데이터의 좌표값이 어느 상황에서든 바뀔 때마다 실행될 수 있도록 변경
클릭한 요소 관리 id값을 주고 노드들과 비교하면서 상태 관리 ]]></description><link>부스트캠프/멤버십/8주차/pr-요소-추가.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/pr-요소 추가.md</guid><pubDate>Wed, 13 Nov 2024 06:18:24 GMT</pubDate></item><item><title><![CDATA[그룹 프로젝트_3주차_마스터클래스]]></title><description><![CDATA[클라이언트과 서버의 request, response가 있을 떄, 이를 그냥 요청하고 받으면 누가 요청했는지 알 필요가 없게끔 stateless하게 웹이 구성되어 있음
'인증받은 것을 표현하자' stateless한 것을 stateful하게 관리
세션값을 유니크하게 만들기
로그인 후 브라우저의 쿠키 -&gt; 개발자 도구로 조회 가능
서버는 클라이언트의 상태를 알고 있음토큰 기반 인증
인증 정보를 서버에서 가지고 있지 않기 때문에 편리함
매번 다른 서버로 갈 때가 있는데 모든 인증을 서버에서 유지하기가 어려움
따라서 이를 인지할 수 있는 토큰을 통해 사용자의 validation을 처리
해시값을 이용해 무결성 체크
API에 대한 권한
토큰은 쿠키값에 저장?
쿠키의 접근을 스크립트로 하지 못하게 http-only설정
엑세스토큰을 플로우로 확인하고 리프레시 토큰을 써서 갱신
어플리케이션 로직까지 갈 필요가 없으니 정적인 것들을 개선할 필요가 없음. 바로 라우팅 처리
인증은 네트워크 보안의 의미
리프레시 토큰 - 시간 관리상 하기 부족하니까 낮은 우선순위로 두기양방향 통신은 실시간성이 요구되는 다양한 애플리케이션에서 필수적.
대표적인 양방향 통신 방법은 아래와 같음.클라이언트가 일정한 간격으로 서버에 HTTP 요청을 보내 데이터를 가져오는 방식
단방향 통신이지만, 주기적으로 데이터를 요청함으로써 간접적인 양방향 통신 구현 가능
setInterval을 통해 http 요청 보내기
구현이 간단하며 대부분의 브라우저에서 지원
기존 HTTP 인프라를 그대로 사용가능 불필요한 요청이 빈번하게 발생하여 서버 부하 증가
실시간성 부족, 데이터 업데이트 지연 발생 실시간성이 크게 요구되지 않는 간헐적인 데이터 업데이트
간단한 상태 모니터링 대시보드
뉴스 피드나 공지사항 업데이트 등
클라이언트가 서버에 요청을 보내면 서버는 새로운 데이터가 생길 때까지 응답을 지연시키는 방식
데이터가 준비되면 서버가 응답을 보내고, 클라이언트는 즉시 새로운 요청을 보내는 방식
데이터의 양, 종류, 리소스를 보고 결정함
실시간성 향상, 클라이언트가 새로운 데이터를 즉시 받을 수 있음
불필요한 요청 감소, 서버 부하 상대적으로 적음 여전히 HTTP 요청의 한계 존재
구현 복잡성 증가, 서버 리소스 소비 채팅 애플리케이션
실시간 알림 시스템
실시간 업데이트가 필요한 협업 도구 등
Server-Sent Events는 서버에서 클라이언트로 일방향으로 지속적인 데이터 스트림을 전송하는 방식임. 클라이언트는 서버로부터 지속적으로 데이터를 수신할 수 있지만, 클라이언트에서 서버로 데이터를 보내는 것은 불가능함.
구현이 비교적 간단하고 효율적임
자동 재연결 기능 제공
텍스트 기반 데이터 전송에 최적화됨 단방향 통신만 가능함
과거 브라우저에서 지원되지 않을 수 있음 실시간 뉴스 피드
실시간 주식 시세 업데이트
실시간 스포츠 경기 점수 업데이트 클라이언트에서 서버로 연결 요청 클라이언트는&nbsp;EventSource&nbsp;객체를 생성해&nbsp;/sse&nbsp;경로로&nbsp;GET&nbsp;요청을 보냄.
이 요청을 통해 데이터를 지속적으로 수신할 준비를 함. 서버에서 연결을 유지하고 스트리밍 응답 시작 서버는 클라이언트의 요청에 대해&nbsp;Content-Type: text/event-stream&nbsp;헤더를 설정하고 응답을 유지함.
이 상태에서 서버는 데이터를 계속해서 클라이언트로 푸시할 수 있음. 서버가 주기적으로 데이터를 전송 서버는 특정 이벤트나 일정 시간 간격에 따라 데이터를&nbsp;res.write()&nbsp;메서드를 사용해 클라이언트로 전송함.
각 메시지는&nbsp;data:로 시작하고 두 개의 개행 문자(\n\n)로 끝내야 하며, 이를 통해 클라이언트는 메시지의 끝을 구분할 수 있음. 클라이언트에서 실시간으로 데이터 수신 클라이언트는&nbsp;onmessage&nbsp;이벤트 핸들러를 통해 서버에서 전송된 데이터를 실시간으로 수신하고 처리할 수 있음. 실시간 통신의 필요성이 커지면서 2011년에 WebSocket이 표준화.
WebSocket은 이 TCP프로토콜을 기반으로 작동하며, 데이터가 순서대로 전송되도록 하고 오류가 발생할 경우 자동으로 복구. HTTP 핸드셰이크로 연결을 시작한 후 TCP 소켓을 통해 양방향 데이터 전송을 지속함.
http 요청을 보낸 후 업그레이드 하는 방식 실시간 데이터 교환이 중요한 애플리케이션에 적합. 낮은 지연 시간, 실시간 데이터 교환에 최적화됨
효율적인 데이터 전송, 헤더 오버헤드 감소
클라이언트와 서버가 동시에 데이터를 주고받을 수 있음 지속적인 연결로 인한 서버 자원 소모
구현 복잡성 증가
일부 방화벽이나 프록시에서 차단될 수 있음 실시간 채팅 애플리케이션
실시간 게임
실시간 협업 도구 (예: 공동 문서 편집)
실시간 데이터 스트리밍 (예: 라이브 스포츠 중계) JAX Polling 간헐적인 데이터 업데이트가 필요한 경우 Long Polling 실시간 채팅이나 알림 등, 중간 정도의 실시간성이 필요한 경우 SSE 서버에서 클라이언트로 지속적인 데이터 스트림이 필요한 경우 WebSocket 높은 실시간성과 양방향 통신이 필요한 경우 무상태 -&gt; 이를 보완하기 위해 세션이나 쿠키 사용
websocket-key : 브라우저의 고유한 ID값을 만들어 보내고, 서버는 이로 식별한다
Oauth는 사용자 자격 증명을 공유하지 않는다?
-&gt; ID와 패스워드를 공유하지 않는다.
ID와 패스워드를 공유하게 된다면 악용 가능
제한된 방식의 접근만 허용하기
oauth를 쓰게 된다면 사용자가 소유한 리소스 중에서 접근을 명시적으로 허가한 부분만 접근 가능 client -&gt; 브라우저가 아닌 oauth를 사용하려는 우리의 서버 authorization Server -&gt; github의 인증서버, 리소스 소유자에게 인증을 받고 토큰 발급 Resouce Server -&gt; github api의 서버, 엑세스 토큰으로 접근 허용 인증(authentication) 내가 누구다 라고 증명하는 것
실제 누구가 맞는지 확인하는 과정 권한 부여(authorization) 요청한 리소스에 대해서 권한이 있나 없나 확인하고 적절한 권한이 있으면 리소스를 제공 아이디 패스워드 아이디 패스워드를 가지게 되면 모든 리소스에 접근이 가능해서 문제가 될 수 있음 토큰 인증
AccessToken과 Refresh Token을 함께 사용한 인증
JWT를 사용한 인증
LDAP / AD 인증과 권한 부여를 동시에 가능
일반 사용자의 정보 유출을 막으면서 서드 파티에게 필요한 정보를 제공 가능
세밀하게 scope 제어 가능
현재 사실상의 업계 표준 우리 서비스가 유저에게 Authorization Request를 보냄(사용자에게 인증 요청)
유저는 리소스에서 로그인 및 회원 정보 제공
클라이언트는 유저로부터 받은 결과물(허용 범위, 정보)를 가지고 깃허브의 인증 서버로 보냄
인증 서버는 정확한 정보가 맞는지 확인과 함께 요청한 서비스가 실제로 맞는지 확인
확인이 되면 인증 서버는 엑세스 토큰을 발급
엑세스 토큰을 가지고 리소스 서버에서 scope에 허용된 정보만 가져옴
리소스 서버는 제한된 범위의 리소스를 보여줌 엑세스 토큰은 세션에서 db에 저장해놓기
리소스 서버의 엑세스 토큰을 들고 있을 필요가 없음+----------+
| Resource |
| Owner |
| (일반 유저)|
+----------+ ^ | (B)
+----|-----+ Client Identifier +---------------+
| -+----(A)-- &amp; Redirection URI ----&gt;| |
| User- | (깃허브에서 로그인 페이지) | Authorization |
| Agent -+----(B)-- User authenticates ---&gt;| Server |
| | | |
| -+----(C)-- Authorization Code ---&lt;| |
+-|----|---+ (요청한 서비스,스코프,유저) +---------------+ | | ^ v (A) (C) | | | | | | ^ v | |
+---------+ | |
| |&gt;---(D)-- Authorization Code ---------' |
| Client | &amp; Redirection URI |
| | (앱의 시크릿 키) |
| |&lt;---(E)----- Access Token -------------------'
+---------+ (w/ Optional Refresh Token) Authorization Code Grant
authorizationURL에 다른 쿼리 파라미터로 내어주기
<img src="https://i.imgur.com/Dr6MO8w.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
보통은 oauth인증받은거를 기반으로 redirect uri로 이동<br>
<img src="https://i.imgur.com/pBMzVIn.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
code를 받음<br><img src="https://i.imgur.com/JGSuvD8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
authorization 서버로 받은 코드를 넣어 다시 보내기<br>
<img src="https://i.imgur.com/63fLUwB.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
토큰 받기]]></description><link>부스트캠프/멤버십/3주차/그룹-프로젝트_3주차_마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/그룹 프로젝트_3주차_마스터클래스.md</guid><pubDate>Wed, 13 Nov 2024 05:43:16 GMT</pubDate><enclosure url="https://i.imgur.com/Dr6MO8w.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/Dr6MO8w.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[react-konva를 이용하여 노드 추가기능 구현하기]]></title><description><![CDATA[
function averageLocation(children: number[], data: NodeData, parentNode?: Node) { if (!children.length) { return parentNode ? { x: parentNode.location.x + 30, y: parentNode.location.y + 30 } : { x: 0, y: 0 }; } const x = children.reduce((acc, curr) =&gt; data[curr.toString()].location.x + acc, 0) / children.length; const y = children.reduce((acc, curr) =&gt; data[curr.toString()].location.y + acc, 0) / children.length; return { x, y };
}
만약 x,y값을 기준으로 좌표를 평균내어 추가하게 된다면, 처음엔 문제 없이 children들의 평균값을 내거나, 만약 children이 없을 경우에는 자식이 생길 예정인 부모 노드의 x,y좌표에서 30씩 떨어져서 생성될 수 있도록 했다.하지만 해당 코드의 문제점은 만약 2개의 노드 사이에서 평균 x,y좌표를 구한 노드 1개가 생성된다고 할 때, 위치를 하나도 변경하지 않고 그대로 다시 추가를 누르면 평균값으로 나온 노드와 함께 평균을 다시 구하게 되므로 사실상 똑같은 평균 x,y좌표가 나올 수밖에 없다.더 큰 문제는 내가 데이터를 상태로 다루고 있는데, 이 상태가 업데이트 될 때마다 데이터를 dependency array에 두고 useEffect로 충돌 방지를 실행시키고 있다는 사실이었다.useEffect(() =&gt; { checkCollision(layer, updateNode); }, [data]);
내 충돌 방지의 로직의 허점은 두 노드가 완벽하게 포개질 때, 서로 무한대로 x +축을 향해 움직인다는 점이었다.//vector.ts
export function verticalVector(a: Location, b: Location) { return { x: a.y - b.y, y: b.x - a.x };
} export function unitVector(a: Location, b: Location) { const v = verticalVector(a, b); const vectorLength = Math.sqrt(v.x ** 2 + v.y ** 2); return { x: v.x / vectorLength, y: v.y / vectorLength };
} //addNode.ts
function getNewNodePosition(children: number[], data: NodeData, parentNode: Node) { if (!children.length) { return parentNode ? { x: parentNode.location.x + 30, y: parentNode.location.y + 30 } : { x: 0, y: 0 }; } const lastChildren = data[children[children.length - 1]]; const uv = unitVector(parentNode.location, lastChildren.location); return { x: lastChildren.location.x + uv.x * 50, y: lastChildren.location.y + uv.y * 50, };
}
요소에서 수직벡터를 구하는 공식은 기존 벡터를 구하는 공식에서 반대로 해서 x,y좌표를두 점 와 가 있을 때, 벡터 는 의 공식으로 구할 수 있다.하지만 우리가 구하는 것은 벡터에 대해 수작으로 그어지는 수직벡터를 구해 수직벡터 방향에서 내가 원하는 정도만큼 떨어진 거리를 만들어내는 것이므로, 수직벡터의 공식을 활용하여 구해야 한다.벡터 의 수직 벡터는 두 가지 방향으로 구할 수 있는데, 시계방향으로의 수직벡터와 반시계방향으로의 수직벡터이다. 시계 방향의 경우 로 계산할 수 있으며, 반시계방향의 경우는 의 공식으로 계산이 가능하다.
하지만 우리 프로젝트의 경우 처음 초기 데이터 생성 과정에서 만약에 ai를 통해 회의록을 업로드하고 여기서 키워드를 뽑아내어 마인드맵을 만든다고 할 때, 생성되는 키워드 노드들은 각각 시계방향으로 돌아가면서 생성되는 규칙을 가지고 있기 때문에 새롭게 만드는 하위 생성 노드의 경우도 시계방향으로 구하기로 했다.
// 두 점 사이의 벡터 구하기
export function vector(a: Location, b: Location) { return { x: b.x - a.x, y: b.y - a.y };
} // 벡터의 수직 벡터 구하기
export function perpendicularVector(v: { x: number; y: number }, clockwise: boolean = true) { return clockwise ? { x: -v.y, y: v.x } : { x: v.y, y: -v.x };
} vector 함수는 두 점 a와 b 사이의 벡터를 반환합니다.
perpendicularVector 함수는 주어진 벡터 v에 대해 clockwise 파라미터에 따라 시계 방향 또는 반시계 방향으로 회전된 수직 벡터를 반환합니다.
]]></description><link>부스트캠프/멤버십/8주차/react-konva를-이용하여-노드-추가기능-구현하기.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/react-konva를 이용하여 노드 추가기능 구현하기.md</guid><pubDate>Wed, 13 Nov 2024 01:10:24 GMT</pubDate></item><item><title><![CDATA[react-konva를 이용하여 원 사이 충돌 방지 시키기]]></title><description><![CDATA[이번에 마인드맵을 react-konva로 구현하는 과정을 거치면서 마인드맵의 각 노드 간에 충돌을 방지시키지 않으면 여러 요소들이 겹쳐져 있는 상태가 나올 것이기 때문에, 이러한 충돌을 방지하고자 이에 관련되어 로직을 보강하기로 했다.type NodeProps = { parentNode?: Node; node: Node; depth: number; text: string; updateNode: (id: number, updatedNode: Node) =&gt; void;
}; function NodeComponent({ parentNode, node, depth, text, updateNode }: NodeProps) { return ( &lt;&gt; &lt;Circle id={node.id.toString()} onDragMove={(e) =&gt; { updateNode(node.id, { ...node, location: { x: e.target.x(), y: e.target.y(), }, }); }} onDragEnd={(e) =&gt; updateNode(node.id, { ...node, location: { x: e.target.x(), y: e.target.y(), }, }) } draggable x={node.location.x} y={node.location.y} fill={"white"} width={100} height={100} radius={70 - depth * 10} stroke="black" strokeWidth={3} /&gt; &lt;Text name="text" text={text} x={node.location.x - 20} y={node.location.y - 10} /&gt; {parentNode &amp;&amp; ( &lt;ConnectedLine from={parentNode.location} to={node.location} fromRadius={70 - (depth - 1) * 10 + 10} toRadius={70 - depth * 10 + 10} /&gt; )} &lt;/&gt; );
}
기본적인 노드의 정보는 이러하다. 만약 노드 간에 부모-자식 관계가 있다면 이런 식으로 react-konva의 Line을 커스텀한 ConnectedLine이라는 컴포넌트를 추가적으로 렌더링 하도록 했다.추가적으로 각 노드에는 dragmove와 dragend 이벤트를 달아서 해당 요소를 드래그 앤 드롭 시에 계속해서 상태를 바꾸면서 노드의 위치를 갱신할 수 있도록 했다.export type Node = { id: number; keyword: string; depth: number; location: Location; children: number[] | [];
}; type DrawNodeProps = { data: Node[]; root: Node; depth?: number; parentNode?: any; update?: (id: number, node: Node) =&gt; void;
}; export function DrawNodefromData({ data, root, depth = 0, parentNode, update }: DrawNodeProps) { return ( &lt;&gt; {/* from */} &lt;NodeComponent text={root.keyword} depth={depth} parentNode={parentNode} node={root} updateNode={update} /&gt; {/* to */} {root.children?.map((childNode, index) =&gt; ( &lt;DrawNodefromData data={data} key={index} root={data[childNode - 1]} depth={depth + 1} parentNode={root} update={update} /&gt; ))} &lt;/&gt; );
}
노드의 부모-자식을 렌더링하는 방식은 위와 같다. 모든 노드는 직렬화 되어있는 상태이고, children에는 노드의 id만을 가지고 있다.
노드의 id는 index를 1부터 시작하여 만들었기 때문에 계속해서 서브트리의 루트로 가게 될 때에는 root를 id값에서 1을 빼어 인덱스로 접근할 수 있도록 하였다.그렇다면 이 노드 사이에서 어떻게 충돌할 때의 문제를 해결할 수 있을까?
내가 생각했을 때 가장 기본적인 해결 방식은 '충돌이 됐을 때, 충돌당한 노드를 겹치지 않도록 밀어낸다' 였다. 그렇기 때문에, 나는 충돌한 각도를 어느정도 알고 있고, 밀어낼 때마다 각 원이 가져야 하는 최소 사이의 길이만 정한다면 이를 통해 리렌더링 과정에서 노드들을 피하게 할 수 있을 것 같았다.//...
const layer = useRef(null); useEffect(() =&gt; { layer.current.on("dragmove", (event) =&gt; checkCollision(layer, event, updateNodeList)); }, []);
가장 먼저 필요한 것은 layer에 이벤트를 다는 일이다. react-konva에서는 useRef를 layer에 달게 되면 layer 안의 모든 요소들이 jsx와 같은 요소처럼 접근할 수 있기 때문에, children에도 접근할 수 있다. 가장 처음에 생각한 방식은 무조건 맨 처음에 어떤 요소를 드래그해서 옮기기 시작하면 옮기는 이벤트가 발동될 때마다 layer 안에 있는 children들에 대해 모두 collision을 확인하고, 드래그하고 있는 요소들과 충돌하는 노드가 있는지 확인을 해야 했다.export function checkCollision(layer, event, update) { const dragTarget = event.target; const dragTargetRect = event.target.getClientRect(); layer.current.children.forEach((child) =&gt; { if ( !(child.attrs.name === "text") &amp;&amp; !(child.attrs.name === "line") &amp;&amp; isCollided(child, dragTarget, dragTargetRect) ) { const newPosition = moveOnCollision(child, dragTarget); update(parseInt(child.attrs.id), { location: newPosition }); } });
}
dragmove 이벤트가 발동될 때마다 해당 checkCollision 함수가 실행된다. 이벤트가 발동되면서 해당 함수에 이벤트 객체를 그대로 넘겨주어 이 함수에서 확인할 수 있도록 해주었다.
dragTarget의 경우, 현재 드래그 하고 있는 Target의 객체를 넘겨준다.
event 객체의 target property에서 getClientRect 메서드는 해당 요소가 가지고 있는 크기범위를 직사각형 형태로 나타내준다.<img src="https://i.imgur.com/6luPbOC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
요런 식으로 각도가 있는 요소들도 전부 직사각형의 범위로 측정한 값을 보내준다. 대부분 충돌 감지를 할 때는 위와 같이 충돌이라고 할 수 있는 범위를 직사각형 형태로 측정하여 감지하는 것으로 보았기 때문에 나 또한 이를 기준으로 측정했다. getClientRect()를 실행한 값을 dragTargetRect에 할당하였다.layer.current.children.forEach((child) =&gt; { if ( !(child.attrs.name === "text") &amp;&amp; !(child.attrs.name === "line") &amp;&amp; isCollided(child, dragTarget, dragTargetRect)
다음으로는 layer의 children에 접근하여 각각의 요소에 대해서 모두 해당 요소가 현재 드래그하고 있는 요소와 충돌되는지를 검사하도록 했다.여기서 !(child.attrs.name === "text") &amp;&amp; !(child.attrs.name === "line")가 들어간 이유는 layer의 children 안에는 비단 Circle 객체만 있는 것이 아닌, 같은 depth에 text와 line을 두었기 때문이다. 그렇게 되면 text와 line에 대해서도 충돌 감지를 하기 때문에 예상치 못한 부수효과를 가져올 수 있어 원에 대해서만 충돌 감지를 할 수 있도록 했다.export function isCollided(node, target, targetRect) { if (node === target) return false; return haveIntersection(node.getClientRect(), targetRect);
} function haveIntersection(r1, r2) { return !(r2.x &gt; r1.x + r1.width || r2.x + r2.width &lt; r1.x || r2.y &gt; r1.y + r1.height || r2.y + r2.height &lt; r1.y);
}
충돌을 감지하는 로직은 생각보다 어렵지 않다. 드래그 하고 있는 요소를 제외시키기만 하고, 나머지는 x,y 좌표가 서로 겹치는지만 검사하면 된다.
두 개의 원 r1,r2가 있다고 할 때, 각각의 요소에 대해서 x,y 좌표를 모두 충돌되어 있는지 검사하는 조건문을 넣었다.만약 충돌 검사 조건문에서 충돌이 되었다고 판단이 되면, 조건문 블록으로 넘어가 노드를 이동시키는 로직을 실행한다. const newPosition = moveOnCollision(child, dragTarget); update(parseInt(child.attrs.id), { location: newPosition });
moveOnCollision은 충돌된 요소가 가야 할 x,y좌표를 계산하는 함수이다. 이 함수의 결과를 newPosition에 할당하고 해당 좌표를 상태 업데이트 시켜주어 리렌더링이 바로 일어나면서 위치가 업데이트된다.function moveOnCollision(targetNode, draggedNode) { const dx = targetNode.attrs.x - draggedNode.attrs.x; const dy = targetNode.attrs.y - draggedNode.attrs.y; const angle = Math.atan2(dy, dx); const minDistance = 5; const moveX = Math.cos(angle) * minDistance; const moveY = Math.sin(angle) * minDistance; return { x: targetNode.attrs.x + moveX, y: targetNode.attrs.y + moveY, };
}
moveOnCollision은 충돌이 된targetNode와 충돌을 시킨draggedNode를 인자로 받는다. 각 객체에는 내가 attribute로 넘겼던 x,y,radius 등의 정보가 attrs에 담겨 있으므로 여기에 접근하여 값을 계산한다.dx,dy는 두 점 사이의 거리를 x,y좌표로 계산한 값이다. 먼저 두 점을 잇는 선을 빗변으로 직각삼각형을 그린 뒤, 역탄젠트를 통해서 각도를 구해야 하기 때문이다. Math.atan2는 아크탄젠트, 즉 역탄젠트를 구하는 Math 모듈의 함수이다.<br>
<a data-tooltip-position="top" aria-label="https://ko.khanacademy.org/math/geometry/hs-geo-trig/hs-geo-solve-for-an-angle/a/inverse-trig-functions-intro" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.khanacademy.org/math/geometry/hs-geo-trig/hs-geo-solve-for-an-angle/a/inverse-trig-functions-intro" target="_self">역탄젠트 알아보기</a> 아크탄젠트를 구했다면 해당 각도가 곧 충돌했을 때의 방향을 나타내는 각도이며, 라디안 값으로 나타난다.
이 각도에 x축의 경우 Math.cos, y축의 경우 Math.sin을 이용하여 각도 값을 x,y축 성분으로 변환하여 해당 방향으로 minDistance만큼 가도록 했다. 이 부분의 계산은 sin(angle) = a/c, cos(angle) = b/c 인 것을 생각했을 때, minDistance가 c로 간다고 생각했더니 이해가 나름 편했다(사실 아직도 잘 모름) 아무튼 여기서 minDistance는 두 원 사이에 어느 정도의 거리가 있어야 하는지를 나타내는 변수이며, 이를 각 사인(아크탄젠트값), 코사인(아크탄젠트값)에 곱해주면 x,y 축을 어느정도 옮겨야 하는지 알 수 있다.
마지막에는 기존 요소의 x,y 좌표에 이동해야 할 x,y의 값만큼을 더해주었다.그렇게 moveOnCollistion은 충돌이 일어난 요소들에 대해서 피할 수 있는 좌표 값을 주고, 이를 update(parseInt(child.attrs.id), { location: newPosition });를 통해서 업데이트 함으로서 노드의 상태를 다시금 업데이트하고 리렌더링이 일어나면서 캔버스에 반영된다.내가 생각했던 로직의 경우 이벤트가 일어난 타겟, 즉 해당 노드에서 다른 모든 노드들을 검색하고 현재 드래그 하고 있는 노드 객체와 충돌되는 다른 노드들에 대해서 충돌을 방지할 수 있도록 했다.
하지만 그럴 경우, 해당 노드와 충돌하는 경우만을 검색하기 때문에 사실상 충돌로 인해 움직인 노드가 움직이게 된다면, 사실상 움직인 노드가 다른 요소들과 충돌할 경우에 대해서는 고려하지 않았기 때문에 이 경우 움직인 노드가 다른 노드와 충돌하는 예외가 생기게 된다. 이런 식으로 충돌된 요소들끼리의 충돌은 적용하지 않는다.]]></description><link>부스트캠프/멤버십/8주차/react-konva를-이용하여-원-사이-충돌-방지-시키기.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/react-konva를 이용하여 원 사이 충돌 방지 시키기.md</guid><pubDate>Sun, 10 Nov 2024 14:21:23 GMT</pubDate><enclosure url="https://i.imgur.com/6luPbOC.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/6luPbOC.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[화면 기록 2024-11-10 오후 11.20.13]]></title><link>부스트캠프/멤버십/8주차/화면-기록-2024-11-10-오후-11.20.13.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/화면 기록 2024-11-10 오후 11.20.13.mov</guid><pubDate>Sun, 10 Nov 2024 14:20:53 GMT</pubDate></item><item><title><![CDATA[무제 파일]]></title><link>부스트캠프/멤버십/8주차/무제-파일.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/무제 파일.md</guid><pubDate>Sun, 10 Nov 2024 11:43:41 GMT</pubDate></item><item><title><![CDATA[react-konva를 이용하여 원 사이 라인 그리기]]></title><description><![CDATA[import { Node } from "@/types/Node";
import { useEffect, useState } from "react";
import { Circle, Group, Layer, Line, Stage, Text } from "react-konva"; type NodeProps = { x: number; y: number; depth: number; text: string; setNodeLocation?: any;
}; function NodeComponent({ x, y, depth, text, setNodeLocation }: NodeProps) { return ( &lt;Group&gt; &lt;Circle draggable x={x} y={y} fill={"white"} radius={50 - depth * 5} stroke="black" strokeWidth={3} onDragMove={(e) =&gt; { setNodeLocation({ x: e.target.x(), y: e.target.y(), }); }} onDragEnd={(e) =&gt; setNodeLocation({ x: e.target.x(), y: e.target.y(), }) } /&gt; &lt;Text text={text} x={x - 20} y={y - 10} /&gt; &lt;/Group&gt; );
} type DrawNodeProps = { root: Node; x: number; y: number; depth?: number; parentPosition?: any; update?: () =&gt; void;
}; export function DrawNodefromData({ root, x, y, depth = 0, parentPosition, update }: DrawNodeProps) { const [nodeLocation, setNodeLocation] = useState(root.location); const nodeSpacing = 150; useEffect(() =&gt; { console.log(nodeLocation); }, [nodeLocation]); return ( &lt;&gt; {parentPosition &amp;&amp; ( &lt;Line points={[parentPosition.x, parentPosition.y, nodeLocation.x, nodeLocation.y]} stroke="gray" strokeWidth={2} /&gt; )} &lt;NodeComponent x={nodeLocation.x} y={nodeLocation.y} text={root.content} depth={depth} setNodeLocation={setNodeLocation} /&gt; {root.children?.map((childNode, index) =&gt; ( &lt;DrawNodefromData key={childNode.id} root={childNode} x={nodeLocation.x + (index - root.children!.length / 2) * nodeSpacing} y={nodeLocation.y + nodeSpacing} depth={depth + 1} parentPosition={nodeLocation} update={update} /&gt; ))} &lt;/&gt; );
} Line 함수형 컴포넌트는 points에 배열을 인자로 받음인자에는 [시작점x,시작점y, 끝점x, 끝점y] 가 들어감. 그럼 그대로 그 두 요소의 x,y 좌표 사이에 선을 그어줌state로 관리하고 있는 노드를 해당 인자의 값에 넣어주어 상태가 변할 때, 즉 x,y 좌표가 움직일 때 setter함수가 실행되는데 그 때마다 렌더링이 이루어지기 때문에 선은 이 x,y좌표에 따라 움직이게 됨<img src="https://i.imgur.com/c5Bekmc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 끝점, 만약 대분류-중분류-소분류로 이루어져 있는 마인드 맵에서 선을 이을 때, 끝점이 가르키는 x,y 좌표의 경우에는 원이 위로 가서 선이 보이지 않는 형태가 되지만 시작하는 점의 x,y좌표에서는 앞으로 와서 원의 중심저메에서 뻗어나가는 형태가 되어버림z-index를 주고 노드가 위로 올라가게 할 수도 있지만, 이는 정상적인 해결 방식이 아닌 임시 방편에 불과하다고 생각한다.따라서 다른 방식으로 노드를 이어보려고 하는데, 문제는 원 안에 있는 노드를 어떻게 잘라내느냐였다.현재 내가 알고 있는 정보는 시작점으로 되어 있는 점과 끝점이다. 이 점 사이의 거리를 이용하여 시작점에서 끝점으로 이어지는 선이 그어졌다고 가정했을 때, 이어져 있는 두 노드 간의 선에서 시작점의 선이 노드를 빠져나올 때의 가장자리가 가지는 x,y 값을 알 수 있을 것 같았다. 벡터 구하기:
시작 점의 좌표가 xc, yc이고, 이를 이어주려는 끝점의 좌표가 xp,yp라고 하자. 먼저, 원의 중심으로 향하는 방향을 나타내는 벡터를 구할 수 있다. 이 벡터는 임의의 점과 원의 중심 사이의 차이로 계산할 수 있다 벡터의 길이 구하기: 이제 이 벡터의 길이를 구해 방향을 정규화한다. 여기까지는 피타고라스의 정리를 통해 쉽게 구할 수 있다. 단위 벡터 구하기
벡터를 단위 벡터로 정규화하여 방향만 남기고 크기를 1로 만듭니다. 단위 벡터를 구하려면 원래 벡터의 각 성분을 벡터의 길이로 나눈다 가장자리 좌표 구하기
단위 벡터 방향으로 반지름만큼 이동하면, 원의 가장자리 좌표를 구할 수 있습니다. 원의 중심점에 단위 벡터의 성분을 각각 반지름 r만큼 곱해서 더하면 된다. // from 원의 중점에서 to 원의 중점으로 이어지는 선에서 from 선의 위치를 원의 중점이 아닌 가장자리의 위치 구하는 함수
function getCircleEdgePoint(from: Location, to: Location, r: number) { const dx = to.x - from.x; const dy = to.y - from.y; const vector = Math.sqrt(dx * dx + dy * dy); const xEdgePoint = Math.ceil(from.x + (r * dx) / vector); const yEdgePoint = Math.ceil(from.y + (r * dy) / vector); return { xEdgePoint, yEdgePoint, };
}
해당 함수를 통해 벡터 길이를 구하고, 반지름에 단위 벡터를 곱하여 가장자리가 어떤 좌표인지 x,y 각각의 좌표에 더해주어 곱했다.// Point의 인자로 만들어주는 함수
// 각각의 원에 대해서 가장자리 쪽으로 갈 수 있게끔 해줌
function getLinePoints(from: Location, to: Location, r: number) { const fromCircleEdgePoint = getCircleEdgePoint(from, to, r); const toCircleEdgePoint = getCircleEdgePoint(to, from, r); return [ fromCircleEdgePoint.xEdgePoint, fromCircleEdgePoint.yEdgePoint, toCircleEdgePoint.xEdgePoint, toCircleEdgePoint.yEdgePoint, ];
} type ConnectedLineProps = { from: Location; to: Location; radius: number;
}; export function ConnectedLine({ from, to, radius }: ConnectedLineProps) { return &lt;Line points={getLinePoints(from, to, radius)} stroke="gray" strokeWidth={2} /&gt;;
}
기존의 Line을 계속 활용하면서도 여기서 이어지는 선에 대해 원의 중점이 아닌, 각 원에서 뻗어나온 가장자리의 좌표로 선을 잇는 것이 이상적이기 때문에 이를 함수화했다.points 인자에 들어갈 값은 from과 to의 원 가장자리 좌표를 구해야 하는데, getCircleEdgePoint는 단일책임원칙을 지키기 위해 함수를 분리하여 한 원의 가장자리 좌표를 구하는 함수로 만들었다. 따라서 getLinePoints라는 함수를 따로 만들어 인자로 그대로 넣을 수 있는 함수로 활용할 수 있도록 하였다.<br><img src="https://i.imgur.com/Ymf6Gep.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
어딘가 미묘하게 두 선이 어느정도 띄워져있는지가 다른 것 같다..// from 원의 중점에서 to 원의 중점으로 이어지는 선에서 from 선의 위치를 원의 중점이 아닌 가장자리의 위치 구하는 함수
function getCircleEdgePoint(from: Location, to: Location, r: number) { const dx = to.x - from.x; const dy = to.y - from.y; const vector = Math.sqrt(dx * dx + dy * dy); const xEdgePoint = Math.ceil(from.x + (r * dx) / vector); const yEdgePoint = Math.ceil(from.y + (r * dy) / vector); return { xEdgePoint, yEdgePoint, };
}
코드를 살펴보며 생각해보니 나는 현재 분류에 따라서 하위 요소의 경우 depth를 조금씩 줄이고 있었는데, 더 작아지거나 커지는 선의 경우에는 사실상 from의 반지름을 가지고 계산했기 때문에 더 커졌던 문제를 가져온 것으로 보인다.// Point의 인자로 만들어주는 함수
// 각각의 원에 대해서 가장자리 쪽으로 갈 수 있게끔 해줌
export function getLinePoints(from: Location, to: Location, r: number) { const fromCircleEdgePoint = getCircleEdgePoint(from, to, r); const toCircleEdgePoint = getCircleEdgePoint(to, from, r); return [ fromCircleEdgePoint.xEdgePoint, fromCircleEdgePoint.yEdgePoint, toCircleEdgePoint.xEdgePoint, toCircleEdgePoint.yEdgePoint, ];
}
그러므로 고쳐야 할 것은 여기였던 것이다. from의 원이 가지는 원의 반지름과 to 원이 가지는 원의 반지름을 모두 받아야 했다.//depth가 70 - depth * 10 이라고 할 때
&lt;ConnectedLine from={parentPosition} to={nodeLocation} fromRadius={70 - (depth - 1) * 10 + 10} toRadius={70 - depth * 10 + 10} /&gt;
그렇게 되면 이런 식으로 두 원의 반지름을 모두 받고export function getLinePoints(from: Location, to: Location, fromRadius: number, toRadius: number) { const fromCircleEdgePoint = getCircleEdgePoint(from, to, fromRadius); const toCircleEdgePoint = getCircleEdgePoint(to, from, toRadius); return [ fromCircleEdgePoint.xEdgePoint, fromCircleEdgePoint.yEdgePoint, toCircleEdgePoint.xEdgePoint, toCircleEdgePoint.yEdgePoint, ];
}
계산 과정에서 각각의 반지름을 넣어주어 각각의 원에서 가장자리 좌표를 구할 수 있도록 해 주었다.<br><img src="https://i.imgur.com/aYk7867.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
어어... 그만..<br><img src="https://i.imgur.com/Y2MWzT2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">넘어가버리기~내가 기대한 것은 선이 서로에게 어느정도 가까이 닿거나 교집합이 생기기 시작하면 둘을 잇는 선이 생기지 않는 것이었다.하지만 이를 고려하지 않고 둘의 좌표를 무조건 계산하여 선을 그리다 보니 원이 근접했을 대에 원이 안쪽으로 파고드는 문제를 가지게 되었다.
나중에 충돌 방지를 넣는다면 이러한 문제는 어느정도 해소될 수 있지만, 나중에 예상치 못한 오류를 낳을 수도 있기 때문에 이러한 점도 고려하여 선을 그려야겠다 싶었다.// from 원의 중점에서 to 원의 중점으로 이어지는 선에서 from 선의 위치를 원의 중점이 아닌 가장자리의 위치 구하는 함수
export function getCircleEdgePoint(from: Location, to: Location, fromRadius: number, toRadius: number) { const dx = to.x - from.x; const dy = to.y - from.y; const vector = Math.sqrt(dx * dx + dy * dy); if (fromRadius + toRadius - vector &gt; 0) { return { xEdgePoint: 0, yEdgePoint: 0, }; } const xEdgePoint = Math.ceil(from.x + (fromRadius * dx) / vector); const yEdgePoint = Math.ceil(from.y + (fromRadius * dy) / vector); return { xEdgePoint, yEdgePoint, };
}
기존에 가장자리 구하는 함수에서도 그냥 fromRadius와 toRadius 를 둘 다 받은 다음에, 만약 두 원의 반지름을 더한 것이 벡터보다 커지게 된다면 이는 최대한 근접해있다는 사실을 알 수 있기 때문에 이런 경우 x좌표와 y좌표를 모두 0으로 줌으로써 라인이 생성되지 않도록 했다.]]></description><link>부스트캠프/멤버십/8주차/react-konva를-이용하여-원-사이-라인-그리기.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/react-konva를 이용하여 원 사이 라인 그리기.md</guid><pubDate>Sat, 09 Nov 2024 07:25:20 GMT</pubDate><enclosure url="https://i.imgur.com/c5Bekmc.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/c5Bekmc.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그룹프로젝트_2주차 회고]]></title><description><![CDATA[이제까지 코딩을 하는 과정에서 에러를 마주하게 되었을 때, 보통은 구글링이나 ai를 활용하여 정보를 얻고 이를 임시방편처럼 문제를 해결해왔다.하지만 현재는 이러한 문제를 해결하는 방식이 잘못되었으며, 앞으로도 똑같은 에러가 발생하더라도 이에 대한 이해보다는 조치를 위한 검색과 해결을 할 것이라고 생각하여 조금씩이라도 이를 기록하고 있다.하지만 이 문제와 해결하는 과정을 담는 글을 작성하는 과정이 익숙치 않아 생각보다 많은 시간을 잡아먹고 있다고 생각한다. 당장 수요일만 하더라도 빌드 과정에서 생기는 오류를 고치는 과정을 적다가 대부분의 시간이 가버렸고, 이는 곧 생산력을 떨어뜨릴 수 있다고 생각했다.물론 이해를 기반으로 에러를 해결하는 것이 가장 이상적인 방향의 문제 해결이라고 생각하지만 이러한 과정이 전체적인 프로젝트의 일정을 맞추지 못하게 되는 문제를 낳게 될까봐 계속 걱정이 되었던 것 같다.이렇게 공부를 하면서 하나의 오류에도 생각보다 근본적인 기술에 대한 공부를 많이 해야 하기 때문에 ‘문제해결을 위해서 어느 정도의 범위를 잡고 해야 하는가?’에 대한 생각을 계속 하게 되었고, 이를 멘토님께 여쭤보았다.멘토님의 경우 또한 문제 해결을 위해서 해당 문제의 근본적인 문제들부터 하나하나 알아가면서 해결해가는 방식은 좋은 방식이라고 말씀하셨으며, 이를 위한 시간 투자도 마땅히 필요한 것이라고 하셨다.하지만 어떠한 문제가 언제 터질 것임을 우리는 제대로 알지 못하기 때문에, 이를 위한 시간을 미리 버퍼를 두는 것이 정석이라고 하셨다. 즉, 조금 더 보수적으로 일정을 짤 필요성이 있다는 것.멘토님의 말씀을 듣고 그렇기 때문에 보다 빠른 생산성 또한 요구되는 것이라고 생각했다. 프론트엔드의 역량 중 중요한 요소 중 하나는 기한 내에 기능을 완성할 수 있는 역량이다. 빠른 생산성을 기반으로 개발을 하다가 만약 에러가 터진다면 이에 대한 해결 시간을 보다 확보할 수 있기 때문에 어찌보면 당연할 이야기라고 생각한다. 아무튼 그렇기 때문에 일정을 수립하는 과정에서 꼭 시간 내에 아슬아슬하게 맞출 법하게 일정을 잡지 말고, 꼭 중간에 생각치 못한 에러가 생길 것임을 고려하여 일정을 맞추는 것이 중요할 것 같다.처음에는 우리가 계획했던 프로젝트는 바닐라 자바스크립트와 Canvas API를 이용하여 저희가 직접 만든 라이브러리를 통해 마인드맵을 만드는 것을 프론트엔드의 가장 궁극적 목표로 정했었다.가장 기초부터 우리들이 설계하여 만들게 된다면, 이를 통한 바닐라 자바스크립트와 캔버스에 대한 학습 효과가 더욱 클 것이라 생각하여 선택하였다.하지만 백엔드 분께서 아무래도 모든 로직들에 대해서 하나하나 직접 만들고 이를 프로젝트에 적용시키기 까지는 상당한 시간이 걸릴 것 같다는 얘기를 조심스레 꺼내주셨다. 처음부터 이러한 말을 들었을 때는 '괜찮을 것 같은데?'라는 생각이 들었을 수도 있지만 조금이나마 캔버스를 맛본 후에 나온 결과는 '안될 것 같다'였다.따라서 우리는 라이브러리를 사용하되, 자유도가 높은 라이브러리를 활용하여 최대한 우리들이 설계 및 구현하는 기능들이 많게끔 하면서도 6주 안에 완성될 수 있는 정도의 목표를 잡고 다시금 진행하고 있다.하지만 이러한 라이브러리를 사용하는 과정에서, 사실상 이 라이브러리는 수많은 캔버스 라이브러리 중 하나기 때문에 사실상 학습을 한다고 하더라도 해당 라이브러리에 대한 API들의 학습이 정말 저의 성장에 도움이 될까 하는 걱정도 있었던 것 같다.
canvas API를 사용한다고 하면 웹에서 공통적으로 제공하는 기능이기 때문에 다른 곳에서도 많이 쓰일 것 같다고 생각하지만 라이브러리는 아무래도 한정적인 느낌이 강해해서 그런 것 같다고 생각한다. 프레임워크의 경우 개발자가 소프트웨어를 개발함에 있어 코드를 구현하는 개발 시간을 줄이고,&nbsp; 코드의 재사용성을 &nbsp;증가 시키기 위해 일련의 클래스 묶음이나 뼈대, 틀을 라이브러리 형태로 제공되는 것을 말한다.프레임워크의 특징은
개발자가 따라야 하는 가이드를 제공한다.
개발할 수 있는 범위가 정해져있다.
개발자를 위한 다양한 도구 , 플로그인 지원 라이브러리란&nbsp;개발자가 만든 클래스들의 나열로, 다른 프로그램들에서 사용할 수 있도록 제공하는 방식이다.
: 라이브러리와 프레임워크의 차이는&nbsp;제어 흐름에 대한 주도성이 누구에게 / 어디에게 있는가에 있다.&nbsp; 즉, 애플리케이션의 Flow(흐름)을 누가 쥐고 있느냐에 달려있다.
프레임워크는 그 스스로 제어 흐름의 주도성을 갖는 반면, 라이브러리는 개발자가 가지고 있다.
프레임워크는 집이고, 라이브러리는 그 집 안의 가구이다.
라이브러리와 달리 프레임워크는 이미 프로그래밍에 대한 규칙을 가지고 있다. 예를 들면 설정파일의 태그설정이나, DB연동 방법등에 대한 규칙을 가지고 있고 개발자는 이를 따라야한다.
위에서 말했듯 프레임워크는 내가 따라야 하는 것들이지만, 라이브러리는 내가 사용하는 것들 이다. 겉보기에는 비슷해 보이지만 제어 흐름의 주도성은 크게 다르다. 프레임워크의 경우 따라야 하는 것들을 따르며 여러 명이 개발을 해도 얼추 비슷한 것들이 나온다면, 라이브러리는 사용자의 역량에 따라서 결과물이 크게 달라질 수 있다는 것이다.따라서 멘토님께서는 라이브러리를 사용하는 것 정도는 문제가 될 것이 없다고 생각하신다고 하셨다. 프레임워크가 아닌 라이브러리인 이상, 우리가 어떻게 활용하느냐에 따라서 기술적 완성도가 결정되기 때문이다. 우리는 이 라이브러리를 사용하면서 학습 효과가 떨어질까 생각하는 것이 아니라, 어떻게 활용하는지 를 생각하며 이를 문서화하고 기록한다면 보다 다른 방면에서 좋은 학습 효과를 얻을 수 있을 것이라고 말씀해주셨다.이전까지는 프레임워크와 라이브러리의 차이에 대해서 크게 다르다는 느낌을 받지 못했지만, 멘토님의 말씀을 듣고 라이브러리를 다시 보니 확실히 차이가 크다는 느낌을 받았다. 또한 이를 어떻게 커스텀하여 사용할 지 스스로 결정하며 이 또한 나에게 좋은 학습 효과를 줄 것이라 생각한다.내가 생각한 핵심 상태 관리는 세 가지 방식이 있다.
useSearchParams -&gt; 섹션별 상태 관리
useContext
zustand
하지만 이 useContext와 zustand의 경우 둘 다 전역적으로 state를 내려 줄 수 있게 해주는 라이브러리다 보니, 사실상 이 두개 중에 하나를 선택하느냐, 아니면 둘 다 선택하느냐가 계속 고민이 되는 것 같다.
전역으로 관리할 상태는 현재까지는
캔버스에 그릴 요소들의 데이터
로그인 상태
동시 편집자
정도들의 상태가 있는데 이 상태를 무엇으로 관리해야 할 지 고민이 된다. 각각 장단이 뚜렷하다고 생각하기 때문이다.
context api의 경우는 확실히 Provider를 통해서 상태를 내려줄 범위를 직접 지정할 수 있고, 이를 통해 여러 컴포넌트에서 어떤 상태만을 관리할 지에 대해서 명확히 보이는 점이 장점이라고 생각한다.
하지만 확장성을 생각한다면 Provider hell이 만들어질 가능성이 높고, Provider가 감싸고 있는 컴포넌트들의 경우 상태 변경이 일어나면 안쪽의 모든 컴포넌트들이 리렌더링 된다는 점이 큰 단점이다.zustand의 경우는 장점의 경우 낮은 러닝커브, selector 패턴을 이용한 선택적 리렌더링, provider hell 방지 등이 가장 큰 장점이라고 생각한다. 하지만 한 상태가 어떤 여러 컴포넌트에서 사용되는 지는 한눈에 확 알아볼 수 없다는 점이 살짝은 마음에 걸린다.그래서 모든 요소들의 리렌더링이 필요한 데이터, 예를 들면 다크 모드와 같은 것들의 경우에는 context api로 사용하고 나머지의 경우는 모두 전역관리 라이브러리를 사용하는 방식도 괜찮을 것 같아서 계속해서 고민해보아야 할 문제인 것 같다.]]></description><link>부스트캠프/멤버십/2주차/그룹프로젝트_2주차-회고.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/그룹프로젝트_2주차 회고.md</guid><pubDate>Fri, 08 Nov 2024 04:41:10 GMT</pubDate></item><item><title><![CDATA[그룹 프로젝트_2주차]]></title><description><![CDATA[<a data-href="그룹프로젝트_2주차_마스터클래스" href="부스트캠프/멤버십/2주차/그룹프로젝트_2주차_마스터클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹프로젝트_2주차_마스터클래스</a><br>
<a data-href="그룹프로젝트_2주차 회고" href="부스트캠프/멤버십/2주차/그룹프로젝트_2주차-회고.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹프로젝트_2주차 회고</a>]]></description><link>부스트캠프/멤버십/2주차/그룹-프로젝트_2주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/그룹 프로젝트_2주차.md</guid><pubDate>Fri, 08 Nov 2024 04:09:40 GMT</pubDate></item><item><title><![CDATA[그룹프로젝트_2주차_마스터클래스]]></title><description><![CDATA[정량적인 코드의 품질을 위한 소프트웨어 테스트
아래 링크의 4가지 레벨이 일반적인 테스트 종류로 본다.<a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.seguetech.com/the-four-levels-of-software-testing/" target="_self">http://www.seguetech.com/the-four-levels-of-software-testing/</a>
unit test : 소프트웨어의 최소단위, 보통 함수를 가리킴 Integration test : 단위 기능이 합쳐진 기능에 대한 테스트
System test : 위 내용보다 더 큰 개념, 전체 시스템에 대한 동작 테스트 Acceptance(인수) Test : 고객이 ok할 수 있는지 판단하기 위한 테스트
최근에 많이 쓰는 용어
UI 테스트 : FE에서 존재하는 개념으로, UI 기능 단위로 진행하는 테스트. 보통 Unit test와 system test 사이라고 볼 수 있음.
E2E Test: End-to-end 테스트. Integration Test와 비슷한 느낌
테스트를 하는 이유 -&gt; 유지보수의 측면에서 대비하기 위해 사용하는 테스트
회귀 테스트(regretion test) : 이전에 돌렸던 코드가 마이그레이션 이후 잘 동작되는지 확인
리액트의 단위 테스트 -&gt; 컴포넌트 테스트
순수함수 -&gt; 어떠한 입력에 부수효과 없는 결과가 나오는지 확인하고 순수함수 형태로 만들어야 함
Test Runner -&gt; Jest, mocha 등. 확장자는 spec.ts, test.js 등으로 표현
한 순수 함수를 테스트하는 경우에는 정확한 결과가 나오는지만 보면 되지만 함수 안에 다른 함수를 호출하는 코드가 된다면 그 안에서 호출한 함수가 잘못되었을 수도 있음
최소 단위 함수부터 테스트
테스트 케이스 도출
테스트 가능한 함수로 리팩토링
given -&gt; when -&gt; then 패턴 일관된 방식의 테스트 코드 구현을 위해서 given(테스트에 필요한 값) -&gt; when(실행) -&gt; then(테스트) 테스트코드 -&gt; 마이그레이션에 효과적
소프트웨어의 의존성이 강해지면 나중에 테스트가 잘못될 수도 있기 떄문 조직에 맞는 워크플로를 하자 gitflow는 추천하기 어렵다 필요하다면 커스텀해서 사용할 것 Bisect - 이진탐색으로 탐색 어떤 커밋에서 버그가 발생하는지 빠르게 추적
기본적인 사용 방법은 다음과 같습니다: 시작: git bisect start 명령으로 시작합니다.
범위 설정: 버그가 없었던 마지막 좋은 커밋을 지정하기 위해 git bisect good &lt;커밋 해시&gt;를 입력합니다.
버그가 발생한 나쁜 커밋을 지정하기 위해 git bisect bad &lt;커밋 해시&gt;를 입력합니다. 이진 검색 진행: 이후 Git은 중간 커밋을 체크아웃해줍니다. 문제가 발생했는지 확인한 후 git bisect good 또는 git bisect bad를 입력하면, Git은 다음 중간 커밋으로 이동해 점진적으로 범위를 좁혀갑니다.
결과 확인: 버그가 발생한 커밋을 찾으면 Git에서 해당 커밋 정보를 표시해주며, git bisect reset 명령으로 원래 브랜치 상태로 돌아갑니다. Git Bisect는 특히 긴 커밋 히스토리에서 버그를 정확히 찾는 데 시간을 절약해주기 때문에, 디버깅 시 매우 효율적입니다.
workflow를 자동화할 수 있도록 도와주는 도구 (ex. 빌드, 테스트 및 배포 파이프라인) 레포지토리에서 PR이 열리거나 이슈 생성 등의 이벤트가 발생했을 떄 이를 트리거로 설정할 수 있다.
순차 혹은 병렬로 실행될 수 있는 Job 하나 이상을 포함
각각의 Job은 독립적인 가상 머신 Runner 혹은 Container 안에서 실행되고 스크립트를 실행하거나 Action을 실행하는 하나 이상의 Step으로 구성된다.
Action은 워크 플로우를 단순화할 수 있는 재사용 가능한 확장 하나 이상의 Job을 실행하는 설정 가능한 자동화 프로세스
workflow는 레포지토리에 있는 YAML 파일로 정의
레포지토리에서 이벤트가 발생할 때 수동으로 혹은 지정된 일정에 따라 트리거되어 실행됨
workflow는 ./github/workflows 에 정의
하나의 레포지토리는 여러 workflow를 가질 수 있음
workflow는 다양한 작업 수행 가능 PR 빌드하고 테스트하기
릴리즈 생성될 때마다 앱 배포
새 이슈 열릴 때마다 레이블 추가 워크플로를 트리거하는 하나 이상의 이벤트.
하나 이상의 작업 → 하나 이상의 단계를 실행 ( Runner 머신에서 실행)
각 단계에서 워크플로를 간소화할 수 있는 재사용 가능한 확장인 작업을 정의하거나! 스크립트를 실행할 수 있다..
<br><img src="https://i.imgur.com/uMRiXCI.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">트리거란 워크플로를 실행하게 하는 이벤트이다. 아래와 같은 트리거를 사용할 수 있다.
푸시
릴리스 생성
이슈 열리는 경우
예약된 시간
수동 같은 Runner에서 실행되는 workflow의 단계(step)의 집합
각 단계(step)는 실행되는 쉘 스크립트이거나 실행될 액션
단계는 순서대로 실행되며 서로 의존 관계가 있음
각 단계가 동일한 Runner에서 실행되므로 한 단계에서 다른 단계로 데이터를 공유할 수 있음 먼저 앱 빌드 단계 실행 후 빌드된 앱을 테스트하는 단계 수행 Job은 다른 Job과의 의존성을 설정할 수 있으며 기본적으로 의존성이 없어 병렬 실행
Job이 다른 Job에 의존하게 설정하게 되면 그 Job이 완료될 때까지 기다린 후 실행된다. 정의된 순서대로 실행된다. (서로 종속된다) event에 의해 workflow가 trigger 될 때 이를 실행하는 서버
각 runner는 한 번에 하나의 Job을 실행할 수 있다.
GitHub은 workflow를 실행할 가상머신을 제공 (Ubuntu Linux, Microsoft Windows, MacOS) API 키, 비밀 번호를 workflow에 사용하기 위해 secret를 활용할 수 있다. Organization 수준의 secret을 사용하면 Organization 안의 여러 repository에서 이를 공유할 수 있다.
Repository 수준의 secret을 사용하면 해당 Repository 안에서 secret안의 변수를 사용할 수 있다. Secret 이름 지정 규칙 비밀 이름에는 영숫자 문자([a-z],&nbsp;[A-Z],&nbsp;[0-9]) 또는 밑줄(_)만 사용할 수 있습니다. 공백은 사용할 수 없습니다.
비밀 이름은&nbsp;GITHUB_&nbsp;접두사로 시작할 수 없습니다.
비밀 이름은 숫자로 시작할 수 없습니다.
이름은 대/소문자를 구분하지 않습니다.
비밀 이름은 해당 수준에서 고유해야 합니다. <br><a data-tooltip-position="top" aria-label="https://docs.github.com/ko/actions/using-workflows/workflow-syntax-for-github-actions#about-yaml-syntax-for-workflows" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.github.com/ko/actions/using-workflows/workflow-syntax-for-github-actions#about-yaml-syntax-for-workflows" target="_self">GitHub Actions에 대한 워크플로 구문</a><br>
<a data-tooltip-position="top" aria-label="https://docs.github.com/ko/actions/managing-workflow-runs" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.github.com/ko/actions/managing-workflow-runs" target="_self">워크플로 실행 및 배포 관리</a>
YAML 파일로 정의되어야 한다. (.yml, .yaml)
name GitHub이 Action 탭에서 표시할 workflow의 이름
생략할 경우 해당 yaml 파일의 경로를 표시한다. run-name
on workflow를 실행하기 위한 이벤트를 정의할 수 있다. 깃허브에서 제공하는 템플릿이 존재
또는 커스텀으로 워크플로를 만들 수 있다.
Github에서 코드를 분석하여 유용할 수 있는 워크플로 템플릿을 제공 해 준다.
→ 예를 들어 swift코드가 포함된 경우 swift프로젝트에 대한 제안이 표시된다.
템플릿은 빠르게 시작하고 실행할 수 있도록 설계되어 다음과 같은 다양한 구성을 제공
<br>CI:&nbsp;<a data-tooltip-position="top" aria-label="https://github.com/actions/starter-workflows/tree/main/ci" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/actions/starter-workflows/tree/main/ci" target="_self">연속 통합 워크플로</a>
<br>배포:&nbsp;<a data-tooltip-position="top" aria-label="https://github.com/actions/starter-workflows/tree/main/deployments" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/actions/starter-workflows/tree/main/deployments" target="_self">배포 워크플로</a>
<br>자동화:&nbsp;<a data-tooltip-position="top" aria-label="https://github.com/actions/starter-workflows/tree/main/automation" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/actions/starter-workflows/tree/main/automation" target="_self">워크플로 자동화</a>
<br>코드 검사:&nbsp;<a data-tooltip-position="top" aria-label="https://github.com/actions/starter-workflows/tree/main/code-scanning" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/actions/starter-workflows/tree/main/code-scanning" target="_self">코드 검사 워크플로</a>
<br>페이지:&nbsp;<a data-tooltip-position="top" aria-label="https://github.com/actions/starter-workflows/tree/main/pages" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/actions/starter-workflows/tree/main/pages" target="_self">페이지 워크플로</a>
워크플로 템플릿을 시작으로 커스텀 워크플로를 빌드하거나 사용할 수도 있다.많은 프로젝트를 단일 레포지토리에서 관리하는 방식
애자일한 조직에서는 모노레포를 많이 채용브랜치 -&gt; 커밋의 참조동작이 다름
merge했을 때 fast-forward는 대부분 브랜치만 옮겨짐 명령이 아닌, 별다른 할 일이 없어서 내 브랜치가 옮겨지고 커밋이 옮겨질 때 3-way-merge 베이스 커밋의 내용과 합쳐지는 브랜치, 합쳐질 브랜치를 모두 포괄하여 3-way-merge라고 함 rebase 재배치
커밋을 직렬로 바꿈
커밋은 불변객체이기 때문에 다른 커밋으로 만듦
내가 내 커밋을 들어 대상에게 옮기기 ]]></description><link>부스트캠프/멤버십/2주차/그룹프로젝트_2주차_마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/그룹프로젝트_2주차_마스터클래스.md</guid><pubDate>Wed, 06 Nov 2024 06:07:53 GMT</pubDate><enclosure url="https://i.imgur.com/uMRiXCI.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/uMRiXCI.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[PR]]></title><description><![CDATA[
zustand 설치 전역 관리 라이브러리를 통한 상태 관리를 위해 설치
가볍고 의존성이 없다는 점과 러닝 커브가 낮다는 점에서 선택하였음 react-konva, konva 설치 캔버스 관련 라이브러리 설치
konva를 선택한 이유 레퍼런스가 어느정도 되어 있다
react 지원이 되고 상태관리와 함께 연동이 가능하다
npm 다운로드 수가 많다
바닐라 자바스크립트로 짜기에는 무조건 된다고 하기 힘들 정도의 규모기 때문에 라이브러리를 사용하기로 했음 vitest 설치 프론트엔드 테스팅을 위한 라이브러리 package.json node 버전 명시 tailwind tailwind className명 순서 정리 플러그인 메인영역에 들어가는 모든 컴포넌트 퍼블리싱 캔버스
유저가 조작하여 캔버스를 갱신할 수 있는 영역 뷰 상태 관리
음성파일 AI 변환 파일 상태 관리
드래그 앤 드롭을 통한 파일 업로드 텍스트(회의록) AI 변환 회의록 상태 관리 리스트 뷰를 통한 캔버스 조작 계층 구조 표현
hover시 추가, 삭제 아이콘
키워드 더블클릭시 input태그로 변경하여 수정상태 조작 로그인 모달 깃허브, 구글 로그인 버튼 추가
바깥 영역 클릭 시 닫힘 컴포넌트별 스타일 추가 아이콘 추가 서비스에 사용되는 모든 아이콘 png 파일 src/assets에 저장 캔버스 데이터 구조 설계 및 반영 데이터 구조 Node 타입 선언 및 Node 타입으로 된 더미 데이터 임시 보관 custom hook을 사용한 상태 관리 useAccordian 아코디언 상태 관리 useModal 모달 상태 관리 useNodeActions 노드 상태 관리 useSection 섹션별로 useSearchParams를 이용하여 메인 조작 영역 관리 풀 리퀘스트 템플릿 추가 CI 방식 협의
모노레포 구성 방식
]]></description><link>부스트캠프/멤버십/8주차/pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/PR.md</guid><pubDate>Wed, 06 Nov 2024 05:58:47 GMT</pubDate></item><item><title><![CDATA[브라우저의 렌더링과 캔버스]]></title><description><![CDATA[나는 개인적으로 html canvas를 활용한 서비스는 프론트엔드의 정수라고 생각한다. 아마 극한으로 프론트엔드에서 극한까지 사용하게 된다면 figma와 같은 궁극의 결과물이 나오지 않을까.. 생각해서 찍먹해보지 않을 수 없었다.
그래서 새롭게 프로젝트를 시작하는 과정에서 나는 마인드맵을 캔버스로 그려주는 서비스를 만들려고 했는데, 여기서 고민이 하나 있었다.html 캔버스는 그래픽 요소를 그리기 위한 html 내장 콘텐츠로, 원하고자 하는 것을 비트맵 기반으로 그려낼 수 있다.
하지만 사실 다이어그램같은 요소들을 그려내는 과정에서 캔버스는 굳이 필수사항이 아니라고 생각한다.<img src="https://i.imgur.com/Wk5GFIn.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
당장 react-flow만 보아도 각 다이어그램들을 모두 div로 표현하면서, 여기서 CSS를 붙여 사용하는 방식인데, 캔버스로 굳이 할 필요가 없다는 생각도 들었다.
하지만 canva와 excalidraw와 같은 서비스들은 모두 canvas 기반으로 작동하는 서비스들이었기 때문에, 문득 이 html 요소들과 canvas 중에 무엇이 더 성능에 좋을까? 하는 의문이 들었다.이에 대해서는 보다 브라우저의 렌더링에 대해 이해해야지 이유를 찾을 수 있을 것 같다고 판단하여 브라우저의 렌더링에 대해 간략하게나마 정리해보았다.우리는 브라우저가 어떻게 보여지는지에 대해서 말해보라는 질문을 받으면 아마 간단하게 'HTML를 해석해서 DOM Tree로 파싱하고 CSS도 파싱한 담에 그려냅니다'라고 말할 수 있다. 하지만 이 '그려냅니다'라는 말은 많은 과정이 함축되어 있는 말이다.<br><img src="https://i.imgur.com/LeIQ6n2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">브라우저는 Rendering Engine, Javascript Engine, Graphics Library 3가지 요소로 렌더링이 처리된다. 각 요소들은 가지는 한계가 명확하기 때문에 각자의 역할만을 담당한다.
렌더링 엔진 HTML 파싱 후 DOM트리 생성 자바스크립트 엔진(V8) 자바스크립트 코드 실행 그래픽 라이브러리 화면에 그리기 렌더링 엔진의 경우 자바스크립트를 읽을 수 없기 때문에 html의 렌더링만 담당한 후, 구글의 V8 자바스크립트 엔진을 통해 자바스크립트를 해석하고 그래픽 라이브러리를 통해 우리가 보는 화면을 그려낸다.
이 일련의 과정은 모두 메인 쓰레드에서 작동한다.<br>
<img src="https://i.imgur.com/Y1kZrdv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
하지만 이 DOM 요소를 만들고 자바스크립트를 해석하여 화면을 그리는 과정 자체가 16ms를 넘다 보니까 모니터의 주사율 60Hz의 관점에서도 프레임 드랍이 발생한다.<br>
<img src="https://i.imgur.com/aC7OzHT.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이 문제는 메인 쓰레드가 이 세 가지 작업을 모두 하려고 하다 보니까 생기는 문제이다.
그렇다면 이 문제를 해결하기 위한 방법은 무엇이 있을까?
바로 메인 스레드가 모든 작업을 처리하지 않게 하는 것이다.<br><img src="https://i.imgur.com/6sYm0n8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">브라우저에서 사용되는 스레드는 비단 메인스레드만 있지 않다.
웹페이지를 효율적이고 부드럽게 렌더링하기 위해 별도의 컴포지터 스레드와 래스터 스레드가 렌더러 프로세스에서 실행된다.
그렇다면 이 컴포지터 스레드와 래스터 스레드가 무엇인지, 또 그것의 역할이 무엇인지에 대해서는 다시 브라우저 렌더링을 파악하면서 알아보도록 하자.앞에서 말했던 것처럼 브라우저는 DOM 트리를 만들고, CSS를 파싱하여 스타일 시트를 생성하고, 스타일을 계산한다.스타일을 계산한다고 모든 요소들이 우리가 예상한 대로 화면에 그려지는 과정에서도 많은 과정들이 수반된다.해당 단계에서는 여러 파싱 단계를 거친다.
HTML을 파싱하여 DOM Tree 생성
CSS를 파싱하여 CSSOM 생성
DOM + CSSOM의 렌더 트리 생성
이 과정 자체도 많지만 사실 이 정도는 기본으로 알고 있는 브라우저의 렌더링 단계이니 더 깊은 설명은 생략한다
<br><img src="https://i.imgur.com/9Vsu0Qv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="max-width: 100%;">이 단계에서는 어디에 그려야 할 지에 대해서 결정한다.<br><img src="https://so-so.dev/c6dc3877cfc2c9133a2cfd37ba174120/layout_cost.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">위 예시에서도 글자 크기가 커지면서 박스를 넘어가게 되면 이 부분에 대해서도 줄바꿈 등의 계산을 모두 해당 과정에서 수행해야 한다.<br><img src="https://i.imgur.com/1yipANC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그렇기에 브라우저는 스타일이 적용된 DOM을 다시금 훑으면서 레이아웃 트리를 만든다. 이 레이아웃 트리에는 오로지 '보이는' 요소들이 '어디에' 보여야 할 지에 대한 정보를 가지고 있다.레이아웃 트리가 만들어지면 다음에는 Pre-paint와 paint과정을 거친다. pre-paint는 말 그대로 그리기 전에 하는 작업과 그리는 작업이다.Pre-painting는 다음 단계에서 화면에 그려낼 레이어를 구성하기 위한 준비 단계이다. 해당 단계에서는 두가지 단계로 이루어진다.
paint Invalidation
브라우저가 화면의 일부를 다시 그려야 한다고 판단할 때 기존의 페인팅 정보를 무효화한다. 이 과정은 페이지의 시각적 상태가 바뀌어 현재의 그리기 정보가 더 이상 유효하지 않다고 판단될 때 실행된다.<br>
<img src="https://i.imgur.com/3BkJTo9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Property Tree<br>
<img src="https://i.imgur.com/2h5NdF4.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
무효화가 끝나면 transform, opacity 등의 속성을 트리화시켜 각 노드에서 이 Property Tree의 노드를 참조하여 레이어를 합치는 단계에서 필요한 효과를 빠르게 적용할 수 있다.
이 DOM, 스타일, 레이아웃을 기반으로 브라우저에게 '어떻게 그려야 할 지' 에 대해 정의하는 paint records를 생성한다. 위에서 말한 것과 같이 z-index를 두는 경우 요소들을 브라우저 내에서 그리게 된다면 그리는 순서에도 차이가 발생하기 때문이다. 페인트 레코드에는 세 가지 정보가 포함된다.
Action (e.g. Draw Rect)
Position (e.g. 0, 0, 300, 300)
Style (e.g. backgroundColor: red)
<br><img src="https://i.imgur.com/IZ6wQSy.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 이 받은 정보들을 기반으로 실제로 그리는 작업은 여기서 수행되지 않는다는 점을 기억해야 한다.<br><img src="https://i.imgur.com/GOoIoqa.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Paint Records를 만들었으면 그 paint records를 가지고 일정한 기준에 따라 layer로 분리한 다음에 Paint Layer를 생성한다.
이렇게 페인트 레이어를 분리하는 과정을 Layerize 과정이라고 한다. 이 과정에서 나오는 결과물은 여러개의 paint layer이다. 이 paint layer는 보통
최상위 요소(root element)
position: relative, absolute&nbsp;사용
3D(translate3d,&nbsp;preserve-3d, ,..)나 perspective transform 사용
&lt;video&gt;,&nbsp;&lt;canvas&gt;&nbsp;태그 사용
CSS&nbsp;filter나 alpha mask 사용
정도로 구분된다.
Paint Layer중 Compositing Trigger 를 가지고 있거나 스크롤 가능한 컨텐츠가 있을 경우 별도의 Graphics Layer가 생성된다.Compositing Trigger
3D 변형:&nbsp;translate3d,&nbsp;translateZ&nbsp;…
&lt;video&gt;,&nbsp;&lt;canvas&gt;,&nbsp;&lt;iframe&gt;&nbsp;요소
position: fixed
CSS 트랜지션과 애니메이션을 사용해 구현한&nbsp;transform과opacity&nbsp;애니메이션
position: fixed
will-change
filter
분리된 graphnics Layer들은 독립적인 픽셀화가 가능하여 프레임마다 후에 설명할 단계인 래스터하는 과정을 다시 실행하지 않고 GPU 연산이 가능하기 때문에 빠른 스크롤링이나 애니메이션이 가능하다.<br><img src="https://i.imgur.com/d3pIRBM.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">아무튼 이 Composited Layer List 과정에서 각 레이어를 그리는 스레드는 래스터 스레드, 이를 통해 만들어진 결과물을 웹페이지에 합성하는 작업은 컴포지트 스레드가 담당하면서 메인스레드와는 별개로 작동한다.Layerize단계의 출력인 Composited Layer List는 PrePaint단계에서 생성한 Property Tree와 함께 합성 스레드(Composite Thread)로 복사되는 과정을 ‘Commit’이라 한다.<br><img src="https://i.imgur.com/SFctXRI.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">메인 스레드의 작업은 여기에서 끝난다는 사실도 중요하게 기억해야 할 점이다. 커밋 이후에는 자바스크립트를 실행하거나 렌더링 파이프라인을 다시 실행할 수 있다.이 과정에서는
요소들을 작은 단위로 나누어 "그려내는" 래스터화 작업 (Tilling)
이를 통해 만들어진 요소들을 한 곳에 "합치는" 작업인 컴포지트 작업(Composite)
으로 나누어진다.
Tilling단계에서는 받았던 Paint Layer를 기반으로 각 레이어들을 따로 그려야 할 필요성이 있다. 레이어를 따로 그린 다음에 이를 합쳐 하나의 결과물이 나오도록 하기 때문이다.하지만 이 레이어는 크기가 클 수도 있기 때문에 이를 다수의 타일(Tile) 형태로 나눠 래스터 스레드로 보내면서 래스터화해 GPU 메모리에 저장한다. <br><img src="https://i.imgur.com/0Mbs6pd.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Tilling은 이렇게 타일 형태로 분할하는 작업을 의미한다. 각 타일에는 PaintRecord가 포함되고, 뷰 포트 포함 여부나 인접성 등에 따라 다른 우선순위를 가지면서 래스터화된다.이 Raster 단계가 실질적으로 그리는 단계이다.<br>
<img src="https://i.imgur.com/2ZUerC4.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">각 타일을 래스터화 시키는 작업은 skia라는 그래픽 라이브러리를 사용하여 비트맵 이미지를 생성하고 이를 GPU 메모리에 저장한다.<br><img src="https://i.imgur.com/77UTyqh.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이 과정 자체를 cpu가 아닌 gpu에게 담당하도록 하면서 보다 자연스러운 애니메이션 등을 연출할 수 있는 환경이 주어진다.이렇게 타일들이 래스터화되면 drawquad라는 데이터가 생성되고, 쿼드에는 메모리에서 타일의 위치와 웹 페이지 합성을 고려해 타일을 웹 페이지의 어디에 그려야 하는지에 관한 정보를 가지고 있으며, 앞서 생성한 레이어와 Property Tree 정보를 바탕으로 생성된다.<br><img src="https://i.imgur.com/cX8ejby.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이 쿼드들이 모인 것을 컴포지터(합성) 프레임이라고 하는데, 이는 웹 페이지의 프레임을 나타낸다. <br><img src="https://i.imgur.com/D8qVSjE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">컴포지트 스레드의 경우에는 pending tree와 active tree를 가지고 서로 swap하는 멀티버퍼링 패턴을 가지고 있다. 비동기로 진행되는 래스터 작업 중에 이전 커밋에 대한 내용을 보여주어야 하기 때문에 가지는 패턴이다.pending tree는 커밋을 받고 렌더링에 필요한 작업이 완료되면 pending tree를 active tree로 복제한다. 이렇게 분리 된 트리구조로 인해 active tree에서 GPU작업을 하는 동안 pending tree에서 커밋된 변경사항을 대기시킬 수 있다.마지막으로 activate된 쿼드들은 Compositor Frame, 즉 위에서 말한 합성 프레임이라는 데이터로 묶여 GPU프로세스로 전달된다.
컴포지트 스레드의 최종 목표는 commit받은 레이어를 쪼개서(tiling) 래스터화하고 Frame으로 만들어 GPU에 전달하는 것이다.만약 스크롤 이벤트가 발생하면 컴포지터 스레드는 GPU에게 보내질 다른 컴포지터 프레임을 생성한다.<br><img src="https://i.imgur.com/Q1Ow2Ed.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
마지맞 Display에서는 GPU 프로세스의 viz 스레드에서 여러 개의 합성 프레임을 단일 합서으 프레임으로 합치는 작업을 하며, 화면에 픽셀을 렌더링하면서 한 프레임을 그리는 과정까지가 렌더링의 파이프라인이다.앞의 렌더링 과정에서 보면 어느정도 왜 캔버스를 사용하는 것이 성능적으로 이점을 가지는 지에 대해서는 감이 조금은 올 수도 있다.기존 DOM 요소를 통해 다이어그램을 조작한다고 생각해보자.
다이어그램을 조작하는 과정에서 사용자는 계속해서 클라이언트와 상호작용할 일이 많다. 이를 다른 말로 생각하면 그만큼 요소가 변할 일이 많고, 기존 DOM 요소가 변경되거나 수정이 되면 HTML 파싱, Layout, Pre-paint 등의 과정이 반복해서 이루어지면서 오버헤드가 생길 수 있다는 이야기기도 하다.<br><img src="https://i.imgur.com/yBCtbGX.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 캔버스의 경우에는 다르다. 캔버스의 경우에는 자바스크립트로 canvas api를 통해서 각 요소들을 어떻게 그려야 하는 지에 대해 Paint Record의 형태로 이미 정의되어 있다. 그렇기 때문에 캔버스에서 그려지는 요소들이 메인 스레드에서 하는 작업이라고는 자바스크립트를 통해 paint record들을 정의하는 작업정도밖에 되지 않는다. 따라서 위 사진처럼 메인쓰레드에서는 Recording만을 수행하여 그림을 그리는 방법을 정의하기만 하고, 컴포지터 스레드와 래스터 스레드를 통해 타일링과 래스터링하는 과정이 진행되면서, 보다 CPU의 부담은 낮아짐으로써 프레임 드랍이 일어날 확률 또한 줄어들게 된다.<br><img src="https://i.imgur.com/uJCIKSa.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">추가적으로 현재는 Offscreen Canvas API가 새롭게 생기며, canvas를 조작하는 자바스크립트만을 또 떼어내 이를 Web worker에서 처리함으로써 기존에 메인 스레드에서 동작하던 코드를 워커 스레드에서 실행 및 비트맵 그리기를 수행하면서 보다 성능이 향상될 수 있다.<br><img src="https://i.imgur.com/XZ5IBsq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이 OffscreenCanvas는 기존의 DOM에서 완전히 분리되고 동기화 기능이 없기 때문에 일반 캔버스에 비해 속도가 향상되는 효과를 가질 수 있다.이를 통해 쓰레드의 경우에는 계속해서 리렌더링할 DOM이 줄어들면서 자원을 더 사용할 수 있는 여유가 생기기 때문에 이 부분에서도 이점을 가질 수 있다.캔버스에 그릴만한 요소가 많아지면 많아질수록 DOM 객체로 만들게 되면 그만큼 걸리는 과정에서 오버헤드가 크므로 캔버스의 경우가 DOM 객체를 그리는 과정보다는 보다 성능이 좋을 수 있다.<br><a data-tooltip-position="top" aria-label="https://idchoi2.medium.com/javascript-%EB%8F%84%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0-html-vs-svg-vs-canvas-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-9e1ce2396fcd" rel="noopener nofollow" class="external-link is-unresolved" href="https://idchoi2.medium.com/javascript-%EB%8F%84%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0-html-vs-svg-vs-canvas-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-9e1ce2396fcd" target="_self">도형 그리기 html vs svg vs canvas 성능 비교</a>
이는 레퍼런스에서 또한 확연하게 좋아지는 성능을 통해서도 증명할 수 있는 사실이다.하지만 캔버스의 경우 또한 반복해서 렌더링하는 방식이다보니, 이 과정에서 애니메이션의 처리와 같은 부분에서 성능이 저하될 수 있는 가능성 또한 배제할 수 없다. 따라서 이러한 부분의 경우에는 캔버스의 최적화를 최대한 고려하면서 개발하는 편이 가장 이상적이라고 생각한다.처음에 개발을 시작하면서 브라우저가 어떻게 띄워지는지에 대해서는 DOM tree와 CSSOM 정도로만 알고 있었는데, 이번 기회에 렌더 트리를 만들고 '그려내는' 작업에 대해서 딥다이브를 해보니 브라우저가 정말 많은 기술의 집합체였구나를 깨달았다. 하긴 그렇게 쉬우면 다 만들었지..
아무튼 이번 기회를 통해 브라우저의 렌더링 과정을 이해하면서 캔버스를 활용할 때 좋은 배경 지식이 생긴 것 같아 나름 만족스럽다.
지금 쓴 것도 나름 축약해서 정리한 것이긴 한데, 나중에 시간이 된다면 보다 더 면밀하게 살펴볼 예정이다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://d2.naver.com/helloworld/5237120" target="_self">https://d2.naver.com/helloworld/5237120</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.chrome.com/blog/inside-browser-part3" target="_self">https://developer.chrome.com/blog/inside-browser-part3</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://so-so.dev/web/browser-rendering-process/" target="_self">https://so-so.dev/web/browser-rendering-process/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.chrome.com/docs/chromium/blinkng#composite-after-paint-pipelining-paint-and-compositing" target="_self">https://developer.chrome.com/docs/chromium/blinkng#composite-after-paint-pipelining-paint-and-compositing</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://onlydev.tistory.com/82" target="_self">https://onlydev.tistory.com/82</a>]]></description><link>부스트캠프/멤버십/8주차/브라우저의-렌더링과-캔버스.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/브라우저의 렌더링과 캔버스.md</guid><pubDate>Sun, 03 Nov 2024 14:45:40 GMT</pubDate><enclosure url="https://i.imgur.com/Wk5GFIn.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/Wk5GFIn.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그룹프로젝트 1주차_마스터 클래스]]></title><description><![CDATA[팀 스포츠를 시작한다고 할 때
첫 시작 -&gt; 기본 동작 -&gt; 트레이닝 -&gt; 포지션 역할 -&gt; 미니게임 -&gt; 실전 게임혼자가 아니라 그룹이 하는 프로젝트
새롭게 시작하는 기간에서는 그룹이 같은 목표를 위해 달려야 함그랬을 때 프로젝트를 성공하는 방법?
프로젝트의 완성도에 대한 부담감 낮추기
프로젝트 -&gt; 상받아야 하고, 경쟁하는 것이 아님
프로젝트에서 남는 것은 내가 무엇을 고민하고, 어떻게 해결하고, 협업하는 경험의 과정이 남는 것이니 결과를 의식해서 성공하기만 하려고 하지 않기프로젝트는 상황에서 최선의 선택을 하면 좋은 것임
개발자만 가지고 돌아가는 프로젝트가 아님
스스로 여러 역을 해야 함
팀을 위해서 결정, 싫은 일 하기학계 vs 업계
이론 vs 실무
일하는 방법은 software engineering을 통해 배울 수 있음
일하는 방법이기 때문에 이론적인게 정립이 되기 전에 회사에서 어떻게 시도해보고 하는 것이 더 먼저 되는 것이 많음. 케이스로 정리가 되는 경우는 이렇게 운영해서 어떻게 됐더라 하는 식의 결과가 나오는 경우가 많음
이론적으로 배울 때 업계는 다른 방식을 시도하고 있을 수 있음. 이 자체가 현업에서 모두가 일하지 않는다는 사실 기억하기. 그래서 꼭 이론을 지켜야 할 필요가 없음
닫힌 생각보다는 열린 생각으로!

프로젝트에서는 우리끼리 결정을 해야 하는 것들이 많음. 의견 대립이 있을 수도 있지만 이게 싸우는게 아니라 우리들의 활동을 하기 위해서 우선적으로 해야 할 것이 무엇인가?에 대해 정리하기
-&gt; 그라운드 룰
어떤 시도가 필요한지 함께 결정하기
태도나 말투, 응답 등으로 신뢰가 쌓이기 전에 깨짐
같은 팀에서 작성한 것 같은 코드가 남아야 함
비슷비슷한 코드가 나와야 함
브랜치 전략, 일감의 관리공동의 목표 세우기
개인의 책임도 있지만 공동의 책임도 있기 떄문에 역할 분담 잘 하기
프로젝트에서 몰아주는 것이 아니라 서로 다 해보기
모두 프로젝트에 주인의식 가지기<img src="https://i.imgur.com/u6TAxmH.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
waterfall로 동작하도록 하는 것이 좋지 않음
단계가 불필요한게 아니라 어떤 단계를 어떻게 거치는지가 중요
폭포수의 문제는 위에서 물이 가득 차야 떨어짐
각 단계가 끊어져 있는 경우가 많음
모든 단계가 이어져 있음을 기억하기
기획/요구사항(1주차까지 결정하기)
시스템 구성도(아키텍처 뷰) -&gt; 전체 구성, 서버 구성, 앱 구조 등 전체 큰 그림을 그려서 함께 공유
그 뒤에 어떻게 만들지를 설계 핵심 기능별 동작 흐름 + API 문서 동작 흐름을 가지고 동작 상세 기능 목록(백로그)
- 중요<br>
- 세 단계로 나눠짐(에픽, 스토리, 태스크)<img src="https://i.imgur.com/EW9rovF.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
- 계속해서 명확화와 구체화 시키고 이를 제품으로 만들기
- 요구사항을 구체적으로 어떻게 구현하고 동작하게 만들지를 만들어가는 과정
0은 할 수 있는 정도만 하고 1,2,3에 투자하기!
<br><img src="https://i.imgur.com/ZpzckIB.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
코드를 구현하기 전에 건물을 멀리서부터 가까이 보는 것처럼 아키텍처를 볼 수 있음할 일을 정해서 PBI(Product Backlog Items) 만들기
팀원 전체의 목표를 공유하고 멋진 세부적인 계획을 세운다
epic -&gt; story -&gt; task<br><img src="https://i.imgur.com/72drGid.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
제품 백로그: 해야 할 일들을 다 써놓은 것들
스프린트 백로그: 이번주에 할 일들큰 덩어리를 쪼개서 story를 나누고(A) 예상시간 추정하기(B)
스프린트 기간을 넘어가게 된다면 다음주로 넘겨야 되겠구나 등을 계획하기 위해 예상 시간을 정해놓기<br>
<img src="https://i.imgur.com/udMPQeI.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
주어 동사 목적어를 한 문장으로 써 놓은 것이 스토리
사용자가 있고 무엇을 해야 하는지 문장으로 표현
주어 동사 목적어가 있는 문장 형태면 오해하지 않고 이해할 수 있기 때문<br><img src="https://i.imgur.com/VSV90g6.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
요구 사항은 다소 불명확함
누가 무엇을 정확히 쓰기<br>
<img src="https://i.imgur.com/cpvytXv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
동작 하나를 위해서 프론트, 백에서 필요한 것들을 모두 쓰기작업을 다 할 수 있는지 예측해보기
태스크 단위로 예측하는 이유는 너무 크면 이게 언제 끝날지 예측하기 어려움
일감 단위로 작업 시간 예측하기
time-boxed 일감 두기
주어진 시간 내에 할 수 있는가 판단하기
스펙을 버릴 것인가 선택하기 선택과 집중하기 배포를 미룰 것인가 선택하기 금요일날 매주 배포 팀 개발 속도를 측정할 수 있는가
안해본 일들의 경우 예측하기가 매우 어려움 + 사람마다 예측하는 정도가 모두 다름
-&gt; 예측 시간을 정할 때 플래닝 포커 등을 해보기
크거나 작다고 예측하는 사람에게 서로의 의견 나눠보기어떻게 해야 끝났는지가 명확해야 함
-&gt; 인수 조건 Acceptance Criteria 확인해야 하는 사항들
모든 단계에서 실수를 하기 때문에 확인하는 단계가 꼭 필요한데 이를 의식적으로 해야 함
설계도 확인하기<br>
<img src="https://i.imgur.com/LYYrISF.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/tkUet0g.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
어떻게 완료할 것인지를 꼭 적어놓기<br><img src="https://i.imgur.com/ea15kiA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
기능 요구사항들이 있는데 이는 테스트하기 쉽지만, 신뢰, 사용, 효율성 등 비기능 요구사항들이 숨겨져 있음<br><img src="https://i.imgur.com/DjdZIvd.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
개발 팀에서 필요한 요구사항을 어떻게 구현할 것인지에 따라서 스토리에 가까운 테스트케이스
우리 팀의 절차와 인프라에서 하는 것들을 종합적으로 고려해서 선택<br>
<img src="https://i.imgur.com/KUjMowW.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/hPh3cOL.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
현황판 만들어서 관리하기<br><img src="https://i.imgur.com/5UNuT4g.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
감정적인 상태를 공유하기<br>
<img src="https://i.imgur.com/to5AuVe.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
프로젝트에 역할을 줬는데 상황공유 안하다가 못할 것 같다는 식으로 하지 않기
배포를 못하는 상태로 개발 X 개발할 수 있는 상태로 꾸준히 개발하기
기능을 조금 만들더라도 계속 배포해서 실제 사용자처럼 사용해보기<br><img src="https://i.imgur.com/3p72xsT.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
회고를 하는 목적 -&gt; 팩트 중심으로 쓰는 것도 중요하지만 근데 그게 왜 내가 의도했던 것과 달라졌는지, 방해요소, 실패 요인 등에 대해 팀 관점에서 같이 분석
특정 사람을 비난하는 것이 아니라 다 같이 이후에 더 잘 할 방법을 찾기<br>
<img src="https://i.imgur.com/EDRo7Ip.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/kvNNEap.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">waterfall처럼 모든 단계가 끊어져 있지 않고
다시 수정해야 하는 일들이 많아짐
대부분 앞 단계에서 실수를 하게 됨<br><img src="https://i.imgur.com/exanOJ4.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
무조건 완벽하게 하는 것보다 만들어 가면서 개선하기<br><img src="https://i.imgur.com/RHP5eqC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
스크럼의 용어와 방식을 무조건 따르는 것이 아니라 공동의 목표를 세워놓고 그것을 잘하기 위해서 공유하고 개선<br><img src="https://i.imgur.com/1ZYLgyV.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
점진적으로 더 잘하게 만드는 방법
뒤에 가서 고치려고 하면 힘듦
이걸 줄여서 1-2주 안에 할 수 있는 만큼만 하자맨먼스 미신
사람이 많아질수록 커뮤니케이션 비용은 점점 증가한다
소통해야 하는 일들이 많아지기 떄문
업무 시간
일주일 내내 개발 할 수 없음
회사 가서도 비슷함
빠른 피드백 고리와 점진적 개선 + 자동화 도구 활용<br><img src="https://i.imgur.com/BYM6Cwu.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
품질을 어느정도로 유지할 지에 대해서 합의가 필요<br><img src="https://i.imgur.com/P5QLRHZ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/vxJmVIx.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/rbhRaUz.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">데이터 통신 -&gt; swr
http 캐싱 표준
라이브러리의 이름을 swr로
라이브러리의 핵심 -&gt; 캐싱
라운드 트립 : 클라이언트와 서버가 주고받는 시간은 방해가 되기 때문에 웹의 최대 단점이 됨
캐시 컨트롤 -&gt; 60초 동안은 신선한 상태라서 캐시 사용(max-age:60)
60-120초 사이의 구간(stale-while-revalidate=120)
Nginx에서 SWR를 설정하려면 Cache-Control 헤더를 다음과 같이 추가const {data,isLoading} = useQuery({ queryKey: ['todos'], queryFn: fetchTodos, cacheTime: })
컴포넌트 간 상태 공유와 자동 업데이트
props로 전달
context API 활용
Redux등 외부 상태관리 라이브러리
React Query는 queryKey를 기반으로 데이터를 캐싱
동일한 queryKey를 사용하는 컴포넌트들끼리는 상태를 자동으로 공유하고 최신 상태로 동기화
useQuery는 구독을 의미. 처음 실행할 때는 옵저버 생성하는 개념
서버상태의 핵심 -&gt; 캐시 데이터
옵저버는쿼리 객체를 구독하고 쿼리의 상태 변화 감시
컴포넌트는 옵저버를 구독하여 쿼리의 상태 변화를 반영하고 필요할 때 리렌더링
querykey 배열의 두번째 요소는 해당 데이터의 의존성
이 값이 변경되면 queryFn이 다시 실행되어 re-fetching됨
useQuery한 결과를 다시 클라상태(useState)로 보관할 필요 없음mutation -&gt; 데이터를 변경 -&gt; invalidate시키기
원래는 데이터를 업데이트하면 응답을 받아오고 post-&gt;get요청을 다시 함
새롭게 업데이트 되면 이를 구독하고 있는 컴포넌트들이 모두 리렌더링됨querykey로 구독해서 리렌더링을 시킬 수 있다는 점이 큰 장점
이미 SWR 방법이 캐시에 특화되어있음
라이브러리가 개념을 가져와서 사용하고 있음
fetching 결과를 캐시할까
브라우저에는 cache api가 따로 있기도 함로딩중, 성공, 실패의 상태 관리
useActionState -&gt; 폼 처리를 용이하게 하면서 비동기 상태를 쉽게 지원에러 핸들링
useState로 에러 상태를 설정
Error boundary
React Query의 onError
Error Boundary + React Query(throwOnError 속성)
최신 데이터가 아니면 사용자 경험에 문제가 발생할 수 있으므로 특정 조건에서 자동으로 데이터를 리페칭이 필요할 때마다리액트에서는 포커스가 변경되거나 네트워크가 재연결될 때마다 데이터를 수동으로 갱신하도록 설정
addEventListener -&gt; focus, online에 fetchData 달기
ReactQuery -&gt; refetchOnReconnect대량의 데이터를 한번에가져오는 것은 성능 저하
페이징 및 무한 스크롤과 같은 UX를 통해 필요한 데이터만 부분적으로 불러오기
리액트에서는 -&gt;현재 페이지 상태를 관리하고 페이지가 스크롤이나 페이징에 따라 변경되면 새로운 데이터를 가져와 이전 데이터에 추가
스크롤하는 타이밍에 가져오기
화면에 그 부분이 보이느냐를 IntersectionObserver를 통해 보고 관리
Throttling(스크롤이벤트 제어)클라이언트에서 데이터를 추가/삭제 등 수정할 경우 서버와의 동기화 필요
post 요청 후에 다시 get 요청을 보내기
React Query의 경우에는 invalidateQueries를 통해 다시 갱신해서 캐시 업데이트를 할 수 있도록 함갔다가 오고 ok받고 다시 리스트 요청해서 받고 하는 과정이 오래걸림
-&gt; 받는 타이밍에 받는 화면에 업데이트 시켜버리기(낙관적 업데이트)미리 페이지 로드 시점에 데이터를 가져오고 getData에서 캐시된 데이터를 가져올 수 있으면 바로 가져오기
3번 페이지 보고 있다가 4번 페이지를 미리 로드시켜놓고 페이지를 선택하면 바로 데이터를 가져와서 사용
-&gt; UX에 도움. 반응성을 높여줌리액트의 prefetchQuery 사용경량 상태 관리라이브러리 zustand
컴포넌트 간의 상태를 중앙에서 관리하고 컴포넌트가 필요할 때 상태를 직접 구독
create 함수 내부에서 비동기 호출
데이터 로드 이후 set 메서드를 통해 상태를 업데이트
상태 저장 및 구독
useStore를 호출하여 상태를 구독하고 사용 회의의 내용을 문서화함으로써 서로의 커뮤니케이션이 틀리지 않았는지를 확인
기록에 대해서 서로가 이를 확인하는 습관 가지기
일종의 증거자료로 활용해야 할 필요성이 있음
문서화에 대한 이야기를 해놔야 서로의 생각이 달랐네를 확인할 수 있음]]></description><link>부스트캠프/멤버십/1주차/그룹프로젝트-1주차_마스터-클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/그룹프로젝트 1주차_마스터 클래스.md</guid><pubDate>Fri, 01 Nov 2024 08:22:16 GMT</pubDate><enclosure url="https://i.imgur.com/u6TAxmH.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/u6TAxmH.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[canvas에서의 드래그앤드롭]]></title><description><![CDATA[html 캔버스의 경우 해당 프레임마다 새롭게 그려야 하는 특성이 있음
기존의 html과는 다르게 캔버스 내의 어떤 요소를 움직이게 된다면, 새롭게 그려내지 않고 요소만을 움직였을 때, 기존의 요소가 해당 위치에 그대로 남아 잔상이 생기는 문제 발생
이를 해결하기 위한 방법으로 새롭게 계속 캔버스를 그려내야 함그렇다면 캔버스에서의 드래그 앤 드롭은 어떻게 이루어 지는가?
캔버스에 onmousedown 이벤트를 걸어놔야 할 필요성이 있음
캔버스는 그려진 요소에 대해 직접적으로 접근이 불가능함
그려진 요소에 접근하기 위해서는 event 객체가 반환하는 clientX와 clientY를 받아 이를 활용하여 요소 안에 접근하는지를 확인해야 할 필요성이 있음하나의 직사각형이 {x: 200, y:50, width: 200, height: 200} 이고, 이 직사각형을 캔버스의 (0,0) 좌표에 그린다고 가정
그려진 직사각형은 (0,0)부터 (200, 50)까지의 범위를 차지하고 있음
그렇다면 해당 요소를 클릭하는지 확인하는 방법은 캔버스에 mousedown 이벤트가 발생할 때, 이벤트가 발생한 clientX와 clientY가 직사각형의 범위 내에 있는지 좌표로 계산해야 함
clientX는 0~200 사이에 있어야 하고, clientY는 0부터 50 사이에 있어야 함
이를 판단하는 함수를 따로 만들고 boolean값으로 구별한 뒤에, 요소 안에 있으면 드래그앤드롭 이벤트가 작동할 수 있도록 해야 함]]></description><link>부스트캠프/멤버십/8주차/canvas에서의-드래그앤드롭.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/canvas에서의 드래그앤드롭.md</guid><pubDate>Thu, 31 Oct 2024 03:56:50 GMT</pubDate></item><item><title><![CDATA[그룹 프로젝트_1주차]]></title><description><![CDATA[<a data-href="그룹프로젝트 1주차_마스터 클래스" href="부스트캠프/멤버십/1주차/그룹프로젝트-1주차_마스터-클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">그룹프로젝트 1주차_마스터 클래스</a>
그룹프로젝트는 우리들의 몫
멘토님이 대부분 듣기만 하실 것임
검토 요청을 해주시는 역할
겪었던 경험들을 많이 공감될 수 있으니까 전달해주시도록 하겠음
목요일 7~8시까지 그룹 멘토링 진행
노션의 경우는 너무 어려울 것 같고 필요에 의해서 하는게 아니다 보니까 나중에 조금 흔들릴 것 같다
아이디어를 수렴하는 회의
하나의 아이디어를 정해야 할 떄는 중재를 해서 돌아오는 역할을 하는 사람이 있어야 함
아이디어를 발산하는 회의
자유롭게 여러 의견을 내놓을 수 있는 환경
주제만 정해도 어느정도 괜찮다고 생각
주제를 정하고 히스토리를 가져(왜 이런 주제, 아이디어가 나오게 된 이유, 어떤 식으로 발전, 어떤 것을 얻을 것인지)
내일도 만나는데 주제를 정해야 한다는 업무적인 생각 보다는 친해지는 시간을 갖는 것도 좋을 것 같다.
여러명의 프로젝트를 하다보면 모두가 속도가 다르기 때문에 한 명이 뒤쳐질 수 있음. 그렇다고 그 사람을 두고 나머지 사람을 두고 가면 네 명이 다 완주를 할 수 없음. 네명이 다 완주하기 위해선 제일 앞에 있는 사람이 뒤로 가서 도와주자
]]></description><link>부스트캠프/멤버십/그룹프로젝트-1주차/그룹-프로젝트_1주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/그룹프로젝트 1주차/그룹 프로젝트_1주차.md</guid><pubDate>Mon, 28 Oct 2024 10:17:08 GMT</pubDate></item><item><title><![CDATA[React Query]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://tech.kakaopay.com/post/react-query-1/#user-content-fn-2" target="_self">https://tech.kakaopay.com/post/react-query-1/#user-content-fn-2</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://musma.github.io/2023/09/14/react-query.html" target="_self">https://musma.github.io/2023/09/14/react-query.html</a>]]></description><link>부스트캠프/챌린지/react-query.html</link><guid isPermaLink="false">부스트캠프/챌린지/React Query.md</guid><pubDate>Sat, 26 Oct 2024 17:44:03 GMT</pubDate></item><item><title><![CDATA[React 19 베타에서 새롭게 추가된 것들]]></title><description><![CDATA[React 19가 2024년 4월 25일 베타버전이 나오게 되었다.
여기에 대해서도 조금 더 자세히 알아보고 이를 어떻게 활용하면 좋을지 생각하기 위해 새롭게 추가된 주요 기능들을 정리해 보려고 한다.리액트에서 말하는 Actions는 비동기적인 작업의 수행을 의미한다. 그렇다고 일반적인 data를 가져오기 위한 fetching이 아니라, form에 대한 action과 같이 사용자의 상호작용에 따라 비동기적으로 http 요청을 보내는 등의 작업을 정의한 것으로 보인다.
React 19는 이러한 Actions에 대해 정의하고 이를 기반으로 구축되었다. 따라서 이를 통한 여러가지 기능들이 추가되었다.이전까지의 비동기적으로 http 요청을 보내고 받아서 응답에 따라 뷰를 렌더링 하는 방식으로 많이 사용했었다.// Before Actions
function UpdateName({}) { const [name, setName] = useState(""); const [error, setError] = useState(null); const [isPending, setIsPending] = useState(false); const handleSubmit = async () =&gt; { setIsPending(true); const error = await updateName(name); setIsPending(false); if (error) { setError(error); return; } redirect("/path"); }; return ( &lt;div&gt; &lt;input value={name} onChange={(event) =&gt; setName(event.target.value)} /&gt; &lt;button onClick={handleSubmit} disabled={isPending}&gt; Update &lt;/button&gt; {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;} &lt;/div&gt; );
}
따라서 이를 위한 isPending, error와 같은 state가 필요했다. data fetching하는 로직의 경우에는 사용자 경험을 위해서 로딩 상태와 에러 상태를 기록하는 것은 중요한 관심사였다.이에 fetching에서는 항상 loading과 error의 상태를 관리하는 로직 자체가 반복이 되다보니 과거에는 useFetch라는 커스텀 훅을 만들어 이를 다양한 api fetching에 활용했었다.import { useState, useEffect } from 'react'; type Status = 'initial' | 'pending' | 'fulfilled' | 'rejected'; interface UseFetch&lt;T&gt; { data?: T; status: Status; error?: Error;
} export const useFetch = &lt;T&gt;( fetchFunction: (...args: any[]) =&gt; Promise&lt;T&gt;, ...args: any[]
): UseFetch&lt;T&gt; =&gt; { const [state, setState] = useState&lt;UseFetch&lt;T&gt;&gt;({ status: 'initial', data: undefined, error: undefined, }); useEffect(() =&gt; { let ignore = false; const fetchData = async () =&gt; { setState({ ...state, status: 'pending' }); try { const data = await fetchFunction(...args); if (!ignore) { setState({ status: 'fulfilled', data }); } } catch (error) { if (!ignore) { setState({ status: 'rejected', error: error as Error }); } } }; fetchData(); return () =&gt; { ignore = true; }; }, [fetchFunction]); return state;
}; 이를 통해서 코드의 재사용성이나 가독성을 더 높일 수 있었다.
React 19에서는 이러한 비동기 처리 코드에 대해서 useTransition에서 pending상태를 리액트 내부에서 관리할 수 있도록 해주어 로딩 상태에 대해서 따로 상태로 선언하여 관리할 필요성이 줄어들었다.// Using pending state from Actions
function UpdateName({}) { const [name, setName] = useState(""); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const handleSubmit = () =&gt; { startTransition(async () =&gt; { const error = await updateName(name); if (error) { setError(error); return; } redirect("/path"); }) }; return ( &lt;div&gt; &lt;input value={name} onChange={(event) =&gt; setName(event.target.value)} /&gt; &lt;button onClick={handleSubmit} disabled={isPending}&gt; Update &lt;/button&gt; {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;} &lt;/div&gt; );
}
비동기 함수가 실행되면서 isPending은 즉시 true값으로 바뀌고 비동기 처리가 일어난 후에는 다시 false값으로 바뀐다. startTransition을 통해 렌더링의 우선순위를 낮추어 isPending에 대한 리렌더링을 우선적으로 수행한 후에 비동기 작업을 처리함으로써 보다 상호작용이 가능하고 반응형이 될 수 있는 UI가 될 수 있다.이러한 Actions에 대해서 보다 범용적이고 쉽게 사용될 수 있도록 React 19에서는 useActionState라는 훅을 새롭게 추가했다.const [error, submitAction, isPending] = useActionState( async (previousState, newName) =&gt; { const error = await updateName(newName); if (error) { // You can return any result of the action. // Here, we return only the error. return error; } // handle success return null; }, null,
위에서 본 useFetch와 비슷하게 useActionState가 작동하고 있음을 볼 수 있다. 이 actionState는 기존에 ReactDOM.useFormState로 사용되었지만 현재는 deprecated되고 useActionState로 이름이 바뀌어 나오게 되었다.
인자로 콜백 함수가 들어가며, 래핑된 상태로 action이 반환된다. 이를 통해 사용자의 action에 대해서 로딩, 에러 상태 처리를 위한 코드를 보다 간편하고 가독성 있게 작성할 수 있다.&lt;form action={actionFunction}&gt;
form에 대한 액션 처리는 이전까지만 해도 쓰기가 어려운 부분이 있었다. form에 대한 action을 처리하는 방법은 onSubmit과 같은 방법을 통해 이벤트를 처리했지만, action이라는 어트리뷰트를 추가하여 여기에 action에 대한 핸들러 함수를 넣게 된다면 form 자체 뿐만 아니라 input, button요소의 action과 formAction 프로퍼티로 넘겨줄 수 있다.&lt;form&gt;은 action이 성공했을 경우에 제어되지 않은 컴포넌트에 대해 form을 재설정한다. action 뿐만이 아니라 따로 수동으로 form을 초기화 할 때는 requestFormReset이라는 새로운 React DOM API를 통해서 폼을 초기화시킬 수 있다.form의 상태를 보고 이에 대한 처리를 하기 위해서는 다른 버튼과 같은 컴포넌트 요소들에게도 따로 props를 내려줘서 이에 대한 상태를 처리해야 했다.
이전까지의 경우 그대로 props로 받아 내려주거나, useContext훅을 사용하여 내려주고, 이를 컴포넌트에서 받아 사용할 수 있었다.이번에 React 19에서는 이러한 부분에 대해 useFormStatus라는 새로운 훅을 추가하여 props를 직접 내려받거나 context api를 사용할 일 없이 폼 하위의 요소들에서 useFormStatus 훅을 실행시키면서 부모 폼에 대해서 pending state를 받을 수 있게 되었다.import {useFormStatus} from 'react-dom'; function DesignButton() { const {pending} = useFormStatus(); return &lt;button type="submit" disabled={pending} /&gt;
}
데이터의 변경이 이루어질 때 UI 패턴에서 많이 이루어지던 방식이 낙관적 업데이트이다. 낙관적인 업데이트는 서버로 보낸 요청이 정상적일 것이라고 예상하고,&nbsp;클라이언트의 요청에 대한 응답이 오기 전에 클라이언트의 데이터를 미리 변경시키는 작업을 말한다.
이러한 낙관적 업데이트의 경우는 React에서 없었던 기능이었기에 React Query를 이용하여 사용하였다. 하지만 React 19에서 새롭게 useOptimistic 훅이 추가되어 이를 사용하여 낙관적 업데이트를 할 수 있다.function ChangeName({currentName, onUpdateName}) { const [optimisticName, setOptimisticName] = useOptimistic(currentName); const submitAction = async formData =&gt; { const newName = formData.get("name"); setOptimisticName(newName); const updatedName = await updateName(newName); onUpdateName(updatedName); }; return ( &lt;form action={submitAction}&gt; &lt;p&gt;Your name is: {optimisticName}&lt;/p&gt; &lt;p&gt; &lt;label&gt;Change Name:&lt;/label&gt; &lt;input type="text" name="name" disabled={currentName !== optimisticName} /&gt; &lt;/p&gt; &lt;/form&gt; );
}
위의 예시를 볼 때, useOptimistic을 실행하면 낙관적 업데이트를 시킬 상태와 이 상태를 조작하는 setter 함수를 반환한다. optimisticName를 사용하여 action이 일어남과 동시에 setOptimisticName을 통해 기존의 데이터를 업데이트가 일어난 후의 데이터로 바꿔주면 그 즉시 렌더링에 반영된 후, action에 대한 비동기 요청이 이루어진다. 만약 이 과정에서 비동기 요청이 실패하거나 끝났을 경우, optimisticName는 다시 setter함수를 실행하기 전, 즉 newName에서 currentName으로 돌아가게 된다.React 19에서는 렌더링에서 리소스를 읽을 수 있는 use라는 새로운 API를 도입했다.
use중인 Promise를 읽으면 Promise가 resolve 될 때까지 React는 Suspend, 즉 중단 상태로 기다린다. import {use} from 'react'; function Comments({commentsPromise}) { // `use` will suspend until the promise resolves. const comments = use(commentsPromise); return comments.map(comment =&gt; &lt;p key={comment.id}&gt;{comment}&lt;/p&gt;);
} function Page({commentsPromise}) { // When `use` suspends in Comments, // this Suspense boundary will be shown. return ( &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;Comments commentsPromise={commentsPromise} /&gt; &lt;/Suspense&gt; )
}
따라서 use를 사용하는 컴포넌트는 렌더링을 하지 않고 Promise가 resolve될 때까지 기다린 다음에 resolve가 되면(Promise가 fulfilled된 상태) 그때부터 렌더링을 하기 시작한다.그렇기 때문에 선언적 프로그래밍이 가능해지고, 이는 곧 가독성과 유지보수성을 높여준다. 선언적 프로그래밍
무엇을(WHAT) 나타내야 하는지를 프로그래밍적으로 표현하는 것
어떻게(HOW) 나타내야 하는지를 프로그래밍적으로 표현하는 명령형 프로그래밍보다 한 단계 더 추상화된 프로그래밍 방식
무엇보다 이 use가 쓸만하다고 느낀 점은 Suspense와 합쳐졌을 때이다.
기존의 Suspense의 경우는 데이터를 fetching하는 컴포넌트의 모듈에서 Promise를 throw하고, Suspense가 이를 받아 Promise가 resolve되지 않은 상태면 fallback 프로퍼치에 들어가 있는 UI를 렌더링하고, resolve된 이후에는 선언형으로 작성된 코드에 데이터를 넣어 렌더링만 하는 방식으로 활용했었다.export function fetchData&lt;T&gt;(fn: Promise&lt;T&gt;): { read: () =&gt; T } { let status = "pending"; let result: T; const suspender = fn.then( (r) =&gt; { status = "success"; result = r; }, (e) =&gt; { status = "error"; result = e; }, ); function read() { switch (status) { case "pending": throw suspender; case "error": throw result; default: return result; } } return { read };
}
그래서 이런 식으로 fetchData라는 함수를 따로 만들어 활용하는 방식으로 했었지만 함수형 컴포넌트 안에 들어가게 된다면 무한루프가 돌게 되기 때문에 바깥쪽에서 가져와야만 했다.const response = getHeadlines();
export default function ShortNews() { const headlines = response.read(); return ( &lt;div&gt;...&lt;/div&gt; )
}
이런 식으로 바깥쪽에서 함수를 실행하고 read 함수를 통해 데이터를 가져오는 방법도 있고&lt;Suspense fallback={&lt;p&gt;사용자 정보 로딩중...&lt;/p&gt;}&gt; &lt;User resource={fetchData("1")} /&gt;
&lt;/Suspense&gt;
...
function User({ resource }) { const user = resource.user.read(); return ( &lt;div&gt; &lt;p&gt; {user.name}({user.email}) 님이 작성한 글 &lt;/p&gt; &lt;Suspense fallback={&lt;p&gt;글목록 로딩중...&lt;/p&gt;}&gt; &lt;Posts resource={resource} /&gt; &lt;/Suspense&gt; &lt;/div&gt; );
} 이런 식으로 아예 함수를 실행한 결과를 컴포넌트의 props로 넘겨주는 방식도 있다.나 또한 waterfall 현상과 같은 부분을 해결하고 지긋지긋한 useEffect-fetchData의 늪에서 벗어날 수 있다는 점에서 좋은 기능이라고 생각했지만 이런 식으로 데이터를 가져오는 방식이 정말 마음에 들지 않았다. 선언형 프로그래밍으로 가독성은 높아졌지만, 코드의 흐름이 원래 알던 방식과는 달라서 불편했다.
waterfall 현상
UI가 마치 폭포처럼 위에서 아래로 순차적으로 나타나는 현상
상위 컴포넌트의 렌더링이 끝난 후에 하위 컴포넌트의 렌더링이 시작되기 때문에 발생하는 현상
react Query를 쓸 수도 있겠지만 이제까지 react Query를 쓰지 않은 내 입장에서는 use의 기능 추가가 매우 반가웠다!use 안에 Promise, fetching하는 함수를 실행하면 이에 따라 promise가 reosolve 될 때까지 Suspense의 fallback ui가 띄워지기 때문에 보다 코드의 흐름을 명확히 알 수 있다는 점이 좋았다.하지만 use는 맨 처음 렌더링 과정에서 만들어진 Promise에 대해서는 지원하지 않는 특징을 가지고 있다. 따라서 아직은 맨 처음 데이터를 가져올 때만 유용하게 사용될 수 있을 것 같다. 아니면 react-Query와 함께 사용하는 방법도 방법 중 하나가 될 수 있을 것 같다.또 하나 강력한 기능으로, context 또한 use를 통해 읽어오는 것이 가능하다.const ColorContext = createContext(""); function App() { return ( &lt;ColorContext value="blue"&gt; &lt;Form /&gt; &lt;/ColorContext&gt; );
} function Form() { return ( &lt;div&gt; &lt;Button show={true}&gt;True&lt;/Button&gt; &lt;Button show={false}&gt;False&lt;/Button&gt; &lt;/div&gt; );
} function Button({ show, children,
}: { show: boolean; children: React.ReactNode;
}) { if (show) { const theme = use(ColorContext); return &lt;button style={{ backgroundColor: theme }}&gt;{children}&lt;/button&gt;; } return false;
}
컴포넌트의 최상위 레벨에서만 호출해야 하는 useContext의 단점을 보완하고 조건분이나 반복문 내부에서도 사용할 수 있어 보다 유연하게 사용될 수 있으며, 추가적으로 Provider를 쓰지 않고도 context를 내려줄 수 있는 기능 또한 추가되어 use와의 시너지가 잘 맞을 것 같다.React Server Component는 리액트의 새로운 패러다임으로, 기존 클라이언트 사이드 렌더링만 지원하는 React에서 보다 Next.js같이 발전한 방식으로 볼 수 있다.리액트의 서버 컴포넌트는 기존에 CSR 방식으로 운영되던 리액트가 한 번에 모든 리소스를 다운로드 받고 띄워야 하는 만큼 이에 대한 대기 시간이 점차 길어지자 이를 개선하기 위해 설계된 방식이다.사용자와의 상호작용 없이 정적 요소만 담은 컴포넌트의 경우, 훨씬 빨리 컴포넌트를 렌더링할 수 있는 환경인 서버에서 직접 렌더링하는 편이 낫다. 이를 통해
리렌더링의 필요성을 없애 성능 개선
자바스크립트의 번들링 크기 축소
초기 페이지 로드 속도 개선
이외에도 많은 성능적, 사용자 환경적 개선을 기대할 수 있기 때문에 React 또한 next.js처럼 서버 컴포넌트에 대한 지원을 계속 업데이트하고 있다.
React는 서버사이드 렌더링을 지원하기 위해 기존 SSR 서버와는 다른 별도의 서버를 사용했다. 별도의 서버에서 미리 서버 컴포넌트를 렌더링 한 다음, 이를 띄워주는 방식이다. 해당 서버 컴포넌트는 빌드 시 CI 서버에서 한번 실행할 수도 있고, 웹 서버를 사용하여 각 요청마다 새롭게 실행할 수도 있다. import db from './database'; async function Note({id}) { const note = await db.notes.get(id); return ( &lt;div&gt; &lt;Author id={note.authorId} /&gt; &lt;p&gt;{note}&lt;/p&gt; &lt;/div&gt; ); } async function Author({id}) { const author = await db.authors.get(id); return &lt;span&gt;By: {author.name}&lt;/span&gt;; } ```
이런 식으로 함수형 컴포넌트 자체를 비동기 함수로 만든 다음에, 서버에서 데이터를 가지고 와 렌더링하여 사용자와 상호작용 없는 컴포넌트를 빠르게 보여줄 수 있다.
앱이 로드될 때 클라이언트는 사용된 라이브러리를 보지 못하고 오로지 렌더링된 출력물만 볼 수 있기 때문에 상호작용과 상태 관리는 되지 않지만, 상호작용이 필요한 부분과 필요없는 부분을 나누어 서버 컴포넌트와 클라이언트 컴포넌트를 나누어 개발하면 보다 성능이 올라갈 것이다. ```jsx
// Server Component
import db from './database'; async function Page({id}) { // Will suspend the Server Component. const note = await db.notes.get(id); // NOTE: not awaited, will start here and await on the client. const commentsPromise = db.comments.get(note.id); return ( &lt;div&gt; {note} &lt;Suspense fallback={&lt;p&gt;Loading Comments...&lt;/p&gt;}&gt; &lt;Comments commentsPromise={commentsPromise} /&gt; &lt;/Suspense&gt; &lt;/div&gt; );
} ... // Client Component
"use client";
import {use} from 'react'; function Comments({commentsPromise}) { // NOTE: this will resume the promise from the server. // It will suspend until the data is available. const comments = use(commentsPromise); return comments.map(commment =&gt; &lt;p&gt;{comment}&lt;/p&gt;);
}
서버에서 직접 Suspense에 대한 스트리밍이 지원되기 때문에 보다 Suspense가 활용될만한 곳이 많아진 것 같다고 생각한다.
위에 보이는 예시처럼 서버 컴포넌트는 직접 서버에서 비동기 컴포넌트에 대해 fetching하는 함수를 넘겨주고, use를 사용하여 Promise를 인자로 넣음으로써 서버 컴포넌트 안에 클라이언트 컴포넌트가 작동하는 방식으로도 활용이 가능하다.
여기서 suspense 또한 Comments의 부모로 있기 때문에 정상적으로 Suspense fallback UI가 렌더링되고, 클라이언트 컴포넌트에서 비동기적으로 데이터가 들어오면 이에 따라 안쪽 요소를 채우도록 할 수 있다.// Server Component
import Button from './Button'; function EmptyNote () { async function createNoteAction() { // Server Action 'use server'; await db.notes.create(); } return &lt;Button onClick={createNoteAction}/&gt;;
}
"use server" 지시어를 사용하여 서버에서 실행하는 비동기 함수를 서버 컴포넌트에서 사용할 수 있도록 할 수 있다.
위와 같이 액션에 대해서 비동기적으로 처리해야 하는 부분에서 use server를 쓰고, 서버에서 이 액션에 대해 처리할 수 있다.리액트가 컴포넌트를 생성하는 과정에서 이렇게 서버에서 사용하는 비동기 함수를 가져오게 되면 함수에 대한 참조를 Button의 onClick 인자에 넘겨준다. "use server"; export async function createNoteAction() { await db.notes.create();
}
클라이언트 컴포넌트의 경우에는 "use server" 지시어를 사용하는 파일에서 서버 액션을 가져올 수 있다."use client";
import {createNoteAction} from './actions'; function EmptyNote() { console.log(createNoteAction); // {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNoteAction'} return &lt;button onClick={createNoteAction} /&gt;
}
그러면 클라이언트 컴포넌트가 빌드되는 과정에서 함수에 대한 참조를 생성하여 넘겨줌으로써 서버 액션을 사용할 수 있도록 할 수 있다.액션으로 서버 액션을 구성한다는 것이 무슨 뜻일까?
이는 아래의 예시를 보면 어느정도 이해가 가능하다."use server"; export async function updateName(name) { if (!name) { return {error: 'Name is required'}; } await db.users.updateName(name);
}
...
"use client"; import {updateName} from './actions'; function UpdateName() { const [name, setName] = useState(''); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const submitAction = async () =&gt; { startTransition(async () =&gt; { const {error} = await updateName(name); if (!error) { setError(error); } else { setName(''); } }) return ( &lt;form action={submitAction}&gt; &lt;input type="text" name="name" disabled={isPending}/&gt; {state.error &amp;&amp; &lt;span&gt;Failed: {state.error}&lt;/span&gt;} &lt;/form&gt; ) }
예시에서는 "use server" 지시어를 사용하여 updateName이라는 서버 액션을 만들었다. 이 서버 액션의 경우 직접적으로 db에 접근하여 이름을 수정하는 로직이 담겨있다.
아래 "use client"를 사용한 코드에서는 안에서 submitAction이라는 액션을 하나 더 만들었다. 이 액션은 클라이언트에서 서버와의 데이터 통신에 한 겹 더 래핑한 구조를 가지고 있다. 추가적으로 비동기적으로 동작하는 서버 액션에 대해 에러 상태와 pending 상태를 추가하기 위해서 error라는 state와 useTransition을 통해 pending 상태를 관리하고 있다. 이를 통해 서버 액션에 대해 pending 상태에 접근할 수 있기 때문에 이런 식으로도 액션을 둘 다 활용하여 로직을 더 보완할 수 있다.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.jeong-min.com/64-react-19-use/" target="_self">https://www.jeong-min.com/64-react-19-use/</a>]]></description><link>부스트캠프/챌린지/react-19-베타에서-새롭게-추가된-것들.html</link><guid isPermaLink="false">부스트캠프/챌린지/React 19 베타에서 새롭게 추가된 것들.md</guid><pubDate>Sat, 26 Oct 2024 17:36:59 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 요격 시스템]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/181188" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/181188</a>A 나라와 B 나라 간에 전쟁중에 A는 x축에 평행한 미사일을 발사하고, B 나라는 이를 수직으로 요격한다.
조건은 미사일의 양 끝에서는 요격을 할 수 없다는 조건만 붙어있고, 미사일의 개구간 (s,e) 사이의 값이라면 어느 곳이든 가능하다.아무튼 A 나라에서 미사일을 여러발 쏠 때, 이를 요격할 수 있는 최소한의 미사일 수를 구하는 문제이다.<br>
<img src="https://i.imgur.com/UzM9He1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이런 식으로 B가 최대한 많은 미사일을 요격할 수 있는 x좌표를 구하고, 이를 위해 최소 몇 개의 미사일이 필요한 지에 대해서 구해야 한다.맨 처음에는 2차원 배열로 기록한 다음에 열마다 확인하려고 했는데, 이 경우에는 targets의 길이가 500,000의 길이까지 커질 수 있고, 개구간 (s,e)는 100,000,000까지 갈 수 있으므로 배열로 풀기에는 너무 많은 메모리와 시간이 소모되어 불가능 할 것 같다. 최대한 많은 미사일을 한 번에 요격할 수 있어야 한다.
그렇다면 최대한 많은 미사일들이 지나가는 x좌표를 그때마다 선택하게 된다면 최소한으로 필요한 요격 미사일을 구할 수 있을 것 같다.
그렇다면 가장 많은 곳을 지나는 미사일 구간을 어떻게 찾느냐가 문제인데,,, 여전히 1억개의 구성 요소를 지닌 배열을 만들기에는 부담이 있다. 이를 배열이 아닌 다른 방식으로 풀 수 있는 방법이 있을까?
라는 생각에 그냥 처음에 sort로 s를 기준으로 한 오름차순 정렬을 한 뒤에 순차적으로 가면서 최대한 많이 미사일을 요격할 수 있는 방법으로 범위를 조정하면 되지 않을까? 생각했다.function solution(targets) { let missile = 0; let start = 0; let end = 0; targets.sort((a,b) =&gt; a[0] - b[0]) targets.forEach((target) =&gt; { if(end &lt;= target[0]) { missile++; start = target[0]; end = target [1]; } else{ if(start &lt; target[0]) start = target[0]; if(end &gt; target[1]) end = target[1]; } }) return missile
}
그래서 forEach로 요소들을 돌면서 미사일이 최대한 많이 요격할 수 있도록 미사일이 쏠 수 있는 범위를 start, end 따로 선언하여 미사일을 돌 때마다 조정했으며, 조정할 수 있는 범위를 넘겼을 경우에는 필요한 미사일이 하나 더 추가된다고 판단하여 이 때 미사일의 개수를 올려주었다.<br><img src="https://i.imgur.com/JLxRO1M.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
요격성공]]></description><link>알고리즘/[프로그래머스]-요격-시스템.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 요격 시스템.md</guid><pubDate>Sat, 26 Oct 2024 10:18:38 GMT</pubDate><enclosure url="https://i.imgur.com/UzM9He1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/UzM9He1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Concurrent mode]]></title><description><![CDATA[동시성 모드(concurrent mode)는 한 가지 일이 끝날 때 까지 무조건 다음 작업을 기다리는 것이 아닌, 한 가지 일이 실행 중일 동안 다른 일을 수행하는 것을 의미한다.
그렇다면 이 동시성(concurrency)이 병행성(parallelism)과 같은 의미를 가진 동의어가 아닌가? 라고 생각할 수 있겠지만 둘이 말하는 작업의 동시성은 조금 다르다.동시성의 경우 한 가지 일이 무조건 끝날 때까지 기다리는 것이 아니라, 그 사이에 다른 일을 할 수 있으면 하는 것이다.
반면 병행성의 경우는 동시에 두 가지 이상의 일을 하는 것이다. 그러니 한 가지 일이 끝날 때까지 기다리는 것과는 상관이 없고 작업마다 각각 알아서 수행하는 것이다.
가장 쉬운 예로, 손이 두개지만 빠른 사람과 손이 여덟개인 사람을 생각하면 동시성과 병행성이 무엇을 의미하는 것인지 느낌이 올 것이다.리액트에서의 동시성 처리는 여러 작업을 처리할 수 있도록 작업들을 작은 조각들로 나누고, 스케줄러를 통하여 각 작업들의 중요도에 따른 우선순위를 부여한다(time-slicing). 아무리 손이 빠른 사람이라고 하더라도 사실상 단계별로 하지 않으면 결국 전체적인 작업은 망가지기 마련이다.
샌드위치 만드는 과정에서 빵을 굽는 작업과 잼을 바르는 작업을 할 때, 빵을 먼저 굽고 잼을 바르듯이 작업에도 우선순위를 부여하고 이에 따라 작업을 처리할 필요가 있다.리액트가 이렇게 나눈 작업들을 처리하는 과정에서 메인스레드는 블록되지 않으며, 동시에 여러 작업을 처리하면서 우선 순위에 따라 각 작업들 간에 전환이 가능하게 되었다.이와 같이 리액트 18버전부터는 동시성 렌더링을 통해서 렌더링 자체에 개임하고, 이를 중단하거나 재개, 폐기하는 등 작업들을 단위별로 조정할 수 있게 되었다.React 18 이전에는 렌더링이 동기적으로 처리되었기 때문에 이 중간에 어떤 것도 개입할 수 없었다. 이는 곧 렌더링이 실행되면 렌더링이 끝날 때까지 무조건 기다려야 했다는 이야기기도 했다.그래서 만약 렌더링이 오래 걸리는 작업의 경우에는, 다음 수행한 작업이 블로킹되어 애플리케이션 자체가 렉을 먹는 듯한 모습을 보여주어 UX가 현저히 떨어지게 된다.이러한 문제를 해결하기 위해서 개발자들은 Debounce와 Throttle 방식을 사용하여 어느정도 해소할 수 있었다.
Debounce
사용자의 입력이 연속으로 들어올 때 마지막 입력 후 일정 시간이 지난 다음에 무거운 작업을 수행하는 방식 Throttle
특정 시간 동안 한 번만 함수를 실행할 수 있도록 제한하는 방식.
하지만 이러한 방식 또한 Debounce의 경우에는 성능이 좋아도 모든 기기에서 같은 시간동안 대기 후에 작업 수행을 해야했고, Throttle의 경우에는 Throttle 주기를 짧게 가져갈수록 성능은 점점 떨어진다는 한계가 보였다.그렇기 때문에 이러한 동기적 렌더링의 한계를 해소하고자 동시성의 필요성이 대두되어 나오게 되었다.기존의 ReactDOM 함수의 프로토타입 함수로 사용하던 render를 사용하지 않고 ReactDOM의 프로토타입 함수인 createRoot를 통해서 객체를 생성한 뒤, 해당 객체의 render 함수를 통해 엔트리 포인트를 렌더링시킨다.import ReactDOM from 'react-dom';
import App from 'App'; const container = document.getElementById('app'); // 이전 버전(React 17)
const container = document.getElementById('app'); ReactDOM.render(&lt;App /&gt;, container); // Concurrent Mode 도입 이후(React 18)
// 루트 생성
const root = ReactDOM.createRoot(container); // 루트 객체의 메서드로 앱을 렌더링
root.render(&lt;App /&gt;);
{루트객체}.render를 통해서 앱을 렌더링시키게 되면 개선된 기능들과 동시 처리를 위한 startTransition, useTransition, useDeferredValue 훅을 사용할 수 있다.<img src="https://i.imgur.com/VbEpPyR.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
여러 개의 상태를 업데이트할 경우, 기존에는 하나의 state의 업데이트 -&gt; 변경된 상태를 리렌더링 -&gt; 다음 state의 업데이트의 단계로 상태가 업데이트 되었기 때문에 여러번 리렌더링이 발생하였고, 이에 성능적으로 좋지 않은 효과를 가져왔다.기존의 React 17까지도 Automatic Batching이 적용은 되어 있었지만, 적용되는 곳이 이벤트 핸들러 함수 내부로 한정적인 특성을 가졌다.
그러다보니 네트워크 호출(Promise)에 대한 .then 메서드의 콜백 함수에 여러개의 상태 업데이트가 들어가 있다거나 setTimeout의 콜백 함수 안의 여러 상태 업데이트 등에서는 상태 업데이트가 일괄처리가 아닌, 순차처리 방식으로 동작하면서 변경된 state의 수만큼 리렌더링을 수행하게 된다. 그러다보니 성능적으로 떨어지는 효과를 가지게 된 것이다.이에 React18부터 Concurrent Mode가 활성화되면, 모든 Promise나 setTimeout, 이벤트 콜백 등에서 다수 개의 상태 업데이트가 일괄로 처리되도록 변경되었다.<br><img src="https://i.imgur.com/rwH08eL.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Transition 관련 훅들은 전부 우선순위를 직접 관리하여 렌더링 과정에서 성능을 개선하기 위해 새롭게 추가된 훅들이다.
위에서 말한 것과 같이 이전의 렌더링 방식은 동기적으로 계속해서 UI에 대한 업데이트 실행 -&gt; 리렌더링의 반복이었다. <br><img src="https://i.imgur.com/CQ49j39.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 동시성 렌더링 방식으로 변경되면서 첫 상태 업데이트부터 최종적으로 보여야 하는 화면의 렌더링까지 가는 과정에서 중간에 계속해서 우선순위가 낮은, 즉 가벼운 업데이트를 끼워 비교적 가벼운 업데이트 -&gt; 무거운 업데이트순으로 업데이트를 시킬 수 있도록 처리하여 UI blocking 없이 동시에 다른 작업이 수행되는 것과 같은 사용자 경험을 제공할 수 있게 되었다.useTransition은 이러한 동시성을 구현하기 위해 필요한 훅이다. 이 훅은 리액트 컴포넌트 안에서 동시성 모드에 접근할 수 있도록 해준다.import { useState } from 'react'; export function FilterList({ names }) { const [query, setQuery] = useState(''); const changeHandler = ({ target: { value } }) =&gt; setQuery(value); return ( &lt;div&gt; &lt;input onChange={changeHandler} value={query} type="text" /&gt; {names.map((name, i) =&gt; ( &lt;ListItem key={i} name={name} highlight={query} /&gt; ))} &lt;/div&gt; );
} function ListItem({ name, highlight }) { const index = name.toLowerCase().indexOf(highlight.toLowerCase()); if (index === -1) { return &lt;div&gt;{name}&lt;/div&gt;; } return ( &lt;div&gt; {name.slice(0, index)} &lt;span className="highlight"&gt; {name.slice(index, index + highlight.length)} &lt;/span&gt; {name.slice(index + highlight.length)} &lt;/div&gt; );
}
해당 코드를 보면 input의 내용이 바뀔 때마다 setState를 실행하고 있고, state가 바뀌게 되면 리렌더링이 이루어지며, names를 map하는 함수가 리렌더링 때마다 실행되며 UI를 다시금 화면에 띄운다.하지만 이러한 name들이 점점 많아질 수록, input에 빠르게 입력하게 된다면 리렌더링 속도가 input 이벤트핸들러의 setState가 실행되는 속도를 따라가지 못하게 되고, 결극 input의 value가 빠르게 입력될 수 없는 문제를 가지게 된다.<br>
<a data-tooltip-position="top" aria-label="https://codesandbox.io/p/sandbox/heavy-update-as-urgent-ejwbg" rel="noopener nofollow" class="external-link is-unresolved" href="https://codesandbox.io/p/sandbox/heavy-update-as-urgent-ejwbg" target="_self">예시 보기</a>이럴때, 무거운 작업은 List의 리렌더링이 될 것이고, 비교적 가벼운 작업은 input의 eventHandler 안에 들어있는 setState에 대한 input의 value 리렌더링이다. 그렇다면 이 input의 리렌더링에 대해서 우선순위를 높여 input먼저 계속 먼저 리렌더링 될 수 있게만 한다면 input이 밀리게 되는 현상을 방지할 수 있는 것이다. 그럴 때 사용하는 훅이 useTransition 훅이다.[isPending, startTransition] = useTransition()
useTransition을 사용하면 isPending, startTranstion의 리턴값을 받는다.
isPending: transition이 pending 상태인지 알려주는 boolean 값
startTransition(callbackFn): UI 업데이트에 관한 로직을 콜백 함수로 넘겨줌
이 startTransition을 통해서 콜백함수의 setState를 통한 리렌더링 로직을 우선순위가 낮도록 설정하여 후순위로 렌더링이 이루어질 수 있도록 하면서 성능을 개선한다.
`startTransition` lets you update the state without blocking the UI.
라고 React의 공식문서에서 나와 있는 설명과 같이, UI를 따로 블로킹하지 않고 상태를 업데이트 하도록 시킴으로써 비교적 무거워서 다른 UI의 렌더링을 막는 작업들을 의도적으로 지연시킬 수 있다.import { startTransition } from 'react'; function TabContainer() { const [tab, setTab] = useState('about'); function selectTab(nextTab) { startTransition(() =&gt; { setTab(nextTab); }); } // ...
}
이런 식으로 setState가 있는 부분의 경우 렌더링 과정에서 막히지 않고 따로 진행되기 때문에 가벼운 UI의 업데이트 등이 막히지 않고 바로바로 렌더링이 될 수 있는 환경을 제공한다.useDeferredValue는 상태의 업데이트 우선순위를 낮춘다는 점에서 useTransition과 유사하게 동작하는 면이 있다.
하지만 startTransition은 콜백함수 내부에 setState를 사용하는 방식이고, useDeferredValue는 state값을 인자로 받아서 지연된 값을 반환하는 함수이다. 따라서 useTransition은 상태를 변화시키는 행동 자체를 래핑하는 것이고, useDeferredValue은 값 자체를 래핑해서 사용하는 형태이다.useDeferredValue로 래핑한 상태의 경우에는 다른 상태값이 모두 상태 변경이 이루어진 이후에 자신이 바뀌게 된다. 값 변화의 우선순위가 낮아지기 때문에 다른 상태들의 업데이트 이후에 실행되는 것이다.그렇기에 사용하는 방식에 따라 useTransition과 useDeferredValue를 취사 선택하여 사용한다.
useTransition : 상태 변경에 대한 리렌더링이 모두 이루어진 후 콜백 함수 실행 콜백 함수 안에 setState를 넣어 사용 useDeferredValue: 상태 변경에 대한 리렌더링이 모두 이루어진 후에 변한 값에 대한 리렌더링
추가적으로 useDeferredValue는 Suspense와 함께 사용이 가능하다 .
만약 useDeferredValue의 인자로 설정한 상태가 변경하게 되면 새로운 값으로 인한 백그라운드 업데이트 동안 이전의 상태를 보여준다. 업데이트 이전의 상태를 보여주면서 다음 컴포넌트들의 렌더링이 모두 이루어진 후에 해당 상태를 참조하는 컴포넌트에서 다시금 렌더링을 시도한다. 이 렌더링을 시도하는 과정에서 기존에는 훅을 사용하여 새롭게 데이터를 fetching하는 동안 나올 ui를 설정하거나 Suspense를 활용하여 fallback UI를 보여줌으로써 사용자에게 로딩중임을 보여줄 수 있다.
Suspense
콘텐츠가 렌더링할 준비가 되기 전까지 대체 UI를 보여주는 태그
export default function App() { const [query, setQuery] = useState(''); return ( &lt;&gt; &lt;label&gt; Search albums: &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt; &lt;/label&gt; &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt; &lt;SearchResults query={query} /&gt; &lt;/Suspense&gt; &lt;/&gt; );
} 기본적으로 컴포넌트가 일시 중단됐을 때 lazy loading이나 use, Next.js와 같은 suspense 지원하는 프레임워크의 데이터 페칭 등을 사용하게 되면 가장 가까운 상위 Suspense 컴포넌트가 fallback ui를 띄워주게 된다. import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return ( &lt;&gt; &lt;label&gt; Search albums: &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt; &lt;/label&gt; &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt; &lt;SearchResults query={deferredQuery} /&gt; &lt;/Suspense&gt; &lt;/&gt; );
}
여기서 useDeferredValue를 사용하게 되면 기존 상태를 업데이트한 값에 대해서 지연된 렌더링이 이루어지고, 그 렌더링이 다시금 이루어지는 동안 이전의 값이 있을 경우 이를 표시함으로써 이전의 값을 나타낼 수 있다.또한 이 방식을 조금 더 활용하여 기존의 값과 만약 값이 바뀌었다면 이를 비교하는 변수 하나를 만들어 refetching하고 있는 상태를 알 수 있는 ui로 보여줄 수도 있다.import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return ( &lt;&gt; &lt;label&gt; Search albums: &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt; &lt;/label&gt; &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt; &lt;div style={{ opacity: isStale ? 0.5 : 1, transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear' }}&gt; &lt;SearchResults query={deferredQuery} /&gt; &lt;/div&gt; &lt;/Suspense&gt; &lt;/&gt; );
}
위 예시에서는 새롭게 업데이트된 deferredQuery와 이전의 값이어던 query를 비교한 변수인 isStale을 따로 선언하여 이에 따라 transition을 주며 refetching중인 상태를 나타내었다. 이를 비교하여 ui를 띄울 때는 suspense의 fallback ui보다는 기존의 값을 띄우는 방식으로도 사용할 수 있다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://dmitripavlutin.com/react-usetransition/" target="_self">https://dmitripavlutin.com/react-usetransition/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@heelieben/React-18-Concurrent-Rendering" target="_self">https://velog.io/@heelieben/React-18-Concurrent-Rendering</a>]]></description><link>부스트캠프/멤버십/8주차/concurrent-mode.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/Concurrent mode.md</guid><pubDate>Fri, 25 Oct 2024 12:07:25 GMT</pubDate><enclosure url="https://i.imgur.com/VbEpPyR.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/VbEpPyR.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[프로그래머스] 석유 시추]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/250136" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/250136</a>한 열을 수직으로 뚫는 시추관에서 한 번 뚫었을 때 가장 많이 받을 수 있는 석유의 양을 계산하는 문제
맨 처음에는 그냥 루프 돌아서 석유만 골라내면 되는거 아닌가 생각했지만,, 석유가 이어져 있을 경우 이어져있는 석유가 모두 들어오기 때문에 이에 대해서도 계산이 필요함DFS로 석유의 양을 계산한다고 하면 지나간 길을 표시해야 하는데, 이걸 얕은 복사로 해버리면 다음 열에서 시추를 할 때 지나간 길이 표시된 석유의 경우 판단하기 어렵다
그렇다고 깊은 복사로 해버리면, 열을 도는 과정에서 function solution(land) { const oilMap = new Map(); land.forEach((rowArr,row) =&gt; { rowArr.forEach((colArr, col) =&gt; { const oilRoad = []; const drilled = drilling(oilMap, land, row, col, oilRoad); oilRoad.forEach((oiledCol) =&gt; { if(oilMap.has(oiledCol)) oilMap.set(oiledCol,oilMap.get(oiledCol) + drilled); else oilMap.set(oiledCol, drilled); }) }) }) let max = 0; for (let val of oilMap.values()){ if(max&lt;val) max = val; } return max;
} function drilling(oilMap,land,row,col,road){ if(!land[row][col]) return 0; if(!road.includes(col)) road.push(col); land[row][col] = 0; let oils = 1; // dfs if(row &gt; 0) oils += drilling(oilMap,land, row-1, col, road); if(row&lt;land.length-1) oils += drilling(oilMap, land, row+1, col, road); if(col &gt; 0) oils += drilling(oilMap,land, row, col-1, road); if(col&lt;land[0].length-1) oils += drilling(oilMap, land, row, col+1, road); return oils;
}
이런 식으로 dfs 탐색을 하면서 지나간 자리를 0으로 만들고, 지나갔던 열에 대해서 모두 배열에 넣은 뒤에 map에서 col의 키값에 해당 석유 덩이의 크기만큼을 더해주는 방식으로 순회를 돌고, 마지막에는 만들어진 map에 대해서 최댓값을 찾도록 했다.<br><img src="https://i.imgur.com/OAVtMef.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
정확성 테스트는 모두 통과했으나, 효율성 테스트에서는 2개가 런타임 에러가 떴다.
다른 사람들이 질문한 것을 보았을 때, 아마 재귀가 깊어지면서 나오는 에러때문이 아닐까 싶었다.function solution(land) { const oilMap = new Map(); for (let row = 0; row &lt; land.length; row++) { for (let col = 0; col &lt; land[row].length; col++) { if (land[row][col]) { const oilRoad = []; const drilled = drilling(oilMap, land, row, col, oilRoad); oilRoad.forEach((oiledCol) =&gt; { if (oilMap.has(oiledCol)) { oilMap.set(oiledCol, oilMap.get(oiledCol) + drilled); } else { oilMap.set(oiledCol, drilled); } }); } } } let max = 0; for (let val of oilMap.values()) { if (max &lt; val) max = val; } return max;
} function drilling(oilMap, land, startRow, startCol, road) { const queue = [[startRow, startCol]]; let oils = 0; while (queue.length &gt; 0) { const [row, col] = queue.shift(); if (land[row][col] === 0) continue; oils++; land[row][col] = 0; if (!road.includes(col)) road.push(col); if (row &gt; 0 &amp;&amp; land[row - 1][col]) queue.push([row - 1, col]); if (row &lt; land.length - 1 &amp;&amp; land[row + 1][col]) queue.push([row + 1, col]); if (col &gt; 0 &amp;&amp; land[row][col - 1]) queue.push([row, col - 1]); if (col &lt; land[0].length - 1 &amp;&amp; land[row][col + 1]) queue.push([row, col + 1]); } return oils;
}
이번에는 BFS를 활용하여 문제를 풀었을 때 모두 정답이 떴다.
BFS의 경우에는 재귀를 이용하지 않고 큐를 이용하기 때문에, 런타임 에러가 발생하지 않아 정답이 뜬 것으로 보인다.]]></description><link>알고리즘/[프로그래머스]-석유-시추.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 석유 시추.md</guid><pubDate>Fri, 25 Oct 2024 11:18:02 GMT</pubDate><enclosure url="https://i.imgur.com/OAVtMef.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/OAVtMef.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지]]></title><description><![CDATA[<a data-href="챌린지 Day_1" href="부스트캠프/챌린지/챌린지-day_1.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_1</a><br>
<a data-href="챌린지 Day_2" href="부스트캠프/챌린지/챌린지-day_2.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_2</a><br>
<a data-href="챌린지 Day_3" href="부스트캠프/챌린지/챌린지-day_3.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_3</a><br>
<a data-href="챌린지 Day_4" href="부스트캠프/챌린지/챌린지-day_4.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_4</a><br>
<a data-href="챌린지 1주차 회고" href="부스트캠프/챌린지/챌린지-1주차-회고.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 1주차 회고</a><br>
<a data-href="챌린지 Day_5" href="부스트캠프/챌린지/챌린지-day_5.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_5</a><br>
<a data-href="챌린지 Day_6" href=".html" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_6</a><br>
<a data-href="챌린지 Day_7" href="부스트캠프/챌린지/챌린지-day_7.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_7</a><br>
<a data-href="챌린지 Day_8" href="부스트캠프/챌린지/챌린지-day_8.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_8</a><br>
<a data-href="챌린지 Day_9" href="부스트캠프/챌린지/챌린지-day_9.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_9</a><br>
<a data-href="챌린지 Day_10" href="부스트캠프/챌린지/챌린지-day_10.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_10</a><br>
<a data-href="챌린지 Day_11" href="부스트캠프/챌린지/챌린지-day_11.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_11</a><br>
<a data-href="챌린지 Day_12" href=".html" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_12</a><br>
<a data-href="챌린지 Day_13" href="부스트캠프/챌린지/챌린지-day_13.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_13</a><br>
<a data-href="챌린지 Day_14" href=".html" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_14</a><br>
<a data-href="챌린지 Day_15" href=".html" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_15</a><br>
<a data-href="챌린지 Day_16" href="부스트캠프/챌린지/챌린지-day_16.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_16</a><br>
<a data-href="챌린지 Day_17" href=".html" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_17</a><br>
<a data-href="챌린지 Day_18" href="부스트캠프/챌린지/챌린지-day_18.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_18</a><br>
<a data-href="챌린지 Day_19" href=".html" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_19</a><br>
<a data-href="챌린지 Day_20" href=".html" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_20</a><br>
<a data-href="릴레이노트" href="부스트캠프/챌린지/릴레이노트.html#_0" class="internal-link" target="_self" rel="noopener nofollow">릴레이노트</a><br>
<a data-href="2주차 릴레이노트" href="부스트캠프/챌린지/2주차-릴레이노트.html#_0" class="internal-link" target="_self" rel="noopener nofollow">2주차 릴레이노트</a><br>
<a data-href="학습 정리" href="부스트캠프/챌린지/학습-정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">학습 정리</a><br>
<a data-href="릴레이프로젝트" href="부스트캠프/챌린지/릴레이프로젝트.html#_0" class="internal-link" target="_self" rel="noopener nofollow">릴레이프로젝트</a><br>
<a data-href="3주차 개인회고" href="부스트캠프/챌린지/3주차-개인회고.html#_0" class="internal-link" target="_self" rel="noopener nofollow">3주차 개인회고</a><br>
<a data-href="챌린지 회고" href="부스트캠프/챌린지/챌린지-회고.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 회고</a>]]></description><link>부스트캠프/챌린지/챌린지.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지.md</guid><pubDate>Thu, 24 Oct 2024 15:41:26 GMT</pubDate></item><item><title><![CDATA[프로젝트 관련 수료생 밋업]]></title><description><![CDATA[태림님(FE)
부족한 시간이지만 사전 조사는 충분히 하기 무엇이 필요한지
이 앱을 어떻게 구현할 지에 대한 설계
기술을 사용했을 때의 문제와 이를 위한 해결
의사 결정 과정 ADR 작성 피해갈 수 없는 뷰 공장 앱의 완성을 위해 뷰를 만들기 위해 너무 시간이 들어감
기술적 도전이 먼저 파트 분배를 잘 하는 법 구현에 대한 디테일한 기능명세 작성 문저 작성 경험 &amp; 팁 조금이라도 계속 쓰려고 노력하기
Issue나 PR 작성할 때 template 사용<img src="https://i.imgur.com/cAnBoNY.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내가 쓰는 패턴을 생각해서 내용만 비우고 다시써보기 잘 정리된 문서 활용 잘 쓴 문서를 통해 나를 표현하기 자기소개서에 링크 첨부와 내가 문제해결을 위한 과정을 적음
해당 프로젝트에서 제일 기억나는 기능이나 API 최대한 지금 수치화를 많이 해두고 기록을 많이 하자
일정 관리
플래닝 포커를 통한 일정 산정
- 원할한 프로젝트 진행 - 언제 내가 작업을 마칠 수 있는지 알리기
- 효과적인 커뮤니케이션과 신뢰성 형성 - 경험을 바탕으로 근거 기반의 대화가 가능
- 백로그 하나하나 우선순위를 정해서 어디까지 할 수 있을지 예측하기
코드리뷰
하나의 기능도 여러명이 Task를 나눠가지기
코드 리뷰는 모두가 Approve 해야 머지 가능 새로운 시각 공유와 피드백 왜 개선이 필요한지에 대한 근거를 확실히 말하기
그 외 이야기
함께 일하는 것 같은 환경 만들기
온라인 장소의 경우 게더 문서화 잘해두기
Notion &amp; Github Wiki
회고 방식
4L, KPT, 5F 등의 회고 방법론 선택
- kpt의 경우 어떤 problem에 대한 어떤 try를 시도해야 하는지에 대해 화살표로 연결
회고를 통한 팀 문화 발전
kpt 방식을 통해 problem들에 대해 실천 가능한 try를 뽑고 keep으로 만들기
문제에 대한 불만의 problem x 개선점을 생각하는 학습 과정
다시 돌아간다면..
그룹프로젝트의 주제? 기술적 도전에 집중하자
구현 과정에서 마주친 문제를 해결하는 과정도 기술적 도전이 될 수 있다 ]]></description><link>부스트캠프/멤버십/그룹프로젝트-1주차/프로젝트-관련-수료생-밋업.html</link><guid isPermaLink="false">부스트캠프/멤버십/그룹프로젝트 1주차/프로젝트 관련 수료생 밋업.md</guid><pubDate>Thu, 24 Oct 2024 11:11:34 GMT</pubDate><enclosure url="https://i.imgur.com/cAnBoNY.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/cAnBoNY.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[현업에서 말하는 좋은 프로젝트 - 자문위원님들]]></title><description><![CDATA[테오님
냉정하게 말씀드리자면 사이드 프로젝트가 면접에서 차지하는 비중이 크지 않음
이 사람의 태도, 경험 등을 평가
그럼에도 인상적인 프로젝트? 기술적 도전이나 난이도를 가진 것들을 어필하는데, 실직적으로 어려운게 아닐 수 있음
자잘자잘한 것들이 쌓여가는 것들
프론트는 손도 많이 타서 신경 쓰는 만큼 좋아짐
얼만큼 노력하고 고민했는가에 대한 고민이 드러나는 프로젝트
이를 위해 투자한 노력이 보이는 것들
내가 어디까지 만들려고 했지? 완성하려고 했지? 사람들에 대한 반응이 중요 프론트엔드의 기술적 완성도를 가지고 보게 됨 관심을 보였다 하더라도 기술적 가치를 가지는 프로젝트
기술적 고민, 기술적 역량을 발휘하는 것
이를 위해서 얼마나 신경쓰고 노력했는지 티가 나는 것들 노성균님(BE)
이력서를 보고 면접 여부를 결정하면서 그 과정에서 포트폴리오를 봄
완성도를 높이기 위해서 무엇을 고민했는지
그러면 이 부분을 면접때 파고들면서 어디까지 고민하고 해결하려 했는지를 확인
주니어 개발자에게 기대하는 수준 -&gt; 기술자끼리 하는 대화 서로간에 같이 일했을 때 좋은 사람
이력서에 이러한 프로젝트의 완성도를 높이기 위해 데모의 소스코드를 보는 편
데모형 로그인 아이디와 비밀번호 제공이 중요. 대부분 안보심 포트폴리오가 이력서 검토때는 큰 비중을 차지하지는 않지만 면접까지 했을 떄는 이야기가 달라짐 왜에 대한 질문에 답할 수 있어야 함
필주님(And)
프로젝트를 봤을 때 Readme, 돌려보는 과정을 한눈에 봤을 때 ,프로젝트를 명확히 볼 수 있음
이 프로젝트는 무슨 문제를 해결하기 위한 것인가? 에 대한 명확한 답이 되어 있는 것
이게 최선일까? 라는 생각을 하면서 기능개선, 사용자 최적화 등에 대해 다양하게 생가게하기
내 목표에 대해 계속 생각하면서 완성도 높여가기
성균님(Web - BE)
백엔드의 관점
눈에 보이는 부분들이 거의 없음 -&gt; 어떻게 판단?
단순 기능 구현이 아니라, 실제 서비스에서 지원하고, 잘되면 늘리는 확장성이 높을 수 있는지
프로젝트 간단한 기능 구현을 위해서는 겉으로 보일땐 똑같지만 나중에 기능이 추가되면서 확장이 안될 때가 많음
프로젝트 팀을 이뤄 협업하는 과정에서 api를 만들면 가져다 쓰는 부분이다 보니까 사용을 할 수 없는 부분이 있음
배포에도 수동 배포가 아닌 CI/CD 서버가 죽었을 때 원인을 찾을 수 있어야 함 도영님(IOS)
코드로 쳤을 때는 코딩을 많이 하는 것이 좋은 포트폴리오(X)
커피를 예시로 말한다면 10잔을 만드는 것보다 맛있는 1잔을 만드는지
실수가 일어나지 않는 코드
UI/UX에 어색한 부분이 없는지 확인
테오님
개발자에게 완성도가 중요한 이유 -&gt; 마감일이 있기 때문
제한된 기간 내에 릴리스
릴리즈 한 이후 개선
릴리즈마다 의미가 있어야 함
어디까지를 잘라도 완성도가 있는지 알 수 있는 능력이 중요
모든 개발이 업데이트를 하면서 나가기 떄문에 완성도가 중요
그럼 어디까지를 해야할까? 평가에 몰입이 깨지면 그만하는 경우가 많음 -&gt; 최소한의 단위
정말 써보는건지/테스트하는건지
내가 정말 이 릴리즈만 가지고도 의미를 만들어 낼 수 있나?
한 사이클에 한 릴리즈 단위로
의미로 부여할 수 있는가? 지속적으로 의미를 부여해나가야 함
지금 무엇을 해야 완성도가 높아지는가?에 대한 기능 성균님(Web-BE)
팀단위로 이루어짐
협업을 할 때 중요한 것은 팀끼리 거리감을 좁힌 상태에서 시작
자유롭게 의견을 나누기
모르는 것을 말할 수 있는 분위기
분업을 한 상태에서 열심히 하면 되는 것이 아니라, 팀으로 봤을 때 전체적으로 최적화
클라이언트 개발자를 위한 API 만들기
문서화하기
스케줄을 잡아 일을 하면서 책임감이 없다라고 말할 때 일정이 딜레이 되는 경우 발생 -&gt; 바로 말하기
테오님
목적을 이루는데 있어서 타협을 하거나 도전할 필요 없이 개인의 목적, 팀의 목적을 맞추는 방법이 얼마든지 있음 최대한 펼쳐두고 모든 것들을 만족할 수 있는 방법을 찾는 것 공평하게 하는 것이 협업이 아님. 잘하는 사람에게 일을 더 많이 줄 수 있는 것이 좋은 팀
업무의 총량가지고 평가하지 않아야 함
팀으로써 생각했을 때 팀을 잘되게 하는 방법에 대해 생각 막판에 결정을 해야 하는 순간이 올 때 합의하지 말 것. 합의할 경우 서로의 마음 상처가 이루어질 수밖에 없음
결정을 합의하려고 하지 않고, 결정하는 방법을 합의하자
결정권자가 합의하면 신속하고 빠르고 강직하게 갈 것.
고민하단 것은 고만고만하기 때문에 빠르게 하는 것이 오히려 좋음
1명의 리드보다는 여러분야의 결정권을 확실하게 위임해주어야 함
수평은 상호작용의 횟수가 많아지는 것이지 결정권이 공평해야 하는 건 아니라는거 기억하기
좋은팀의 측정 기준 = 상호작용의 횟수!
슈퍼패스? 가져가는 그라운드 룰도 괜찮을듯 도영님(Be)
내가 잘하고 싶은 것, 동료가 하고 싶은 것을 판단해서 잘 분배하기
은근히 한명이 마두를 잡고 가고 나머지는 따라가게 되는 경우가 많음. 그러다 보면 자기주도권을 잃게 됨
어느 팀에 가서 각자의 역할을 해야 하는데, 각자의 역할을 분명하게 가지는 것이 중요함
난이도가 낮은 것을 하더라도 확실히 하고, 도움을 필요로 해도 결국 책임은 나라는 것을 계속 기억할 것
필주님(And)
협업할 때는 커뮤니케이션을 강조
그 전에 각자의 분야에 대해서 확실히 가져가기
각자 분야를 정하더라도 너무 거기에 매몰되지 않기
내 분야의 코드를 올리고 내가 봤을 떄 이 부분을 고치면 좋지 않을까? 하는 부분에 대해서는 자유롭게 할 수 있는 분위기가 되어야 함
문서화를 담당한다 하더라도 다른 사람들도 할 수 있어야 함
이가 바탕이 되기 위해서는 커뮤니케이션이 중요 팀 스크럼이나 회고를 의무감에 진행하는 경우가 있었는데, 이럴 때 레드플래그라고 생각하고 돌아보기
스크럼 시간을 기대되는 시간으로 만들기
내 문제 해결 방식을 해결하기
막혀서 답이 없어 보이는데 이걸 오픈하면 해결할 수 있지 않을까? 하고 오픈한 뒤 다른 사람들의 의견도 들어보기 테오님
멘토링을 하게 되면 멘토링을 팀별, 개개인별로 받는 경우가 있음
팀의 경우 프로젝트가 좋은 방향으로 가고 있는지
이야기를 들으려고 하기 보다는 설명을 하려고 하기
면접 보듯이 해야 도움이 되고 어떻게 진행되고 있는지 알아야 멘토가 제대로 된 조언을 해줄 수 있음
우리의 맥락을 공유하고 얘기하기! 개개인
- 개인적으로 가지고 있는 문제에 대해 딥하게 코드 스타일, 내용, 방법이 맞는지를 확인받기
- 실질적으로 어떻게 하는 것이 제일 좋은지 해결 방법 찾기
- 나의 맥락을 설명함으로써 해결하려고 하기
<img src="https://i.imgur.com/GUkrt2y.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
성균님
개발자는 I가 많아 대부분 말을 안하려고 함
오프라인으로 만날 수 있으면 최대한 만나기
1대1로 얘기하면서 많이 알아갈 수 있는 시간 가지기
주변 사람들에게도 게스트로 초대해서 문제에 대한 해결을 다양한 사람들에게 많이 받기
필주님
팀 멘토링 모든 것을 물어보는 팀? 기초적인 것을 찾지도 않고 물어보지 않기
너무 세세하게 (여기에 엔터를 넣을까요.. 등) 하는 질문들도 지양
멘토가 대신 결정해주길 바라는 질문을 지양하기
만약 지금 팀에서 어떤 해결 방안에 대해서 좋은 방안이 있는지, 깊게 학습 할 수 있는 방식 듣기
내 해결방식의 장단점을 분석하고 더 있을까요?라는 식으로 물어보기 개인 멘토링 어떤 문제를 해결할 건지 정리를 해서 들어가기
코드리뷰 멘토링에서 긴 시간 상담 지양
시간을 정하고 문제를 해결하여 효율적으로 하기
나의 감정상태를 객관적으로 살펴보고 스트레스 관리 방법 찾은 후에 개인 멘토링 시간을 보다 효율적으로 사용하기 도영님
질문을 하루 전에 준비하기
시간에 임박해서 준비해서 이야기하면 좋은 질문이 되기 쉽지 않음
맥락을 이해시키기 위해 질문을 먼저 주기
멘토님도 미리 준비할 수 있음
정말로 커뮤니케이션을 하면서 좋은 것을 다져 나가는 시간으로 활용하기
필주님
영상 컨텐츠, 미디어 컨텐츠, 게시판, 이커머스 등의 프로젝트
모든 프로젝트를 할 때 이 API를 제대로 사용했는가? 에 대한 고민을 게속 해야함
내가 진짜 필요해서 만드는 프로젝트인지를 생각해보기(중요)
해결하고자 하는 문제가 가장 명확해야 함
기획은 어차피 바뀌기 때문에 세세한 것까지 하지 않기 현업 가도 맨날 바뀌기 때문에 큰 의미 두지 않기 내가 과연 처음 코드를 확장성 있게 썼는가를 고민하기
ai 많이 활용하기 고려해야 할 점들 복잡한 과정을 거쳐야 결과물이 나오는 스텝을 가지고 있는데 AI를 통해 프로젝트가 단순해질 때 적용하는 것을 생각해보기
내가 ai를 활용한다면 생산성을 높일 수 있을 때 도영님
무조건 주제에만 구애받지 않기
큰 주제에서 생각해보기
실현 가능한 주제를 생각해보기
서비스의 범위를 너무 넓게 만들지 않기 할 수 있는 정도의 범위 성균님
백엔드 기획할 때 확장성을 고려하면서 하기 완성도를 높이기 위해 안정성을 높이기
나중에 구현할 때 기획 단계에서 세부적인 고려사항들도 어느정도 생각해보면서 설계하기
어떤 식으로 할지 고민 많이 해보기
테오님
내가 만드는 가치는 기획이 결정함
프로젝트 자체의 가치, 목표가 명확해야 함
6주정도의 작은 프로젝트인 만큼 고려해서 만들기
저게어도 내가 필요하거나 우리 팀이 필요하거나 관심사를 만들어야 함
부스트캠퍼들에게 공감을 받을 만한 것들
잘되면 많이 쓸 수 있는 것들이 아니라, 응당 쓸 수 있는 것들
엣지 포인트, 당장 쓸 수 있는지의 여부
프론트엔드로 가치를 만들기 나의 기술적 가치로 가치를 만들기
사용자가 화면을 통해 데이터 조작, 내용을 받아보기
기술적 가치로 해결할 수 있는 것들(나의 불편함을 해결할 수 있는 것들) 목표가 의미 있을 때
사용성에 대한 고민함
UI/UX에 대한 고민하기 클릭 이벤트 뿐만이 아니라 다양한 이벤트등을 다뤄보면서 사용성을 높여보기 확장성을 높이게 만들기 ]]></description><link>부스트캠프/멤버십/그룹프로젝트-1주차/현업에서-말하는-좋은-프로젝트-자문위원님들.html</link><guid isPermaLink="false">부스트캠프/멤버십/그룹프로젝트 1주차/현업에서 말하는 좋은 프로젝트 - 자문위원님들.md</guid><pubDate>Wed, 23 Oct 2024 11:35:31 GMT</pubDate><enclosure url="https://i.imgur.com/GUkrt2y.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/GUkrt2y.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[React Portal]]></title><description><![CDATA[React에는 참 신기한게 많다.
별별 것들을 다 해놓고 라이브러리라고 우기는게 되게 초보 사냥터에서 독식하는 고인물같다..암튼 React Portal은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 방식을 제공한다. 간단하게 생각해보자면 자식 컴포넌트를 다른 곳에 갖다 전달할 수 있다는 뜻이다. React의 트리 구조에 따라서 부모 컴포넌트가 렌더링 될 경우에 자식 요소 또한 따라서 렌더링 될 수밖에 없다. 하지만 만약 자식 요소가 바뀌지 않는다면 굳이 렌더링을 다시 할 필요가 없고, 성능을 떨어뜨리는 원인밖에 되지 않으므로 포탈을 사용한다.그렇게 포탈로 자식 컴포넌트를 바깥에 내놓음으로써 이러한 문제를 해결함과 동시에 DOM 요소에서는 부모-자식관계처럼 보이지만 이를 독립적으로 관리할 수 있기 때문에 사용한다.&lt;div&gt; &lt;SomeComponent /&gt; {createPortal(children, domNode, key?)}
&lt;/div&gt; // 적용 예시
import { createPortal } from 'react-dom'; // ... &lt;div&gt; &lt;p&gt;This child is placed in the parent div.&lt;/p&gt; {createPortal( &lt;p&gt;This child is placed in the document body.&lt;/p&gt;, document.body )}
&lt;/div&gt;
포탈을 사용하기 위해서는 createPortal을 실행하여 포탈을 생성해야 한다.
children: JSX 조각 (예: &lt;div /&gt; 나 &lt;SomeComponent /&gt;), Fragment (&lt;&gt;...&lt;/&gt;), 문자열이나 숫자, 또는 이들의 배열과 같이 React로 렌더링할 수 있는 모든 것.
domNode: document.getElementById()가 반환하는 것과 같은 일부 DOM 노드. 노드는 이미 존재하고 있어야 한다. 업데이트 중에 다른 DOM 노드를 전달하면 포털 콘텐츠가 다시 생성된다
선택적 key: 포털의 키로 사용할 고유 문자열 또는 숫자
이렇게 포탈을 생성하면 반환값으로 React node를 반환한다. 리액트는 렌더링 중에 이 포탈로 만들어진 React node를 보면 제공된 children을 설정한 domNode 안에 배치한다.
따라서 위와 같은 예시로 포탈을 만들게 되면 현재 코드 상에서 &lt;p&gt;This child is placed in the document body.&lt;/p&gt;는 현재 우리가 보는 것과 같이 div 태그의 자식 요소처럼 보이지만 실제로 렌더링 할 때를 보면 다르다.&lt;body&gt; &lt;div id="root"&gt; ... &lt;div style="border: 2px solid black"&gt; &lt;p&gt;This child is placed inside the parent div.&lt;/p&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;p&gt;This child is placed in the document body.&lt;/p&gt;
&lt;/body&gt;
마치 이런식으로 포탈을 통해 뿅~ 넘어간 뒤 document의 body쪽으로 이동한 것이다.]]></description><link>부스트캠프/멤버십/8주차/react-portal.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/React Portal.md</guid><pubDate>Fri, 18 Oct 2024 02:23:09 GMT</pubDate></item><item><title><![CDATA[week8_4일차_PR]]></title><description><![CDATA[
서버 GET : 헤드라인 가져오기
GET: 구독한 언론사 가져오기
GET: 모든 언론사 가져오기
GET: 카테고리 데이터 (카테고리 -&gt; 내부 언론사 -&gt; 내부 기사) 가져오기
POST: 더미 데이터들 추가(폐기) suspense와 concurrent mode
firebase functions
Error boundary와 Suspense를 합쳐놓은 AsyncBoundary는 이제까지 바운더리 안에 요소들을 넣어 놓고, 안쪽 컴포넌트에서 렌더링 하는 방식으로 했었다.
하지만 이런 경우, 컴포넌트 안에서 fetch를 하게 되면, 계속해서 리액트가 리렌더링을 실행하게 되고, 이 과정에서 반복적으로 같은 http 요청이 날라가는 문제가 있었다.
이러한 문제는 계속해서 렌더링이 실행될 때, 안에서 state로 관리하고 있지 않기 때문에 컴포넌트가 실행되는 과정에서 계속해서 초기화되는 문제가 원인이었다.
이를 해결하기 위해서, 맨 처음에는 cache라는 객체를 fetching하는 함수의 바깥에 두고 key값을 엔드포인트로 하여 관리하고자 했다.
하지만 이러한 경우는 임시방편에 불과하기 떄문에 어떻게 하면 더 Suspense와 Fetching 로직을 잘 이용할 수 있을까를 고민하였다.export default function getHeadlines() { return fetchData&lt;Article[]&gt;(fetcher.get(HEADLINE_URI)); }
... const response = getHeadlines();
export default function ShortNews() { const headlines = response.read(); return ( &lt;div className="flex gap-4"&gt; &lt;AutoRollingNews newsList={headlines?.slice(0, Math.floor(headlines.length / 2))} direction="LEFT" /&gt; &lt;AutoRollingNews newsList={headlines?.slice(0, Math.floor(headlines.length / 2))} direction="RIGHT" /&gt; &lt;/div&gt; );
} 따라서 fetch하는 함수 자체를 컴포넌트의 바깥에서 실행하고, 데이터 페칭이 비동기적으로 작동함과 동시에 컴포넌트를 보다 선언적으로 관리하기 위한 리팩토링을 진행했다.안녕하세요 멘토님! 항상 고생 많으십니다🙇‍♂️
벌써 마지막 리뷰네요 🥲 멘토님 피드백을 듣고 새롭게 배운 것들이 정말 많았는데 많이 아쉽습니다ㅠㅠ이번에 firestore을 조금씩 알아가면서 NOSQL이 재밌기도 하면서 생각보다 더 설계가 어려웠습니다.. 관계형 데이터베이스에서 설계하는 것과는 다르게 각각의 collection에 대해서 어떻게 관리해야 할 지에 대해서 고민이 많이 되더라고요..
저같은 경우는 이번에 category, article, publisher등의 도메인을 각각 루트 수준의 컬렉션으로 관리했는데, 이럴 경우에 만약 publisher(언론사)에서 작성한 기사의 경우에 대해서 각 기사 document의 id만을 담아놓을 수 있도록 하였고, 이를 순회하면서 그때마다 db에 접근하여 바로 데이터를 가져올 수 있게 하였습니다.
하지만 이런 경우 한번에 가져오지 않고 하나의 데이터를 가져오기 위해서 수차례 데이터베이스에 접근하는 것이 과연 괜찮은 방법일지 갑자기 궁금해져서 질문드립니다!
entities : 도메인별 컴포넌트와 하위 디렉토리들 widget: entities들이 모여 하나의 섹션, 즉 페이지에서 활용하는 큰 단위의 독립적 컴포넌트들. entities들을 묶고 하위 entites로 필요한 state를 내려주는 역할
app : 엔트리 포인트이자 전역 스타일, 현재는 단일 페이지므로 해당 app에 안쪽 요소를 채워넣을 예정
shared: 공통적으로 어디서나 쓰일 수 있고 데이터를 담고 있지 않는 컴포넌트들 하위 디렉토리로는 ui: 기본적인 디자인 요소 api: 필요한 api fetching하는 함수들
lib: 컴포넌트에서 필요한 유틸함수들이나 재사용 불가능한 컴포넌트
model: 비즈니스 로직(훅)이나 데이터 구조를 정의한 타입 이제까지 계속해서 조금씩 고치면서 폴더 구조를 이런 식으로 나누어 보았습니다. 첫 주에 말씀드렸던 부분에서 조금씩 고쳐진 버전이 있습니다.
저는 model에서 훅과 타입, 상수가 따로 분리되어 있었다면 좋겠다는 생각을 하긴 했지만 전체적인 구조는 불편한 점이 많지는 않았는데, 혹시 생각하시는 개선 방안이 있으시다면 조금 더 말씀해주시면 감사하겠습니다!그 외에는 전체적으로 피드백을 해주시면 감사하겠습니다!
이번주 스터디 그룹에서 저는 가장 만족스럽게 느꼈던 부분이 아마 제가 몰랐던 학습 키워드를 많이 얻었던 부분 같습니다! 멘토님 뿐만 아니라 그룹원분들이 던져주시는 키워드들도 모르는게 많아서 성장하는 느낌이 많이 들더라구요ㅎㅎ
그래서 추가적으로 요청드리고 싶었던 것이 혹시 제가 보다 학습했으면 좋겠다고 생각하시는 키워드가 있으시다면 말씀해주시면 감사하겠습니다ㅎㅎ
2주일동안 정말 감사했습니다!!]]></description><link>부스트캠프/멤버십/8주차/week8_4일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/week8_4일차_PR.md</guid><pubDate>Thu, 17 Oct 2024 10:14:18 GMT</pubDate></item><item><title><![CDATA[week8_3일차_PR]]></title><description><![CDATA[
Error Boundary를 통한 컴포넌트 오류 처리
Suspense를 통한 컴포넌트의 로딩 상태 관리
fetchData를 통해 Suspense에서 catch할 수 있는 상태를 throw 하는 로직 작성 Error boundary
Concurrent Mode
Suspense
import ShortNews from "@entities/autoRollingNews/ui/shortNews";
import Header from "@/shared/ui/header";
import { Contents } from "@/widgets/contents";
import AsyncBoundary from "@/shared/lib/asyncBoundary"; function App() { return ( &lt;div className="flex w-[930px] flex-col gap-9"&gt; &lt;Header /&gt; &lt;AsyncBoundary&gt; &lt;ShortNews /&gt; &lt;/AsyncBoundary&gt; &lt;Contents /&gt; &lt;/div&gt; );
} export default App; 나는 이런 식으로 AsyncBoundary라는 컴포넌트를 따로 만들어 Error boundary &amp; Suspense 컴포넌트를 놓고 안의 children 요소들의 로딩 상태와 오류를 catch할 수 있도록 해주었다.하지만 그 과정에서 기존의 useEffect로 data를 fetching하는 로직의 경우, useEffect는 컴포넌트가 렌더링 후 마운트 되었을 때 나타나는 상태지만, Suspense로 로딩 상태를 처리하는 경우 컴포넌트가 선언적으로 되어있기 때문에 데이터를 만약 받아오지 않은 상태라면 렌더링을 하지 않고 그동안 suspense의 fallback ui만 보여준 후 데이터가 받아졌을 경우에 렌더링을 한다.그렇기 때문에 사실상 useEffect로 하는 로직이 제대로 먹히지 않았다. 이러한 문제를 해결하기 위해 useEffect를 제거함과 동시에 state 또한 hook으로써 작동하기 때문에 제대로 렌더링 과정에서 관리되지 못할 것 같다고 판단했다.
이에 데이터를 일반 변수로 선언해둔 다음에 온메모리에서 이를 관리하면 되지 않을까? 하는 생각이 들었고, 이에 대해서 fetching하는 로직을 따로 만들어보았다.let dataCache: any | null = null;
let suspenderCache: Promise&lt;void&gt; | null = null;
let error: Error | null = null; export function fetchData&lt;T&gt;(fn: Promise&lt;T&gt;) { if (dataCache) { return { read() { return dataCache; }, }; } if (!suspenderCache) { suspenderCache = fn .then((data) =&gt; { dataCache = data; }) .catch((err) =&gt; { error = err; }); } return { read(): T { if (error) throw error; if (dataCache === null) { throw suspenderCache; } else { return dataCache; } }, };
} 이를 통해 비동기적으로 fetching하는 로직이 작동하면서 로딩중인 상태, 에러 상태, 정상 데이터 반환 상태를 분기처리하여 던져주어 에러에 대해서는 Errorboundary가 처리를 하고, 로딩 중 상태의 경우 data를 fetching중인 상태를 던져 리액트에서 이를 감지하여 Suspense fallback ui를 렌더링할 수 있도록 해주었다.
데이터가 정상적으로 받아졌을 때는 read함수를 통해서 데이터를 받아와 선언적으로 구성했던 컴포넌트에 대해서 렌더링할 수 있도록 해줬다.]]></description><link>부스트캠프/멤버십/8주차/week8_3일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/week8_3일차_PR.md</guid><pubDate>Wed, 16 Oct 2024 16:21:55 GMT</pubDate></item><item><title><![CDATA[tree shaking과 code splitting]]></title><description><![CDATA[번들링 과정에서 ESM 방식의 경우 정적 파일 분석을 진행함. 정적 파일들을 분석하는 과정에서 함수들이나 변수들에 대한 중복 선언에 대해 다시금 선언해주지 않게 하는 기능을 함 + 참조하지 않는 변수나 함수 등에 대해서 사용하지 않는다고 판단하여 삭제함
dynamic import -&gt; lazy loading]]></description><link>부스트캠프/멤버십/8주차/tree-shaking과-code-splitting.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/tree shaking과 code splitting.md</guid><pubDate>Wed, 16 Oct 2024 05:05:01 GMT</pubDate></item><item><title><![CDATA[week8_2일차_PR]]></title><description><![CDATA[
서버 서버 데이터 구조 NOSQL에 맞도록 재설계
article 제작
라우터 설정
헤드라인 get api 설계 및 구현 클라이언트 프로그레스바가 끝날 때 두번 함수 호출되는 문제 해결
Press -&gt; Publisher로 도메인 이름 변경
props drilling이 넓게 퍼지는 컴포넌트를 context 사용하여 리팩토링
rollingnews 부분을 데이터 fetching해서 가져올 수 있도록 리팩토링 setTimeout과 setInterval의 지연 간격
react portal Suspense와 Error Boundary
firebase functions
firestore data structure
firebase firestore에서는 document, collection의 개념을 가진 NOSQL(Document Database)로 세 가지의 데이터 구조화 방법을 제시한다.
문서의 중첩 데이터 문서 내에 배열 또는 지도 등 복합 객체를 중첩
하나의 문서 안에 통으로 데이터를 넣는 스타일 하위 컬렉션 문서 내에 다시급 하위 컬렉션을 주고, 컬렉션 별로 관리할 수 있도록 하는 스타일 루트 수준 컬렉션
- 데이터베이스 루트 수준에 컬렉션을 만들고, 각 컬렉션 내에서 쿼리하여 사용하는 스타일
나와 같은 경우 category, article, publisher,user 네 가지 데이터들을 만들어 놨었는데, 이러한 데이터에 대해서 카테고리에도 해당 카테고리를 가지고 있는 기사들에 대한 정보를 가지고 있어야 했고, 만약 하나의 정보에 갱신이 일어나게 된다면 다른 도메인 또한 함께 갱신이 이루어졌어야 했다.
예를 들어, 기사가 새롭게 하나가 추가된다면, 해당 기사에 선택된 카테고리에도 카테고리 도메인이 관리하는 기사에 대해서 추가하는 갱신 작업이 이루어져야 했고, 언론사인 publisher에서도 언론사별 기사가 추가됐어야 했기 때문에 이렇게 하나의 데이터 갱신이 연쇄적인 갱신으로 가는 경우 각각의 도메인을 루트 수준 컬렉션으로 하는 것이 낫겠다고 생각했다. 루트 수준에서 각 도메인을 관리하면서 하나가 추가되면 추가된 문서에 대해서 갱신을 하기 위해서는 문서의 아이디 자체만을 다른 도메인에 갱신하고, 데이터 조회가 필요할 때면 필요한 아이디를 가져다 그때마다 아이디 값을 통해 탐색 없이 바로 접근이 가능하기 때문에 해당 방법이 가장 합리적이라고 생각했다.안녕하세요 멘토님! 오늘도 고생 많으십니다ㅎㅎ
어제 오늘 계속 nosql 공부를 하고 데이터 구조를 짜느라 많이 진전도가 없긴 하지만 질문이라도 드리고 싶었습니다..ㅎ저번 리뷰에서도 언급해주셨던 부분인데, 컴포넌트의 관심사 분리에 대하여 여쭤보고 싶습니다
사실 이번에 처음 관심사 분리를 해보다보니까 많이 헷갈리더라고요😅저는 하나의 작은 컴포넌트에서도 관심사 분리를 더 해보고자 각자 맡는 역할을 분리하려고 했었습니다. 제가 컴포넌트에서 관심사를 분리한 기준은
ui : 오로지 렌더링만을 담당하는 부분, 필요한 경우 동적으로 바뀌는 값을 가질 수 있음
비즈니스 로직: 사용자의 모든 경험에 직간접적으로 관여하는 데이터 관리 로직들. 훅이나 ui 조작 함수 등 같이 상태값이 바뀌는 것 자체가 상태값을 통해서 사용자가 보이는 것들이 바뀌게 되는 모든 것들
을 나누어야 한다고 대부분의 컴포넌트들을 위와 같이 나누었던 상태였습니다.
저번에 피드백 주신 부분의 경우 프로그레스바를 컴포넌트화시키게 되면 사실 이 컴포넌트 자체가 프로그레스바만의 역할을 지닌다고 생각하기 때문에 안의 로직과 ui등에 대해서 굳이 분리할 필요가 있냐는 말씀을
해주셔서 저 또한 분리할 필요가 없다고 생각했습니다.그래서 현재 제가 다시금 생각한 구조는 보다 큰 컴포넌트의 경우, 즉 재사용이 불가능한 정도의 컴포넌트에 대해서는 모두 ui와 비즈니스 로직 등을 커스텀 훅과 같은 형태로 분리하였습니다. 하지만 말씀해주신 프로그레스바와 같이 재사용이 가능한 정도의 컴포넌트의 경우에는 가장 작은 역할 하나만을 담당하기 때문에 굳이 나눌 필요가 없다고 생각하여 분리하지 않는 구조를 생각해보았습니다.이를 통해 질문드리고 싶었던 것이 두 가지가 있는데,
ui/비즈니스 로직 분리에 대한 저의 방식에 대한 멘토님의 고견
재사용 가능한 컴포넌트와 불가능한 컴포넌트가 어찌보면 보다 세부적인 관심사를 나눈/나누지 않은 구조로 되어있는데 이러한 구조들이 통일성을 해치는 느낌이 있어서 구조에 대한 멘토님의 고견
을 여쭙고 싶었습니다!
나머지는 편하게 봐주시고 피드백 주실 부분 말씀해주시면 반영해보겠습니다!
항상 리뷰 정성들여 해주셔서 감사합니다. 좋은 저녁 되세요!🙇‍♂️]]></description><link>부스트캠프/멤버십/8주차/week8_2일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/week8_2일차_PR.md</guid><pubDate>Tue, 15 Oct 2024 10:14:01 GMT</pubDate></item><item><title><![CDATA[setInterval과 setTimeout]]></title><description><![CDATA[setTimeout과 setInterval은 호출을 할 때 자주 쓰이는 메서드이다.
이 두 함수들에는 '일정 시간이 지난 후 원하는 함수를 예약 실행' 할 수 있게 해주는 기능을 가진다.
하지만 이 예약 실행에도 작동 방식에 따라 setTimeout과 setInterval이 나누어진다.
setTimeout -&gt; 일정 시간이 지난 후에 함수를 실행
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ... ) setInterval -&gt; 일정 시간 간격을 두고 함수 실행
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
두 개의 작동 방식은 다르지만 setInterval을 통해 setTimeout을 만들 수 있고, setTimeout을 이용해 setInterval로 만들 수도 있다./** setInterval을 이용하지 않고 아래와 같이 중첩 setTimeout을 사용함
let timerId = setInterval(() =&gt; alert('째깍'), 2000);
*/ let timerId = setTimeout(function tick() { alert('째깍'); timerId = setTimeout(tick, 2000); // (*)
}, 2000);
이처럼 두 함수의 역할은 보다 명확한 '시간'을 가지고 함수를 다루는 비슷한 함수들이라고 생각을 할 수 있다. 실제로 setTImeout과 setInterval이 받는 인자의 종류와 개수가 같기 때문에, 만약 같은 함수를 지속적으로 실행하는 스케줄링과 같은 경우에 있어서 setInterval을 많이 쓰곤 한다.
하지만 이러한 setInterval을 쓸 때 꼭 주의해야 할 점이 있다.let i = 1;
setInterval(function() { func(i++);
}, 100);
다음과 같은 setInterval은 똑같이 동작하도록 setTimeout을 이용하여 만들 수 있다.let i = 1;
setTimeout(function run() { func(i++); setTimeout(run, 100);
}, 100);
하지만 이 각각의 코드가 동작 자체는 똑같이 동작하지만, 실제로 이 함수가 실행되는 방식에 대해서는 조금 다르다.let i = 1;
setInterval(function() { func(i++);
}, 100);
<img src="https://i.imgur.com/VCUyoS7.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
setInterval로 함수를 실행하는 경우에는 함수간 호출의 지연 간격이 실제 명시한 간격보다 짧아지는 효과를 가진다.
왜냐하면 함수에는 그 함수를 실행시키는 과정에서 걸리는 시간 또한 간격에 포함되어 있기 때문이다.반면 setTimeout을 중첩으로 실행하여 일정 간격으로 함수를 실행시키는 방법을 보자let i = 1;
setTimeout(function run() { func(i++); setTimeout(run, 100);
}, 100);
<br><img src="https://i.imgur.com/YIsYlYk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
중첩 setTimeout을 사용할 경우에는 이전 함수의 실행이 종료된 이후에 다음 함수 호출에 대한 스케줄링 계획이 짜여지기 때문에 명시한 지연 시간이 보장된다.
따라서 보다 명확하게 스케줄링 시간을 관리하기 위해서는 setTimeout을 통해 스케줄링 하는 것이 보다 확실한 방법이다.하지만 둘 다 스케줄링 메서드 중 하나기 때문에 CPU의 과부하나 브라우저 탭이 백그라운드인 등의 상황에 대해서는 타이머의 지연 시간이 이에 따라 늘어나기 때문에 이 또한 유의해서 사용해야 할 필요성이 있다.]]></description><link>부스트캠프/멤버십/8주차/setinterval과-settimeout.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/setInterval과 setTimeout.md</guid><pubDate>Tue, 15 Oct 2024 05:47:57 GMT</pubDate><enclosure url="https://i.imgur.com/VCUyoS7.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/VCUyoS7.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week8_1일차_PR]]></title><description><![CDATA[
클라이언트 컴포넌트 분리(ProgressBar, autoRollingNews) autoRollingNews setTimeout으로 리팩토링 확인 모달 위치 조정 및 다른 이벤트가 발생하지 않도록 관리 서버 데이터 구조 구상
서버 초기 환경설정
더미데이터 삽입 기타 주간계획작성 NOSQL
useReduce
firebase functions
나는 이번에 배포에 필요한 시간을 줄이기 위해서 저번 미션과 동일하게 firebase functions를 활용하여 서버를 만들고, 클라우드 데이터베이스인 firestore를 이용하여 데이터를 가져오는 작업을 서버에서 하는 식으로 구상했다.이 과정에서 클라우드 데이터베이스에 더미 데이터를 넣어놓을 계획이었지만, 이 과정에서 NOSQL인 클라우드 데이터베이스를 어떻게 활용하여 각 카테고리별 뉴스 데이터
내가 구독한 언론사의 뉴스 데이터
각 언론사의 뉴스 데이터
내가 구독한 언론사
전체 언론사
를 어떻게 구분하여 클라이언트로 넘겨주어야 할까? 에 대한 고민이 되었다.
내가 관리해야 하는 도메인을 나누어보자면
언론사(press)
구독(subscriptions)
언론사의 뉴스(articles)
가 있다.
<img src="https://i.imgur.com/YRN9gGb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
일단 현재 계획상으로는 해당 다이어그램과 같이 subscription에서는 press property에서 press들을 참조하고, Press의 articles 프로퍼티에서는 article들을 참조하며 article에서는 각 기사들에 대한 정보를 담을 수 있도록 했다.Articles
id: number
title:string
created_at: string
thumbnail_image:string
openLink:string
category:string
Press
id: number
pressName: string
pressLogo:string
openLink:string
editDate:string
articles : Articles[]
Subscription
id: number
subscriber: string
press: Press[]
NOSQL을 알아보는 과정에서 Firestore에 추천하는 데이터 구조 옵션이 있었다.
문서의 중첩 데이터로 표현
하위 컬렉션으로 표현
루트 수준 컬렉션
이를 적절히 활용하기 위해 나는 각 category, publisher, article을 collections로 구분할 수 있게 해 주어 도메인을 구분할 수 있도록 해주었다.
따라서 categories(collections) -&gt; category(doc) -&gt; publishers(collections) -&gt; publisher(doc) -&gt; articles(collections) -&gt; article(doc)와 같은 구조로 더미데이터가 구성된다.
]]></description><link>부스트캠프/멤버십/8주차/week8_1일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/week8_1일차_PR.md</guid><pubDate>Tue, 15 Oct 2024 01:10:11 GMT</pubDate><enclosure url="https://i.imgur.com/YRN9gGb.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/YRN9gGb.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_8주차_주간계획]]></title><description><![CDATA[
타입스크립트를 리액트에 적용하면서 보다 타입스크립트에 적응하는 과정을 거치기
babel, vite 등의 번들링 툴에 익숙해지기
tailwindcss를 써보면서 익숙해지기
Vite를 이용한 이유는 개발 과정에서 결과를 확인하기 위해 빌드하는 작업 자체가 시간이 조금 걸렸기 때문에 보다 원할한 DX(개발자 경험)을 위해서는 Vite가 낫다고 판단하였다.vite는 애플리케이션에서 사용하는 모듈에 대해 dependencies와 source code 두 가지의 범주로 나누어 개발 시작 시간을 개선한다.dependencies의 경우 개발시 내용이 바뀌지 않을 사용하는 라이브러리의 의존성 번들링 과정을 수행한다.
Vite는 Esbuild의 빌드 툴을 사용하여 번들링을 수행하는데, Esbuild의 경우 기존 webpack이나 parcel보다 100배 이상 빠른 속도를 보장한다.
<img src="https://i.imgur.com/m02Qv9T.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> Source code의 경우 우리가 대표적으로 사용하는 프레임워크의 확장자를 사용하면서 만드는 컴포넌트, 즉 Non-plain Js들의 소스코드를 의미한다. 해당 코드들의 경우에는 실행하기 위해서는 컴파일을 수행할 필요성이 있다.<br>
<img src="https://i.imgur.com/09THGeF.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
하지만 기존의 번들링된 코드 기반 개발 서버는 개발하는 과정에서 소스 코드의 수정이 일어났을 때마다 통채로 다시 번들링하는 과정이 필요했기 때문에 불필요한 시간 소요가 발생했다.<br><img src="https://i.imgur.com/uOvekx1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이러한 문제를 느낀 Vite는 Native ESM 방식을 이용해서 개발 서버(Hot Reloading)를 구동한다.
ESM 방식을 사용하는 방식의 장점은, import를 통해 동적으로 그때그때 필요한 파일들만을 가져온다는 점이다. 번들링을 하지 않고 개별 파일에 대해 트랜스파일링만 한 다음 이를 import하는 구조들을 통해 하나의 페이지를 완성할 수 있도록 만들었다.따라서 나는 빠른 개발을 위해 vite를 선택했다<br><img src="https://i.imgur.com/58yg3ku.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
콘텐츠는 웹 화면의 정중앙 배치
기본 상단 영역 왼쪽에 뉴스 스탠드 로고 클릭시 새로고침 오른쪽에는 시스템 날짜 최신 뉴스 자동 롤링
언론사별 기사들을 확인하는 영역 전체 언론사 탭의 그리드 보기를 디폴트로
내가 구독한 언론사 탭의 타이틀 옆에는 badge 컴포넌트로 내가 구독한 언론사의 숫자를 표시 <br><img src="https://i.imgur.com/eGMIXnr.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
왼쪽 바와 오른쪽 바는 각각 다른 최신 뉴스의 헤드라인 5개가 5초마다 자동으로 무한 롤링됨
좌우 영역의 시간차를 1초로 하여 두 영역의 뉴스가 동시에 롤링되지 않도록 함
롤링 시, 바 영역 안에서 제목이 위로 넘어가는 애니메이션을 적용
각 영역에 마우스를 hover하면 무한 롤링을 일시정지하고, 헤드라인에 밑줄을 표시
마우스가 해당 영역에서 벗어나면 다시 1초의 간격을 두고 두 영역의 뉴스가 롤링되도록 함
<br><img src="https://i.imgur.com/dfqtREZ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
가로 930px, 세로 388px 영역에 6*4의 테이블이 들어가도록 한다
각 테이블의 셀에는 언론사 브랜드 마크가 중앙에 배치
언론사 브랜드 마크의 순서는 페이지가 새로고침 될 때마다 랜덤으로 배치
그리드의 과주에는 화살표를 배치하여 페이지를 넘김
가장 첫 페이지와 가장 끝 페이지에서 disabled 되는 화살표는 아예 표시 X
<br><img src="https://i.imgur.com/Md0obJj.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
각 언론사 브랜드마크가 있는 셀에 마우스를 올리면, 구독하기 버튼이 뜸
이미 구독하고 있는 언론사의 경우, 해지하기 버튼
<br><img src="https://i.imgur.com/jbG0Bi5.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
각 분야 카테고리에서 언론사의 기사 확인 종합/경제
방송/통신
IT
영자지
스포츠/연애
매거진/전문지
지역 선택된 카테고리의 이름 옆에는 해당 카테고리에 속해있는 언론사의 개수와 현재 언론사의 순서를 표시
언론사의 순서는 화면이 새로고침 될 때마다 랜덤으로 정하기
현재 순서의 언론사 내용 표시
한 언론사당 20초간 화면이 보이지 않음
카테고리명 배경이 프로그레스 바가 되어 초마다 색이 차오르도록 애니메이션 적용
20초가 되면 다음 언론사의 내용이 나타남
카테고리의 마지막 언론사가 20초간 보여진 후에는 다음 카테고리로 넘어감
가장 마지막 카테고리의 마지막 언론사가 보여진 후에는, 처음 카테고리의 첫 언론사로 돌아옴
좌우의 화살표를 통해서도 즉시 이전/다음 언론사로 이동
선택된 카테고리 외의 다른 카테고리에는 마우스를 올리면 밑줄이 생김
각 카테고리를 누르면 해당 카테고리로 바로 이동 언론사 기사 영역에는 아래의 요소들이 들어감 언론사 브랜드 마크
최종 편집 일시
구독하기 버튼
썸네일이 있는 메인 뉴스 1건
타이틀만 있는 서브 뉴스 6건
편집권에 대한 안내 문구 메인 뉴스에 마우스를 올리면 썸네일은 5% 확대되고 뉴스 타이틀에 밑줄 생김
구독하기 버튼을 누르면 서버에서 처리되는 시간동안 버튼에 loading indicator가 보이도록 하고, 완료되는 즉시 내가 구독한 언론사 탭의 리스트 보기 화면으로 이동
<br><img src="https://i.imgur.com/mBUUNLa.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내가 구독한 언론사의 리스트 보기 -&gt; 전체 언론사의 리스트 보기 화면과 동일하되, 카테고리들이 나열되어있던 가로 탭에 언론사의 이름과 &gt; 화살표 아이콘이 보이도록
언론사는 구독한 순서대로 배치
전체 언론사 탭 상태에서는 그리드 보기가 기본인 것처럼, 내가 구독한 언론사 탭 상태에서는 리스트 보기가 기본<br>
<img src="https://i.imgur.com/U0vncL5.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
구독 해지 버튼을 누르면 커스텀 알럿 뜨기 예, 해지합니다
아니오 각 버튼에도 마우스를 올리면 텍스트에 밑줄이 생기도록
'예, 해지합니다'를 선택하면 즉시 구독이 해지되고, 목록의 다음 순서 언론사가 바로 나타나도록 함
<br><img src="https://i.imgur.com/Jouweif.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내가 구독한 언론사의 그리드 보기 화면은 전체 언론사의 그리드 보기 화면과 동일
다만, 사용자가 구독을 누른 언론사의 브랜드마크만 보이고, 나머지 칸은 비어있도록
구독중인 언론사의 브랜드 마크 셀에 마우스를 올리면 구독 해지 버튼이 나타남 리스트 보기 상태에서 구독 해지를 하는 것과 동일하게 알럿이 뜨도록 함
구독이 해지되는 즉시 그리드에서 해당 언론사의 브랜드마크가 사라짐 <br><img src="https://i.imgur.com/kfqLkDE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Foundation의 컬러 팔레트 저옵를 활용해 다크모드 테마 만들기
다크모드로 전환 시, 로고들도 다크모드 버전으로 일괄 전환 Vite 설정
tailwind 설정
eslint 설정
prettier 설정 컴포넌트 설계 각 컴포넌트 별로 나눠야 할 부분 설계
data fetching이 필요한 부분 설계
폴더 구조 설계
폴더 구조에 맞도록 컴포넌트와 데이터 등 설계 mock 데이터 설계
<br><img src="https://i.imgur.com/ekkPl7N.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
콘텐츠는 웹 화면의 정중앙 배치
기본 상단 영역 왼쪽에 뉴스 스탠드 로고 클릭시 새로고침 오른쪽에는 시스템 날짜 최신 뉴스 자동 롤링
언론사별 기사들을 확인하는 영역 전체 언론사 탭의 그리드 보기를 디폴트로
내가 구독한 언론사 탭의 타이틀 옆에는 badge 컴포넌트로 내가 구독한 언론사의 숫자를 표시 가로 930px, 세로 388px 영역에 6*4의 테이블이 들어가도록 한다
각 테이블의 셀에는 언론사 브랜드 마크가 중앙에 배치
언론사 브랜드 마크의 순서는 페이지가 새로고침 될 때마다 랜덤으로 배치
그리드의 과주에는 화살표를 배치하여 페이지를 넘김
가장 첫 페이지와 가장 끝 페이지에서 disabled 되는 화살표는 아예 표시 X
각 언론사 브랜드마크가 있는 셀에 마우스를 올리면, 구독하기 버튼이 뜸
이미 구독하고 있는 언론사의 경우, 해지하기 버튼 각 분야 카테고리에서 언론사의 기사 확인 종합/경제
방송/통신
IT
영자지
스포츠/연애
매거진/전문지
지역 선택된 카테고리의 이름 옆에는 해당 카테고리에 속해있는 언론사의 개수와 현재 언론사의 순서를 표시
언론사의 순서는 화면이 새로고침 될 때마다 랜덤으로 정하기
현재 순서의 언론사 내용 표시
카테고리명 배경이 프로그레스 바가 되어 초마다 색이 차오르도록 애니메이션 적용
20초가 되면 다음 언론사의 내용이 나타남
카테고리의 마지막 언론사가 20초간 보여진 후에는 다음 카테고리로 넘어감
가장 마지막 카테고리의 마지막 언론사가 보여진 후에는, 처음 카테고리의 첫 언론사로 돌아옴
좌우의 화살표를 통해서도 즉시 이전/다음 언론사로 이동
선택된 카테고리 외의 다른 카테고리에는 마우스를 올리면 밑줄이 생김
각 카테고리를 누르면 해당 카테고리로 바로 이동 언론사 기사 영역에는 아래의 요소들이 들어감 언론사 브랜드 마크
최종 편집 일시
구독하기 버튼
썸네일이 있는 메인 뉴스 1건
타이틀만 있는 서브 뉴스 6건
편집권에 대한 안내 문구 메인 뉴스에 마우스를 올리면 썸네일은 5% 확대되고 뉴스 타이틀에 밑줄 생김
구독하기 버튼을 누르면 서버에서 처리되는 시간동안 버튼에 loading indicator가 보이도록 하고, 완료되는 즉시 내가 구독한 언론사 탭의 리스트 보기 화면으로 이동
내가 구독한 언론사의 리스트 보기 -&gt; 전체 언론사의 리스트 보기 화면과 동일하되, 카테고리들이 나열되어있던 가로 탭에 언론사의 이름과 &gt; 화살표 아이콘이 보이도록
언론사는 구독한 순서대로 배치
전체 언론사 탭 상태에서는 그리드 보기가 기본인 것처럼, 내가 구독한 언론사 탭 상태에서는 리스트 보기가 기본 flux 아키텍처의 철학과 활용 방법
React Router를 활용하는 방법
NOSQL에서의 문서 구조 서버에 맞는(firebase functions) 데이터 설계하기 서버리스 환경에서의 구조에 대해서 설계 기존의 컴포넌트에서 useReducer로 리팩토링 하기 좋은 것들을 찾고 리팩토링
useContext를 이용하여 props drilling으로 문제가 될만한 것들을 찾고 리팩토링
서버와의 연동 firestore 더미 데이터 삽입
CRUD 설계 기사 관련 모든 기사 조회(Get)
롤링 뉴스용 짧은 기사 조회(Get) 구독 관련 구독한 언론사 조회(Get)
구독한 언론사의 기사 조회(Get) ]]></description><link>부스트캠프/멤버십/8주차/멤버십_8주차_주간계획.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/멤버십_8주차_주간계획.md</guid><pubDate>Tue, 15 Oct 2024 00:24:40 GMT</pubDate><enclosure url="https://i.imgur.com/m02Qv9T.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/m02Qv9T.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_8주차]]></title><description><![CDATA[<a data-href="멤버십_8주차_주간계획" href="부스트캠프/멤버십/8주차/멤버십_8주차_주간계획.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_8주차_주간계획</a><br>
<a data-href="멤버십_8주차_마스터클래스" href="부스트캠프/멤버십/8주차/멤버십_8주차_마스터클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_8주차_마스터클래스</a><br><a data-href="week8_1일차_PR" href="부스트캠프/멤버십/8주차/week8_1일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week8_1일차_PR</a><br>
<a data-href="week8_2일차_PR" href="부스트캠프/멤버십/8주차/week8_2일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week8_2일차_PR</a><br>
<a data-href="week8_3일차_PR" href="부스트캠프/멤버십/8주차/week8_3일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week8_3일차_PR</a><br>
<a data-href="week8_4일차_PR" href="부스트캠프/멤버십/8주차/week8_4일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week8_4일차_PR</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.isquaredsoftware.com/2021/01/context-redux-differences/" target="_self">https://blog.isquaredsoftware.com/2021/01/context-redux-differences/</a>]]></description><link>부스트캠프/멤버십/8주차/멤버십_8주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/멤버십_8주차.md</guid><pubDate>Mon, 14 Oct 2024 14:43:42 GMT</pubDate></item><item><title><![CDATA[NOSQL 맛보기]]></title><description><![CDATA[Not Only SQL의 약자.
RDBMS의 한계를 극복하기 위해 만들어진 데이터베이스로, RDBMS와 같이 고정된 스키마나 JOIN이 존재하지 않는 다소 자유로운 데이터베이스.앞에서도 말했듯이 RDBMS에는 어느정도 한계가 있다.
복잡도와 용량적인 측면에서 한계를 가지고 있으며, 활용에도 제약이 깐깐하기 때문에 이러한 점은 장점이면서도 단점으로 다가온다.NoSQL은 유연성과 확장성이 더 뛰어나기 때문에 많은 경우 SQL보다 선호됩니다. NoSQL 시스템 사용의 주요 이점은 개발자가 기존 관계형 데이터베이스의 오버헤드 없이 데이터를 빠르고 쉽게 저장하고 액세스할 수 있다. 따라서 개발을 함에 있어서 기본 데이터 스토리지 구현에 대한 걱정 없이 기능 및 코어 비즈니스 로직을 더 빠르게 제공하는 데 집중할 수 있다.이를 정리해보면
유연성 : 스키마 선언 없이 필드의 추가 및 삭제가&nbsp;자유로운 Schema-less 구조
확장성 : 스케일 아웃에 의한&nbsp;서버 확장이 용이
고성능 : 대용량 데이터를 처리하는&nbsp;성능이 뛰어나다
가용성 : 여러 대의 백업 서버 구성이 가능하여 장애 발생 시에도&nbsp;무중단 서비스가 가능
등의 장점을 가진다. 하지만 이렇게 유연성과 같은 장점은 단점으로도 작용할 수 있는 점이 있다.
스키마가 없기 때문에 그만큼 유연하지만, 유연한 만큼 데이터베이스 일관성에 약하다.
추가적으로 key값에 대한 입출력만 지원
스키마가 정해져 있지 않아, 데이터에 대한 규격화가 되어 있지 않다.
데이터가 여러 컬렉션에 중복되어 있어서 데이터를&nbsp;UPDATE 하는 경우 모든 컬렉션에서 수행해야하기 때문에 느리다.
데이터 중복으로 인한 수정 작업의 번거로움
<img src="https://i.imgur.com/UZWsSBv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> BASE
(Basically Available, Soft State, Eventually Consistent)
Basically Available(가용성)<br>
<img src="https://blog.kakaocdn.net/dn/VoGEi/btrmgJc8ylA/eASXClupzZr4n9jOTBIZWk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Master 서버에 장애 발생 시에도 여러 Slave 서버로 인해 무중단 서비스가 가능함Soft State(소프트 상태)<br><img src="https://blog.kakaocdn.net/dn/VCgVg/btrmhZzvs5a/u4Vf2vb95KScglJ41lZfl0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">각각의 데이터가 도달한 시점에 데이터가 갱신됨Eventually Consistent(결과적 일관성)<br><img src="https://blog.kakaocdn.net/dn/rIkdf/btrmhtASzmH/O6lknKCfk6J9bKWvjPtQu0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">복제 메커니즘에 의해 모든 서버에 데이터 복제가 동시에 실행될 수 없음
시스템 부하 및 네트워크 속도에 따라 서버에 복제하는 시간이 다를 수 있으나 최종적으로는 모든 서버에 데이터가 복제됨
특징 : 데이터 가용성과 데이터 처리 성능이 향상되도록한다
중점 사항 : 서비스 가용성
Key와 Value으로 구성된 배열구조의 데이터베이스로 가장 단순한 구조
저장과 조회 라는 가장 간단한 원칙에 충실한 데이터베이스 기본적인 패턴으로 Key, Value가 하나의 묶음으로 저장되는 구조이기 때문에 속도가 빠르며 분산 저장에 용이하다
값에 모든 데이터 타입이 허용가능하다. 대신 모든 데이터 타입을 허용하는 만큼 데이터 입력 단계에서 검증 로직을 제대로 구현해야 한다 Key는 중복될 수 없고 이 Unique Key에 각각 하나의 Value를 가지고 있는 형태가 된다. 데이터를 조회 및 입력할 때, Key를 가지고 접근할 수 있다. 성능 향상을 위해 RDBMS 에서 캐싱 (Redis)
장바구니 같은 웹애플리케이션에서 일시적인 속성 추적
이미지나 오디오 파일 같은 대용량 객체 저장 Redis
AWS DynamoDB
Riak
Document Database 또는 Document-Oriented Database는 위의 Key-Value Database와 같이 데이터 저장에 Key-Value Type를 사용한다.
하지만 Key-Value Database와의 중요한 차이는&nbsp;Document Database는 값을 문서로 저장함 문서란&nbsp;semi-structured entity이며 보통 JSON이나 XML 같은 표준 형식 값을 저장하기 전에 schema를 별도로 정의하지 않으며, 문서를 추가하면 그게 바로 schema가 된다.
각 문서별로 다른 필드를 가질 수 있으며, 따라서 개발자가 애플리케이션에서 데이터를 입력하는 단계에서 컬럼과 필드의 관리가 제대로 이루어지도록 보장하는 것이 매우 중요하다. 예를 들어 필수 속성(Null을 허용하지 않는 속성)에 대한 관리도 애플리케이션 레벨에서 관리가 이루어져야 한다. 예시로 MongoDB의 AirBnB DataSet의 일부를 보자. 다음과 같은 JSON 형태의 문서로 관리된다.{ "_id": "10006546", "listing_url": "https://www.airbnb.com/rooms/10006546", "name": "Ribeira Charming Duplex", "summary": "Fantastic duplex apartment with three bedrooms, located in the historic area of Porto, Ribeira (Cube)...", "house_rules": "Make the house your home...", "property_type": "House", "calendar_last_scraped": { "$date": { "$numberLong": "1550293200000" } }, "amenities": [ "TV", "Cable TV", "Wifi", "Kitchen", "Paid parking off premises", "Smoking allowed", "Microwave" ] }
Document Database 는 다음과 같은 목적으로 주로 활용된다.
1. 대용량 데이터를 읽고 쓰는 웹 사이트용 백엔드 지원
2. 제품처럼 다양한 속성이 있는 데이터 관리
3. 다양한 유형의 메타데이터 추적
4. JSON 데이터 구조를 사용하는 애플리케이션
5. 비정규화된 중첩 구조의 데이터를 사용하는 애플리케이션
MongoDB CouchDB Couchbase
컬럼 패밀리 데이터베이스는 대용량 데이터, 읽기와 쓰기 성능, 고가용성을 위해 설계되었다.
구글의 Big Table, 페이스북은 Cassandra가 있다.
Relation Database와 동일한 용어를 사용하여 스키마 정의
컬럼 수가 많으면 관련된 컬럼들을 컬렉션으로 묶음
Document Database와 마찬가지로 미리 정의된 스키마를 사용하지 않아 개발자가 데이터를 입력하는 시점에 원하는 대로 컬럼을 추가
테이블간 조인 지원 안함
일반적으로 비정규화 되어 있으며 한 객체에 관련된 모든 정보를 가능한 매우 너비가 넓은 단일 Row에 넣어서 보관함
여러대로 구성된 클러스터에서 운영 되므로 데이터가 적다면 document나 key-value database가 나음
<br><img src="https://miro.medium.com/v2/resize:fit:1400/0*dlH4j-lgJcWU2WlT.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
데이터베이스에 쓰기 작업이 많은 애플리케이션 지리적으로 여러 데이터 센터에 분산되어 있는 애플리케이션 복제본 데이터가 단기적으로 불일치하더라도 큰 문제가 없는 애플리케이션 동적 필드를 처리하는 애플리케이션 수백만 테라바이트 정도의 대용량 데이터를 처리할 수 있는 애플리케이션 Hbase Cassandra GCP BigTable Microsoft Azure Cosmos DB**
]]></description><link>부스트캠프/멤버십/8주차/nosql-맛보기.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/NOSQL 맛보기.md</guid><pubDate>Mon, 14 Oct 2024 12:16:14 GMT</pubDate><enclosure url="https://i.imgur.com/UZWsSBv.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/UZWsSBv.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_8주차_마스터클래스]]></title><description><![CDATA[웹 아키텍처 스타일 중 하나이며, 사실상 웹 아키텍처의 표준
URI로 자원을 식별하고, HTTP 메서드(GET/POST/DELETE 등)를 통해 자원을 조작STATE -&gt; 변경이 되는 데이터들
JSON, XML, HTML 등
XML은 계층적인 데이터 구조를 정의
데이터를 문자열로 받을 수 있고, Key-value 구조처럼 받을 수도 있음. 이들이 하나의 표현 방법이고, 선택함 URI와 HTTP 메서드를 활용해 클라이언트와 서버 간에 교환되는 과정 모든 것이 자원(Resource) URI를 통한 자원의 식별
고유한 id를 부여해서 나중에라도 들어가도 똑같이 볼 수 있도록 설계해야 함 자원은 다양한 형태로 표현함
stateless 서버는 클라이언트 상태를 기억하지 않음
페이지 단위 개발의 경우에는 상태 저장(세션 정보)을 서버에서 저장. 누구한테 줬는지 확인하지 않음
서버는 단순해지고, 확장성 용이 캐시 가능 캐시는 백엔드에서 redis 등 효과적으로 하기 위해 캐시를 둠
클라이언트에서도 캐시 처리에 대한 방법이 많음 React-Query
Apollo Client
Service-worker
캐시가 브라우저에 저장되는 방식 중복 요청 방지
응답 헤더에 Cache-control, Expires layered System 캐시 서버, 웹서버, 프록시 서버, L4... Uniform Interface URI
Status code
HTTP 기반 메서드를 활용해서 자원의 조작 가능 stateless로 충분한가? 언제 statefulgksrk? stateless에서는 연속된 요청에서 데이터 양이 증가하는 문제
쿠키? 세션
개인화, 인증, 권한 관리 등
두 가지의 균형이 중요 중복 요소 분리하기
렌더링 영향도가 낮은 상태(전처리 영역)
사실 suspense와 error boundary쓰면 됨 컴포넌트는 무엇인가? 의미있는 요소. (modal, calendar, navigation, slider, UI의 독립적인 화면단위 등)
React 컴포넌트 재사용을 해야하는가? 반복 또는 중복인가? 현실은? 화면은 조금만 달라도 재사용은&nbsp;어렵다.&nbsp;😣 동작, 스타일 등 만약 여러개의 상태를 공유하는 법 하나의 상태를 공유한다고 할 때 한 쪽에는 함수를 넣어주고, 이벤트 이미터와 비슷한 방식으로 이벤트를 호출하는 방법도 있고, 동작하고자 하는 함수를 전달하는 방법도 있음 unidirection data flow action 을 전달
store에서 데이터 변경 관리
view는 store를 구독하는 방식 <img src="https://krasimir.gitbooks.io/react-in-patterns/content/chapter-08/fluxiny_basic_flux_architecture.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">//view에서
dispatch({ type: 'deposit', payload: 10
}) //reducer에서 switch (action.type) { case "deposit": return { action.payload } .... .....
복잡한 상태관리에서 useState보다 유리하다.
구체적인 상태변경을 감추고, reducer에 맡길 수 있다.
또한 콜백(setState 등)을 계속 하위component 에 전달해줘야 하는 불편함을 줄일 수 있다. 대신 dispatch라는 매개체 역할의 함수를 전달해준다.<br>참고 :&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://react.dev/reference/react/useReducer" target="_self">https://react.dev/reference/react/useReducer</a>const initialState = {count: 0}; function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; default: throw new Error(); }
} function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt; &lt;/&gt; );
} Hooks API에서도 Flux architecture 를 따르며 개발 가능.
view 에서 상태변경 로직도 분리.
"그렇다면 Redux를 어느정도 대체가능?"
Context API 조합으로 같이 사용하면 어떨까? const postReducer = (posts, { type, payload }) =&gt; { switch (type) { case 'SET_INITIAL': return [...payload]; case 'ADD_POST': return [...posts, { title: payload, id: posts.length + 1, picked: false }]; case 'TOGGLE_PICKED': return posts.map(post =&gt; post.id === payload ? { ...post, picked: !post.picked } : post ); default: return posts; }
}; export const PostsContext = React.createContext(); const App = () =&gt; { const [posts, dispatch] = React.useReducer(postReducer, []); const addItemHandler = () =&gt; { const newTitle = prompt("Enter new post title"); if (newTitle) { dispatch({ type: 'ADD_POST', payload: newTitle }); } }; return ( &lt;PostsContext.Provider value={{ posts, dispatch }}&gt; &lt;PickedItems posts={posts} /&gt; &lt;button onClick={addItemHandler}&gt;ADD&lt;/button&gt; &lt;Items posts={posts} /&gt; &lt;/PostsContext.Provider&gt; );
};
pure function은 순수 함수로 제작
테스트 하기가 용이함(예측이 쉬움
테스트 가능성 ]]></description><link>부스트캠프/멤버십/8주차/멤버십_8주차_마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/멤버십_8주차_마스터클래스.md</guid><pubDate>Mon, 14 Oct 2024 05:59:40 GMT</pubDate><enclosure url="https://krasimir.gitbooks.io/react-in-patterns/content/chapter-08/fluxiny_basic_flux_architecture.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://krasimir.gitbooks.io/react-in-patterns/content/chapter-08/fluxiny_basic_flux_architecture.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[상태 관리를 위한 context API와 전역 상태 라이브러리에 대한 고찰]]></title><description><![CDATA[Context란?
리액트로 만들어진 애플리케이션에서는 부모가 가지고 있는 데이터를 자식에서도 사용하고 싶다면 props로 데이터를 넘겨준다.
이렇게 부모의 데이터를 계속해서 자식 컴포넌트로 넘겨주는 과정을 props drilling이라고 하는데, 이 props drilling은 일정 depth를 넘게 된다면 어느순간 데이터의 흐름을 놓치기 십상이고, 이에 따라 유지보수성 또한 떨어진다.이러한 props들의 관리가 점점 어려워지자, 리액트에서 등장한 개념이 Context이다. context를 사용하면 명시적인 props의 전달이 없더라도 선언한 하위 컴포넌트 모두에서 자유롭게 원하는 값을 가져와 사용할 수 있다. 이게 가능할 수 있었던 이유는 리액트는 구성 요소들의 정보를 가진 fiber 트리가 있기 때문에 해당 트리에서 따로 관리할 수 있도록 context를 일반 함수형 컴포넌트가 아닌 따로 context에 대한 처리가 있기 때문이다. 그렇기 때문에 props는 구성 요소 트리를 통해 데이터를 전달하게 될 수 있다.function ParentComponent() { const [counter, setCounter] = useState(0); //context 선언 const MyContext = React.createContext() // state와 setter함수를 한번에 담고 있는 객체 설정 const contextValue = {counter, setCounter}; return ( &lt;MyContext.Provider value={contextValue}&gt; &lt;SomeChildComponent /&gt; &lt;/MyContext.Provider&gt; )
}
이런 식으로 state와 setter 함수에 대해서 하나로 묶어준 다음에, useContext()로 선언한 값에 떄하여 Provider 속성을 통해 context를 내려주는 컴포넌트로 사용할 수 있다.function NestedChildComponent() { const { counter, setCounter } = useContext(MyContext); // do something with the counter value and setter
}
그렇게 되면 ]]></description><link>부스트캠프/멤버십/8주차/상태-관리를-위한-context-api와-전역-상태-라이브러리에-대한-고찰.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/상태 관리를 위한 context API와 전역 상태 라이브러리에 대한 고찰.md</guid><pubDate>Mon, 14 Oct 2024 03:59:01 GMT</pubDate></item><item><title><![CDATA[배럴 파일에 대한 고찰]]></title><description><![CDATA[
해당 글은 다음 글을 번역 및 정리한 글입니다.
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/" target="_self">https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/</a>
만약 여러 파일들을 가진 프로젝트를 사용한다고 하면, 우리는 이런 식으로 import해와서 해당 모듈을 사용한다.import { foo } from "./some/other-file"; export function myCoolCode() { // Pretend that this is super smart code :) const result = foo(); return result;
}
하지만 이런 파일이 한두개라면 괜찮겠지만, 라이브러리들을 보면 정말 많은 모듈들이 있다. 또한 각 모듈마다 파일을 나누게 된다면 우리가 사용하는 import 문은 점점 더 많아지게 된다.하지만 이렇게 import를 하지 않기 위해서는 모듈들을 한 곳에 모두 모아놓고 관리할 수도 있으나, 그렇게 되면 파일 자체가 여러 역할을 지니기 때문에 나중에 유지보수성이 낮아지게 된다.사이즈가 점점 더 커질 때마다 이 문제는 점점 더 심해질 것이다.import { foo } from "../foo";
import { bar } from "../bar";
import { baz } from "../baz";
결국 우리는 각각의 디렉토리에서 모듈들을 하나하나씩 다 import문을 쓰게 되된다. 불필요하게 import가 길어지면서 코드가 예뻐보이지 않을 수 있다.이러한 문제를 해결하기 위해 배럴 파일(barrel file) 이라는 패턴을 사용할 수 있다.
배럴 파일은 여러 개의 모듈 디렉토리 위에 하나의 index.js를 두고 export 하는 방식이다.// feature/index.js
export * from "./foo";
export * from "./bar";
export * from "./baz";
이렇게 상위에서 모든 것들을 다시금 export해주는 파일을 만들게 되면 여러 모듈들을 한번에 import 해올 수 있기 때문에, 위 예시처럼 3개의 import 문이 하나로 합쳐질 수 있다.import { foo, bar, baz } from "../feature";
여러 개의 모듈을 한번에 모아서 한 곳에서 받아오면 이만큼 보기 좋은게 없다!실제로 리액트의 경우도 이런 방식으로 배럴 파일을 두고 있다.// react/packages/react/index.js
/** * Copyright (c) Meta Platforms, Inc. and affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. * * @flow */ ... // Export all exports so that they're available in tests.
// We can't use export * from in Flow for some reason.
export { __CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, __COMPILER_RUNTIME, Children, Component, Fragment, Profiler, PureComponent, StrictMode, Suspense, cloneElement, createContext, createElement, createRef, use, forwardRef, isValidElement, lazy, memo, cache, startTransition, unstable_DebugTracingMode, unstable_LegacyHidden, unstable_Activity, unstable_Scope, unstable_SuspenseList, unstable_TracingMarker, unstable_getCacheForType, unstable_useCacheRefresh, useId, useCallback, useContext, useDebugValue, useDeferredValue, useEffect, experimental_useEffectEvent, useImperativeHandle, useInsertionEffect, useLayoutEffect, useMemo, useOptimistic, useSyncExternalStore, useReducer, useRef, useState, useTransition, useActionState, version,
} from './src/ReactClient';
그렇기 때문에 우리는 이런 식으로 간편하게 import문을 통해서 여러 훅들을 가져와 사용한다.import { useState } from "react";
정말 깔끔하고 보기 좋지 않은가?
이걸 보고 각각의 여러 모듈들을 가진 파일들에 대해 index를 두고 import하려는 사람들은 성능에 대해서 생각해볼 필요가 있다.만약 이러한 패턴이 가독성이 좋아보여서 자신의 폴더 구조 또한 배럴 파일 패턴을 적용하기 위해서 많은 파일들이 있는 디렉토리에서 index.js를 두고 다시금 export 한다고 생각해보자.그렇게 된다면, 이 index.js들은 디렉토리 계층 구조에서 한 계단씩 계속 올라가면서도 index.js 배럴 파일이 생길 것이고, 마지막 루트에서는 하나의 index.js에 모든 모듈들을 담을 수 있게 된다.아유 깔끔하니 야무지네~..~<br>
<img src="https://i.imgur.com/cy5w2kr.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">라고만 생각한다면 나중에 큰코 다칠 수 있다.우리는 이 index.js 파일을 통해 하나의 모듈을 import 한다고 했을 때, 내가 필요한 모듈만을 import해와서 사용한다고 생각한다. 하지만 이는 반은 맞고 반은 틀리다.내가 필요한 모듈만을(X) import해와서 사용한다(O)배럴 파일에 있는 모듈들 중에 하나를 import해와서 사용하는 경우, 배럴 파일에 있는 모든 모듈들은 import를 해오는 과정에서 함께 import된다.이 말의 의미는 무엇인가?
결국 전역변수가 있다면 이에 따른 예외가 발생할 수 있다는 것이다.// a.js
globalThis.foo = 123; // b.js
console.log(globalThis.foo); // should log: 123 // index.js
import "./a";
import "./b";
여기에서 이런 식으로 b를 실행하게 되면 123이 출력되는 것을 알 수 있다.
결국 이는 곧 전역 변수를 생성했을 때, 하나라도 충돌이 날 수 있다는 가능성을 포함한다. 그렇기에 우리의 예상과는 다른 동작이 일어날 수 있다.결국 위 예시를 통해서도 알 수 있듯이, 내가 b 모듈만 가져와서 사용한다고 하더라도, 배럴 파일에서 가져오는 과정에서 배럴 파일이 import하는 모든 모듈들 또한 함께 딸려오게 된다.
이 문제는 테스트를 할 때 더 안좋은 방향으로 작용한다.jest와 같은 테스트러너는 테스트 파일마다 새로운 자식 프로세스에서 실행되는데, 만약 테스트 파일이 여러개라면 모듈 그래프를 각 파일마다 처음부터 그리고 import해오는 과정이 반복적으로 발생하기 때문에 이에 대한 비용을 모두 지불해야 한다.
모듈 그래프를 그리는데 6초가 걸린다고 가정하면, 테스트 파일이 100개일 때는 10분동안 테스트만 돌려야 한다는 뜻이다.문제는 모듈 그래프를 그리는 비용 뿐만이 아니다. import cycle linitng rules에 대한 린팅 과정에서 생기는 비용 또한 부가적으로 발생한다.
import cycle liniting rules
모듈들이 순환 참조하는 상황을 방지하기 위해 정해놓는 린팅 규칙으로, 모듈 간의 의존성을 명확하게 유지하기 위해 사용한다.
린터는 파일 별로 실행되기 때문에 결국 테스트파일 100개가 생기면 여기에 따라서도 린터가 각각 생성될 수밖에 없다. 그렇게 되면 린팅도 각각 import되는 모든 모듈에 대해 검사를 진행하는 과정에서 시간은 기하급수적으로 증가한다.<br><img src="https://i.imgur.com/z7nHx1U.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
레퍼런스에서는 순환참조하는 파일을 만든 후에, 모듈 그래프를 그리는 비용을 측정한 그래프를 첨부했다. 모듈은 비어있는 상태임에도 불구하고 모듈이 많아지면 많아질수록 비용은 엄청나게 높아지는 것을 볼 수 있다. 500개 모듈:&nbsp;0.15s * 100 / 4&nbsp;=&nbsp;3.75s&nbsp;오버헤드
1000개 모듈:&nbsp;0.31s * 100 / 4&nbsp;=&nbsp;7.75s&nbsp;오버헤드
10000개 모듈:&nbsp;3.12s * 100 / 4&nbsp;=&nbsp;1:18m&nbsp;오버헤드
25000개 모듈:&nbsp;16.81s * 100 / 4&nbsp;=&nbsp;~7:00m&nbsp;오버헤드
50000개 모듈:&nbsp;48.44s * 100 / 4&nbsp;=&nbsp;~20:00m&nbsp;오버헤드
만약 4개의 프로세스가 병렬 처리된다고 해도, 50000개 모듈까지 가면 테스트 한번 하는데 한세월 걸리는 대참사가 벌어진다.
그래서 최근 현업에서는 배럴 파일의 사용을 최대한 지양하고 있다고 한다. 우리 또한 이러한 배럴 파일이 성능에 미치는 영향을 제대로 알고 사용할 필요가 있다.
개발 환경의 성능을 높이기 위해서는 배럴 파일 사용을 재고하자
모듈 관리의 편리함보다 성능이 더 중요하다
효율적인 코드 관리를 위해서는 각 모듈을 명확하게 import하는 것이 바람직하다
]]></description><link>부스트캠프/멤버십/8주차/배럴-파일에-대한-고찰.html</link><guid isPermaLink="false">부스트캠프/멤버십/8주차/배럴 파일에 대한 고찰.md</guid><pubDate>Sun, 13 Oct 2024 07:01:11 GMT</pubDate><enclosure url="https://i.imgur.com/cy5w2kr.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/cy5w2kr.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_7주차_마스터클래스]]></title><description><![CDATA[CDN(Contents Delivery Network)
정적인 파일들을 올려놓고 엔드 유저에게 빨리 보내줄 수 있도록 올려놓기
AWS S3, Cloud Front 두 가지 서비스bucket을 만드는게 시작점
bucket의 근본적인 기능은 파일을 업로드 하는 것
생성한 버킷의 이름의 리소스 url로 접근하여 빠르게 가져올 수 있음]]></description><link>부스트캠프/멤버십/7주차/멤버십_7주차_마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/멤버십_7주차_마스터클래스.md</guid><pubDate>Fri, 11 Oct 2024 09:52:41 GMT</pubDate></item><item><title><![CDATA[week7_4일차_PR]]></title><description><![CDATA[
프로그레스바 애니메이션 구현 및 페이지 이동
리팩토링 (컴포넌트 재사용성 높이기)
<img src="https://i.imgur.com/gv2t79A.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/HTeKQMA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> requestAnimationFrame
CSS - transition
안녕하세요 멘토님! 오늘도 고생 많으십니다ㅎㅎ
어제 저는 대부분의 ui를 구현했고 현재는 세부적인 상태관리와 같은 부분을 조금씩 채워나가고 있습니다!
아래에 있는 것들은 제가 구현을 하는 과정에서 고민하고 해결하거나 아직까지 의문점이 좀 남은 것들을 정리해 보았습니다. 편하게 봐주시고 말씀해주시면 감사하겠습니다🙇‍♂️🙇‍♂️ 저번 시간에 멘토님께서도 말씀해주셨다시피 패턴을 그대로 사용해서 프로젝트를 진행하기에는 무리가 있다고 생각했습니다. 기존의 fsd 패턴의 목적은 그대로 가져가되, 제가 감당할 수 있을 정도의 규모가 될 수 있도록 폴더 구조를 개선해보았습니다.
app : 앱의 엔트리 포인트를 의미합니다. 저는 단일 페이지만 사용할 예정이기 때문에 pages 디렉토리를 따로 나눌 필요가 없다고 판단하여 app에 컴포넌트들을 조합하여 넣게 되었습니다.
entities : 각 도메인들을 디렉토리별로 나누어 관리합니다. 각 도메인 별로 api, lib, model, ui의 하위 폴더를 가지고 있습니다.(autoRollingNews는 따로 해놓을 에정) api: 비즈니스 로직과 api 호출 등을 합친 함수들을 보관할 예정입니다.
lib: 해당 컴포넌트들을 제작하는 과정에서 한정적으로 필요하고, 따로 다른 도메인의 컴포넌트들이 공유해서 사용하지 않는 함수들이나 컴포넌트들에 대해서 모으려고 합니다.
model : 각 도메인과 컴포넌트에 관련된 데이터의 타입이나 custom hook 등을 보관해두는 디렉토리입니다.
ui: 다른 로직들을 분리하고 최대한 시각적으로 보여지는 ui만 구성해놓은 컴포넌트 파일들입니다. shared : 공유할 수 있는 파일들을 보관합니다. 아이콘이나, 모든 컴포넌트에서 공통적으로 사용할 수 있는 common 컴포넌트 파일들을 보관합니다.
widgets: entities의 도메인들이 가진 컴포넌트를 합쳐 크게 나눌 수 있는 컴포넌트 단위로 묶어놓은 컴포넌트입니다.
개선한 폴더 구조에서 더 개선하면 좋을 점이 있는지 말씀해주시면 감사하겠습니다! 데이터 처리 방식<br>
<img src="https://i.imgur.com/9FR4hoP.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
리스트형 보기에서는 뉴스를 언론사들 별로 볼 수 있다.
페이지 전환 아이콘이나 카테고리를 누르면 해당 카테고리의 전체가 뜬다.
여기서 카테고리에 있는 모든 뉴스를 그때그때마다 불러와야 할까, 아니면 한번에 받고 이를 분류해서 카테고리 헤더와 안쪽 내용을 만들면 될까?에 대해 고민했던 것 같다.
네이버를 살펴보았는데, 카테고리를 눌렀을 때나 다음 뉴스를 눌렀을 때 따로 data fetching이 이루어지는 것 같는 것 같다.
나 또한 카테고리, 언론사 변경 시마다 계속해서 통신을 하는 것 자체가 비효율적이라고 판단했다.
따라서 처음에 모든 카테고리의 데이터를 받으면서도, 이러한 데이터를 카테고리, 언론사별로 따로 구분하면서 페이지네이션과 비슷하게 만들어놓았다. 기존의 데이터를 가지고 있으면서 계속해서 언론사나 카테고리가 바뀔 때마다 페이지를 변경할 수 있도록 하였다.
이 점은 어제 하면서 고민 과정에 있었는데 다른 프로젝트를 하면서도 많이 고민했던 문제 같습니다. 모든 데이터를 한번에 가져와서 분류하느냐 vs. 각각 카테고리 별로 그때마다 넘어갈 때마다 다시금 카테고리에 대해서만 fetching을 다시금 해와야 할까라는 부분에 있어서 계속 확신을 갖지 못하는 것 같습니다. (현재는 일단 모든 데이터를 한번에 가져와서 바로 처리하는 것으로 구현했습니다.)
전자의 경우 모든 데이터를 한번에 가져오는 과정 자체가 데이터가 많다보니 보다 응답시간이 오래 걸려 사용자 경험이 떨어지지 않을까라는 고민이 있습니다. 하지만 그렇다고 후자를 선택하기에는 카테고리마다 이동하면서 계속해서 서버에 요청을 날리게 되면 서버가 가지게 되는 부담이 늘지 않을까 걱정됩니다. 이에 대해서 멘토님은 어떻게 생각하시는지 고견을 여쭙고 싶습니다!오늘은 이정도인 것 같습니다ㅎㅎ 긴 글 읽어주셔서 감사합니다!! 편안한 밤 되세요 :)]]></description><link>부스트캠프/멤버십/7주차/week7_4일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/week7_4일차_PR.md</guid><pubDate>Thu, 10 Oct 2024 10:10:39 GMT</pubDate><enclosure url="https://i.imgur.com/gv2t79A.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/gv2t79A.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_7주차]]></title><description><![CDATA[<a data-href="멤버십_7주차_주간계획" href="부스트캠프/멤버십/7주차/멤버십_7주차_주간계획.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_7주차_주간계획</a><br>
<a data-href="멤버십_7주차_마스터클래스" href="부스트캠프/멤버십/7주차/멤버십_7주차_마스터클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_7주차_마스터클래스</a><br><a data-href="week7_1일차_PR" href="부스트캠프/멤버십/7주차/week7_1일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week7_1일차_PR</a><br>
<a data-href="week7_2일차_PR" href="부스트캠프/멤버십/7주차/week7_2일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week7_2일차_PR</a><br>
<a data-href="week7_3일차_PR" href="부스트캠프/멤버십/7주차/week7_3일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week7_3일차_PR</a><br>
<a data-href="week7_4일차_PR" href="부스트캠프/멤버십/7주차/week7_4일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week7_4일차_PR</a>]]></description><link>부스트캠프/멤버십/7주차/멤버십_7주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/멤버십_7주차.md</guid><pubDate>Thu, 10 Oct 2024 09:40:38 GMT</pubDate></item><item><title><![CDATA[Atomic Design]]></title><description><![CDATA[
Atoms(원자): 가장 작은 UI 구성 요소 (버튼, 입력 필드 등)
Molecules(분자): 여러 원자가 모여서 이루어진 더 복잡한 요소 (입력 필드 + 버튼)
Organisms(생물): 여러 분자가 모여서 큰 UI 컴포넌트 (폼, 네비게이션 바 등)
Templates(템플릿): UI 컴포넌트들의 구조 (페이지 레이아웃 등)
Pages(페이지): 템플릿에 실제 데이터를 넣어서 완성된 페이지
// Button.js
const Button = ({ label }) =&gt; &lt;button&gt;{label}&lt;/button&gt;;
export default Button;
// SearchBar.js
import Button from './Button'; const SearchBar = () =&gt; ( &lt;div&gt; &lt;input type="text" /&gt; &lt;Button label="Search" /&gt; &lt;/div&gt;
);
export default SearchBar;
// Header.js
import SearchBar from './SearchBar'; const Header = () =&gt; ( &lt;header&gt; &lt;h1&gt;My App&lt;/h1&gt; &lt;SearchBar /&gt; &lt;/header&gt;
);
export default Header;
// PageTemplate.js
import Header from './Header'; const PageTemplate = ({ children }) =&gt; ( &lt;div&gt; &lt;Header /&gt; &lt;main&gt;{children}&lt;/main&gt; &lt;/div&gt;
);
export default PageTemplate;
// HomePage.js
import PageTemplate from './PageTemplate'; const HomePage = () =&gt; ( &lt;PageTemplate&gt; &lt;p&gt;Welcome to the Crong world!&lt;/p&gt; &lt;/PageTemplate&gt;
);
export default HomePage;
storybook -&gt; 컴포넌트 하나에 대해서 스토리를 넣어 테스트하듯이 함
작은 컴포넌트만 가능하기 떄문에 아토믹 디자인과 얼추 맞음컴포넌트를 잘 나누면 Jest 뿐만 아니라 테스트에도 용이
재사용성, 생산성 향상
디자인 시스템과의 조화
-&gt; 컴포넌트 디자인의 장점
단점 -&gt; 파일이 너무 많아짐/]]></description><link>부스트캠프/멤버십/7주차/atomic-design.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/Atomic Design.md</guid><pubDate>Thu, 10 Oct 2024 04:33:36 GMT</pubDate></item><item><title><![CDATA[week7_3일차_PR]]></title><description><![CDATA[
dummydata를 이용하여 ui 완성
애니메이션 완성
그리드형 목록 캐러셀을 이용한 페이지 관리
페이지 전환시 애니메이션
각각의 뉴스사에 마우스를 올리면 ui 변경
페이지에 따라 화살표 아이콘 생성
화살표를 이용한 페이지 이동 리스트형 목록 캐러셀을 이용한 페이지 관리
섹션 내 있어야 할 요소들 언론사 브랜드마크 최종 편집 일시 [구독하기] 버튼 썸네일이 있는 메인 뉴스 1건 타이틀만 있는 서브 뉴스 6건 편집권에 대한 안내 문구 배럴 파일
애니메이션
CSS의 transform 속성
Carousel
<img src="https://i.imgur.com/9FR4hoP.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
리스트형 보기에서는 뉴스를 언론사들 별로 볼 수 있다.
페이지 전환 아이콘이나 카테고리를 누르면 해당 카테고리의 전체가 뜬다.여기서 카테고리에 있는 모든 뉴스를 그때그때마다 불러와야 할까, 아니면 한번에 받고 이를 분류해서 카테고리 헤더와 안쪽 내용을 만들면 될까?에 대해 고민했던 것 같다.
네이버를 살펴보았는데, 카테고리를 눌렀을 때나 다음 뉴스를 눌렀을 때 따로 data fetching이 이루어지는 것 같는 것 같다.
나 또한 카테고리, 언론사 변경 시마다 계속해서 통신을 하는 것 자체가 비효율적이라고 판단했다.
따라서 처음에 모든 카테고리의 데이터를 받으면서도, 이러한 데이터를 카테고리, 언론사별로 따로 구분하면서 페이지네이션과 비슷하게 만들어놓았다. 기존의 데이터를 가지고 있으면서 계속해서 언론사나 카테고리가 바뀔 때마다 페이지를 변경할 수 있도록 하였다.]]></description><link>부스트캠프/멤버십/7주차/week7_3일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/week7_3일차_PR.md</guid><pubDate>Wed, 09 Oct 2024 13:17:16 GMT</pubDate><enclosure url="https://i.imgur.com/9FR4hoP.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/9FR4hoP.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week7_2일차_PR]]></title><description><![CDATA[
기본적인 ui 제작중
아이콘 컴포넌트들 제작
ui 제작 과정에서 필요한 더미 데이터 제작
애니메이션 조금 하다가 미룬이..ㅎ Fsd
css grid
animation
tailwindcss &lt;svg width="24" height="22" viewBox="0 0 24 22" fill="none" xmlns="http://www.w3.org/2000/svg" &gt; &lt;path d="M19.0554 2.41708C19.7228 2.69364 20.3292 3.099 20.84 3.60999C21.351 4.12075 21.7563 4.72718 22.0329 5.39464C22.3095 6.0621 22.4518 6.77751 22.4518 7.49999C22.4518 8.22248 22.3095 8.93789 22.0329 9.60535C21.7563 10.2728 21.351 10.8792 20.84 11.39L19.78 12.45L12 20.23L4.22 12.45L3.16 11.39C2.1283 10.3583 1.54871 8.95903 1.54871 7.49999C1.54871 6.04096 2.1283 4.64169 3.16 3.60999C4.19169 2.5783 5.59096 1.9987 7.05 1.9987C8.50903 1.9987 9.9083 2.5783 10.94 3.60999L12 4.66999L13.06 3.60999C13.5708 3.099 14.1772 2.69364 14.8446 2.41708C15.5121 2.14052 16.2275 1.99817 16.95 1.99817C17.6725 1.99817 18.3879 2.14052 19.0554 2.41708Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /&gt; &lt;/svg&gt;
기존의 svg는 이와 같은 형태로 되어있다.svg를 활용하는 방법은 다양하다.
가장 쉬운 방법은 img 태그의 src 속성으로 가져오는 것이다.
img 태그의 src 속성으로 해당 svg를 그대로 import 해와도 아이콘은 정상 작동한다. 하지만 이런 경우 이미지로 svg가 들어가기 때문에 tint-color 와 같은 부분을 바꿀 수 있는 방법이 어렵다. filter로 색상을 조절할 수는 있지만 이와 같은 경우 따로 설정이 필요하기 때문에 번거롭다고 생각했다.나는 이러한 방법이 번거롭다고 생각했기 때문에 차라리 이를 컴포넌트화시키면 어떨까? 하고 생각해보았다.import { IconProps } from "./iconPropsType"; export const NewspaperIcon = ({ className, size }: IconProps) =&gt; { return ( &lt;svg width={size === "l" ? "24" : "16"} height={size === "l" ? "24" : "16"} viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" &gt; &lt;path d="M20 3.75V18.5C19.9998 18.6249 20.0463 18.7455 20.1305 18.8378C ... 75 6.497Z" fill="#14212B" className={className} /&gt; &lt;/svg&gt; );
}; 이와 같이 사이즈는 기획서에 명시된 대로 16px과 24px밖에 없기 때문에 사이즈를 두가지로 나누어 삼항연산자를 통해 구분해줘도 괜찮을 것 같다고 생각했다.하지만 각 컴포넌트에 대해서 굳이 하나씩 만들어줘야 하기 때문에 다소 불편하다는 느낌이 없잖아 있었다.
현재는 그렇게 많지는 않아서 괜찮았지만 나중에 아이콘들이 훨씬 많아진다면 enum처럼 관리하면서 각 아이콘의 path attribute인 d만 관리해서 사용할 수 있지 않을까? 하는 생각이 있다 .안녕하세요 멘토님! 고생 많으십니다ㅎㅎ
오늘은 ui 구성하면서 애니메이션이 낯설어서 계속 헤매다가 크게 진전된게 없네요ㅎㅎ..
금일 리뷰 요청드리고 싶은 것은 폴더 구조입니다.client ├─ .prettierrc ├─ README.md ├─ eslint.config.js ├─ index.html ├─ package-lock.json ├─ package.json ├─ postcss.config.js ├─ public │ └─ fonts ├─ src │ ├─ app │ │ └─ App.tsx │ ├─ entities │ │ ├─ PressItem │ │ │ ├─ api │ │ │ ├─ index.tsx │ │ │ ├─ lib │ │ │ ├─ model │ │ │ └─ ui │ │ │ └─ pressItem.tsx │ │ ├─ article │ │ │ ├─ api │ │ │ ├─ lib │ │ │ ├─ model │ │ │ └─ ui │ │ │ └─ article.tsx │ │ ├─ autoRollingNews │ │ │ ├─ api │ │ │ ├─ index.tsx │ │ │ ├─ lib │ │ │ │ └─ dummy.ts │ │ │ ├─ model │ │ │ │ └─ useNewsData.ts │ │ │ └─ ui │ │ │ ├─ autoRollingNews.tsx │ │ │ ├─ autoRollingNewsItem.tsx │ │ │ └─ shortNews.tsx │ │ ├─ category │ │ │ ├─ api │ │ │ ├─ lib │ │ │ ├─ model │ │ │ └─ ui │ │ ├─ mainArticle │ │ │ ├─ api │ │ │ ├─ lib │ │ │ ├─ model │ │ │ └─ ui │ │ ├─ newsHeader │ │ │ ├─ api │ │ │ ├─ index.tsx │ │ │ ├─ lib │ │ │ ├─ model │ │ │ └─ ui │ │ │ └─ newsHeader.tsx │ │ └─ subArticle │ │ ├─ api │ │ ├─ lib │ │ ├─ model │ │ └─ ui │ ├─ features │ ├─ index.css │ ├─ main.tsx │ ├─ shared │ │ ├─ lib │ │ │ ├─ getToday.ts │ │ │ └─ index.ts │ │ └─ ui │ │ ├─ alert.tsx │ │ ├─ badge.tsx │ │ ├─ button.tsx │ │ ├─ header.tsx │ │ ├─ icons │ │ │ ├─ chevron-right.tsx... │ │ ├─ index.tsx │ │ ├─ logo.tsx │ │ └─ todaysDate.tsx │ ├─ vite-env.d.ts │ └─ widgets │ ├─ articles │ │ ├─ api │ │ ├─ lib │ │ ├─ model │ │ │ ├─ dummy.json │ │ │ └─ dummy.ts │ │ └─ ui │ │ └─ ariticles.tsx │ └─ subArticles │ ├─ api │ ├─ lib │ ├─ model │ └─ ui ├─ tailwind.config.js ├─ tsconfig.app.json ├─ tsconfig.json ├─ tsconfig.node.json └─ vite.config.ts
현재 저의 폴더구조입니다.
저는 이번 프로젝트를 통해서 비즈니스 로직, 데이터, ui등 관심사를 분리하기 위해 fsd 패턴의 요소를 일부 가져와 활용하려고 합니다.
하지만 막상 관심사를 분류하라! 라고 했을 때 무엇을 어떻게 나누어야 할까?에 대한 고민이 계속 듭니다. 아직은 관심사에 대한 개념 자체가 부족한 것 같습니다.현재 제가 계획하고 있는 바로는 크게 보았을 때(layer)
entities : 비즈니스 로직을 담고 있는 독립적인 데이터들을 다루는 컴포넌트(api fetch)
widget: entities들이 모여 하나의 섹션, 즉 페이지에서 활용하는 큰 단위의 독립적 컴포넌트들. entities들을 묶고 하위 entites로 필요한 state를 내려주는 역할
feature: 각 컴포넌트에 부여될 수 있는 이벤트들을 도메인별로 묶어 놓는 디렉토리
app : 엔트리 포인트이자 전역 스타일, 현재는 단일 페이지므로 해당 app에 안쪽 요소를 채워넣을 예정
shared: 공통적으로 어디서나 쓰일 수 있고 데이터를 담고 있지 않는 컴포넌트들
이 정도로 디렉토리를 나누었고, entitie나 widgets의 경우는 컴포넌트별로 디렉토리를 나누었습니다.
하위 디렉토리로는
ui: 기본적인 디자인 요소
api: 필요한 api fetching하는 함수들
lib: 컴포넌트에서 필요한 유틸함수들
model: 비즈니스적인 로직
을 담고 있습니다.
여기서 질문드리고 싶은 점은
전체적인 디렉토리의 구조를 통해 관심사 분리가 잘 이루어지고 있는지 궁금합니다. 이 부분은 아직 제대로 완성된 게 없다보니 나중에 다시금 피드백 요청드리겠습니다. 비즈니스적인 로직은 api와는 다른가? 여러 자료들을 찾아보았음에도 아직도 비즈니스 로직과 api 호출의 과정을 명확하게 구분짓는 것이 머릿속에서는 어렵습니다. fsd 패턴대로라면, 만약 블로그 서비스에서 어떤 글을 작성한다고 칠 때, 작성 버튼을 눌렀을 때 실행되어야 하는 함수 -&gt; feature의 함수
작성 버튼을 눌렀을 때 실행된 함수 안에서 api 호출 및 에러에 대한 처리, navigate 등 -&gt; 비즈니스 로직
state로 관리하는 작성하는 글의 데이터(제목, 본문 등) -&gt; model
오로치 fetch만 하는 함수 -&gt; api 이런 식으로 이해했는데, 제가 이해한 비즈니스 로직과 api, 모델의 방향이 맞는지 궁금합니다. 오늘은 많이 한 것이 없어 이것만 따로 질문드립니다ㅠ.ㅠ 다음번엔 조금 더 준비해서 가져와보도록 하겠습니다..!
감사합니다 좋은 하루 되세요☺️]]></description><link>부스트캠프/멤버십/7주차/week7_2일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/week7_2일차_PR.md</guid><pubDate>Tue, 08 Oct 2024 09:59:40 GMT</pubDate></item><item><title><![CDATA[Tailwind 설정하기]]></title><description><![CDATA[npm install -D tailwindcss postcss autoprefixer npx tailwindcss init -p
tailwind만 설치하면 될 줄 알았으나 tailwind가 작동하기 위해서는 postcss와 autoprefixer가 필요하다. 이 둘의 역할에 대해 알아보자.<img src="https://i.imgur.com/whuE2nD.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">postcss의 공식문서에는 PostCSS is a tool for transforming styles with JS plugins. 라고 적혀있다. js를 이용하여 css를 변환시킨다는 이야기이다.postcss는 다른 scss, Stylus들과는 다르게 후처리기의 성격을 지닌다.
CSS 전처리기
화면에 보이기 전에 CSS를 변경하고, 스타일을 적용
CSS 작성 -&gt; 실행 전에 기본 CSS로 컴파일 -&gt; 렌더링
Stylus, Sass, Less 등 CSS 후처리기
화면에 보여진 뒤에 CSS 스타일을 적용
CSS 작성 -&gt; 렌더링 -&gt; 외부 모듈을 사용하여 스타일 변경
PostCSS 등
<br><img src="https://i.imgur.com/oHM1gfQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
postCSS는 위와 같이 Parser -&gt; plugins -&gt; Stringifier 의 과정을 거친다.가장 먼저 Parser에서는 문자열을 tokenizing한 다음 AST로 변환하여 단일 파일을 작성하는 과정을 거친다.
기존의 CSS에 대해서 토큰화 하는 과정을 살펴보자..className { color: #FFF; }
위와 같은 CSS를 만들기 위해서는 우선 이러한 CSS에 대해 tokenizing한 결과를 보면 [ ["word", ".className", 1, 1, 1, 10] ["space", " "] ["{", "{", 1, 12] ["space", " "] ["word", "color", 1, 14, 1, 18] [":", ":", 1, 19] ["space", " "] ["word", "#FFF" , 1, 21, 1, 23] [";", ";", 1, 24] ["space", " "] ["}", "}", 1, 26]
]
이런 식으로 각각 단일 토큰에 대해서 배열로 관리하며, 토큰 타입, 단어, 위치 정보 등을 관리한다.const token = [ // 토큰 타입 'word', // 매칭된 단어 '.className', // 앞 두 숫자 -&gt; 토큰의 시작 위치(optional) // `space`와 같은 토큰은 위치 정보 없음 // 여기서 첫 번째 숫자는 줄 번호이고, 두 번째 숫자는 해당 줄의 열 번호 1, 1, // 이 토큰처럼 여러 문자의 토큰에 대해 끝 위치(optional) // 숫자는 위에서 설명한 규칙과 같음 1, 10
] 이렇게 토큰화된 각각의 CSS에 대해서 postcss의 lib/parse.js와 lib/parser.js의 모듈을 통해 파싱한다. 이 파서를 통해서 CSS에 대한 AST를 생성한다.'use strict' let Container = require('./container')
let Input = require('./input')
let Parser = require('./parser') function parse(css, opts) { let input = new Input(css, opts) let parser = new Parser(input) try { parser.parse() } catch (e) { if (process.env.NODE_ENV !== 'production') { if (e.name === 'CssSyntaxError' &amp;&amp; opts &amp;&amp; opts.from) { if (/\.scss$/i.test(opts.from)) { e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser' } else if (/\.sass/i.test(opts.from)) { e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser' } else if (/\.less$/i.test(opts.from)) { e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser' } } } throw e } return parser.root
} module.exports = parse
parse.default = parse Container.registerParse(parse)
해당 parse에서는 parser 생성자를 통해 다시금 토큰화된 것들을 AST로 만드는 과정을 거치고, 이에 대한 root를 반환한다.그렇게 만들어진 ast에 대해서는 processor(lib/processor.js)를 통해서 플러그인들을 초기화하고 문법적으로 변환하는 과정을 거친다.'use strict' let Document = require('./document')
let LazyResult = require('./lazy-result')
let NoWorkResult = require('./no-work-result')
let Root = require('./root') class Processor { constructor(plugins = []) { this.version = '8.4.47' this.plugins = this.normalize(plugins) } normalize(plugins) { let normalized = [] for (let i of plugins) { if (i.postcss === true) { i = i() } else if (i.postcss) { i = i.postcss } if (typeof i === 'object' &amp;&amp; Array.isArray(i.plugins)) { normalized = normalized.concat(i.plugins) } else if (typeof i === 'object' &amp;&amp; i.postcssPlugin) { normalized.push(i) } else if (typeof i === 'function') { normalized.push(i) } else if (typeof i === 'object' &amp;&amp; (i.parse || i.stringify)) { if (process.env.NODE_ENV !== 'production') { throw new Error( 'PostCSS syntaxes cannot be used as plugins. Instead, please use ' + 'one of the syntax/parser/stringifier options as outlined ' + 'in your PostCSS runner documentation.' ) } } else { throw new Error(i + ' is not a PostCSS plugin') } } return normalized } process(css, opts = {}) { if ( !this.plugins.length &amp;&amp; !opts.parser &amp;&amp; !opts.stringifier &amp;&amp; !opts.syntax ) { return new NoWorkResult(this, css, opts) } else { return new LazyResult(this, css, opts) } } use(plugin) { this.plugins = this.plugins.concat(this.normalize([plugin])) return this }
} module.exports = Processor
Processor.default = Processor Root.registerProcessor(Processor)
Document.registerProcessor(Processor)
이렇게 문법적으로 변환하는 과정을 마치면 이를 다시 순수 CSS 구문으로 바꿔줘야 하는데, Stringifier가 AST를 순회하면서 각 노드에 대해 CSS 문자열을 생성해낸다. /** @type {import('tailwindcss').Config} */
export default { content: [ "./index.html", "./src/**/*.{js,ts,jsx,tsx}", ], theme: { extend: {}, }, plugins: [],
}
%% index.css %%
@tailwind base;
@tailwind components;
@tailwind utilities;
]]></description><link>부스트캠프/멤버십/7주차/tailwind-설정하기.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/Tailwind 설정하기.md</guid><pubDate>Tue, 08 Oct 2024 00:56:00 GMT</pubDate><enclosure url="https://i.imgur.com/whuE2nD.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/whuE2nD.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[fsd 패턴]]></title><description><![CDATA[기능 분할 설계(Feature-sliced Design, FSD)는 모듈 간의 느슨한 결합과 높은 응집력을 제공할 수 있으며, 쉽게 확장할 수 있는 아키텍처이다.
<img src="https://i.imgur.com/tO9yswk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이러한 패턴은 세 가지 구분 개념이 있다.
이러한 세 가지 구분 개념이 곧 depth를 의미하기 때문에 이는 곧 디렉토리의 depth는 3으로 제한됨을 의미한다.
그렇다면 이 가장 상위의 디렉토리들을 중심으로 어떻게 애플리케이션이 구성될까?
이전에 가장 최상위의 layer부터 알아보자
app 애플리케이션 로직이 초기화되는 곳
프로바이더, 라우터, 전역 스타일, 전역 타입 선언 등
애플리케이션의 진입점 역할 processes(depricated) 이 레이어는 여러 단계로 이루어진 등록과 같이 여러 페이지에 걸쳐 있는 프로세스를 처리
이 레이어는 더 이상 사용되지 않는 것으로 간주되지만 여전히 가끔씩 마주할 수 있습니다. 선택적 레이어입니다. pages 애플리케이션 각각의 페이지 widgets 페이지에 사용되는 독립적인 UI 컴포넌트
entities가 모인 것들 features 이 레이어는 비즈니스 가치를 전달하는 사용자 시나리오와 기능
각 이벤트들을 담당하는 로직
선택적 레이어 entities 비즈니스 엔티티
사용자, 리뷰, 댓글 등과 같이 분리할 수 있는 컴포넌트
핵심 도메인 모델과 비즈니스 로직을 담고 있음 shared 이 레이어에는 특정 비즈니스 로직에 종속되지 않은 재사용 가능한 컴포넌트와 유틸리티
여기에는 UI 키트, axios 설정, 애플리케이션 설정, 비즈니스 로직에 묶이지 않은 헬퍼 등 각각 7개의 디렉토리들은 기능적으로 세분화되어 각자의 역할을 담당하고, 이러한 요소들이 계층적인 구조를 가지기 때문에 한 방향으로만 흐르는 linear flow를 유지한다. 즉, 위의 사진에서 하나의 layer는 자기 자신을 가리키는 layer 아래의 layer들만 참조 가능하다.
이러한 여러 layer들이 계층 구조를 유지하면서 서로 약한 의존 관계를 가진 상태로하나로 점점 합쳐져 하나의 app이 완성되는 구조인데, 이 점이 FSD의 핵심이자 가장 중요한 법칙이다<br>
<img src="https://i.imgur.com/CREMf65.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/iJJFpxc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
추상화한다면 위의 사진과 같이
shared(재사용한 컴포넌트들)
-&gt; entities(독립된 컴포넌트들)
-&gt; features(각 컴포넌트의 기능을 명시한 script)
-&gt; widgets(컴포넌트들이 모여 만든 하나의 큰 컴포넌트 단위)
-&gt; pages(큰 컴포넌트들이 모여 만든 하나의 페이지)
-&gt; app(entry point)
의 순서로 하나의 큰 애플리케이션을 위해 계층적으로 올라가면서 결국 마지막엔 이 모든 것이 합쳐진 하나의 애플리케이션이 완성되는 구조이다.각자 레이어들 안에는 서브 디렉토리가 존재하는데, 이를 slice라고 한다.
slice는 주로 도메인 별로 나눈다.
슬라이스는 특정 엔티티에 대해서 코드를 그룹화 하는데, 추상적인 것에 대한 연결이 아닌 명확한 비즈니스 개체에 대한 연결이 존재하고 이를 코드의 가치에 따라 그룹화한다.<br>
<img src="https://i.imgur.com/yVam9En.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이와 같이 필요한 값에 대해서 독립적으로 다룰 수 있는 디렉토리를 생성한다.각 슬라이스는 세그먼트로 구성되며 목적에 따라 슬라이스 내의 코드를 나누는데 도움이 될 수 있다.
api - 필요한 서버 요청 및 데이터 타입, mapper 등
UI - 슬라이스의 UI 컴포넌트.
model - 비즈니스 로직, 즉 상태와의 상호 작용. actions 및 selectors가 이에 해당
lib - 슬라이스 내에서 사용되는 보조 기능(유틸함수들)
config - 슬라이스에 필요한 구성값이지만 구성 세그먼트는 거의 필요하지 않음.
consants - 필요한 상수.
이와 같이 계층적인 디렉토리 구조에서 private한 컴포넌트들을 유지하기 위해 중요한 점이 있는데, index.js의 활용이다.
각 layer바로 아래의 디렉토리들에는 index.js를 두고, 이를 하위 폴더들의 것들에서 전부 import해오고, 상위 계층에서 이 index.js를 Import 해와서 사용하는 방식이다. 이런식으로 캡슐화를 이루어낼 수 있다.
높은 응집도: 코드는 영향력의 범위(layer), 도메인(slice), 그리고 기술적 목적(segement)에 따라 관리가 되어, 새롭게 접하는 사람들에게 이해하기 쉬운 정형화된 아키텍쳐를 제공한다.
로직 재사용 통제: 각 아키텍쳐의 컴포넌트는 목적과 예상 가능한 의존성 (dependency)을 지닌다. 이는 곧 코드에서 지역적으로 사용할 것과 전역적으로 사용할 것을 엄격하게 구분한다는 뜻이기도 하다. 따라서, DRY 원칙과 적응 가능성간의 균형을 잡아준다.
변경이나 리팩토링에 안정적임: 특정 layer의 모듈은 같은 layer의 다른 모듈에서 사용 불가능하다. 다른 상위 layer에서도 마찬가지로 사용 불가능하다. 따라서 독립적인 변경이 가능하여 예상치 못한 결과를 방지할 수 있다
균일성: 러닝커브가 높기는 하지만 표준화된 구조덕에 적응 후에는 프로젝트가 보다 수월하게 굴러감
]]></description><link>부스트캠프/멤버십/2주차/fsd-패턴.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/fsd 패턴.md</guid><pubDate>Mon, 07 Oct 2024 15:06:22 GMT</pubDate><enclosure url="https://i.imgur.com/tO9yswk.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/tO9yswk.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week7_1일차_PR]]></title><description><![CDATA[
주간 계획 작성 컴포넌트 나눠서 설계해보기
기초 환경 세팅(번들링, ts, tailwindCSS, 파일 구조 등) fsd
관심사 분리
번들링
tailwindCSS
Vite를 이용한 이유는 개발 과정에서 결과를 확인하기 위해 빌드하는 작업 자체가 시간이 조금 걸렸기 때문에 보다 원할한 DX(개발자 경험)을 위해서는 Vite가 낫다고 판단하였다.vite는 애플리케이션에서 사용하는 모듈에 대해 dependencies와 source code 두 가지의 범주로 나누어 개발 시작 시간을 개선한다.dependencies의 경우 개발시 내용이 바뀌지 않을 사용하는 라이브러리의 의존성 번들링 과정을 수행한다.
Vite는 Esbuild의 빌드 툴을 사용하여 번들링을 수행하는데, Esbuild의 경우 기존 webpack이나 parcel보다 100배 이상 빠른 속도를 보장한다.
<img src="https://i.imgur.com/m02Qv9T.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> Source code의 경우 우리가 대표적으로 사용하는 프레임워크의 확장자를 사용하면서 만드는 컴포넌트, 즉 Non-plain Js들의 소스코드를 의미한다. 해당 코드들의 경우에는 실행하기 위해서는 컴파일을 수행할 필요성이 있다.<br>
<img src="https://i.imgur.com/09THGeF.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
하지만 기존의 번들링된 코드 기반 개발 서버는 개발하는 과정에서 소스 코드의 수정이 일어났을 때마다 통채로 다시 번들링하는 과정이 필요했기 때문에 불필요한 시간 소요가 발생했다.<br><img src="https://i.imgur.com/uOvekx1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이러한 문제를 느낀 Vite는 Native ESM 방식을 이용해서 개발 서버(Hot Reloading)를 구동한다.
ESM 방식을 사용하는 방식의 장점은, import를 통해 동적으로 그때그때 필요한 파일들만을 가져온다는 점이다. 번들링을 하지 않고 개별 파일에 대해 트랜스파일링만 한 다음 이를 import하는 구조들을 통해 하나의 페이지를 완성할 수 있도록 만들었다.따라서 나는 빠른 개발을 위해 vite를 선택했다기존에 내가 나누던 대로 컴포넌트를 나누어 보았다.<br>
<img src="https://i.imgur.com/ekkPl7N.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
각 컴포넌트마다 필요한 이벤트와 어떤 data를 fetching해서 하위 컴포넌트에 props로 전달해주어야 할지를 적었다.
하지만 이제까지 내가 했던 프로젝트에서는 하나의 컴포넌트 안에서 ui, 비즈니스 로직, 데이터 처리 등의 모든 로직들이 얽혀있었다. 얽혀있어 가독성 또한 좋지 않던 탓에 오류 하나의 원인이 된 컴포넌트를 찾는 과정 또한 오래 걸리게 되었다.
따라서 나는 이번 프로젝트에서 컴포넌트 별로 ui, 비즈니스 로직, 데이터 처리와 같은 것들에 대해 모두 분리하고, 단일책임원칙(SRP)를 지켜가면서 설계를 다시 해볼 예정이다.
이러한 설계 과정에서 기능별로 나누고, 이를 조합하여 하나의 애플리케이션을 만들 수 있도록 하는 fsd 패턴을 적용하려 한다.
fsd 패턴의 경우 기능별로 나누고, 디렉토리를 기반으로 관심사를 명확하게 나눌 수 있다는 점에서 보다 가독성과 기능별 확장 등이 용이하다고 판단했다. 따라서 위 컴포넌트를 기반으로 fsd 패턴을 이용하여 어떤 방식으로 나누어 볼 수 있을지에 대해서 설계중이다.]]></description><link>부스트캠프/멤버십/7주차/week7_1일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/week7_1일차_PR.md</guid><pubDate>Mon, 07 Oct 2024 14:11:57 GMT</pubDate><enclosure url="https://i.imgur.com/m02Qv9T.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/m02Qv9T.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_7주차_주간계획]]></title><description><![CDATA[
타입스크립트를 리액트에 적용하면서 보다 타입스크립트에 적응하는 과정을 거치기
babel, vite 등의 번들링 툴에 익숙해지기
tailwindcss를 써보면서 익숙해지기
Vite를 이용한 이유는 개발 과정에서 결과를 확인하기 위해 빌드하는 작업 자체가 시간이 조금 걸렸기 때문에 보다 원할한 DX(개발자 경험)을 위해서는 Vite가 낫다고 판단하였다.vite는 애플리케이션에서 사용하는 모듈에 대해 dependencies와 source code 두 가지의 범주로 나누어 개발 시작 시간을 개선한다.dependencies의 경우 개발시 내용이 바뀌지 않을 사용하는 라이브러리의 의존성 번들링 과정을 수행한다.
Vite는 Esbuild의 빌드 툴을 사용하여 번들링을 수행하는데, Esbuild의 경우 기존 webpack이나 parcel보다 100배 이상 빠른 속도를 보장한다.
<img src="https://i.imgur.com/m02Qv9T.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> Source code의 경우 우리가 대표적으로 사용하는 프레임워크의 확장자를 사용하면서 만드는 컴포넌트, 즉 Non-plain Js들의 소스코드를 의미한다. 해당 코드들의 경우에는 실행하기 위해서는 컴파일을 수행할 필요성이 있다.<br>
<img src="https://i.imgur.com/09THGeF.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
하지만 기존의 번들링된 코드 기반 개발 서버는 개발하는 과정에서 소스 코드의 수정이 일어났을 때마다 통채로 다시 번들링하는 과정이 필요했기 때문에 불필요한 시간 소요가 발생했다.<br><img src="https://i.imgur.com/uOvekx1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이러한 문제를 느낀 Vite는 Native ESM 방식을 이용해서 개발 서버(Hot Reloading)를 구동한다.
ESM 방식을 사용하는 방식의 장점은, import를 통해 동적으로 그때그때 필요한 파일들만을 가져온다는 점이다. 번들링을 하지 않고 개별 파일에 대해 트랜스파일링만 한 다음 이를 import하는 구조들을 통해 하나의 페이지를 완성할 수 있도록 만들었다.따라서 나는 빠른 개발을 위해 vite를 선택했다<br><img src="https://i.imgur.com/58yg3ku.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
콘텐츠는 웹 화면의 정중앙 배치
기본 상단 영역 왼쪽에 뉴스 스탠드 로고 클릭시 새로고침 오른쪽에는 시스템 날짜 최신 뉴스 자동 롤링
언론사별 기사들을 확인하는 영역 전체 언론사 탭의 그리드 보기를 디폴트로
내가 구독한 언론사 탭의 타이틀 옆에는 badge 컴포넌트로 내가 구독한 언론사의 숫자를 표시 <br><img src="https://i.imgur.com/eGMIXnr.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
왼쪽 바와 오른쪽 바는 각각 다른 최신 뉴스의 헤드라인 5개가 5초마다 자동으로 무한 롤링됨
좌우 영역의 시간차를 1초로 하여 두 영역의 뉴스가 동시에 롤링되지 않도록 함
롤링 시, 바 영역 안에서 제목이 위로 넘어가는 애니메이션을 적용
각 영역에 마우스를 hover하면 무한 롤링을 일시정지하고, 헤드라인에 밑줄을 표시
마우스가 해당 영역에서 벗어나면 다시 1초의 간격을 두고 두 영역의 뉴스가 롤링되도록 함
<br><img src="https://i.imgur.com/dfqtREZ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
가로 930px, 세로 388px 영역에 6*4의 테이블이 들어가도록 한다
각 테이블의 셀에는 언론사 브랜드 마크가 중앙에 배치
언론사 브랜드 마크의 순서는 페이지가 새로고침 될 때마다 랜덤으로 배치
그리드의 과주에는 화살표를 배치하여 페이지를 넘김
가장 첫 페이지와 가장 끝 페이지에서 disabled 되는 화살표는 아예 표시 X
<br><img src="https://i.imgur.com/Md0obJj.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
각 언론사 브랜드마크가 있는 셀에 마우스를 올리면, 구독하기 버튼이 뜸
이미 구독하고 있는 언론사의 경우, 해지하기 버튼
<br><img src="https://i.imgur.com/jbG0Bi5.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
각 분야 카테고리에서 언론사의 기사 확인 종합/경제
방송/통신
IT
영자지
스포츠/연애
매거진/전문지
지역 선택된 카테고리의 이름 옆에는 해당 카테고리에 속해있는 언론사의 개수와 현재 언론사의 순서를 표시
언론사의 순서는 화면이 새로고침 될 때마다 랜덤으로 정하기
현재 순서의 언론사 내용 표시
한 언론사당 20초간 화면이 보이지 않음
카테고리명 배경이 프로그레스 바가 되어 초마다 색이 차오르도록 애니메이션 적용
20초가 되면 다음 언론사의 내용이 나타남
카테고리의 마지막 언론사가 20초간 보여진 후에는 다음 카테고리로 넘어감
가장 마지막 카테고리의 마지막 언론사가 보여진 후에는, 처음 카테고리의 첫 언론사로 돌아옴
좌우의 화살표를 통해서도 즉시 이전/다음 언론사로 이동
선택된 카테고리 외의 다른 카테고리에는 마우스를 올리면 밑줄이 생김
각 카테고리를 누르면 해당 카테고리로 바로 이동 언론사 기사 영역에는 아래의 요소들이 들어감 언론사 브랜드 마크
최종 편집 일시
구독하기 버튼
썸네일이 있는 메인 뉴스 1건
타이틀만 있는 서브 뉴스 6건
편집권에 대한 안내 문구 메인 뉴스에 마우스를 올리면 썸네일은 5% 확대되고 뉴스 타이틀에 밑줄 생김
구독하기 버튼을 누르면 서버에서 처리되는 시간동안 버튼에 loading indicator가 보이도록 하고, 완료되는 즉시 내가 구독한 언론사 탭의 리스트 보기 화면으로 이동
<br><img src="https://i.imgur.com/mBUUNLa.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내가 구독한 언론사의 리스트 보기 -&gt; 전체 언론사의 리스트 보기 화면과 동일하되, 카테고리들이 나열되어있던 가로 탭에 언론사의 이름과 &gt; 화살표 아이콘이 보이도록
언론사는 구독한 순서대로 배치
전체 언론사 탭 상태에서는 그리드 보기가 기본인 것처럼, 내가 구독한 언론사 탭 상태에서는 리스트 보기가 기본<br>
<img src="https://i.imgur.com/U0vncL5.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
구독 해지 버튼을 누르면 커스텀 알럿 뜨기 예, 해지합니다
아니오 각 버튼에도 마우스를 올리면 텍스트에 밑줄이 생기도록
'예, 해지합니다'를 선택하면 즉시 구독이 해지되고, 목록의 다음 순서 언론사가 바로 나타나도록 함
<br><img src="https://i.imgur.com/Jouweif.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내가 구독한 언론사의 그리드 보기 화면은 전체 언론사의 그리드 보기 화면과 동일
다만, 사용자가 구독을 누른 언론사의 브랜드마크만 보이고, 나머지 칸은 비어있도록
구독중인 언론사의 브랜드 마크 셀에 마우스를 올리면 구독 해지 버튼이 나타남 리스트 보기 상태에서 구독 해지를 하는 것과 동일하게 알럿이 뜨도록 함
구독이 해지되는 즉시 그리드에서 해당 언론사의 브랜드마크가 사라짐 <br><img src="https://i.imgur.com/kfqLkDE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Foundation의 컬러 팔레트 저옵를 활용해 다크모드 테마 만들기
다크모드로 전환 시, 로고들도 다크모드 버전으로 일괄 전환 Vite 설정
tailwind 설정
eslint 설정
prettier 설정 컴포넌트 설계 각 컴포넌트 별로 나눠야 할 부분 설계
data fetching이 필요한 부분 설계
폴더 구조 설계
폴더 구조에 맞도록 컴포넌트와 데이터 등 설계 mock 데이터 설계
<br><img src="https://i.imgur.com/ekkPl7N.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
콘텐츠는 웹 화면의 정중앙 배치
기본 상단 영역 왼쪽에 뉴스 스탠드 로고 클릭시 새로고침 오른쪽에는 시스템 날짜 최신 뉴스 자동 롤링
언론사별 기사들을 확인하는 영역 전체 언론사 탭의 그리드 보기를 디폴트로
내가 구독한 언론사 탭의 타이틀 옆에는 badge 컴포넌트로 내가 구독한 언론사의 숫자를 표시 가로 930px, 세로 388px 영역에 6*4의 테이블이 들어가도록 한다
각 테이블의 셀에는 언론사 브랜드 마크가 중앙에 배치
언론사 브랜드 마크의 순서는 페이지가 새로고침 될 때마다 랜덤으로 배치
그리드의 과주에는 화살표를 배치하여 페이지를 넘김
가장 첫 페이지와 가장 끝 페이지에서 disabled 되는 화살표는 아예 표시 X
각 언론사 브랜드마크가 있는 셀에 마우스를 올리면, 구독하기 버튼이 뜸
이미 구독하고 있는 언론사의 경우, 해지하기 버튼 각 분야 카테고리에서 언론사의 기사 확인 종합/경제
방송/통신
IT
영자지
스포츠/연애
매거진/전문지
지역 선택된 카테고리의 이름 옆에는 해당 카테고리에 속해있는 언론사의 개수와 현재 언론사의 순서를 표시
언론사의 순서는 화면이 새로고침 될 때마다 랜덤으로 정하기
현재 순서의 언론사 내용 표시
카테고리명 배경이 프로그레스 바가 되어 초마다 색이 차오르도록 애니메이션 적용
20초가 되면 다음 언론사의 내용이 나타남
카테고리의 마지막 언론사가 20초간 보여진 후에는 다음 카테고리로 넘어감
가장 마지막 카테고리의 마지막 언론사가 보여진 후에는, 처음 카테고리의 첫 언론사로 돌아옴
좌우의 화살표를 통해서도 즉시 이전/다음 언론사로 이동
선택된 카테고리 외의 다른 카테고리에는 마우스를 올리면 밑줄이 생김
각 카테고리를 누르면 해당 카테고리로 바로 이동 언론사 기사 영역에는 아래의 요소들이 들어감 언론사 브랜드 마크
최종 편집 일시
구독하기 버튼
썸네일이 있는 메인 뉴스 1건
타이틀만 있는 서브 뉴스 6건
편집권에 대한 안내 문구 메인 뉴스에 마우스를 올리면 썸네일은 5% 확대되고 뉴스 타이틀에 밑줄 생김
구독하기 버튼을 누르면 서버에서 처리되는 시간동안 버튼에 loading indicator가 보이도록 하고, 완료되는 즉시 내가 구독한 언론사 탭의 리스트 보기 화면으로 이동
내가 구독한 언론사의 리스트 보기 -&gt; 전체 언론사의 리스트 보기 화면과 동일하되, 카테고리들이 나열되어있던 가로 탭에 언론사의 이름과 &gt; 화살표 아이콘이 보이도록
언론사는 구독한 순서대로 배치
전체 언론사 탭 상태에서는 그리드 보기가 기본인 것처럼, 내가 구독한 언론사 탭 상태에서는 리스트 보기가 기본
]]></description><link>부스트캠프/멤버십/7주차/멤버십_7주차_주간계획.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/멤버십_7주차_주간계획.md</guid><pubDate>Mon, 07 Oct 2024 12:29:58 GMT</pubDate><enclosure url="https://i.imgur.com/m02Qv9T.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/m02Qv9T.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Prettier 설정하기]]></title><description><![CDATA[{ "arrowParens": "always", // 화살표 함수의 매개변수가 하나일 때 괄호를 사용할지 여부 "bracketSpacing": true, // 객체 리터럴에서 중괄호 내부에 공백 삽입할지 여부 "endOfLine": "auto", // EoF 방식, OS별로 처리 방식이 다름 "htmlWhitespaceSensitivity": "css", // HTML 공백 감도 설정 "jsxBracketSameLine": false, // JSX의 마지막 `&gt;`를 다음 줄로 내릴지 여부 "jsxSingleQuote": false, // JSX에 singe 쿼테이션 사용 여부 "printWidth": 80, // 한 줄에 출력되는 코드의 최대 길이 "proseWrap": "preserve", // markdown 텍스트의 줄바꿈 방식 (v1.8.2) "quoteProps": "as-needed" // 객체 속성에 쿼테이션 적용 방식 "semi": true, // 세미콜론 사용 여부 "singleQuote": true, // single 쿼테이션 사용 여부 "tabWidth": 2, // 탭 간격 "trailingComma": "all", // 여러 줄을 사용할 때, 후행 콤마 사용 방식 "useTabs": false, // 탭 사용 여부 "vueIndentScriptAndStyle": true, // Vue 파일의 script와 style 태그의 들여쓰기 여부 (v1.19.0) "parser": '', // 사용할 parser를 지정, 자동으로 지정됨 "filepath": '', // parser를 유추할 수 있는 파일을 지정 "rangeStart": 0, // 포맷팅을 부분 적용할 파일의 시작 라인 지정 "rangeEnd": Infinity, // 포맷팅 부분 적용할 파일의 끝 라인 지정, "requirePragma": false, // 파일 상단에 미리 정의된 주석을 작성하고 Pragma로 포맷팅 사용 여부 지정 "insertPragma": false, // 미리 정의된 @format marker의 사용 여부 (v1.8.0) "overrides": [ { "files": "*.json", "options": { "printWidth": 200 } } ], // 특정 파일별로 옵션을 다르게 지정함, ESLint 방식 사용
}
]]></description><link>부스트캠프/멤버십/7주차/prettier-설정하기.html</link><guid isPermaLink="false">부스트캠프/멤버십/7주차/Prettier 설정하기.md</guid><pubDate>Mon, 07 Oct 2024 07:48:58 GMT</pubDate></item><item><title><![CDATA[멤버십_6주차_마스터클래스]]></title><description><![CDATA[모든 것이 객체다!?어떠한 사물 === Object.현실세계를 인지하면서 프로그래밍을 하자!에서 출발=&gt; 상상하고,볼 수 있고,만질 수 있는 것들은 모두 객체이다.모든 객체는 속성(property)과 행위(method)를 가질 수 있음.
속성 : 사람의 키,나이,몸무게 행위 : 움직이다, 먹다, 자다, 공부하다 people.eat();
people.getAddress(); //method~~~~
people.address; //property
업계에서 현실적으로 사용되는 용어
속성,필드,property는 같은말. 함수,메서드도 같은말. <img src="https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1602139788399oopconceptimage15345345.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.miltonmarketing.com/wp-content/uploads/2018/04/oopconceptimage15345345.png" target="_self">https://www.miltonmarketing.com/wp-content/uploads/2018/04/oopconceptimage15345345.png</a>
어떠한 객체를 표현하기 위해, 일반화된 형태로 만든 것.어떠한&nbsp;집합이나 분류에 가깝다.(사람, 동물, 자동차 등)
추상적.class를 통해서 얻을 수 있는 개별객체.유일한 사물.실체에 가깝다(crong, 사자, 벤츠)
구체적.# OOP가 없었다면? 비슷한 형태의 자동차를 만드는 코드가 반복적으로 표현됐을것임. 객체지향을 통해서 이를 간단하고 효과 적으로 표현.<br><img src="https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1602420061378%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">객체지향 프로그래밍 언어에서 강조된 개념들.
Class 캡슐화(Encapsulation) 상속(Inheritance) 다형성(polymorphism) 추상화(abstraction) JavaScript는 class 없이 프로그래밍이 가능하다.
ES Classes는 ECMAScript 2015에서나 표준으로 등장. 그전에는 TypeScript 의 도움으로 사용.
생성자 함수와 prototype 속성을 통해서 클래스 형태를 구성할 수 있음.내부에서만 알고 있으면 될 것을, 외부에 공개하지 않는다. 필요한 것은 외부에 접근을 허용한다.private, public 개념.
JavaScript도 이를 지원하고 있음.module pattern을 통해서 이를 구현할 수도 있긴함.공통부분을 분리해서 재사용하려는 목적.상위클래스와 하위클래스간에 연결을 짓는다.
동동-&gt;사람, BMW -&gt; 자동차, 포크레인-&gt;중장비,&nbsp;아들 -&gt; 아빠(X) kind of 관계. prototype기반의 객체간 연결 chain을 통해 상속구조를 만들 수 있음.child.prototype = Object.create(parent.prototype);
ES6 Class의 extends 키워드 역시 내부적으로는 결국 prototype을 통한 상속구조임.다양한 성질로 동작하는 것.overriding을 통한 재정의, overloading을 통한 메서드 중복정의.JavaScript는 prototype chain내에 동일한 메서드를 두고 overriding구현은 가능.하지만, interface가 없고, method overloading을 공식지원하지 않음(다만,어떠한 타입을 체크해서, 다른 메서드를 호출해서 실행하도록 구현할 수는 있음)JavaScript에 다형성이 존재하냐?는 중요한 논쟁거리는 아님.
오버로딩은 같은 클래스 내에서 메소드 이름은 같지만 매개변수가 다른 여러 메소드를 정의하는 것이고,
오버라이딩은 상속 관계에 있는 클래스에서 상위 클래스의 메소드를 하위 클래스가 재정의하는 것.
필요한 부분만을 선택해서 클래스를 만드는 것.'차'는 '버스'클래스와 '중장비'클래스로 구분지을 수 있는데, 버스와 중장비는 서로 다른 속성과 행위가 필요하다. 이렇게 필요한 부분을 선택해서 클래스를 만들 수 있고, 이를 추상화라고 함.JavaScript에서도 이를 표현하는건 당연히 가능!class없이 바로 object로 표현가능(singleton)var healthObj = { name : "달리기", lastTime : "PM10:12", showHealth : function() { console.log(this.name + "님, 오늘은 " + this.lastTime + "에 운동을 하셨네요"); }
} healthObj.showHealth();
class를 에서 제공하는 constructor라는 생성자가 주어짐. class를 호출하면 constructor가 자동호출 됨.constructor는 instance를 만들어서 반환. 다시말해 객체(instance)를 생성해서 반환.class Health{ constructor(name,healthTime) { this.name = name; this.healthTime = healthTime; } showHealth(){ console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요"); } } const ho = new Health("crong", "12:12");
ho.showHealth();
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://caniuse.com/#feat=es6-class" target="_self">https://caniuse.com/#feat=es6-class</a>function을 new 키워드로 호출하면, 그 함수는 constructor가 됨.const Health = function(name,healthTime) { this.name = name; this.healthTime = healthTime; this.showHealth = function() { console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요"); }
} const ho = new Health("crong", "12:12");
ho.showHealth();
function Health(name, healthTime) { this.name = name; this.healthTime = healthTime;
} Health.prototype.showHealth = function() { console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요");
} const ho = new Health("crong", "12:12");
ho.showHealth();
Object.create는 직접적으로 prototype키워드를 사용하진 않지만, Prototype object를 만드는 것과 동일.const healthObj = { showHealth : function() { console.log(this.name + "님, 오늘은 " + this.healthTime + "에 운동을 하셨네요"); }
} const ho = Object.create(healthObj, { name: { value: "crong" }, healthTime: { value: "12:22" } }) ho.showHealth();
Object.create는 prototype기반 상속을 좀더 매끄럽게 사용하기 위해 탄생했다고 이해할 수 있음.Object.create를 사용하면 상속구조가 잘 만들어짐. 하지만 ES6 Classes의 extend를 사용해서 이제 보다 쉽게 클래스간 상속 구조를 만들 수 있게 됨.여러개의 객체를 만들어서 생성할 필요가 없을때, 즉 일반화할 필요가 없는 경우에는 단순히 object literal로 객체를 표현.하나 이상으로 개별적인 객체를 생성해야 할 때.TypeScript는 Microsoft사가 JavaScript를 확장해서 만든 언어이다.(superset)따라서 JavaScript 문법을 그대로 다 사용할 수 있으며, 추가로 사용할 수 있는 강력한 문법들을 제공한다.<br><img src="https://4.bp.blogspot.com/-pYn2LAUvMNQ/WtWXBIT2IRI/AAAAAAAACK8/n9pH7ikTpo4xqIl8odqkJ7kfnbfpcsbxACLcBGAs/s1600/typescript.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">class Cat { constructor(name) { this.name = name; } jump() { console.log('살금살금 점프'); } sleep(time) { setTimeout(() =&gt; console.log('zzzZZ.'), time); } getName() { return this.name; }
}
class Cat { private name: string; constructor(name: string) { this.name = name; } jump(): void { console.log('살금살금 점프') } sleep(time: number): void { setTimeout(() =&gt; console.log('zzzZZ.'), time); } getName(): string { return this.name; }
} 소스코드 타입 검사기 컴파일러 타입 정의 파일 yarn global add typescript
tsc --init
tsc practice.ts node practice.js
<br><a data-tooltip-position="top" aria-label="https://www.typescriptlang.org/play" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.typescriptlang.org/play" target="_self">TypeScript Playground</a>string, boolean, number, bigint, symbol, null, undefinedfunction, array, object, RegExp, Date ..Tuple, Enum, Any, Void, Never, Unions, unknownJavaScript의 type은 동적으로 결정되는 특징을 가진 dynamic typing(동적타이핑) 언어다.TypeScript에서는 정적타이핑을 목적으로 하고 있다. 다시 말해 코드에 타입을 명시적으로 선언하고 그에 맞는 값을 할당해야 한다.이렇게 추가된 타입 선언은 런타임 단계에서 문제가 발생하는 것이 아니고, 개발 중에 IDE를 통해서 쉽게 정적인 에러를 발견할 수가 있다. 이 부분은 TypeScript의 큰 장점이다.타입 시스템은 아래와 같은 단계로 타입에 오류가 있는지를 확인.// 오류가 있는 코드임
const crong = "crong crong";
crong.forEach(); 코드를 분석해서 타입과 값을 이해 (crong이 있군)
각 값의 타입을 확인 (crong은 문자열이군)
각 값이 어떻게 사용할 수 있는지 방법 확인(crong에 forEach는 없는데...)
오류 표시 ("Property 'forEach' does not exist on type 'string'")
진단과 분석(프로파일링)
퍼포먼스(수행 과정에 대한 녹화하고 진단)
개발자 도구(lighthouse)
로딩 타이밍에 빠른 화면 노출과 빠른 반응 노출
테스트
ete 테스트(end-to-end 테스트)
]]></description><link>부스트캠프/멤버십/6주차/멤버십_6주차_마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/멤버십_6주차_마스터클래스.md</guid><pubDate>Fri, 04 Oct 2024 08:25:07 GMT</pubDate><enclosure url="https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1602139788399oopconceptimage15345345.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1602139788399oopconceptimage15345345.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[firebase functions]]></title><description><![CDATA[Firebase Cloud Functions란?
Firebase에서 cloud functions에 대한 설명을 찾아보면 아래와 같이 나온다.
Firebase용&nbsp;Cloud Functions는 백그라운드 이벤트, HTTPS 요청,&nbsp;Admin SDK&nbsp;또는&nbsp;Cloud Scheduler&nbsp;작업에 의해 트리거된 이벤트에 대한 응답으로 백엔드 코드를 자동으로 실행할 수 있는 서버리스 프레임워크입니다.
쉽게 말해서 서버가 기본적인 api에 대한 로직을 작성한 후 이후 해야 하는 배포부터 관리 문제 전반을 firebase쪽에 이관하는 것이다.
유명한 서버리스 프레임워크는 functions 말고도 aws lambda 등이 있다.
그렇다면 이 서버리스라는 개념은 정확히 무엇을 의미하는 걸까?단어 그대로 server + less, 서버를 관리할 필요가 적어진다는 뜻이다.
개발자가 일일이 서버를 관리할 필요 없이 애플리케이션을 빌드하고 실행할 수 있도록 하는 클라우드 네이티브 개발 모델이다.
그렇다고 서버가 없어지는 것은 아니다. 그저 개발자가 서버를 건드릴 필요가 없다는 뜻이지, 서버리스 모델에도 서버는 존재한다. 하지만 그걸 관리하는 주체가 클라우드 제공업체로 바뀐다는 점과 이 클라우드 제공업체에서 서버 인프라에 대한 프로비저닝, 유지관리, 스케일링 등 서버 관리에서 필요한 필수적인 요소를 대신 해준다.서버리스 아키텍처와 IaaS(Infrastructure-as-a-Service)는 클라우드 컴퓨팅 모델이라는 점에서 공통점을 가지지만, 서버리스는 이벤트 관리 기반 모델이라는 점에서 큰 차이점을 가진다.

<img src="https://i.imgur.com/Iae7V2n.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Iaas(Infrastructure-as-a-Service)
PaaS(Platform-as-a-Service) SaaS(Software-as-a-Sercvice) 와 함께 3대 클라우드 서비스 모델 중 하나이며, 스토리지, 네트워크, 서버 등을 모두 제공하면서 서버 관련 인프라를 모두 제어해준다
Iaas는 사용자가 인프라를 직접 관리하는 것이지만 서버 설정, 네트워킹, OS 설치 등의 세팅과 같은 일련의 과정을 클라우드 상에서 하는 것이다. 반면 서버리스의 경우에는 서버 인프라의 처음부터 끝까지 클라우드를 통해 서비스를 제공하기 때문에 서로 관여하는 정도가 다르다.또한 가장 중요한 점은 Iaas는 서버를 계속 돌리고 있는 상태여야 하기 때문에 가동 시간이나 용량 등에 대해서 비용이 책정되는 반면, 서버리스는 내가 설정해놓은 특정 함수가 실행되었을 경우에 이벤트를 발생시켜 리소스를 동적으로 할당한다(그래서 이름을 lambda나 functions로 하는듯). 따라서 아무리 트래픽이 몰린다 하더라도 동적 할당으로 견딜 수 있다. 하지만 쓴 만큼 돈은 나온다.(on-demand)아무튼 이러한 서버리스 아키텍쳐는 FaaS(Function-as-a-Service) 와 Baas(Backend-as-a-Service) 로 나뉘는데, 우리가 서버리스를 지칭할 때는 주로 FaaS를 나타낸다고 보면 된다.
Faas는 특정 함수 단위로 코드를 실행할 수 있는 서비스로, 클라우드 서비스 제공자가 특정 요청에 대해 발생하는 함수를 실행할 수 있는 환경을 제공하도록 하여 사용자들의 요청에 함수가 실행될 수 있도록 한다.
BaaS(Backend-as-a-Service)
BaaS는 클라우드 제공자가 백엔드(서버)에서 필요한 모든 것들을 제공한다(인증, 스토리지, db 등). Firebase나 AWS Amplify가 대표적이며, 이를 통해 remote 푸시 알림과 같은 기능들을 사용할 수 있다. Stateless하다 함수가 실행되는 동안만 관련된 리소스만을 할당하고 끝나면 반환하기 때문에 상식적으로 생각해도 stateless할 수밖에 없다. 따라서 지속되는 상태를 유지하기 위해서는 DB를 따로 이용해야 할 필요성이 있다. Ephemeral하다(일시적임) stateless와 비슷한 결이긴 하다. 특정 이벤트가 발생했을 경우 컨테이너로서 배포가 되고 회수되는 과정이 반복되기 때문에 일시적으로 배포된다고 볼 수 있다. 장점은 무엇보다 서버를 그대로 맡기기 때문에 서버에 대한 문제를 신경쓰지 않을 수 있다는 점이다. 나같은 프론트가 작은 애플리케이션 하나 만들려면 서버가 필요하기 때문에 서버 코드 쓰고 aws 인스턴스를 파고 배포하랴.. 프록시 설정하랴.. pm2 설정하랴.. crontab 설정하랴... 할게 많은데 제대로 할줄도 몰라서 킹받게 시간을 많이 잡아먹는다.
하지만 이 귀찮은 작업들을 알아서 처리해준다고 하니 우리야 땡큐다. 게다가 대부분 호출 100만건정도는 무료로 제공하는 횟수이니, 미니 프로젝트에서는 이만큼 안성맞춤인 서버가 없다. 또한 갑자기 트래픽이 몰린다고 해도 다이나믹하게 알아서 스케일업을 해주기 때문에 신경쓸 필요가 없다(사실 신경쓰긴 해야함).하지만 장점이 뚜렷한 만큼 그에 따른 단점 또한 명확하다.
서버에 대한 상세 설정이나 인프라 제어 등에 대해서는 모조리 서비스 제공하는 곳에서 관리하기 때문에 우리가 설정할 수 있는 범위가 제한된다는 점이 자유도를 묶는다.
또한 서버리스 함수의 경우에는 나 또한 이번에 하면서 느낀 현상으로, 콜드 스타트(Cold Start) 라는 현상인데 처음 호출 시에 시간 지연이 조금 발생한다.위에서 말했듯이 서버리스는 함수가 실행될 때마다 리소스(자원)을 동적으로 할당하는 구조이기 때문에 함수가 실행되는 동안만 관련된 자원이 할당되고, 실행이 끝나고 응답이 돌아왔다면 함수는 할당된 리소스를 반환한다.<br><img src="https://i.imgur.com/sSac1EY.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
여러 요청이 동시에 오는 경우 기능 복사본을 생성하여 재활용하거나 한번 요청이 갔을때 유지하는 유휴 상태에서 벗어나게 되면 다시 위와 같은 라이프사이클을 돌아야 하게 되니, 다시금 속도가 느려지게 되는 현상이 있다.
예전에 IEEE에서 AWS Lambda와 Microsoft Azure Functions에서 벤치마크를 수행한 결과가 있는데, 300ms에서 24초까지 시간이 걸렸다고 하니 이 점이 사용자에게 서비스 제공 과정에 있어서 치명적인 단점으로 작용한다.
그래서 firebase의 cloud functions와 같은 곳에서는 최소 인스턴스 수를 설정하여 컨테이너를 유지함으로써 최소한 들어올 수 있는 사용자에 대해 바로 응답할 수 있도록 하는 등의 대비책을 통해 속도를 줄이는 방법을 사용한다. 추가적으로 종속성 줄이기, 캐싱 헤더 사용, 올바른 지역 선택 등을 통해 속도를 줄일 수 있다고는 하지만 효과적으로 줄이기 위한 확실한 방법은 최소 인스턴스 수를 유지하는 것이다. 이를 위해 스케줄링을 따로 시켜 계속해서 인스턴스를 유지하도록 하는 등의 방법을 쓰는 것으로 보인다.서버리스(FaaS)에 대해 알아보았으니 사용하면서 직접 알아가보자.
나는 FaaS들 중에 firebase Functions를 사용했다. 이유는 이 전에 firebase를 사용한 cloud messaging 기술을 내 프로젝트 앱에 사용했던 경험이 있는데, firebase에 cloud messaging 말고도 다른 기능들이 정말 많아 계속 한번쯤은 사용해보고 싶다는 생각이 들었기 때문이다.
나는 기존 functions를 통해 런타임에 배포하는 것을 넘어 db 또한 따로 배포하기 귀찮았기 때문에 firebase에서 제공하는 cloud db인 firestore까지 이용할 것이다.
해당 글은 node.js 기준으로 작성되었습니다.
<br><a data-tooltip-position="top" aria-label="https://console.firebase.google.com/?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://console.firebase.google.com/?hl=ko" target="_self">Firebase&nbsp;Console에서 프로젝트 추가하기</a><br>
<img src="https://i.imgur.com/VbeYh5o.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
프로젝트를 추가하는 것은 사이트에서 추가하면 되기 때문에 어려운 것은 없다. 등록을 끝내고 나면 이런 식으로 콘솔이 뜬다.npm install -g firebase-tools
firebase functions를 런타임에 배포하기 위해서는 Firebase CLI가 필요하다.
npm을 통해 다운로드 받아주자
다운로드 받으면 Firebase를 실행하여 로그인 및 기타 초기화 작업을 할 수 있다.// 얘 쓰면 로그인창 뜸
firebase login // 내가 프로젝트 생성할 디렉토리로 이동
cd 디렉토리 // firestore init
firebase init firestore // functions init
firebase init functions
이렇게 세팅하다보면 어떤 언어 쓸거냐는 질문이 나올건데 나는 js로 선택해주었다myproject
+- .firebaserc # `firebase use` 명령어를 통해 프로젝트 간 전환을 빠르게 도와주는 숨김 파일
|
+- firebase.json # 프로젝트 속성을 설명하는 파일
|
+- functions/ # 모든 함수 코드가 포함된 디렉터리 | +- .eslintrc.json # 자바스크립트 린팅 규칙을 포함한 선택적 파일 | +- package.json # Cloud Functions 코드를 설명하는 npm 패키지 파일 | +- index.js # Cloud Functions 코드의 메인 소스 파일 | +- node_modules/ # package.json에 선언된 의존성들이 설치되는 디렉터리
그럼 이런 식으로 처음 세팅이 완료된다//package.json
{ "name": "functions", "description": "Cloud Functions for Firebase", "scripts": { "lint": "eslint .", "serve": "firebase emulators:start --only functions", "shell": "firebase functions:shell", "start": "npm run shell", "deploy": "firebase deploy --only functions", "logs": "firebase functions:log" }, "engines": { "node": "22" }, "main": "index.js", "dependencies": { "cors": "^2.8.5", "firebase-admin": "^12.1.0", "firebase-functions": "^5.0.0" }, "devDependencies": { "eslint": "^8.15.0", "eslint-config-google": "^0.14.0", "firebase-functions-test": "^3.1.0" }, "private": true
}
package.json을 열어보면 이런 식으로 scripts가 짜여 있어서 쓰기 편하다
기억하면 좋은 것은
engines : 내가 쓸 node 버전 설정
scripts
- serve : emulator를 통해서 로컬에서 서버를 킬 수 있다. ui도 제공하니 보고 테스트하기 댕꿀이다
- deploy: functions만 배포
솔직히 난 이정도만 썼다
// The Cloud Functions for Firebase SDK to create Cloud Functions and triggers.
const {logger} = require("firebase-functions");
const {onRequest} = require("firebase-functions/v2/https");
const {onDocumentCreated} = require("firebase-functions/v2/firestore"); // The Firebase Admin SDK to access Firestore.
const {initializeApp} = require("firebase-admin/app");
const {getFirestore} = require("firebase-admin/firestore"); initializeApp();
처음에 index.js가면 잡다한 테스트용들이 주석처리 되어 있고 이런 식으로 해보라고 한다.
initializeApp()을 통해 Firebase 서비스에 접근 가능하도록 초기 설정을 할 수 있으며 인증처리 등의 과정이 이루어지면서 연결된다.요청 핸들러를 사용하면 HTTP 요청을 통해 함수를 트리거시키고, 해당 함수를 통해 응답을 반환시킬 수 있다.요청에 대한 옵션은 이렇게 지정해줄 수 있다.const { onRequest } = require("firebase-functions/v2/https"); exports.sayHello = onRequest( { cors: [/firebase\.com$/, "flutter.com"] }, (req, res) =&gt; { res.status(200).send("Hello world!"); }
);
요런 식으로 cors의 경우 내가 가지고 있는 도메인들을 설정할 수 있으며, 일반 express 사용하듯이 요청과 응답에 대한 콜백함수를 onRequest를 통해 보낼 수 있다.
참고로 exports.뒤의 이름은 기본 url 뒤의 uri로 더 붙게된다const functions = require("firebase-functions");
exports.api = functions.region("asia-northeast3").https.onRequest();
이렇게 region 옵션도 지정해주어 리전 설정해서 속도를 조금이라도 올릴 수 있다.
또한 https 프로퍼티를 통해 onRequest 메서드를 실행하면 배포할 때 https 로 배포된다.기존의 웹 서버 프레임워크를 initialize한 app을 요청 핸들러에 인자로 넣으면 전체 앱을 HTTP 함수에 전달할 수 있다. 따라서 요청과 응답을 웹 서버 프레임워크를 통해 관리할 수 있는 것이다.나는 express를 사용해서 요청과 응답을 처리해보고, 클라이언트와 서버 모두 해당 서버에서 돌릴 생각이었다.const functions = require("firebase-functions");
const path = require("path");
const { initializeApp } = require("firebase-admin/app");
const express = require("express");
const { routeManager } = require("./controller/index.js");
const cors = require("cors"); initializeApp();
const app = express(); app.use(cors());
app.use(express.static(path.join(__dirname, "dist")));
app.use(express.json()); routeManager(app);
app.get("/", (req, res, next) =&gt; { res.send("index");
}); exports.api = functions.region("asia-northeast3").https.onRequest(app);
이렇게 onRequest에 initialize한 app을 인자로 넣어주었다. 그렇게 되면 해당 functions로 오는 http 요청들이 모두 app을 통하게 된다.
나는 간단한 프로젝트를 만들 예정이었기 때문에 미들웨어로 cors와 번들링할 정적 파일들에 대한 설정, json 파싱 등에 대한 설정만 해주었다.클라이언트는 esbuild를 통해 번들링하여 dist라는 디렉토리에 넣어두었기 때문에 저렇게 설정해주었고, 기본 url에 대해서는 index.html파일만을 보내도록 했다. 어차피 SPA로 만든 프로젝트기 때문에 저거 하나만 설정해두었다.
api uri에 클라이언트까지 때려박은 이유는 귀찮아서다<br>
<img src="https://i.imgur.com/ZlDgKYs.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
아무튼 다른 추가적인 uri가 붙는 것에 대해서는 따로 functions를 나누지 않고 express의 Router를 이용해서 각 요청과 응답을 처리해주었다. functions를 도메인별로 나누는 것도 좋고 깔끔한게 좋으면 express에서 route만 별도 파일로도 관리할 수 있어서 취향차이인 것 같다.
암튼 이정도 세팅을 간단하게만 해주고 deploy '딸깍' 하면 배포도 척척 잘된다.참고로 배포하려면 무료 요금제(spark) 요금제에서 Blaze 요금제로 바꿔야 한다.<br>
<img src="https://i.imgur.com/UMyMqP7.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
그래도 앵간한 만큼은 공짜로 쓸 수 있으니 야무지게 써먹자<br>
<img src="https://i.imgur.com/sx8OoQw.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>아무튼 '딸깍'만으로 관리할 필요가 없어지는 서버리스는 프론트인 나에게 그저 빛...<img src="https://i.imgur.com/Tg6rEWE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/sEjPPwh.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
처음 초기 세팅하는 과정에서 functions 세팅을 하고 firestore 세팅도 따로 할 수 있다.
http 요청에 따른 CRUD도 express에서 firestore에 접근하여 조작하면 된다.const admin = require("firebase-admin");
async function getUserList() { try { const data = await admin.firestore().collection("todo").get(); return data.docs.map((doc) =&gt; new User(doc.data()); } catch (error) { throw new Error(error); }
}
admin의 firestore 메서드를 사용하면 해당 프로젝트에 연결되어 있는 firestore에 접근하여 CRUD를 수행할 수 있다.const cityRef = db.collection('cities').doc('SF');
const doc = await cityRef.get();
if (!doc.exists) { console.log('No such document!');
} else { console.log('Document data:', doc.data());
}
중요한 점은 개별 데이터 객체에 대해서 data() 메서드를 사용해야만 내가 원하는 데이터가 나온다따로 functions 없이 firestore에만 접근하고 싶다면 firebase SDK를 따로 설정한 뒤에 서버를 키면서 초기화 시켜주면 된다.firebase 콘솔 -&gt; 프로젝트 설정 -&gt; 아래 내 앱 -&gt; SDK 설정 및 구성에서 내 firebase config를 볼 수 있다.npm install firebase
firebase 따로 설치하고// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries // Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = { apiKey: "API키", authDomain: "도메인", projectId: "프로젝트ID", storageBucket: "스토리지버킷", messagingSenderId: "메시지 센더ID", appId: "앱아이디", measurementId: "측정ID"
}; // Initialize Firebase
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);
이렇게 InitializeApp하고 사용하면 된다.// Create a reference to the cities collection
const citiesRef = db.collection('cities'); // Create a query against the collection
const queryRef = citiesRef.where('state', '==', 'CA');
const citiesRef = db.collection('cities');
const snapshot = await citiesRef.where('capital', '==', true).get();
if (snapshot.empty) { console.log('No matching documents.'); return;
} snapshot.forEach(doc =&gt; { console.log(doc.id, '=&gt;', doc.data());
});
where문을 사용하게 되면 쿼리 객체를 가져오게 되고, get()을 통해 결과를 검색한 결과를 받아올 수 있다.
가져온 객체는 QueryDocumentSnapshot객체로, 여러 개의 프로퍼티를 가지고 있기 때문에 우리가 필요한 데이터만 가져오기 위해서는 data() 메서드를 통해 반환된 데이터를 이용해야 한다.where()&nbsp;메서드는 필터링할 (필드, 비교 연산자, 값)의 3가지 매개변수를 사용한다.
연산자는
&lt;&nbsp;: 미만
&lt;=&nbsp;: 작거나 같음
==&nbsp;: 같음
&gt; :&nbsp;보다 큼
&gt;= :&nbsp;이상
!=&nbsp;: 같지 않음
array-contains : 포함하는 배열
array-contains-any : 배열 안의 것들과 일치하는 모든 레코드
in : 지정된 필드가 비교값과 일치하는 레코드
not-in : 동일한 필드에서 같지 않은 에코드
const stateQueryRes = await citiesRef.where('state', '==', 'CA').get();
const populationQueryRes = await citiesRef.where('population', '&lt;', 1000000).get();
const nameQueryRes = await citiesRef.where('name', '&gt;=', 'San Francisco').get();
==나 array-contains를 연결하여 제약 조건을 AND와 결합citiesRef.where('state', '==', 'CO').where('name', '==', 'Denver');
citiesRef.where('state', '==', 'CA').where('population', '&lt;', 1000000);
제약 조건을 논리적 OR과 결합const bigCities = await citiesRef .where( Filter.or( Filter.where('capital', '==', true), Filter.where('population', '&gt;=', 1000000) ) ) .get();
db.collection("cities").whereEqualTo("country", “USA”).orderBy(“population”);
해당 쿼리에 대해서 정렬 기준을 잡고 정렬
orderBy 안에 들어있는 필드가 없으면 반환하지 않음function addTodo(req) { const id = crypto.randomUUID(); const created_at = new Date().toISOString(); return admin.firestore().collection("todo").add({ id, detail: req.body.detail, created_at, });
}
넣으려는 도메인에 대해서 add메서드를 통해 객체를 그대로 넣어줄 수 있다.
NOSQL인 만큼 데이터를 변형되지 않도록 신경써야 할 것 같다.const citiesRef = db.collection('cities');
const snapshot = await citiesRef.where('capital', '==', true).get();
if (snapshot.empty) { console.log('No matching documents.'); return;
} snapshot.forEach(doc =&gt; { console.log(doc.id, '=&gt;', doc.data());
});
아까 봤던 예시처럼 get()을 통해 데이터를 가져오고 개별 데이터에 대해서 data()를 통해 내가 원하는 데이터만 반환받자async function updateTodo(req) { try { console.log(req.body); const id = req.body.id; const detailToUpdate = req.body.detail; const todoToUpdate = await admin .firestore() .collection("todo") .where("id", "==", id) .limit(1) .get(); if (todoToUpdate.empty) { throw new Error("update할 todo를 찾지 못했습니다."); } const todo = new Todo(cardToUpdate.docs[0].data()); todo.update(detailToUpdate); return cardToUpdate.docs[0].ref.update(todo); } catch (error) { throw new Error("예상치 못한 Error가 발생했습니다."); }
}
데이터를 찾아와서, 데이터를 갱신한 다음 update()메서드를 통해 새롭게 교체할 객체를 넣어주면 통으로 바뀐다async function deleteTodo(req) { try { const id = req.params.id; const cardToDelete = await admin .firestore() .collection("todo") .where("id", "==", id) .limit(1) .get(); console.log("???", cardToDelete.docs[0]); if (cardToDelete.empty) { throw new Error("삭제할 todo를 찾지 못했습니다."); } return cardToDelete.docs[0].ref.delete(); } catch (error) { throw new Error(error); }
}
원하는 데이터에 대해서 찾고 ref property의 delete() 메서드를 통해 삭제할 수 있다.]]></description><link>부스트캠프/멤버십/6주차/firebase-functions.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/firebase functions.md</guid><pubDate>Thu, 03 Oct 2024 16:44:38 GMT</pubDate><enclosure url="https://i.imgur.com/Iae7V2n.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/Iae7V2n.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week6_4일차 PR]]></title><description><![CDATA[
클라이언트 스타일 작업
css 번들링과 클래스 선택자를 통한 스타일 입히기
spinner 설정과 state에 따른 spinner 렌더링 테스트 서버 updateTodo에서 객체를 넘겨주는 방식으로 리팩토링 라이브러리 useEffect에서 이전의 값과 현재 값을 비교하기 위해 넣을 수 있도록 설계
Object.keys()대신 map 자료구조를 사용하여 이벤트 핸들러 검색 성능 최적화 firebase functions &amp; firestore
NOSQL
서버리스 아키텍처
useEffect
useRef
useContext
export default function Mainpage() {
... const [isLoading, setIsLoading] = mhReact.useState(false); async function fetchData() { const data = await apicall.get("/todo"); setTodoList(data); } mhReact.useEffect(async () =&gt; { await fetchData(); }, []);
... return ( &lt;div&gt; ... &lt;TodoList todoList={todoList} fetchData={fetchData} /&gt; &lt;Spinner isLoading={isLoading} /&gt; &lt;/div&gt; );
} state에 따른 화면 렌더링을 테스트해보고 있던 와중에 TodoList에서 각 요소에 대해
<img src="https://i.imgur.com/VwpeWPh.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이와 같이 X 버튼을 만들어 누르면 삭제 api 요청이 갈 수 있도록 만들었다.
하지만 삭제 api 요청이 가고난 뒤에는 다시금 데이터를 fetch해와 삭제해온 뒤 최신 정보를 갱신하기 위해서 앞에서 실행했던 fetchData를 가져올 필요가 있었다. 상위 컴포넌트에서 setTodoList를 통해 해당 리스트들에 대해서 관리하고 있기 때문이다.import * as mhReact from "mhreact";
import { deleteTodo } from "../../features/todo";
import "./index.css"; export default function TodoList({ todoList, fetchData }) { if (!todoList.length) { return &lt;h1&gt;로딩중...&lt;/h1&gt;; } async function onClickDelete(id) { try { await deleteTodo(id); await fetchData(); } catch (error) { alert("삭제 중 오류가 발생했어요!"); } } return ( &lt;ul class="todo-list"&gt; {todoList.map((todo) =&gt; ( &lt;div class="todo-item"&gt; &lt;li&gt;{todo.detail}&lt;/li&gt; &lt;button class="todo-deleteButton" onClick={() =&gt; onClickDelete(todo.id)} &gt; ❌ &lt;/button&gt; &lt;/div&gt; ))} &lt;/ul&gt; );
} 따라서 이런 식으로 fetchData 함수 자체를 가져와 delete 버튼을 누르면 delete api를 보낸 후에 fetchData를 통해서 다시금 정보를 갱신할 수 있도록 해주었다.export function destructuringFunctionalComponentWithRef(element) { const duplicated = {}; Object.entries(element.props.refs).forEach(([ref, val]) =&gt; { if (typeof val === "function") duplicated[ref] = val(); else duplicated[ref] = val; }); return element.type(duplicated);
}
하지만 내가 설계한 fiber를 구성하는 과정에서 destructuringFunctionalComponentWithRef()는 혹시나 컴포넌트가 원하는 것들 중 상태를 넘겨주게 된다면, 홤수는 루트에 붙어있는 상태 참조값을 가져와 반환하는 함수이기 때문에 해당 함수를 실행시켜 반환받은 값을 컴포넌트의 함수 인자로 넣어줬어야 했다. 이 과정때문에 ref에 설정해놓았던 함수들은 모조리 실행시켜 주는 로직으로 작성하였다. 상태와 일반 함수를 따로 구분할 수도 없기 때문이다.
따라서 이를 어떻게 해결하면 좋을까 생각하다가 클라이언트에서 함수를 주는 방식을 바꿔보면 되지 않을까 생각했다.// 변경 전
&lt;TodoList todoList={todoList} fetchData={fetchData} /&gt; // 변경 후
&lt;TodoList todoList={todoList} fetchData={() =&gt; { return fetchData; }} /&gt;
기존에는 함수 자체를 넣어줬었지만, 이번에는 함수를 wrapper 함수로 감싸 함수를 실행하면 내가 넘겨주고자 하는 함수 자체를 반환할 수 있는 함수를 인자로 넘겨주었다.
fetchData 인자는 createElement 과정에서 사용자가 정의한 커스텀 property이기 때문에 props의 ref로 가게 되고, 이를 기반으로 fiber를 만드는 과정에서 destructuringFunctionalComponentWithRef()을 실행시키게 되는데, 해당 함수는 함수를 실행하는 함수가 아닌 함수를 반환하는 함수이기 때문에 실행 과정에서 실행할 함수만 남게 되어 문제를 해결할 수 있었다.안녕하세요 멘토님! 고생 많으십니다ㅎㅎ부족하지만 클라이언트도 번들링한 파일을 보내도록 해서 배포했습니다!<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://asia-northeast3-todo-24f54.cloudfunctions.net/api/" target="_self">https://asia-northeast3-todo-24f54.cloudfunctions.net/api/</a>오늘 질문드리고 싶은 것이 한가지가 있습니다.
화요일 리뷰에서 멘토님께서 커스텀 이벤트를 말씀해주셔서 커스텀 이벤트에 대해서 조금 찾아보았습니다.// CustomEvent 생성
const catFound = new CustomEvent("animalfound", { detail: { name: "cat", },
});
const dogFound = new CustomEvent("animalfound", { detail: { name: "dog", },
}); // 적합한 이벤트 수신기 부착
obj.addEventListener("animalfound", (e) =&gt; console.log(e.detail.name)); // 이벤트 발송
obj.dispatchEvent(catFound);
obj.dispatchEvent(dogFound); // 콘솔에 "cat"과 "dog"가 기록됨 이런 식으로 Custom Event에 대해서 객체를 생성하고 생성한 객체를 dispatchEvenet를 통해 이벤트를 발송하면 해당 커스텀 이벤트를 구독한 곳에 해당 이벤트를 실행하는 발행-구독 패턴을 닮았다고 생각합니다.여쭤보고 싶은 것은 이러한 커스텀 이벤트가 현업에서 많이 쓰이는지 궁금합니다. 저는 이제까지 한번도 사용해본 적이 없어서 생소한 개념이기도 하지만, 발행-구독과 비슷한 패턴을 통해 전역에서 관리할 수 있는 장바구니같은 기능과 같은 곳에서 유용할 것 같다고 생각합니다. 현업에서는 이를 활용하는지, 한다면 어떤 식으로 활용하는지 궁금합니다!벌써 마지막 리뷰네요,,🥲 이제까지 제가 꼼꼼하게 생각하지 못했던 것들을 많이 집어주셔서 저만의 안티패턴을 발견할 수도 있었던 시간이었던 것 같습니다. 항상 정성들여 리뷰해주셔서 정말 감사합니다! ]]></description><link>부스트캠프/멤버십/6주차/week6_4일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/week6_4일차 PR.md</guid><pubDate>Thu, 03 Oct 2024 12:56:41 GMT</pubDate><enclosure url="https://i.imgur.com/VwpeWPh.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/VwpeWPh.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_6주차]]></title><description><![CDATA[<a data-href="멤버십_6주차_주간계획" href="부스트캠프/멤버십/6주차/멤버십_6주차_주간계획.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_6주차_주간계획</a><br>
<a data-href="멤버십_6주차_마스터클래스" href="부스트캠프/멤버십/6주차/멤버십_6주차_마스터클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_6주차_마스터클래스</a><br><a data-href="week6_1일차 PR" href="부스트캠프/멤버십/6주차/week6_1일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week6_1일차 PR</a><br>
<a data-href="week6_2일차 PR" href="부스트캠프/멤버십/6주차/week6_2일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week6_2일차 PR</a><br>
<a data-href="week6_3일차 PR" href="부스트캠프/멤버십/6주차/week6_3일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week6_3일차 PR</a><br>
<a data-href="week6_4일차 PR" href="부스트캠프/멤버십/6주차/week6_4일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week6_4일차 PR</a><br><a data-href="week6_2일차 회고" href="부스트캠프/멤버십/6주차/week6_2일차-회고.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week6_2일차 회고</a>]]></description><link>부스트캠프/멤버십/6주차/멤버십_6주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/멤버십_6주차.md</guid><pubDate>Thu, 03 Oct 2024 10:08:19 GMT</pubDate></item><item><title><![CDATA[week6_3일차 PR]]></title><description><![CDATA[
클라이언트 스타일 작업
useEffect를 통한 data fetch
api 호출을 통해 데이터를 가져오고 리렌더링시키기
로딩중에는 로딩임을 알 수 있는 문구 띄우기 서버 배포
date 값을 추가해서 날짜순으로 데이터를 보내도록 설계 및 구현
빌드한 정적 파일을 렌더링할 수 있도록 설계하여 서버에서 페이지 렌더링 라이브러리 useEffect 설계 및 구현(프로토타입)
root에서 useEffect를 관리 소스맵
useEffect
useEffect의 경우 가장 먼저 이를 구현하기 위해 생각했던 방법은, state처럼 root에 useEffect의 콜백을 등록해놓고, 렌더링 될 때 실행하는 방법이었다.따라서 useEffect 또한 포인터를 옮겨가면서 계속해서 등록할 수 있도록 해놓고, 렌더링이 끝난 뒤 root에 등록되어있는 모든 useEffect에 대해서 실행시킬 수 있도록 했다.
하지만 그런 경우 문제가 있었다.async function fetchData() { const data = await apicall.get("/todo"); setTodoList(data); } mhReact.useEffect(async () =&gt; { await fetchData(); }, []);
해당 컴포넌트 내부의 함수와 같이, useEffect내에서 fetchData하는 함수를 실행시키고, 받은 데이터에 대해서 setter함수를 통해 새롭게 받은 데이터를 등록할 수 있도록 해놓았다.
이런 경우에, useEffect 내의 콜백함수가 commit이 끝난 후 실행이 되면, useEffect 콜백이 실행되면서 setter함수를 통해 다시금 리렌더링을 실행시켰고, 리렌더링이 다시 되고 난 후에는 다시금 useEffect내의 콜백 함수 실행 -&gt; 리렌더링 -&gt; useEffect 콜백 실행....의 무한 루프가 되었다.어떻게 이를 구분해서 한번만 실행하면 좋을까? 라는 고민을 했었는데 현재로서 할 수 있는 생각은 실행 플래그를 놓는 것이었다.import { Root } from "../dom/DomRoot"; /** * * @param {function} callbackFn * * @param {[]} dependencies */
export function useEffect(callbackFn, dependencies) { const root = Root(); if (!root.global.hasOwnProperty("effects")) { root.global.effects = {}; root.global.effectsIdx = 0; } const effectInformation = { fn: null, prev: null, dependencies: null, called: false, }; effectInformation.fn = callbackFn; effectInformation.prev = dependencies; effectInformation.dependencies = dependencies; const index = root.global.effectsIdx; root.global.effects[index] = effectInformation; root.global.effectsIdx++;
}
called라는 프로퍼티를 객체 리터럴에 놓고 객체 자체를 effect로 관리했다.
한번 렌더링이 되면 called가 true로 바뀌고, true된 함수에 대해서는 실행시키지 않고 flag의 값만 false로 다시 바꾸는 방식을 통해 최초 한번만 실행될 수 있도록 하였다.이 외의 prev나 dependencies같은 경우는 Dependencies에 있는 값이 prev값과 변하면 리렌더링이 이루어질 수 있도록 했는데, 아직까지 이는 보완되지는 않았고 계속해서 보완할 예정이다.]]></description><link>부스트캠프/멤버십/6주차/week6_3일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/week6_3일차 PR.md</guid><pubDate>Wed, 02 Oct 2024 12:58:03 GMT</pubDate></item><item><title><![CDATA[week6_2일차 회고]]></title><description><![CDATA[내가 생각했던 방식으로 로직을 짜는 과정에서 계속해서 오류가 났지만 차근차근 해결해가며 처음으로 내 예상대로 작동되는 모습을 볼 수 있었다. 잘 작동되는 브라우저를 보면서 조금 복잡미묘한 기분이 들었다.사실 문제상황, 프레임워크를 만드는 것에 대한 해결 방식은 정해져 있었다. 리액트를 그대로 따라하는 것이 어찌보면 가장 간단한 해결방법이지만 구현하는 것은 기술적으로 아직 한참 부족했다. 그렇기에 내가 할 수 있는 방법은 나만의 방식대로 만들어 보는 것뿐이었다.나만의 방식대로 만들되, 리액트의 핵심적인 부분만은 최대한 구현하려고 애썼다. 하지만 결국 작동 방식은 완전히 다른 라이브러리가 되어버렸다. 이걸 계속 만들면서 '리액트를 학습하는데 도움이 될까?'하는 생각이 컸던 것 같다. 그러다보니 중간에 회의감이 들었고, 멘토님에게 이러한 고민에 대해 여쭤보았다.
처음부터 리액트의 멘탈모델을 그대로 적용하기보단
세부 구현은 다르더라도 "동작"하는 프레임워크를 만들어보시길 권장드리고 싶습니다.
준일님의 블로그 글들이 완전 리액트와 똑같지는 않은 것처럼요.
저는 한번에 큰 성공을 하는 것보다 많은 작은 성공들을 경험하는 것도 가치있다고 생각합니다.
이 말을 듣고 크게 깨달았다. 나는 이제까지 너무 하나의 프레임워크를 학습해야 겠다는 생각에 사로잡혀 과정보단 결과만 계속 보고 있었다. 그러다보니 결국 내가 문제를 해결하기 위해 고민했던 과정과 해결방법들의 가치를 잊고 있었다. 다시금 생각해보니 학습을 하면서 중요한 것은 '리액트를 구현했는가?'가 아닌, '내가 문제를 정의하고 이에 대해 고민하면서 해결해나갔나?'가 되는 것이 맞다고 생각한다.저번주 강의를 해주셨던 연사님께서 '개발자는 문제를 정의하고 해결하는 사람'이라고 말씀을 하신게 기억에 남는다. ai가 급속도로 발전해가는 사회에서 나는 직접 문제를 계속해서 정의해나가고 해결 방법을 생각해내가며 성장해야겠다는 생각을 했었는데, 어느샌가 이런 생각을 까먹은 채 다시금 매몰되는 모습을 보였던 것 같다.내가 만든 야매 리액트가 나름 잘 작동하는 모습을 보며 복잡미묘한 기분이 든 것은 아마 학습을 위한 구현에 얽매어있다가 문제 정의 및 해결을 경험했기 때문인 것 같다. 그러면서 '아, 나도 문제에 대해서 스스로 사고해서 해결할 수 있는 사람이구나!' 하는 생각도 들어 나름 뿌듯한 감정이 들면서 다시금 내가 어떤 방향으로 가고 있었나 되돌아본 시간이 되었던 것 같다. 앞으로의 성장과정에서도 계속해서 뒤돌아보면서 내가 무엇에 집중해야 하는지를 되새겨야겠다고 깨달은 밤이었다🌙]]></description><link>부스트캠프/멤버십/6주차/week6_2일차-회고.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/week6_2일차 회고.md</guid><pubDate>Tue, 01 Oct 2024 15:55:22 GMT</pubDate></item><item><title><![CDATA[week6_2일차 PR]]></title><description><![CDATA[
라이브러리 useState 보완 이벤트와 attribute, refs를 구분한 뒤 element 생성 과정에서 attribute, event, ref에 따라 별도 처리(devideValidProps)
prop 구분별로 배열로 관리
useState에 콜백을 넣을 시에 이전 state값을 인자로 들어갈 수 있도록 리팩토링
setter함수에서 state가 들어갔을 경우 함수형태의 state값이 제대로 렌더링되지 않는 문제 서버 db 생성하기 firebase firestore를 통해 따로 안하
카드 정보 erd 만들기 기본적인 api 설계 및 구현 firebase functions로 서버리스 서버 구축
카드 추가
카드 삭제
카드 수정
카드 조회 useState
firestore &amp; firebase functions
저번 PR에서 고민했던 state의 참조 문제를 해결하고자 state 자체를 함수화시켜 참조값이 복사되는 문제를 해결하고 그때그때 함수를 호출시켜 참조값을 가져오는 방식으로 state를 바꾸었다.
하지만 이를 해결하는 과정에서
렌더링 과정에서 다른 state 안에 state가 들어가 있을 경우 함수가 중첩되어 있기 때문에 하나가 풀리지 않아 제대로 렌더링 되지 않음
input의 value와 같은 attribute에 state값을 넣을 경우 attribute쪽에서 함수인 것을 모르고 렌더링하기 때문에 오류 발생하여 렌더링 되지 않음
과 같은 문제가 발견되었다.
이를 어떻게 하면 해결할 수 있을까 고민하다가 props로 들어오는 요소들에 대해서 구분화할 필요가 있다고 느겼다.
기존의 element 안에서 들어가야 할 요소는
attribue -&gt; 태그의 속성으로 들어가는 값들
event -&gt; 함수로 들어가 렌더링 과정에서 이벤트 등록
이 있었고, 추가적으로 커스텀 컴포넌트의 경우에는 내가 받고자 하는 참조 값에 대해 설정해놨을 경우 해당 참조값을 받는 코드가 트랜스파일링 과정에서 생기게 된다.
// 이렇게 커스텀 컴포넌트를 설정했을 경우...
&lt;TodoList todoList={todo} /&gt; //이런 식으로 트랜스파일링 된다. mhReact.createElement(TodoList, { todoList: todo }) //이게 커스텀 컴포넌트가 트랜스파일됐을 때
export default function TodoList(_ref) { var todoList = _ref.todoList; return mhReact.createElement("ul", null, todoList.map(function (todo) { return mhReact.createElement("li", null, todo); }));
}
트랜스파일링된 형태는 props에 우리가 설정한 커스텀 컴포넌트의 ref 이름이 붙게 되고, 이에 대해서 값을 인자로 넘겨주고 있다.
여기서 상위 컴포넌트는 props를 통해 todoList를 넘겨주고 TodoList는 이를 객체 형태의 인자로 받아 구조분해 할당을 할 수 있음을 알 수 있다.
따라서 나는 이러한 커스텀 컴포넌트가 인자를 요구로 할 때 제대로 값을 함께 넘겨주면서 함수를 실행시켜 줄 수 있도록 props를 refs, events, attrs로 나누어 props를 조금 더 구분화할 수 있도록 하였다.export function createElement(type, props, ...children) { props = devideValidProps(props); if (typeof type === "function") { if (type.name === "App") return; if (props &amp;&amp; props.hasOwnProperty("refs")) return new MhElement(type, props, children.flat()); return type(); } return new MhElement(type, props, children.flat());
}
createElement에서는 props를 받아 그대로 사용하는 것이 아닌, element를 만들기 전에 미리 props에 대한 전처리 과정을 거치도록 해주었다.function devideValidProps(props) { if (!props) return null; const prop = { events: {}, attrs: {}, refs: {}, }; Object.entries(props).forEach(([attr, val]) =&gt; { if (propList.includes(attr)) { prop.attrs[attr] = val; } else if (Object.keys(eventHandlers).includes(attr)) { prop.events[eventHandlers[attr]] = val; } else { prop.refs[attr] = val; } }); return prop;
}
prop이라는 객체 리터럴을 만들고, attr에 들어가야 하는 요소, 이벤트로 들어가야 할 요소, refs로 들어가야 하는 요소를 구분하여 다시금 구조화 시킨 객체를 가지도록 해주었다.export const propList = ["key", "placeholder", "className", "id", "value"]; export const eventHandlers = { // Focus events onBlur: "blur", onFocus: "focus", onFocusIn: "focusin", onFocusOut: "focusout",
...
}; 여기서 propList같은 경우는 배열로 만든데 반해서 eventHandlers의 경우에는 addEventListener의 인자로 넣을 때 받는 이벤트의 이름에서 on을 뺀 형태이기 때문에 따로 객체로 만들어서 나중에 DOM 요소를 만드는 과정에서 바로바로 사용할 수 있게 해주었다.if (typeof element.type === "function") element = destructuringFunctionalComponentWithRef(element);
refs의 경우 참조 문제를 해결하고자 type 자체에 function으로 그대로 두었었는데, 이를 fiber로 만들기 전에 ref가 있는지를 판단해서 ref와 함께 커스텀 컴포넌트 함수를 실행해주거나 없으면 함수만 실행시켜주도록 설계했다.export function destructuringFunctionalComponentWithRef(element) { const duplicated = {}; Object.entries(element.props.refs).forEach(([ref, val]) =&gt; { if (typeof val === "function") duplicated[ref] = val(); else duplicated[ref] = val; }); return element.type(duplicated);
}
물론 ref에도 state가 들어갈 가능성이 있으므로 state를 반환하는 함수를 그대로 유지해놓고, 인자로 넘겨주는 과정에서 duplicated라는 객체 리터럴을 따로 만들어 참조 문제를 해결하였으며, 새롭게 만든 객체 리터럴을 인자로 넘겨주었다.안녕하세요 멘토님! 항상 고생 많으십니다ㅎㅎ
오늘 리뷰에서는 어느정도 제가 설계하려던 리액트의 구조가 잡혀 렌더링 과정에 대한 피드백을 받고 싶어 이에 대해서 간략하게 설명을 곁들이고자 합니다.저의 전반적인 렌더링 과정은 createRoot를 통해 지정한 entry point(App)에 대해서 element 생성 후 Root를 싱글톤으로 두고 해당 elements 프로퍼티에 저장
render를 통해 등록해놓은 element에 대해 render함수 실행
- render함수가 실행될 때마다 root에 등록해놓은 element를 하나씩 재귀적으로 탐색하면서 fiber를 만들어냄
- 기존 fiber가 없을 경우, fiberRoot를 따로 생성하여 싱글톤으로 둠
- 리렌더링이 일어날 때마다 새롭게 element로부터 fiber를 생성해내고, 새롭게 생성된 fiber와 기존 fiberRoot를 재귀적으로 비교(재조정 과정)
- 두 fiber가 같을 경우 그대로 유지
- fiber가 다를 경우 새로운 fiber로 교체
- 재조정이 끝난 뒤 반환되는 fiber를 기준으로 DOM element를 만들어냄
- 재귀적으로 탐색하면서 DOM element를 만들고, 해당 element에 맞는 attribute나 event를 붙여주는 작업을 담당
- 반환받은 DOM element를 가지고 web api인 replaceChild를 통해 DOM을 통채로 교체
와 같은 과정을 가지고 있습니다.
제가 설계한 이 일련의 과정에서 혹시나 보완할 부분이나 피드백 주실 부분이 있다면 말씀해주시면 감사하겠습니다!
항상 정성들여 리뷰해주셔서 감사합니다! ☺️]]></description><link>부스트캠프/멤버십/6주차/week6_2일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/week6_2일차 PR.md</guid><pubDate>Tue, 01 Oct 2024 14:28:58 GMT</pubDate></item><item><title><![CDATA[npm]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_self">https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally</a>]]></description><link>부스트캠프/멤버십/6주차/npm.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/npm.md</guid><pubDate>Tue, 01 Oct 2024 06:00:31 GMT</pubDate></item><item><title><![CDATA[MongoDb 설치부터 첫 시작까지]]></title><description><![CDATA[MongoDB는 오픈소스 비관계형 데이터베이스 관리 시스템(DBMS)로, 테이블과 행을 이용하는 관계형 데이터베이스와는 다르게 주로 JSON 형식으로 데이터를 처리하고 저장한다.
관계형 데이터베이스에서 사용되는 언어인 SQL을 사용하지 않기 때문에 NOSQL DBMS의 유형에 속한다.MySQL(IBM 외부 링크)는&nbsp;구조화된 쿼리 언어로 보관된 데이터에 액세스한다.
이 형식에서는 데이터 유형을 표준화하는 방법인 테이블을 활용하여 데이터베이스를 생성하는 데 스키마를 사용하므로, 값을 검색하고 적절히 쿼리하는 기능을 제공한다. 여러 테이블을 데이터 무결성 및 독립성을 유지한 채로 관리할 수 있다는 점에서 성숙도가 높다고 한다. 웹사이트 데이터베이스, 애플리케이션, 상업용 제품 관리를 비롯한 다양한 상황에 유용합니다.MySQL은 고유의 정적인 특성으로 인해, 트랜잭션 데이터를 관리하는 경우와 같이 데이터 무결성 및 격리가 필수적인 상황에서는 MongoDB보다 선호될 수 있습니다. 그러나 MongoDB는 형식이 덜 제한적이고 성능이 우수하므로, 특별히 가용성과 속도를 최우선으로 고려하는 상황에서는 보다 나은 선택이 될 것입니다.터미널에서 Atlas 데이터베이스 배포를 신속하게 프로비저닝하고 관리하려면 Atlas CLI를 설치하면 좋다.brew install mongodb-atlas
]]></description><link>부스트캠프/멤버십/6주차/mongodb-설치부터-첫-시작까지.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/MongoDb 설치부터 첫 시작까지.md</guid><pubDate>Tue, 01 Oct 2024 05:37:45 GMT</pubDate></item><item><title><![CDATA[week6_1일차 PR]]></title><description><![CDATA[
라이브러리 useState 설계 및 구현 function 형태의 state구현
state를 destructuring하는 과정을 파악하고 구조분해 할당에 대한 해결방법 고안
setter함수를 통한 상태 갱신
파이버 생성 단계에서 갱신된 state가져오기 멘토님 리뷰 반영 즉시 실행 함수
useState
기존에 내가 짠 로직을 보자import { Root } from "../dom/DomRoot"; /** * * @param {any} initialState * @returns {[any, function]} */
export function useState(initialState) { let state = initialState; const setState = (function () { const hostRoot = Root(); // 클로저로 state에 해당하는 index를 setState에 묶어두기 return function (value) { state = value; hostRoot.reRender(); }; })(); return [state, setState];
}
내가 처음 짠 useState를 보면 initialState를 state라는 변수에 할당해놓고 반환하며, setState는 즉시 실행 함수를 통해 state의 값을 갱신해준 다음 리렌더링을 시키도록 로직이 짜여져 있다.하지만 이러한 로직의 경우
여러 개의 state관리가 불가능
한 state에 여러번의 setState가 일어날 경우 반복해서 리렌더링
리렌더링한 후에 갱신된 결과를 알지 못함
등의 문제를 가지고 있다.
이러한 문제들을 하나씩 보완해가면서 구현을 완성시키려고 한다.
해당 문제는 state에서 가장 중요하게 생각하는 문제라 해당 문제부터 해결해야 했다. 값이 변해도 리렌더링 과정에서 새롭게 바뀐 값을 렌더링시키지 않는다면 state의 의미 자체가 없기 때문이다.기존 내가 만든 jsx 프로젝트의 jsx 트랜스파일링된 결과를 보면import * as mhReact from "mhreact";
export default function Mainpage() { var _mhReact$useState = mhReact.useState(1), _mhReact$useState2 = _slicedToArray(_mhReact$useState, 2), numbers = _mhReact$useState2[0], setNumbers = _mhReact$useState2[1]; function onClickButton() { console.log("click"); setNumbers(5); } return mhReact.createElement("div", null, mhReact.createElement("h1", null, "\uBBFC\uD615\uC774\uC758 \uD22C\uB450\uB9AC\uC2A4\uD2B8"), mhReact.createElement("input", { type: "text", placeholder: "\uD560 \uC77C\uC744 \uC4F0\uC790" }), mhReact.createElement("button", { onClick: onClickButton }, numbers));
}
이런 식으로 내가 useState를 호출했을 때 나오는 리턴값인 배열을 구조분해할당 하는 모습을 볼 수 있다.
이러한 구조분해 할당을 통해 원시값을 state로 설정해놓은 numbers의 경우 numbers에는 원시값이 들어오게 되고, 원시값은 기존의 값이 변해도 새롭게 할당하지 않는 이상 변화를 알 수 없다는 점이 리렌더링된 element가 바뀐 state를 알 수 없는 문제를 낳았다.rootFiber에 global property를 두고 해당 객체에 states 프로퍼티를 두려고 했는데 rootFiber가 null값이 나왔다.
생각해보니 useState에 fiber를 두게 되면 가장 처음 root를 Render할 시점만 해도 fiber가 만들어지지 않은 상태이기 때문에 UseState안에서 싱글톤 패턴으로 만들어진 rootFiber를 가져오게 되면 null값이 뜰 수밖에 없었다.
그렇다면 이 useState를 어디서 가져와야 할까?root에서 global이라는 프로퍼티를 두고, 여기서 각 state를 인덱스 : 값의 쌍으로 저장해놓으면 전역에서 모든 state들을 관리할 수 있기 때문에 효율적이지 않을까 생각했다.
이렇게 되면 각 컴포넌트에서 만약 사용하는 state의 경우에는 transpiling 과정에서 해당 state를 통해 해당 참조값을 가져올 수 있도록 해야 한다.state = root.global.states[index]
따라서 useState에 이런 식으로 state값을 내보내도록 하려고 했는데, 문제는 해댕하는 인덱스를 키값으로 갖는 value가 갱신이 되었음에도 리렌더링 하는 과정에서 제대로 참조를 못하고 있었다.
이 또한 구조분해할당으로 각 값을 계속 원시값으로 가지게 되서인 것으로 보인다.따라서 나는 state를 함수로 만들어 보았다.import { Root } from "../dom/DomRoot";
import { RootFiber } from "../dom/rootFiber"; /** * * @param {any} initialState * @returns {[any, function]} */
export function useState(initialState) { const root = Root(); if (!root.global.hasOwnProperty("states")) { root.global.states = {}; root.global.statesIdx = 0; } const index = root.global.statesIdx; if (!root.global.states.hasOwnProperty(index)) { root.global.states[index] = initialState; } // state = root.global.states[index] const state = () =&gt; { console.log('루트',root); return root.global.states[index] } const setState = (function () { // 클로저로 state에 해당하는 index를 setState에 묶어두기 const currentIndex = index; return function (value) { if(typeof value === 'function'){ root.global.states[currentIndex] = value(root.global.states[currentIndex]) root.reRender(); } else{ root.global.states[currentIndex] = value; console.log("state Changed", root.global.states[currentIndex]); root.reRender(); } }; })(); root.global.statesIdx++; return [state, setState];
}
함수를 활용하게 될 경우에는 구조분해할당이 이루어지지 않기 때문에 root에 담겨있는 state들을 참조할 수 있다.현재는 함수를 활용하는 방식을 사용하고 있지만 점점 할수록 문제가 하나둘씩 튀어나왔다.&lt;TodoList todoList={todo} /&gt;
...
export default function TodoList({ todoList }) { return ( &lt;ul&gt; {todoList.map((todo) =&gt; ( &lt;li&gt;{todo}&lt;/li&gt; ))} &lt;/ul&gt; );
} todo라는 배열로 된 state를 하나 만들고 이를 리액트처럼 데이터를 넘겨줘서 배열에 대해 map시킨 결과물을 모두 렌더링시키도록 만들었다.export default function TodoList(_ref) { var todoList = _ref.todoList; return mhReact.createElement("ul", null, todoList.map(function (todo) { return mhReact.createElement("li", null, todo); }));
}
이에 대한 트랜스파일링 결과물은 위와 같이 나온다.mhReact.createElement(TodoList, { todoList: todo }));
해당 함수는 다른 커스텀 컴포넌트들과 똑같이 상위에서 createElement pragma가 붙는다. 여기서 내가 넘겨준 todo라는 값이 props로 가는 것을 볼 수 있었다.
따라서 이런 props에 대해서 분기처리를 해주어 태그의 attribute로 갈 수 있는 것들을 제외한 것들은 데이터로 넘겨줄 수 있어야 했다.export function createElement(type, props, ...children) { props = devideValidProps(props); if (typeof type === "function") { if(type.name === "App") return; if (props &amp;&amp; props.hasOwnProperty("refs")) return type(props.refs); return type(); } return new MhElement(type, props, children.flat());
}
처음에 분기처리 해본 곳은 createElement였다. 하지만 여기서 컴포넌트에 대해 함수를 비리 실행시키게 된다면 상태를 사용하는 커스텀 컴포넌트에서는 이미 구조분해 할당이 이루어진 상태로 root의 node들이 할당되기 때문에 상태가 반영될 수 없다. 특히나 map 함수를 도는 곳이 있다면 결국 map을 통해 모든 element가 미리 만들어지니 새롭게 렌더링이 이루어지지 않는다.다음으로는 함수형 컴포넌트의 경우에는 함수 그대로 풀지 않고 두고, 나중에 렌더링을 하는 과정에서 fiber를 만들어낼 때 풀어내면 되지 않을까 생각했다.export function destructuringFunctionalComponentWithRef(element){ const duplicated = {} Object.entries(element.props.refs).forEach(([ref,val]) =&gt; { if(typeof val === "function") duplicated[ref] = val(); }) return element.type(duplicated)
}
이 과정에서도 원래는 element의 ref를 변경했다가 참조되어 있는 객체의 값이 영구히 변했던 문제도 있어 몇시간동안 쩔쩔매다 duplicated라는 객체 리터럴을 통해서 새롭게 복사하여 element를 만들어내도록 했다.아무튼 이 함수는 createFiberFromElement에서 이를 destructuring할 수 있도록 해주었다.export function createFiberFromElement( element, parent = null, index = 0, key = null
) { //앞에서 state 없는 애들은 다 풀어놓음 if (typeof element.type === "function") element = destructuringFunctionalComponentWithRef(element) if (typeof element !== "object") { parent.textNode = element; return null; }
...
이를 통해 functional component를 만났을 경우, 해당 참조값을 미리 destructuring하지 않게 하도록 하기 위해서 렌더링을 할 때마다 풀고 함수를 실행해서 state값을 가져오도록 했다.
하지만 state를 함수형으로 만들면서 여러가지 문제가 발생했다.
가장 큰 문제는 setter함수에 대해서 콜백을 넣게 되면 prev값을 가져올 수 있도록 하려고 했는데, prev값을 콜백에 인자로 넣는 과정에서 state 함수 자체가 들어가게 되므로, 정상적인 갱신이 아닌 함수형으로만 갱신이 되었다.const setState = (function () { // 클로저로 state에 해당하는 index를 setState에 묶어두기 const currentIndex = index; return function (value) { if(typeof value === 'function'){ root.global.states[currentIndex] = value(root.global.states[currentIndex]) root.reRender(); } else{ root.global.states[currentIndex] = value; console.log("state Changed", root.global.states[currentIndex]); root.reRender(); } }; })();
아직 해당 함수의 prev는 제대로 동작하지 않는데, 이를 어떻게 해결해야 할지 계속 고민중에 있다..]]></description><link>부스트캠프/멤버십/6주차/week6_1일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/week6_1일차 PR.md</guid><pubDate>Mon, 30 Sep 2024 14:26:24 GMT</pubDate></item><item><title><![CDATA[멤버십_6주차_주간계획]]></title><description><![CDATA[
useState 설계 및 구현 setter 함수에 대한 배치처리
useState를 통한 상태 변경 보완 navigation 객체 만들기 navigate를 통해 historyAPI를 이용하여 페이지 이동 서버 구성 db 고르기 mysql과 mongoDB 간단하게 express 서버 구성 기본적인 todo에 대한 CRUD 구성
에러 처리 간단한 todo app을 위한 동작 설계 및 구현 카드 추가
카드 삭제
카드 수정(시간이 된다면,,) ]]></description><link>부스트캠프/멤버십/6주차/멤버십_6주차_주간계획.html</link><guid isPermaLink="false">부스트캠프/멤버십/6주차/멤버십_6주차_주간계획.md</guid><pubDate>Mon, 30 Sep 2024 01:40:24 GMT</pubDate></item><item><title><![CDATA[React Fiber]]></title><description><![CDATA[리액트 파이버는 리액트 버전 16버전부터 새롭게 등장한 재조정 알고리즘이다.
해당 알고리즘은 기존의 스택 형식으로 되어있던 리액트의 리렌더링 자체를 바꾼 알고리즘으로, 리액트를 동작하는 근간 자체를 바꾸었다고 보아도 과언이 아니다. 리액트 팀은 16버전까지 사용하던 스택 기반의 재조정 알고리즘을 사용했다.
하지만 이러한 스택 기반 재조정 알고리즘의 경우 치명적인 문제점이 존재했다.<img src="https://blog.kakaocdn.net/dn/bnWwD4/btqGexjfADe/GWh2KY6PKrn3QPr7dXWlk1/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
해당 gif를 보자.
해당 방식은 리액트의 스택 기반의 재조정 알고리즘을 사용해 reconciliation(재조정)을 거치며 애니메이션을 렌더링한 것이다.<br><img src="https://blog.kakaocdn.net/dn/rJmXg/btqGdLWNC9q/tJ0w8uPOaztVyqyIkck80k/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
반면 새로운 재조정 알고리즘은 꽤나 깔끔하게 움직이는 모습을 보인다.
둘 사이에 왜 이런 차이가 났느냐고 하면 우리의 모니터를 생각해보면 된다.
현대 일반적인 모니터는 보통 초당 60회 화면 갱신을 한다. 화면을 한번 갱신하고 다음 화면을 갱신하기까지동안 1/60초, 즉 16ms 정도가 걸린다는 얘기다.
하지만 만약에 렌더링을 하는 시간이 16ms보다 더 걸린다면 어떻게 될까?
렌더링을 하는 시간이 16ms보다 더 걸리게 된다면 ui가 업데이트되는 속도는 모니터의 주사율을 따라갈 수 없어 모니터가 원하는 만큼의 속도로 빠르게 갱신되지 못하고 끊기게 된다. 그렇기 때문에 위처럼 끊기는 듯한 애니메이션이 연출된다.하지만 스택 알고리즘의 문제는, 이러한 작업들에 대해서 중단하거나 중요한 작업에 대해 먼저 수행할 수 없다는 점이었다. 렌더링에 필요한 작업들이 스택에 들어가서 쌓이면 내부적으로 해당 스택을 전부 비울 때까지 동기적으로 작업이 이루어졌는데, 싱글 스레드로 작동하는 자바스크립트로는 이러한 동기 작업을 중단할 수 없었다. 그렇기에 중요한 렌더링 작업들이 후에 비효율적으로 렌더링 작업을 진행하면서 렌더링 문제가 발생하게 되었다.이러한 이유 때문에 메타의 리액트 팀에게 있어서 16ms는 중요 고려사항으로 자리잡은데 비해, 스택 기반의 알고리즘은 이를 따라갈 수 없기 때문에 결국 새롭게 내놓은 것이 파이버 아키텍처를 기반으로 한 재조정 알고리즘이다.그럼 이제 이러한 파이버 아키텍처에 대해 알아보자.React의 내부 동작은 크게 네 가지의 단계로 구분된다.
Render : JSX 트랜스파일러를 통해 React.createElement를 실행하여 React Element 생성
Reconcile(재조정) : 이전에 렌더링된 실제 DOM트리와 새로 렌더링할 React 엘리먼트를 비교하여 변경점 적용
Commit : 재조정 후 새롭게 만들어진 DOM Element를 브라우저 뷰에 보이게 함
Update : props, state등이 변경 시에 해당 컴포넌트와 하위 컴포넌트에 대해 업데이트 반복
리액트는 이처럼 Render 후 Update(Reconcile &amp; Commit) 단계를 반복하면서 렌더링을 수행한다. 이 과정에서 활용되는 개념이 가상 DOM(Virtual DOM), 정확히 말하면 Fiber Node이다.
리액트의 렌더링 과정은 Fiber Node를 제외하고 설명할 수 없다. 렌더링 과정에서 근본적으로 활용되는 가상DOM이 곧 Fiber Node이기 때문이다. 그러니 먼저 Fiber Node에 대해 알아보도록 하자.리액트 파이버는 리액트에서 관리하는 자바스크립트 객체이다. 파이버는 파이버 재조정자(Fiber Reconciler)가 관리하는데, 이 재조정자가 가상 DOM과 실제 DOM을 비교해 변동사항을 수집 및 반영하는 역할을 한다.이 리액트 파이버를 도입하게 된 이유, 즉 리액트 파이버의 목표는 크게 두가지로 볼 수 있다.
반응성 문제 해결(애니메이션, 레이아웃, 사용자 인터랙션 등) 작업을 분할하고 우선순위를 매겨 먼저 필요한 렌더링부터 작업
상대적으로 우선순위가 낮은 작업을 중단 후에 나중에 다시 시작
이전에 했던 작업이 필요없어질 경우 폐기 비동기적으로 동작하여 효율 증대
- 싱글 스레드에서 동작하는 자바스크립트에서 동기적인 작업을 통해 가지는 비효율성을 해소
이러한 문제를 해결하기 위해 리액트 팀은 파이버를 도입했다. 사실상 점점 애플리케이션 자체가 고도화되면서 하나의 인터랙션에도 많은 이벤트와 애니메이션들이 이루어지는 상황에 위와 같은 문제를 해결하는 것은 필수불가결한 일이기도 했다.
그렇다면 Fiber Node의 구성요소에 대해 알아보자.function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode,
) { // Instance this.tag = tag; this.key = key; this.elementType = null; this.type = null; this.stateNode = null; // Fiber this.return = null; this.child = null; this.sibling = null; this.index = 0; this.ref = null; this.refCleanup = null; this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // Effects this.flags = NoFlags; this.subtreeFlags = NoFlags; this.deletions = null; this.lanes = NoLanes; this.childLanes = NoLanes; this.alternate = null; ...
} tag 리액트 파이버는 1:1관계를 가진다. DOM이든 컴포넌트든 무조건 1:1의 관계를 지니며, 이 유형은 태그 속성 내의 this.tag에 저장된다. 이 type에서는 fuctional component, class component 등 우리가 아는 여러 유형들의 노드들에 대해서 번호로 관리한다. type
elementType 어떤 요소인지 타입 구분 key 컴포넌트를 식별하는데 사용되는 고유값이다. 한 배열 안에서 같은 tag를 가진 여러 개의 요소들이 있다면 재조정자는 순서와 일부 요소의 변경에 대해서 같은 태그를 가지고 있기 때문에 비교하기가 어렵다. 따라서 key를 통해 각 컴포넌트를 구별할 수 있도록 하여 불필요한 렌더링을 방지한다. StateNode 해당 객체에 대한 참조를 가지고 있으며 이 속성을 사용하여 파이버와 관련된 상태들에 접근할 수 있다. child, sibling, return Fiber를 기반으로 트리를 만드는 과정에서 필요한 관계가 이 세 가지 속성에 의해 결정된다. 특히 child가 children(여러개)이 아닌 하나의 자식만을 가지고 있다는 점이 특이한데, 그 child는 자식의 첫 번째 요소를 가리킨다. 자식이 첫 번째 요소만 가리키기 때문에, 만약 하나의 부모에 여러 개의 요소가 들어 있다면, 첫 번째 요소만 자식 요소가 되고 마너지는 해당 자식 요소의 형제 요소들이 된다.
return의 경우 상위 항목, 즉 부모 항목에 대한 참조를 나타낸다. index 같은 태그로 된 여러 개의 형제가 있을 경우 이러한 요소들의 순서를 구별하기 위해 숫자로 관리한다 ref, refCleanup 특정 컴포넌트나 DOM요소에 접근할 수 있도록 DOM요소나 인스턴스에 대한 참조
컴포넌트가 언마운트 될 떄 메모리 누수를 방지하기 위해 refCleanup을 통해 불필요한 참조를 제거함 mode FiberNode가 렌더링되는 방식 정의
Concurrent Mode나 StrictMode와 같은 동작 결정 pendingprops 아직 작업에 대해서 처리하지 못한 props를 저장 memoizedProps pendingprops이 렌더링이 완료되면 memoizedProps로 옮겨가며 현재 가지고 있는 props를 표현한다 updateQueue 상태 업데이트, 콜백함수, DOM 업데이트 등 필요한 작업을 담아두는 큐이다. memoizedState 함수 컴포넌트의 훅 목록으로, useState를 비롯한 모든 훅 리스트와 최신 상태 값 Alternate 뒤에서 더 설명할 것으로, 리액트에 존재하는 두 가지 트리 중에서 자신을 포함하지 않은 반대편 트리를 의미함 flags 노드에서 수행하는 작업을 나타내는 비트 플래그
placement(새로운 DOM 노드 삽입), Update(기존 DOM 노드 업데이트), Deletion(DOM 노드 삭제) 등의 플래그를 통해 리렌더링 여부를 결정 subtreeflags 하위 트리 내에서 발생해야 하는 작업을 나타냄 deletions 삭제해야 하는 자식 노드들의 목록 관리
삭제해야 하는 노드들을 미리 배열에 추가해놓고, 일괄로 처리함 lanes Concurrent Mode에서 작업의 우선순위를 투적 childLanes 하위 트리에서 실행할 작업들의 우선순위를 추적 리액트의 virtual DOM 개념은 렌더링 되어 있는 상태의 DOM 요소에 가지고 있는 rootFiber의 정보와 더불어 추가적으로 하나의 rootfiber를 따로 구성한다.
여기서 root의 경우 fiberRoot와 rootFiber로 두 가지의 root가 있다. fiberRoot의 경우 createRoot를 통해 만드는 가장 기본적인 html 템플릿의 루트로, 계속해서 안쪽 요소의 렌더링이 이루어지는 SPA의 특성상 고정적인 head와 body를 가진 root를 두고 안쪽 요소들만 갈아끼우기 위해 rootFiber를 따로 두어 실질적인 렌더링이 반복적으로 이루어지는 root를 따로 구분했다. 이 root에 대한 fiber를 구성하는 과정에서 root fiber를 하나 더 구성하는 것이 react virtual DOM의 핵심이다. 리액트는 기존 렌더링 되어 있는 상태의 DOM의 정보를 가진 fiber와 새롭게 변동사항이 있을 경우에 이를 반영한 버전의 fiber를 따로 가지고 있는 것이다.상태가 변경됐을 경우에, 리액트는 재조정 과정을 통해 현재 렌더링된 DOM 상태를 가진 fiber와 상태 변경이 이루어진 fiber를 비교하여 변경이 이루어져 업데이트가 이루어져야 하는 부분을 찾고 반영한다. 이 일련의 과정은 fiber를 비교하는 과정에서 볼 수 있다.<br>
<img src="https://i.imgur.com/WX5Ji1T.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
위 사진과 같이 rootFiber에서부터 재조정 과정을 시작한다. 파이버는 재조정 과정에서 performUnitOfWork라는 함수를 실행시키는데, beginwork와 completework 함수가 포함되어 있다. 따라서 안쪽의 파이버로 계속해서 들어가면서 beginwork가 실행되고, 끝까지 들어갔다가 돌아오는 과정에서 return받으면 completework를 실행하며 해당 파이버에 대한 작업을 종료한다.<br>
<img src="https://i.imgur.com/bMKqP19.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
아까 말했던 말을 다시금 생각해보자.
상태가 변경됐을 경우에, 리액트는 재조정 과정을 통해 현재 렌더링된 DOM 상태를 가진 fiber와 상태 변경이 이루어진 fiber를 비교하여 변경이 이루어져 업데이트가 이루어져야 하는 부분을 찾고 반영한다
그렇다면 이 상태변경이 이루어진 fiber는 어디에 할당되어 있는가? 바로 현재 렌더링 되어 있는 DOM 트리, 즉 fiberRootNode의 current 가리키고 있는 rootFiber의 alternate 프로퍼티이다.rootFiber는 current가 가리키고 있는 rootFiber와는 별개로 현재 렌더링된 rootFiber의 alternate props로 다른 rootFiber를 가지고 있다. alternate에 할당된 rootFiber는 변동사항이 반영된 rootFiber이다.
이 두 fiber는 alternate를 통해 서로에 대해 접근하며 변동사항을 반영하고 업데이트된 DOM tree를 만들어낸다. 이렇게 만들어지는 DOM tree는 workInProgress 트리라고 한다. 다시금 강조하지만 workInProgress 트리는 current가 가리키고 있지 않은 alternate의 rootFiber에서 만들어진다.export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber { let workInProgress = current.alternate; if (workInProgress === null) { workInProgress = createFiber( current.tag, pendingProps, current.key, current.mode, ); workInProgress.elementType = current.elementType; workInProgress.type = current.type; workInProgress.stateNode = current.stateNode; if (__DEV__) { workInProgress._debugID = current._debugID; workInProgress._debugSource = current._debugSource; workInProgress._debugOwner = current._debugOwner; workInProgress._debugHookTypes = current._debugHookTypes; } workInProgress.alternate = current; current.alternate = workInProgress; } else { workInProgress.pendingProps = pendingProps; workInProgress.type = current.type; workInProgress.subtreeFlags = NoFlags; workInProgress.deletions = null; if (enableProfilerTimer) { workInProgress.actualDuration = 0; workInProgress.actualStartTime = -1; } } workInProgress.flags = current.flags &amp; StaticMask; workInProgress.childLanes = current.childLanes; workInProgress.lanes = current.lanes; workInProgress.child = current.child; workInProgress.memoizedProps = current.memoizedProps; workInProgress.memoizedState = current.memoizedState; workInProgress.updateQueue = current.updateQueue; const currentDependencies = current.dependencies; workInProgress.dependencies = currentDependencies === null ? null : { lanes: currentDependencies.lanes, firstContext: currentDependencies.firstContext, }; workInProgress.sibling = current.sibling; workInProgress.index = current.index; workInProgress.ref = current.ref; if (enableProfilerTimer) { workInProgress.selfBaseDuration = current.selfBaseDuration; workInProgress.treeBaseDuration = current.treeBaseDuration; } if (__DEV__) { workInProgress._debugNeedsRemount = current._debugNeedsRemount; switch (workInProgress.tag) { case IndeterminateComponent: case FunctionComponent: case SimpleMemoComponent: workInProgress.type = resolveFunctionForHotReloading(current.type); break; case ClassComponent: workInProgress.type = resolveClassForHotReloading(current.type); break; case ForwardRef: workInProgress.type = resolveForwardRefForHotReloading(current.type); break; default: break; } } return workInProgress;
}
dfs(깊이우선탐색) 방식을 활용하여 새롭게 변동사항이 반영된 fiber와 기존의 fiber를 비교한 뒤, 바뀐 부분을 찾고 반영하고, 마지막에 root의 DOM 요소를 리턴하게 되면 새롭게 바꾸어야 할 부분을 반영한 DOM element를 가지게 된다.변경사항이 모두 반영된 rootFiber의 DOM Element가 모두 만들어지고 나면, fiberRoot, 즉 createRoot로 만든 root 컨테이너 파이버의 current가 alternate의 rootFiber를 가리키게 한다. 해당 파이버는 새롭게 반영 및 DOM element 생성이 완료된 fiber이다. current의 포인터만을 alternate를 통해 반대편의 만들어진 rootFiber를 가리키도록 하면서 대기 없이 바로 업데이트가 반영된 DOM 트리를 갈아끼우는 것이다.<br><img src="https://d2.naver.com/content/images/2023/07/14.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이처럼 상태의 변경이나 다른 렌더링에 영향을 끼치는 상태가 변경이 됐을 경우에 재조정을 통해서 fiber를 업데이트하고 이를 DOM 요소에 반영하는 과정을 계속해서 반복하는 과정에서 rootFiber는 기존의 root container인 fiberRoot를 알아야 할 필요성이 있다. 자신이 해당 fiberRoot 안에서 렌더링 되어야 할 요소들의 정보를 담고 있기 때문이다.전체적인 두 트리가 공존하면서 비교되고 만들어진 workInProgressfiber를 한 그림에 표현하면 아래와 같이 나오게 된다.<br>
<img src="https://i.imgur.com/1EfuMA3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">위에서 알아본 Fiber Node와 렌더링 방식에 대한 정보는 알았지만 막상 이 객체가 어떤 로직으로 렌더링을 수행하는 지는 아직도 감이 잡히지 않을 것이다.
따라서 우리는 소스 코드를 따라서 대략적인 첫 렌더링 과정을 알아볼 필요가 있다.
리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다
가장 처음 엔트리 포인트를 만드는 과정부터 첫 페이지가 만들어지기까지의 과정을 알아보자.import { createRoot } from 'react-dom/client'; const root = createRoot(document.getElementById('root'));
root.render(&lt;App /&gt;);
react-dom의 공식문서에서는 createRoot라는 api를 통해 React에 의해 관리되는 UI의 root, 즉 React 컴포넌트를 표시하는 루트를 생성할 수 있다고 한다. 코드를 보면 root라는 id를 가지는 element 자체를 루트로 삼고 여기에 React 컴포넌트들을 렌더링시키기 위해 지정하는 것으로 보인다.
React는 SPA(Single-Page-Application)이기 때문에 여러 페이지를 전환하는 것이 아닌, 하나의 페이지에서 모든 서비스 로직이 이루어지는 형태이며, 페이지 또한 새롭게 페이지 전환을 하는 방식이 아니다 보니까 하나의 Index.html만 두고 안쪽 요소만 바꾸어 가면서 렌더링을 하는 방식을 사용한다. 따라서 React가 렌더링할 공간을 createRoot를 통해 만들고, createFiberRoot()를 호출하여 고유한 FiberRootNode를 생성한다. // Cyclic construction. This cheats the type system right now because
// stateNode is any.
const root = (new FiberRootNode(containerInfo, tag, hydrate): any); if (enableSuspenseCallback) { root.hydrationCallbacks = hydrationCallbacks; } const uninitializedFiber = createHostRootFiber( tag, isStrictMode, concurrentUpdatesByDefaultOverride,
);
root.current = uninitializedFiber; uninitializedFiber.stateNode = root; FiberRootNode 생성자로 만들어진 FiberRootNode는 컨테이너와 태그, 하이드레이션에 대한 정보를 가지고 있다.하지만 FiberRootNode가 만들어지고 createHostRootFiber()를 통해 추가적으로 HostRootFiber 객체를 만들어 root(FiberRoot)의 current에 해당 fiber node를 할당하고, 추가적으로 uninitializedFiber.stateNode 라는 곳에 root를 다시 참조하도록 하면서 순환 참조 구조를 이루게 하는 모습을 볼 수 있다.<br><img src="https://i.imgur.com/t5Nqgnq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">root.render(&lt;SimpleComp /&gt;); 만들어지는 root에 대해서 render 메서드를 실행시키는 과정에서 JSX로 쓰여진 커스텀 컴포넌트는 babel의 트랜스파일러를 통해서 함수로 바뀌게 된다.root.render(React.createElement(SimpleComp, null)); 트랜스파일된 js에서는 pragma로 createElement가 설정되어 있기 때문에createElement를 호출시켜 React Element라는 일반 객체를 만들어 반환하는 함수를 render함수에 콜백으로 넣는 듯한 형태를 띈다. Pragma
트랜스파일러나 컴파일러가 특정 코드를 해석하거나 처리할 때 특별한 지시를 내리기 위해 사용하는 주석 형식의 지시문
// Transpiled &lt;SimpleComp /&gt;
export function SimpleComp() { const [name, setName] = React.useState("Alice"); return React.createElement( "div", null, React.createElement("h1", null, "Hello react!"), React.createElement( "section", null, React.createElement("p", null, `Name : ${name}`), React.createElement( "button", { onClick: (e) =&gt; setName(name === "Samuel" ? "Alice" : "Samuel") }, "Click me" ) ) );
}
참고로 pragma는 jsx에서 모든 dom 요소들에 대해 호출하는 형식으로 되어있기 때문에 계층 구조를 알 수 있다.
아무튼 함수형 커스텀 컴포넌트를 render함수가 콜백으로 가지고 있는 형태이다. 이 createElement를 통해 만들어지는 객체를 render함수를 통해 root에 넣어주는 작업이 수행된다.export function createElement(type, config, children) { let propName; // ..... props[propName] = config[propName]; // props 세팅 key = '' + config.key; // key 세팅 props.children = children; // childrent 세팅 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );
}
createElement는 이런 형식으로 되어 있는데, ReactElement를 반환하는 함수이다.
일반 html element의 경우에는 jsx 트랜스파일링 과정에서
type: html element 이름
key : element의 key
children: 하위 요소
를 가지게 되는데 , SingleComp와 같은 커스텀 컴포넌트와 같은 경우에는 위에서 봤다시피 함수형으로 되어있기 때문에 createElement 안에 SingleComp라는 함수를 반환하는 함수가 type에 들어가게 되고, render api를 통해 root에 SingleComp의 Element를 가지게 된다.
앞에서 말했다시피 첫 렌더링 단계에서는 root.render(&lt;SingleComp/&gt;)를 실행하면 SimpleComp 라는 React Element만 생성하도록 한 뒤에 재조정 단계로 넘어간다.Reconcilation 단계에서는 아까 만들었던 FiberRootNode에 대해서 performUnitOfWork함수를 실행시킨다.
위의 코드에서도 볼 수 있다시피 현재 FiberRoot는 uninitialized된 상태이다
// [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1836-L1862)
function performUnitOfWork(unitOfWork: Fiber): void { // The current, flushed, state of this fiber is the alternate. Ideally // nothing should rely on this, but relying on it here means that we don't // need an additional field on the work in progress. const current = unitOfWork.alternate; setCurrentDebugFiberInDEV(unitOfWork); let next; if (enableProfilerTimer &amp;&amp; (unitOfWork.mode &amp; ProfileMode) !== NoMode) { startProfilerTimer(unitOfWork); next = beginWork(current, unitOfWork, subtreeRenderLanes); stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true); } else { next = beginWork(current, unitOfWork, subtreeRenderLanes); } resetCurrentDebugFiberInDEV(); unitOfWork.memoizedProps = unitOfWork.pendingProps; if (next === null) { // If this doesn't spawn new work, complete the current work. completeUnitOfWork(unitOfWork); } else { workInProgress = next; } ReactCurrentOwner.current = null;
}
하지만 가장 먼저 나오는 것은 current 변수에 unitOfWork.alternate 에 할당하는 일인데, 아까 Fiber node의 alternate는 순환참조하고 있는 fiber에서 반대편의 DOM을 가리킨다고 이야기 했던 것을 기억할 것이다.따라서 current 변수에 UnitOfWork(변경사항이 들어가있는 Fiber)의 alternate를 할당한 이유는 내가 현재 렌더링된 DOM이 아닌 반대편의 변경 사항을 반영한 DOM을 만든 다음에 이를 current로 교체하여 새로운 current로 만들기 위해 현재 작업할 Fiber 노드의 이전 작업 상태를 가져오는 것임을 알 수 있다.다음 코드를 보면 해당 함수에서 beginWork와 completeUnitOfWork 함수가 반복적으로 실행되고 있는 구조임을 알 수 있다.// [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3828-L3829)
function beginWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes,
): Fiber | null {
... switch (workInProgress.tag) { ... case HostRoot: return updateHostRoot(current, workInProgress, renderLanes);
...
}
beginWork는 fiber와 workInProgress라는 다른 fiber를 받는데, next = beginWork(current, unitOfWork, subtreeRenderLanes);
여기서 보면 인자로 받았던 current와 unitOfWork를 넣어주어 두 Fiber를 비교한 후에 변경사항을 반영한 DOM Element를 받는다여기서
current - 현재 렌더링된 DOM의 반대 DOM 트리의 파이버(곧 현재가 될 것이기 때문에 current에 할당)
unitOfWork - 변경사항이 적용된 파이버
라는 점은 계속 기억해두자! 아니면 헷갈려서 나처럼 계속 헤맨다.
앞에서 말했듯이 react는 current라는 파이버 트리 workInProgress라는 파이버 트리, 두 가지 트리를 두고 계속해서 스위칭해가며 한쪽에서는 새롭게 변동사항이 반영된 workInProgress 트리를 만들고, 그 동안엔 current 트리를 보여주다가 workInProgress의 DOM이 모두 완성되면 이를 current로 바꿔주기 때문에 workInProgress Tree와 current Tree에 대해서 계속해서 인지하는 것이 중요하다.아무튼 beginWork에서 해당 파이버가 HostRoot, 즉 렌더링 되어야 하는 요소들의 루트라면 update를 진행한다.// [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1278-L1287)
function updateHostRoot(current, workInProgress, renderLanes) { pushHostRootContext(workInProgress); if (current === null) { throw new Error('Should have a current fiber. This is a bug in React.'); } const nextProps = workInProgress.pendingProps; const prevState = workInProgress.memoizedState; const prevChildren = prevState.element; cloneUpdateQueue(current, workInProgress); processUpdateQueue(workInProgress, nextProps, null, renderLanes);
...
}
update과정에서 변동사항을 가진 workInProgress 트리에서 필요한 pendingprops와 memoizedState를 가져오고, 업데이트를 진행한다.
여기서 updateQueue가 일어나는 이유는 여러 개의 상태가 업데이트 될 경우에 이러한 작업들을 계속 하나씩 처리하는 것보다 배치 처리하는 것이 효율적이기 때문에 queue를 활용하여 처리한다.beginwork에서 이렇게 분기처리를 해서 각각 요소들에 대해서 알맞은 처리를 해주는 과정을 거치고, 기존 fiber 또한 계층 구조로 이루어져 있기 때문에 자식이 있다면 자식으로, 형제가 있다면 형제 fiber node로 옮겨가면서 똑같이 beginwork를 실행해준다. 이 과정에서 재귀적으로 호출이 일어나며, return 받는 시기는 해당 fiber node가 작업을 마치고 completeUnitOfWork를 실행했을 때이다.
beginWork는 Fiber 트리의 하위로 내려가면서 자식 노드부터 작업을 처리
자식 노드의 작업이 끝나면 그 Fiber에서 다시 completeUnitOfWork가 실행되어, 작업이 상위로 완료되며 반환
이 과정에서 재귀적 호출이나 순환적 처리를 통해, 트리의 모든 노드에 대한 작업이 차례차례 처리
function updateHostRoot(){ ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1306-L1307) const nextChildren = nextState.element; if (supportsHydration &amp;&amp; prevState.isDehydrated) { ... } else { // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1397) // Root is not dehydrated. Either this is a client-only root, or it // already hydrated. resetHydrationState(); if (nextChildren === prevChildren) { return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes); } reconcileChildren(current, workInProgress, nextChildren, renderLanes); }
시작의 beginWork에서 HostRoot를 발견하게 되면 fiber는 기존의 fiber tree를 가지고 와서 새롭게 반영될 사항들의 정보를 가지고 있는 fiber node 객체와 기존 객체를 함께 비교하여 변동된 사항을 반영하고, 조정하는 과정을 reconcileChildren이라는 함수를 통해 반영한다. 만약 바꿀 변동사항이 없다면 그대로 둔다. // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L288)
export function reconcileChildren( current: Fiber | null, workInProgress: Fiber, nextChildren: any, renderLanes: Lanes,
) { if (current === null) { // If this is a fresh new component that hasn't been rendered yet, we // won't update its child set by applying minimal side-effects. Instead, // we will add them all to the child before it gets rendered. That means // we can optimize this reconciliation pass by not tracking side-effects. workInProgress.child = mountChildFibers( workInProgress, null, nextChildren, renderLanes, ); } else { // If the current child is the same as the work in progress, it means that // we haven't yet started any work on these children. Therefore, we use // the clone algorithm to create a copy of all the current children. // If we had any progressed work already, that is invalid at this point so // let's throw it out. workInProgress.child = reconcileChildFibers( workInProgress, current.child, nextChildren, renderLanes, ); }
} --&gt; // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1245-L1279)
// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any, lanes: Lanes,
): Fiber | null {
.... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1269) // Handle object types if (typeof newChild === 'object' &amp;&amp; newChild !== null) { switch (newChild.$$typeof) { case REACT_ELEMENT_TYPE: return placeSingleChild( reconcileSingleElement( returnFiber, currentFirstChild, newChild, lanes, ), );
...
} --&gt; // [Link](https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactChildFiber.new.js#L1129)
function reconcileSingleElement( returnFiber: Fiber, currentFirstChild: Fiber | null, element: ReactElement, lanes: Lanes, ): Fiber { const key = element.key; let child = currentFirstChild; while (child !== null) { ... } if (element.type === REACT_FRAGMENT_TYPE) { const created = createFiberFromFragment( element.props.children, returnFiber.mode, lanes, element.key, ); created.return = returnFiber; return created; } else { // [[Link]](https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactChildFiber.new.js#L1199) const created = createFiberFromElement(element, returnFiber.mode, lanes); created.ref = coerceRef(returnFiber, currentFirstChild, element); created.return = returnFiber; return created; } } 재조정 과정은 reconcileChildren -&gt; reconcileChildFibers -&gt; reconcileSingleElement이라는 일련의 과정을 통해 모든 Fiber에 대해 비교하고 재조정하는 과정을 거친다.reconcileChildren의 경우는 기존 노드와 비교하여 변경 사항을 감지하고, 새롭게 Fiber 트리를 만들거나 갱신하는 등의 작업을 수행한다. 이 과정에서 내부에서 호출하는 reconcileChildFibers를 통해 자식 Fiber들을 비교하여 어떤 노드를 갱신, 추가 등의 작업을 할지 결정하고, reconcileSingleElement를 통해 단일 자식 요소를 비교하여 갱신이 됐을 경우 새로운 fiber를 생성하거나 갱신이 필요없는 경우 기존의 fiber를 재활용한다. 이 기존 업데이트가 없는 노드의 fiber에 대해서 재활용하는 과정을 통해 리액트는 작업을 효율적으로 관리할 수 있었다.// [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L849)
function completeWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes,
): Fiber | null { ... switch (workInProgress.tag) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L959) case HostComponent: { ... // 렌더링된 FiberNode가 있거나 `stateNode`에 DOM 인스턴스가 생성되었다면 if (current !== null &amp;&amp; workInProgress.stateNode != null) { // Update 로직 updateHostComponent( current, workInProgress, type, newProps, rootContainerInstance, ); ... } else { // 없다면 DOM 인스턴스 생성 ... const instance = createInstance( type, newProps, rootContainerInstance, currentHostContext, workInProgress, ); appendAllChildren(instance, workInProgress, false, false); workInProgress.stateNode = instance; ... return null; }
작업이 계속해서 깊이 우선 탐색으로 진행되면서 끝에 다다를 때면 다시 completeWork를 실행시키고 return시킨다. 예시로 든 최초 렌더링의 경우에는&nbsp;createInstance()를 호출하여 DOM 인스턴스를 생성한다.createInstance()&nbsp;내부에서는&nbsp;react-dom&nbsp;렌더러에서&nbsp;document.createElement web api를 이용하여&nbsp;html element 인스턴스를 생성한다. 그리고&nbsp;appendAllChildren()에서 child, 즉&nbsp;FiberNode.stateNode를 생성된 DOM 인스턴스에 부착한다. 다시 말해&nbsp;completeWork는 FiberNode로부터 DOM 인스턴스를 완성시키는 과정이다. 마지막에 모든 reconcile 작업이 완료되었을 때는 결국 갱신된 root fiber를 기반으로 재조정되는 하나의 루트 element가 만들어진다.Reconcile 단계가 끝나면 DOM을 교체하기 위한 모든 준비는 끝이 났다. DOM element들도 모두 만들어진 상태이며, 해당 요소들은 갱신된 정보들을 기준으로 만들어진 요소들이다.
이 떄, RootComplete status가 되며 Commit 단계로 돌입하여 브라우저에 변경된 사항들이 보이도록 그리는 것이다.function finishConcurrentRender(root, exitStatus, lanes) { switch (exitStatus) { ... case RootCompleted: { // The work completed. Ready to commit. commitRoot( root, workInProgressRootRecoverableErrors, workInProgressTransitions, ); break; } default: { throw new Error('Unknown root exit status.'); } }
} function commitRoot( root: FiberRoot, recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;, transitions: Array&lt;Transition&gt; | null,
) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1976) commitRootImpl( root, recoverableErrors, transitions, previousUpdateLanePriority, ); ...
} function commitRootImpl( root: FiberRoot, recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;, transitions: Array&lt;Transition&gt; | null, renderPriorityLevel: EventPriority,
) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2163) commitMutationEffects(root, finishedWork, lanes);
} export function commitMutationEffects( root: FiberRoot, finishedWork: Fiber, committedLanes: Lanes,
) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L2045) commitMutationEffectsOnFiber(finishedWork, root, committedLanes); ...
}
finishConcurrentRender -&gt; CommitRoot -&gt; commitRootImpl -&gt; commitMutationEffects -&gt; commitMutationEffectsOnFiber의 순서대로 안쪽으로 들어가면서 함수가 호출되고, 본격적으로 변경 내용을 커밋하기 시작한다.function commitMutationEffectsOnFiber( finishedWork: Fiber, root: FiberRoot, lanes: Lanes,
) { ... // The effect flag should be checked *after* we refine the type of fiber, // because the fiber tag is more specific. An exception is any flag related // to reconcilation, because those can be set on all fiber types. switch (finishedWork.tag) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L2254-L2286) case HostRoot: { recursivelyTraverseMutationEffects(root, finishedWork, lanes); commitReconciliationEffects(finishedWork); ...
}
commitMutationEffectsOnFiber에서는 가장 먼저 들어가는 요소가 fiberRoot가 될 것이므로 recursivelyTraverseMutationEffects를 통해 재귀적으로commitMutationEffectsOnFiber를 DFS 방식으로 호출하여 요소들을 만들어낸다function recursivelyTraverseMutationEffects( root: FiberRoot, parentFiber: Fiber, lanes: Lanes,
) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L2071-L2079) const prevDebugFiber = getCurrentDebugFiberInDEV(); if (parentFiber.subtreeFlags &amp; MutationMask) { let child = parentFiber.child; while (child !== null) { setCurrentDebugFiberInDEV(child); commitMutationEffectsOnFiber(child, root, lanes); child = child.sibling; } } setCurrentDebugFiberInDEV(prevDebugFiber);
}
더이상 child와 sibling을 돌고 난 후 child가 없어 탐색할 것들이 없어졌을 경우에는 다음으로 넘어가 commitReconciliationEffects()를 실행한다function commitReconciliationEffects(finishedWork: Fiber) { ... commitPlacement(finishedWork); ...
} function commitPlacement(finishedWork: Fiber): void { ... // Recursively insert all host nodes into the parent. const parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together. switch (parentFiber.tag) { ... case HostRoot: case HostPortal: { const parent: Container = parentFiber.stateNode.containerInfo; const before = getHostSibling(finishedWork); insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent); break; } ...
}
finishedWork 인자에는 작업이 끝난 Fiber가 들어오며, 이를 commitPlacement()를 통해서 tag의 분기문 중 HostRoot로 가게 되고insertOrAppendPlacementNodeIntoContainer()를 실행시킨다.function insertOrAppendPlacementNodeIntoContainer( node: Fiber, before: ?Instance, parent: Container,
): void { const {tag} = node; const isHost = tag === HostComponent || tag === HostText; if (isHost) { const stateNode = node.stateNode; if (before) { insertInContainerBefore(parent, stateNode, before); } else { appendChildToContainer(parent, stateNode); } } else if (tag === HostPortal) { // If the insertion itself is a portal, then we don't want to traverse // down its children. Instead, we'll get insertions from each child in // the portal directly. } else { const child = node.child; if (child !== null) { insertOrAppendPlacementNodeIntoContainer(child, before, parent); let sibling = child.sibling; while (sibling !== null) { insertOrAppendPlacementNodeIntoContainer(sibling, before, parent); sibling = sibling.sibling; } } }
}
insertOrAppendPlacementNodeIntoContainer를 통해 만들어진 element가 fiber 정보를 가지고 알맞은 위치에 들어갈 수 있도록 DOM을 구성한다.
완성된 DOM 트리의 경우에는 한번에 커밋되면서 실제 브라우저 상에서 변경 사항이 반영된 DOM 구성요소들이 그려져 볼 수 있는 상태가 비로소 된다.function commitRootImpl( root: FiberRoot, recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;, transitions: Array&lt;Transition&gt; | null, renderPriorityLevel: EventPriority,
) { ... // The work-in-progress tree is now the current tree. This must come after // the mutation phase, so that the previous tree is still current during // componentWillUnmount, but before the layout phase, so that the finished // work is current during componentDidMount/Update. root.current = finishedWork;
}
commit이 모두 끝나면 root의 current를 finishedWork로 갱신하여 최신 변경사항을 반영한 rootFiber를 재할당시키면서 최신화시킨다.update와 다른 hook과 같은 경우는 너무 길어져서 다음 화에 계속..<br>
<img src="https://i.imgur.com/MtyQSoN.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">react fiber의 존재는 알고 있었지만, 이번에 이렇게 소스코드를 뜯어가면서 딥다이브하고 어떤 식으로 동작하는지 알게 되면서 정말 많은 것들을 알게된 것 같다. 지피지기면 백전백승이라고, 리액트의 원리를 알게 되니 보다 hook과 같은 요소들을 보다 더 잘 쓸 수 있는 용기마저 생긴다..! 아무튼 이런 dfs와 방식으로 학습하는 것을 좋아하는 편이긴 한데, 이거 하나 쓰는데 지금 이해하고 쓰고 고치고를 반복하느라 하루 이상 쓴 것 같다. 적당히 밸런스를 맞춰 학습해야 할 필요성 또한 깨닫게 된 좋은 시간이었을지도...<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.cnblogs.com/huayang1995/p/15910753.html" target="_self">https://www.cnblogs.com/huayang1995/p/15910753.html</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://d2.naver.com/helloworld/2690975" target="_self">https://d2.naver.com/helloworld/2690975</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://m.blog.naver.com/dlaxodud2388/223195103660" target="_self">https://m.blog.naver.com/dlaxodud2388/223195103660</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;t=1463s" target="_self">https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;t=1463s</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=0ympFIwQFJw" target="_self">https://www.youtube.com/watch?v=0ympFIwQFJw</a>]]></description><link>부스트캠프/멤버십/5주차/react-fiber.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/React Fiber.md</guid><pubDate>Sun, 29 Sep 2024 12:29:56 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bnWwD4/btqGexjfADe/GWh2KY6PKrn3QPr7dXWlk1/img.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bnWwD4/btqGexjfADe/GWh2KY6PKrn3QPr7dXWlk1/img.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[마스터클래스_5주차]]></title><description><![CDATA[SPA와 MPA
Multipage -&gt;
SPA란?
상태관리 -&gt; 어떠한 상태에 의해서 화면의 변경을 모니터링 뷰 모델 바인딩
화면을 어떻게 작게 나눌까, 재사용할까.
변동사항을 탐지하고 리렌더링
변경사항을 탐지하기 위해서는 변경사항과 기존을 비교
diff단계까지도 실제 DOM에서는 따로 갱신이 없고 virtual DOM에서 최소한의 변동 사항을 반영해서 바꿈 -&gt; DOM의 접근을 최소화함
가상DOM -&gt; DOM을 흉내낸 최소한의 객체로 트리구조로 되어있음setCount -&gt; count값 바꾸는 함수
useState로 정의된 값이 count고 count가 바뀌게 되면 상태관리에서 useState에서 setStat가 호출됐을 때 notify가 호출되고 이를 감지하여 바뀌는 형태JSX를 변환하는 과정에서 파싱(토크나이징 -&gt; 렉서 -&gt; 파서)createElement 함수의 역할
DOM노드 생성 및 관리 주어진 태그, 속성, 자식 요소들을 조합하여 새로운 DOM 노드 또는 가상 DOM 노드 생성 컴포넌트 구조화 다양한 컴포넌트를 일관된 인터페이스로 제공 노드 타입 확인
속성 처리
자식 노드 처리
vitual DOM 객체 반환
동기적으로 동작할 경우 싱글 스레드인 nodejs가 동기적으로 하는 과정에서 끊기는 현상이 발생할 수 있음
작업을 분할해서 다음 작업이 들어올 여유를 줌.
setTimeout을 통해 비동기적으로 처리
리액트는 바닐라보다 느리다
동일한 입력이 오면 또 동일한 Virtual DOM 객체를 반환?
절대 변경이 안되는 노드도 가상 DOM에 있어야 하나?
list의 변화를 쉽게 파악하는 방법 리액트에서는 Virtual DOM 용어를 자체를 잘 안씀
React native도 있고 여러 가지가 있기 때문에 DOM이라는 표현을 자제하고 있음
DOM 조작의 비용 프론트에서 DOM 조작의 비용이 가장 느림
브라우저의 렌더링 엔진에서 많은 리소스를 소비
페이지 전체를 새로 그리는 데 많은 시간이 소요될 수 있음(첫 페이지에 대한 로딩 문제) 두 개의 Virtual DOM 트리 간의 변화를 찾는 과정에서 노드의 타입과 속성을 비교
그 결과 React는 DOM을 효율적으로 갱신
노드 타입 비교 노드의 타입이 다르면 해당 노드를 완전히 교체함 속성(props) 비교 노드의 타입이 동일한 경우, 그 노드의 속성을 비교하여 달라진 부분만 수정함 자식 노드 비교 자식 노드를 탐색?
리스트 노드를 쉽게 비교하는 방법? <img src="https://i.imgur.com/GfNGz2B.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
새로운 Virtual DOM 생성
기존 Vitual DOM과 비교
차이점을 기반으로 실제 DOM 업데이트 DOM API를 통한 업데이트 현재 Virtual DOM을 새로운 DOM으로 교체 가상DOM을 쓰는 이유 -&gt; DOM조작의 최소화 비교와 동시에 업데이트
방법: 변경 사항을 감지할 때마다 실제 DOM을 업데이트
장점 : 간단하고 구현이 쉬우며 바로 업데이트되므로 빠르게 반응하는 것처럼 보임
변경 사항이 많으면 성능 저하
배치 처리
변경 사항을 모아서 한번에 실제 DOM에 반영
DOM 조작 DOM 조작을 최소화할 수 있어 성능 향상
리플로우와 리페인트를 줄여 브라우정 성능에 유리 <br><img src="https://i.imgur.com/8g3RCJE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">컴파일 단계에서 상태가 변경될 때 어떤 DOM 조작이 필요할지 미리 결정하고, 그에 맞춰 최적화된 JS 코드를 생성
순수 함수(pure-function)
불변성(immutability)
고차함수(higher-order function) 함수를 인자로 받거나 함수를 반환 뷰 간의 의존을 하게 되면 서로 계속해서 상태 관리를 해야 하기 때문에 얽히게 되는 구조가 될 수밖에 없음const target = { message: "Hello, World!"
}; const handler = { get: function(target, prop) { return prop in target ? target[prop] : "Property does not exist"; }, set: function(target, prop, value) { console.log(`Setting value ${value} to ${prop}`); target[prop] = value; }
}; const proxy = new Proxy(target, handler); // 접근 시
console.log(proxy.message); // "Hello, World!"
console.log(proxy.nonexistent); // "Property does not exist" // 값 설정 시
proxy.message = "Hello, Proxy!"; // "Setting value Hello, Proxy! to message"
console.log(proxy.message); // "Hello, Proxy!"
나 -&gt; target가 관계가 마치 중간 매개체(proxy)를 거쳐 target으로 이동하는 듯함사용자가 입력한 값을 모델의 속성에 반영
-&gt; 모델이 바뀔 경우 뷰는 리렌더링
-&gt; 뷰가 바뀔 경우 렌더링하는 코드를 proxy를 활용해서
target이라는 부분이 모델이 될 수도 있고 뷰를Object.defineProperty
배열이나 요청과 응답 사이의 과정 -&gt; 미들웨어
express 미들웨어의 특징
미들웨어의 순서를 req,res,next라는 표현을 통해 지정할 수 있음.
어떤 주소로 들어왔는지에 대해 제공하는 리소스 -&gt; api
api들을 조금 더 의미있게 정의할 필요가 있음
api의 구성은 reasonable하게 짜야한다
api ?
rest-ful하게 표현할 수 있는명확한 정의
서버측의 동작을 http method로 표현 &amp; resources(Path)
method의 이름과 resouce의 이름을 보았을 떄 어떤 응답이 나올지에 대해 시각적으로 충분히 이해할 수 있는 api가 restful한 api임.
정반대 -&gt; graphQL(추상화 해서 보냄)
http 메서드의 내용과 요청 작업의 주소 부분을 봤을 때 명시적으로 원하는 작업이 무엇인지를 잘 표현하자!db선택에서의 자유도
RDB의 대표주자가 아닌 다른 db의 대표주자들 써보기
NOSQL, DynamoDB
간단한 db의 경우 서버리스로]]></description><link>부스트캠프/멤버십/5주차/마스터클래스_5주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/마스터클래스_5주차.md</guid><pubDate>Fri, 27 Sep 2024 09:38:06 GMT</pubDate><enclosure url="https://i.imgur.com/GfNGz2B.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/GfNGz2B.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week5_4일차 PR]]></title><description><![CDATA[
라이브러리 diff 알고리즘 구현
useState 오늘도 Virtual DOM과 React Fiber..
useState의 경우 해당 상태를 기존의 Root Fiber에 구독하고 상태 업데이트가 일어날 경우 Root부터 Fiber를 구성하여(원래의 리액트는 기존의 fiber를 재사용한다. 나의 경우는 새롭게 Fiber를 만드는 것으로 구상했다) 재구성 과정을 거친 다음에 새롭게 변경된 DOM tree로 교체할 수 있도록 설계를 했었다.나는 바뀐 상태를 다시금 createElement를 통해 구성 요소들을 루트부터 fiber로 만들고 reRender함수를 실행시킴으로써 새롭게 바뀐 것들이 반영되어 렌더링되도록 하고 싶었다. 하지만 새롭게 createElement하는 부분은 어떻게 할 것인가? 에 대해서 고민이 많아진 것 같다.import { Root } from "../dom/DomRoot";
import { RootFiber } from "../dom/rootFiber"; /** * * @param {RootFiber} initialState * @returns {[any, function]} */
export function useState(initialState) { let state = initialState; const hostRoot = Root(); function setState(newState) { state = newState; hostRoot.reRender(); } idx++ return [state, setState];
}
현재는 싱글톤으로 구현해놓은 Root의 안쪽 요소를 맨 처음 createElement하는 과정에서 해당 Element객체들을 elements라는 프로퍼티에 넣어놓고 프로토타입 함수 reRender를 추가하여 해당 Element에게 다시금 렌더링을 시킬 수 있도록 했다.처음 렌더링 됐을 때는 자동적으로 render함수 안에 createElement 함수의 결과물이 인자로 들어갔지만, 이를 다시금 렌더링 하는 과정에서는 createElement에 인자로 들어간 state의 값이 원시값이기 때문에 복사하여 넣어져 있는 상태이다. 따라서, 해당 상태를 변경한다고 해서 createElement 안에 있는 내 state의 값이 변하지 않는다.일단 리액트 자체가 내가 설계한 방식보다 훨씬 복잡하게 구성되어 있기때문에 완전히 똑같이 만들기는 어렵다. 이에 기능을 최대한 줄이면서 내가 원하는 방식대로 동작할 수 있도록 하는 것이 목표인데 useState가 가장 난관인 것 같다. 아직은 해결 방안이 명확하게 떠오르지 않아 이 useState방식에 대해서 보다 고민을 해야 할 것 같다.안녕하세요 멘토님! 고생 많으십니다.
오늘 리뷰에서는 따로 기술적 질문사항은 없습니다. 위에 보시다시피 현재 useState의 설계 방식에 대해서 고민하고 있는데, 이러한 부분은 아직까지 여러 경우의 수를 생각하고 시도하는 중이라 이에 대해서 무턱대로 질문을 하기보다는 여러가지 도전을 해보고 싶습니다.하지만 이 과정에서 제가 겪는 학습 방식의 문제에 대해 조금 여쭤보고 싶습니다.
현재 제가 구현하는 fiber와 이 fiber를 비교하는 diff 알고리즘, dom의 createRoot등 사실상 사용하는 모든 함수들은 리액트를 참고하면서 만든 기능이기는 하지만 프로젝트의 규모에 맞게 임의로 축소한 버전이기에 부족한 부분이 많습니다. 그렇기 때문에 리액트의 로직을 많이 변형하기도 했습니다.
문제는 이러한 리액트의 기본 로직에 대해서 학습을 하고 나름대로 변형해서 구현하는 과정이다 하더라도 사실상 변형하여 구현하는 것이 과연 리액트의 기본 로직 학습이라는 관점에서 볼 때 괜찮은 방법이 맞을까? 하는 생각이 들었습니다.
원리는 학습을 하고 구현을 다른 방식으로 한다 쳐도, 이렇게 변형하면서 학습하는 방식이 오히려 구상하는 로직과 학습했던 지식이 혼동되는 문제가 종종 생겨 걱정도 되어 여쭤보게 되었습니다. 이에 대해서 멘토님의 고견을 여쭈어 봐도 될까요?리뷰해주셔서 감사합니다!😊]]></description><link>부스트캠프/멤버십/5주차/week5_4일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/week5_4일차 PR.md</guid><pubDate>Thu, 26 Sep 2024 14:14:44 GMT</pubDate></item><item><title><![CDATA[week5_3일차 PR]]></title><description><![CDATA[
라이브러리 DOM의 createRoot 설계 및 구현(엔트리 포인트)
reconciliation(새로운 Fiber와 기존 Fiber 재조정) 함수 설계 및 구현 diff 알고리즘은 아직.. render 함수 수정 새로운 파이버를 만들고, 재조정이 필요한 경우 재조정한 후에 DOM에 렌더링하는 과정으로 수정
기존 render함수는 createHTMLElementFromFiber 함수로, 오직 HTML Element만 만드는 과정만 책임질 수 있도록 리팩토링 rootFiber 설계 및 구현 createRootFiber를 통해 새로운 rootFiber 생성 설계 및 구현
getRootFiber를 통해 싱글톤 패턴으로 된 rootfiber를 가져올 수 있도록 구성
patchRootFiber를 통해 재조정이 완료된 파이버를 기존의 rootFiber에서 업데이트시켜주는 로직 설계 및 구현 오늘도 Virtual DOM과 React Fiber..
jsx에서 babel을 통해 트랜스파일링하는 과정에서 각각의 element에 대해서 createElement가 실행되고, 생성된 결과물은 한 객체가 나오게 된다.문제는 이러한 element 객체에 대해서 언제 어디를 fiber객체로 변환하고 계속해서 렌더링 로직을 관리하는가에 대한 고민이 뒤죽박죽이라 다시금 리액트의 공식문서를 보았다.<img src="https://i.imgur.com/WqHqNsk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
React의 공식 문서에서 보면 근본적인 entry point가 되는 것은 index.js이다. index.js와 index.html을 통해 가장 기본적인 뼈대만을 index.html에 만들어 놓고, index.js가 해당 root node를 받아 이를 DOM 자체의 root로 지정한다.그래서 나는 index.js의 root는 브라우저 자체의 root가 되며 Fiber의 root가 되는 곳은 해당 root id를 가진 element 안쪽의 요소가 Fiber의 root가 된다고 이해했다.SPA(Single Page Application)의 핵심은, 페이지의 이동 없이 깔끔하게 마치 '앱'처럼 이동하는 것이다. 이를 위해서는 근본적인 html 전체적인 template 자체를 갈아끼우는 것이 아니라, html 뼈대 자체는 고정적으로 두되 html template 안에서의 body 부분만 계속해서 DOM을 재구성하고 갈아끼우는 것이라고 생각했다. 따라서 root와 FiberRoot를 따로 두는 것이 보다 설득력이 있다고 생각했다.import { render } from "./DomRender"; let instance = null; export function Root(rootNode) { if (instance) return instance; this.rootNode = rootNode; instance = this;
} Root.prototype.render = (element) =&gt; { render(element);
}; export function createRoot(domNode) { return new Root(domNode);
}
따라서 나는 html 뼈대가 되는 root의 경우는 싱글톤 패턴을 이용해 항상 같은 html template을 유지하도록 했으며, render함수를 통해 App, 즉 리액트 상의 엔트리 포인트를 렌더링시키는 render함수를 Root instance의 prototype으로 등록해놓았다.let rootFiber = null; export function createRootFiber(rootFiber) { if (rootFiber) return rootFiber; return new RootFiber(rootFiber);
} export function patchRootFiber(patchedRootFiber) { if (rootFiber) return rootFiber; rootFiber.patch(patchedRootFiber); return rootFiber;
} export function RootFiber(rootFiberInstance) { if (rootFiber) return rootFiber; this.rootFiberInstance = rootFiberInstance; rootFiber = this;
} RootFiber.prototype.patch = (patchedRootFiber) =&gt; { this.rootFiberInstance = patchedRootFiber; rootFiber = this;
};
rootFiber의 경우에는 리액트 상에서 실질적으로 렌더링이 반복적으로 이루어지는 body 안의 요소들을 Fiber 객체로 만들어놓은 인스턴스이다. 재조정이 일어날 경우 patch를 통해 RootFiber객체를 갈아끼운다.이렇게 root를 DOMRoot와 FiberRoot를 두개 모두 싱글톤으로 구현한 다음, 이를 실질적으로 적용해보았다.//index.js
import * as mhReact from "mhreact";
import App from "./app.jsx"; const root = mhReact.createRoot(document.getElementById("root"));
root.render(&lt;App /&gt;);
index.js는 가장 근본적인 뼈대를 만들어주는 역할을 한다.
react 공식문서에 나왔던 Index의 역할처럼, root라는 id를 가진 element를 받아와 해당 element를 root로 설정하여 해당 element 안에서 계속해서 DOM을 갈아끼울 수 있도록 하였고, 실질적인 안쪽 요소의 엔트리포인트는 app.jsx로 설정하였다.&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body id="root"&gt;&lt;/body&gt; &lt;script type="module" src="./bundle.js"&gt;&lt;/script&gt;
&lt;/html&gt;
index.html은 정말 기본적인 뼈대만 가지고 있으면서 body태그를 fiberRoot가 들어갈 리액트의 엔트리포인트로 설정해두었다.
이 엔트리포인트는 script에서 번들링된 코드를 통해 index.js를 실행시켜 body 안쪽에서 &lt;App/&gt; 엔트리 포인트를 렌더링 시킬 수 있도록 해주었다.]]></description><link>부스트캠프/멤버십/5주차/week5_3일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/week5_3일차 PR.md</guid><pubDate>Wed, 25 Sep 2024 14:44:26 GMT</pubDate><enclosure url="https://i.imgur.com/WqHqNsk.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/WqHqNsk.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week5_2일차 PR]]></title><description><![CDATA[
라이브러리 가상DOM을 위한 설계 및 구현 React.createElement -&gt; ReactDOM.render -&gt; React.createFiberFromElement
React.createElement(element에 대한 가상 DOM) 설계 및 구현
ReactDOM.render(element에 대해서 html element로 바꾸어주는 모듈) 설계 및 구현
React.createFiberFromElement(ReactDOM.render에서 렌더링을 위한 파이버 객체) 설계 및 구현 Virtual DOM과 React Fiber
생성자 함수
React는 기존에 createElement를 통해 각 Element에 대한 정보들을 가지는 객체를 생성한다.
하지만 이 객체가 ReactDOM.render에 바로 사용되는 것이 아니고, ReactDOM.render함수 안에서 파이버를 생성하고, 그 파이버를 참조하여 tree를 만든 후에 기존의 root fiber와 비교하여 reconciliation 과정을 거쳐 새롭게 업데이트된 DOM을 렌더링 하여 보여주게 된다.이러한 과정을 구현하기에 앞서서, 함수형으로 되어있는 컴포넌트의 경우에 대해서 어떻게 jsx변환이 이루어지는지와 이에 대한 해결 방안을 생각해보았다./** @jsx mhreact.createElement */ import mhreact from "mhreact";
export function Test() { return &lt;div&gt;컴포넌트 테스트&lt;/div&gt;;
} //트랜스파일링
... /** @jsx mhreact.createElement */ import mhreact from "mhreact";
export function Test() { return mhreact.createElement( "div", null, "\uCEF4\uD3EC\uB10C\uD2B8 \uD14C\uC2A4\uD2B8" );
}
커스텀 컴포넌트를 만든 후 적용시켜 보았다.{ type: 'div', props: { id: 'app', className: 'wow' }, children: [ { type: [Function: Test], props: null, children: [] }, { type: 'p', props: null, children: [Array] }, { type: 'div', props: null, children: [Array] } ]
}
하나의 컴포넌트에서 이렇게 커스텀 컴포넌트를 넣었을 경우, type에는 function이 나오게 된다.
하지만 type에 함수가 오게 된다면 children에 와야 할 안쪽 자식들은 아무것도 오지 않았다. mhreact.createElement(Test, null),
커스텀 컴포넌트를 import해와서 사용한 곳에는 함수 그 자체가 들어가기 때문이다.
따라서 이 함수를 풀어서 createElement쪽에 들어갈 수 있도록 해주어야 한다.{ type: 'div', props: { id: 'app', className: 'wow' }, children: [ { type: [Function: Test], props: null, children: [] }, { type: 'p', props: null, children: [Array] }, { type: 'div', props: null, children: [Array] } ] }
export function createElement(type, props, ...children) { if (typeof type === "function") { return type(); } return new MhElement(type, props, children);
} export function MhElement(type, props, children) { this.type = type; this.props = props; this.children = children;
} 이를 해결하기 위해 함수형같은 경우는 따로 함수를 미리 실행시켜놓고 createElement의 결과로 나오는 값이 children과 같은 알맞은 위치에 같은 데이터가 들어갈 수 있도록 하였다.
추가적으로 Element는 생성자 함수를 통해 객체화시켰다.export function FiberNode(type, key = null) { this.type = type; this.key = key; this.state = null; this.textNode = null; this.props = null; this.index = null; //fibers this.child = null; this.sibling = null; this.return = null;
}
이를 통해 Fiber 객체를 생성하는 로직과 Fiber 객체 자체 또한 생성자 함수로 구현해주었다.
초깃값이 대부분 null로 되어있는 이유는 MhElement 객체에 대해 재귀적으로 실행하면서 Fiber객체를 생성하는 과정에서 그때그때마다 element를 보고 객체를 업데이트시켜주어야 하기 때문이다.안녕하세요. 멘토님. 고생 많으십니다!
이번 리뷰에서는 아직 학습할 것들이 많아 학습에 많은 시간을 쏟은 탓에 많이 하지 못했습니다,,
다음 리뷰에서는 보다 질문을 정리해서 말씀드리겠습니다!
편하게 봐주시고 전체적인 피드백만 해주시면 감사하겠습니다 :)]]></description><link>부스트캠프/멤버십/5주차/week5_2일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/week5_2일차 PR.md</guid><pubDate>Tue, 24 Sep 2024 14:09:39 GMT</pubDate></item><item><title><![CDATA[React의 내부구조]]></title><description><![CDATA[React.createElement는 JSX문법에 대해서 트랜스파일링되는 과정에서 자동적으로 호출되는 API이다.
여기서 알아두어야 하는 것은, Element는 해당 객체를 그릴 수 있는 정보들을 가진 객체일 뿐, 이를 DOM에 그리는 것은 React-DOM이 하는 일이다./** * Create and return a new ReactElement of the given type. * See https://reactjs.org/docs/react-api.html#createelement */
export function createElement(type, config, children) { let propName; // Reserved names are extracted const props = {}; let key = null; let ref = null; let self = null; let source = null; if (config != null) { if (hasValidRef(config)) { ref = config.ref; if (__DEV__) { warnIfStringRefCannotBeAutoConverted(config); } } if (hasValidKey(config)) { if (__DEV__) { checkKeyStringCoercion(config.key); } key = '' + config.key; } self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object for (propName in config) { if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) { props[propName] = config[propName]; } } } // Children can be more than one argument, and those are transferred onto // the newly allocated props object. const childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength &gt; 1) { const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } if (__DEV__) { if (Object.freeze) { Object.freeze(childArray); } } props.children = childArray; } // Resolve default props if (type &amp;&amp; type.defaultProps) { const defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } if (__DEV__) { if (key || ref) { const displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type; if (key) { defineKeyPropWarningGetter(props, displayName); } if (ref) { defineRefPropWarningGetter(props, displayName); } } } return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );
}
CreateElement는 인자로 type, config, children을 받는다.
보면 type을 통해서는 해당 element의 태그 이름을 담고, 해당하는 태그에 대한 attribute들을 초기화시킨다.
config로는 key, ref, self, source 등의 예약된 속성들에 대해서도 관리한다.
children에서는 해당 요소의 자식 요소들을 넣는다. 자식이 여러개인 경우 배열로 만들어 넣는다.
최종적으로는 이를 ReactElement함수에 인자로 다시금 넣어 리턴시킨다.const ReactElement = function(type, key, ref, self, source, owner, props) { const element = { // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, }; if (__DEV__) { // The validation flag is currently mutative. We put it on // an external backing store so that we can freeze the whole object. // This can be replaced with a WeakMap once they are implemented in // commonly used development environments. element._store = {}; // To make comparing ReactElements easier for testing purposes, we make // the validation flag non-enumerable (where possible, which should // include every environment we run tests in), so the test framework // ignores it. Object.defineProperty(element._store, 'validated', { configurable: false, enumerable: false, writable: true, value: false, }); // self and source are DEV only properties. Object.defineProperty(element, '_self', { configurable: false, enumerable: false, writable: false, value: self, }); // Two elements created in two different places should be considered // equal for testing purposes and therefore we hide it from enumeration. Object.defineProperty(element, '_source', { configurable: false, enumerable: false, writable: false, value: source, }); if (Object.freeze) { Object.freeze(element.props); Object.freeze(element); } } return element;
};
최종적으로는 필요한 property에 대해서 정의하고, 이를 Immutable하게 바꾼 뒤 객체를 다시금 리턴시키는 형태이다.function Component(props, context, updater) { this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the // renderer. this.updater = updater || ReactNoopUpdateQueue;
} Component.prototype.isReactComponent = {}; Component.prototype.setState = function(partialState, callback) { if ( typeof partialState !== 'object' &amp;&amp; typeof partialState !== 'function' &amp;&amp; partialState != null ) { throw new Error( 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.', ); } this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
React.component는 재사용가능한 UI를 하나의 묶음으로 묶은 것이다.
이 component는 element들이 모여 하나의 component를 이룬다. 이 updater의 enqueueSetState의 구조는 enqueueSetState(inst, payload, callback) { const fiber = getInstance(inst); const eventTime = requestEventTime(); const lane = requestUpdateLane(fiber); const update = createUpdate(eventTime, lane); update.payload = payload; if (callback !== undefined &amp;&amp; callback !== null) { if (__DEV__) { warnOnInvalidCallback(callback, 'setState'); } update.callback = callback; }
이런 식으로 되어 있는데, 파이버를 인스턴스로부터 가져오고, 이를 업데이트 시키도록 UpdateLane이라는 곳으로 요청을 보내고 있다. 이벤트의 경우는 updateLane이라는 queue에서 순차적으로 처리하는 구조인 것 같다.export function render( element: React$Element&lt;any&gt;, container: Container, callback: ?Function,
) { if (__DEV__) { console.error( 'ReactDOM.render is no longer supported in React 18. Use createRoot ' + 'instead. Until you switch to the new API, your app will behave as ' + "if it's running React 17. Learn " + 'more: https://reactjs.org/link/switch-to-createroot', ); } if (!isValidContainerLegacy(container)) { throw new Error('Target container is not a DOM element.'); } if (__DEV__) { const isModernRoot = isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer === undefined; if (isModernRoot) { console.error( 'You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOMClient.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?', ); } } return legacyRenderSubtreeIntoContainer( null, element, container, false, callback, );
코드가 복잡하지만 파악할 수 있는 부분은Dom Element인&nbsp;container&nbsp;와&nbsp;React Element인&nbsp;element를 인자로 받아서&nbsp;Container의&nbsp;SubTree로 리액트 엘리먼트를&nbsp;Render&nbsp;한다는 것을 파악할 수 있다. 01. 컨테이너 DOM Element 안에 자체적인 DOM 트리를 만든다.
02. 그 안의 컴포넌트들의 변경 사항이 있으면, updateQueue에 등록한다.
03. 해당 updateQueue의 변경 사항들이 배치처리를 통해 실행된다.]]></description><link>부스트캠프/멤버십/5주차/react의-내부구조.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/React의 내부구조.md</guid><pubDate>Mon, 23 Sep 2024 17:25:15 GMT</pubDate></item><item><title><![CDATA[React의 동작 단계 구현]]></title><description><![CDATA[React의 내부 동작은 크게 네 개의 단계로 구현된다.
Render 단계: JSX 선언 또는&nbsp;React.createElement()를 통해 일반 객체인 React Element를 생성한다.
Reconcile 단계: 이전에 렌더링된 실제 DOM 트리와 새로 렌더링할 React Element를 비교하여 변경점을 적용한다.
Commit 단계: 새로운 DOM Element를 브라우저 뷰에 커밋한다.
Update 단계: props, state 변경 시 해당 컴포넌트와 하위 컴포넌트에 대해 위 과정을 반복한다.
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://d2.naver.com/helloworld/2690975" target="_self">https://d2.naver.com/helloworld/2690975</a>]]></description><link>부스트캠프/멤버십/5주차/react의-동작-단계-구현.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/React의 동작 단계 구현.md</guid><pubDate>Mon, 23 Sep 2024 15:45:00 GMT</pubDate></item><item><title><![CDATA[JSX에 대해서]]></title><description><![CDATA[JSX는 주로 우리가 리액트에서 사용하는 확장자명이다.
페이스북에서 JSX를 리액트 만들면서 새롭게 만들기도 했지만, 그렇다고 무조건 리액트에서만 쓰이는 구문은 아니라는 점을 알아야 한다.
JSX는 기존 자바스크립트를 확장한 문법으로, 공식적인 문법은 아니기 때문에 바벨을 사용하여 트랜스파일링할 필요가 있다.리액트 자동 런타임은 활성화되어있을 경우 자동적으로 runtime 파일을 import 해와 JSX를 컴파일하는 함수를 알아서 불러오고, 이를 실행한다.const profile = ( &lt;div&gt; &lt;img src="avatar.png" className="profile" /&gt; &lt;h3&gt;{[user.firstName, user.lastName].join(" ")}&lt;/h3&gt; &lt;/div&gt;
);
이런 식으로 된 jsx 문법을 babel은 @babel/plugin-transform-react-jsx이라는 컴파일 플러그인을 통해서 컴파일시킬 수 있다.import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime"; const profile = _jsxs("div", { children: [ _jsx("img", { src: "avatar.png", className: "profile", }), _jsx("h3", { children: [user.firstName, user.lastName].join(" "), }), ],
});
그렇게 바뀐 코드는 이러한 형태로 나오게 된다.
여기서 babel은 따로 런타임 import에 대해 따로 설정을 해놓지 않았을 경우 기존 react의 jsx-runtime을 사용하여 컴파일한 결과를 내보낸다./** @jsxImportSource custom-jsx-library */ const profile = ( &lt;div&gt; &lt;img src="avatar.png" className="profile" /&gt; &lt;h3&gt;{[user.firstName, user.lastName].join(" ")}&lt;/h3&gt; &lt;/div&gt;
);
만약 내가 커스텀한 jsx 라이브러리로 만들기 위해서는 위에 주석처럼 따로 경로디렉토리를 설정해주면 해당 경로의 jsx-runtime에서 가져와 사용한다.// 결과
import { jsx as _jsx } from "custom-jsx-library/jsx-runtime";
import { jsxs as _jsxs } from "custom-jsx-library/jsx-runtime"; const profile = _jsxs("div", { children: [ _jsx("img", { src: "avatar.png", className: "profile", }), _jsx("h3", { children: [user.firstName, user.lastName].join(" "), }), ],
});
Classic Runtime의 경우, v7혹은 그 이전 바벨의 버전에서는 디폴트로 설정되어있는 기능이다.const profile = ( &lt;div&gt; &lt;img src="avatar.png" className="profile" /&gt; &lt;h3&gt;{[user.firstName, user.lastName].join(" ")}&lt;/h3&gt; &lt;/div&gt;
);
얘는 React의 Runtime을 import해와서 사용하기보다는 React자체를 불러오고, createElement를 그대로 가져와서 사용한다.const profile = React.createElement( "div", null, React.createElement("img", { src: "avatar.png", className: "profile" }), React.createElement("h3", null, [user.firstName, user.lastName].join(" "))
);
이러한 Classic Runtime을 커스터마이징 하기 위해서는 맨 위에 주석처럼 /** @jsx Preact.h */
과 같이 써주면, jsx 옆 모듈의 함수를 가져와 쓸 수 있도록 할 수 있다./** @jsx Preact.h */ import Preact from "preact"; const profile = ( &lt;div&gt; &lt;img src="avatar.png" className="profile" /&gt; &lt;h3&gt;{[user.firstName, user.lastName].join(" ")}&lt;/h3&gt; &lt;/div&gt;
);
그렇게 되면 내가 설정한 라이브러리에서 모듈을 가져와 사용할 수도 있는 형태가 된다.
import문을 통해 미리 모듈을 import해주지 않으면 예상대로 동작하지 않으니 주의해야 한다./** @jsx mhreact.createElement */ import mhreact from "mhreact"; const test = ( &lt;div id="app"&gt; &lt;p&gt;안녕하세요&lt;/p&gt; &lt;div&gt; &lt;p&gt;테스트&lt;/p&gt; &lt;div&gt; &lt;p&gt;테스트2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;
); console.log(test); 이를 활용하여 mhreact라는 라이브러리를 만들고, 클라이언트의 의존성에 추가해준 뒤에 import해오고, createElement라는 함수를 가져와 jsx 형식에서 작성된 html 요소들을 변환해주었다./** @jsx mhreact.createElement */ import mhreact from "mhreact";
var test = mhreact.createElement( "div", { id: "app", }, mhreact.createElement("p", null, "\uC548\uB155\uD558\uC138\uC694"), mhreact.createElement( "div", null, mhreact.createElement("p", null, "\uD14C\uC2A4\uD2B8"), mhreact.createElement( "div", null, mhreact.createElement("p", null, "\uD14C\uC2A4\uD2B82") ) )
);
console.log(test); 변환하게 되면 이와 같이 바벨이 트랜스파일링을 해준 다음에 그 결과를 createElement의 인자로 들어가는 로직으로 변경되었다.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://d2.naver.com/helloworld/2690975" target="_self">https://d2.naver.com/helloworld/2690975</a>]]></description><link>부스트캠프/멤버십/5주차/jsx에-대해서.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/JSX에 대해서.md</guid><pubDate>Mon, 23 Sep 2024 15:41:52 GMT</pubDate></item><item><title><![CDATA[week5_1일차 PR]]></title><description><![CDATA[
초기 환경 세팅 서버, 클라이언트, 라이브러리 분리 세팅
클라이언트 바벨 트랜스파일링 환경 구축 서버 기본적인 초기 세팅 라이브러리 npm publish 후 클라이언트에서 다운로드하여 사용 라이브러리 createElement jsx 파일에서 작성된 html element에 대해서 babel 트랜스파일을 통해 객체로 변환 navigate historyAPI를 이용하여 uri만 변경하되, 실제로 페이지 전환은 이루어지지 않도록 설계중 Virtual DOM
babel과 webpack 트랜스컴파일 과정
jsx 트랜스컴파일 지난 taskify 미션에서 나는 SPA 방식으로 구현하고 싶다는 마음이 들어 historyAPI를 따로 찾아본 적이 있었고, 이를 통해 부족하지만 SPA를 구현해보았다.import Main from "../../pages/main/index.js";
import Login from "../../pages/login/index.js";
import EventManager from "../../feature/index.js"; export default (function navigation() { const navigator = { "/": Main.render, "/login": Login.render, }; function navigate(pathname, prev) { document.body.innerHTML = ""; history.pushState({ pathname: prev }, null, pathname); navigator[pathname](); } function onPageChanged(event) { document.body.innerHTML = ""; EventManager.detachEvent(event.pathname); navigator[window.location.pathname](); } return { navigate, onPageChanged, };
})();
해당 미션에서 나는 SPA 구현 자체를 클라이언트 단에서 모두 관리할 수 있도록 하였다. 따라서 유틸함수에 navigation을 넣어놓고 navigator를 클로저로 관리하면서 페이지 별로 render함수를 두었다(페이지별 render 함수 내부에는 다시 하위 컴포넌트들의 render 함수가 포함되어 있다). 하지만 이번 미션의 경우 따로 이러한 SPA를 구현하는데 필요한 함수들을 라이브러리로 분리하여 관리해야 한다고 느꼈으며, 그런 경우에 기존에 등록해놨던 uri별 render 함수는 virtualDOM과 연결시켜 어떤 방식으로 구현해야 할지에 대해서 고민이 되었다. 아직까지는 virtualDOM또한 트랜스파일링을 통해 객체로 변환시키는 작업밖에 하지 못했기 때문에 이러한 점을 고려하면서 navigate의 작동 방식이 어떻게 가야할 지에 대한 고민은 아직까지는 해결되지 않았다.
virtual DOM의 설계 및 구현 방식에서 navigate또한 염두에 두고 설계할 예정이다.]]></description><link>부스트캠프/멤버십/5주차/week5_1일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/week5_1일차 PR.md</guid><pubDate>Mon, 23 Sep 2024 14:47:31 GMT</pubDate></item><item><title><![CDATA[5주차_주간계획]]></title><description><![CDATA[
Virtual DOM과 React Fiber
상태관리
routing
historyAPI
객체지향원칙(SOLID)
babel과 webpack
트랜스컴파일 과정
jsx 트랜스컴파일
컴포넌트 단위 개발 초기 환경 세팅
historyAPI를 활용하여 SPA 설계 이벤트 페이지마다, 컴포넌트마다 어떤 식으로 위임할지에 대한 설계 및 구현
Navigation 객체에서 더 필요한 메서드를 분석하고 적용 바벨 트랜스파일링 환경 구축 babel 트랜스파일링을 통해 mhreact 라이브러리를 사용
mhreact라이브러리를 사용하여 DOM 렌더링
VirtualDOM 설계 및 구현
VirtualDOM과 실제 DOM과의 비교 및 리렌더링 최소화 로직 설계 및 구현 폴더 구조 정리 fsd패턴 기본적인 서버 구조 설계
MVC 패턴 간단한 todo 객체 설계 및 API 구현 aws 인스턴스에 mysql 서버 구동
db 만들고 nodejs와 연결 Navigation HistoryAPI를 활용하여 페이지 이동 없이 화면 전환(navigate) CreateElement 각 노드를 객체로 변환
객체로 변환한 노드를 실제 html element로 변환
html element로 변환한 것을 DOM상에서 교체 교체 과정에서 교체가 필요한 최소 부분만 골라내어 교체 ]]></description><link>부스트캠프/멤버십/5주차/5주차_주간계획.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/5주차_주간계획.md</guid><pubDate>Mon, 23 Sep 2024 14:31:37 GMT</pubDate></item><item><title><![CDATA[멤버십_5주차]]></title><description><![CDATA[<a data-href="마스터클래스_5주차" href="부스트캠프/멤버십/5주차/마스터클래스_5주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">마스터클래스_5주차</a><br>
<a data-href="5주차_주간계획" href="부스트캠프/멤버십/5주차/5주차_주간계획.html#_0" class="internal-link" target="_self" rel="noopener nofollow">5주차_주간계획</a><br><a data-href="week5_1일차 PR" href="부스트캠프/멤버십/5주차/week5_1일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week5_1일차 PR</a><br>
<a data-href="week5_2일차 PR" href="부스트캠프/멤버십/5주차/week5_2일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week5_2일차 PR</a><br>
<a data-href="week5_3일차 PR" href="부스트캠프/멤버십/5주차/week5_3일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week5_3일차 PR</a><br>
<a data-href="week5_4일차 PR" href="부스트캠프/멤버십/5주차/week5_4일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week5_4일차 PR</a>]]></description><link>부스트캠프/멤버십/5주차/멤버십_5주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/멤버십_5주차.md</guid><pubDate>Mon, 23 Sep 2024 07:17:30 GMT</pubDate></item><item><title><![CDATA[학습스프린트2_마스터클래스_5주차]]></title><link>부스트캠프/멤버십/5주차/학습스프린트2_마스터클래스_5주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/학습스프린트2_마스터클래스_5주차.md</guid><pubDate>Mon, 23 Sep 2024 06:10:23 GMT</pubDate></item><item><title><![CDATA[[백준 7576] 토마토]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.acmicpc.net/problem/7576" target="_self">https://www.acmicpc.net/problem/7576</a>격자 모양 상자의 칸에 하나씩 토마토가 들어가있음
익지 않은 토마토도 익은 토마토에 인접(상하좌우에 존재)하면 하루 뒤 익게 됨
토마토가 모두 익을 때까지의 최소 날짜 출력해당 문제는 BFS로 풀 수 있다.
날짜를 하루씩 더해가면서 익은 토마토 상하좌우에 있는 익지 않은 토마토를 익은 상태로바꿔주면 된다.
날짜를 하루씩 더해가면서 익은 토마토를 기준으로 전진하고, 익은 토마토가 인접해서 익은 토마토가 있다면 익은 토마토의 방향쪽으로 전진한 다음 일수를 누적시키면서 재귀적으로 호출을 시켜준다.
이렇게 계속 전진을 시켜주다 보면 마지막에 익지 않은 토마토가 모두 익은 경우에 결과만 출력시켜주면 된다.]]></description><link>알고리즘/[백준-7576]-토마토.html</link><guid isPermaLink="false">알고리즘/[백준 7576] 토마토.md</guid><pubDate>Sun, 22 Sep 2024 23:39:17 GMT</pubDate></item><item><title><![CDATA[Node.js Libuv에 대한 고찰]]></title><description><![CDATA[Libuv는 비동기 입출력 및 이벤트 기반에 초점을 둔 라이브러리이다.
주요 기능으로는 논블로킹 IO처리, 비동기 파일 시스템 접근 등이 있다.
우리가 알고 있는 Node.js의 핵심적인 로직인 이벤트 루프를 가지고 있는 라이브러리이기도 하다.고전적으로는 기존 IO 처리의 경우 요청마다 스레드를 할당하여 처리하는 구조를 가지고 있다.
기존에는 이 동시성을 위해 멀티스레드를 열고 작업이 완료될 때까지 스레드의 실행을 차단하는 방법을 사용했다. 하지만 여기에선 쓰레드를 열었음에도 idle time, 즉 유효한 시간이 각각의 쓰레드에게 발생하기 때문에 이는 곧 자원의 낭비로 이어진다.이어 나온 방식은 논블로킹의 이벤트 디멀티플렉싱메커니즘이다.
<img src="https://i.imgur.com/o1TK327.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">멀티플렉서가 요청들을 하나로 묶고 디멀티플렉서가 요청을 싱글 스레드에 나눔으로써 모든 요청들을 관리하고 요청이 완료되기 전까지 블로킹, 완료가 된 후에는 이벤트큐에 푸시하는 방법 또한 사용했다.
이러한 메커니즘에 특화된 디자인 패턴으로는 리액터 패턴이 있다.<br><img src="https://i.imgur.com/uQBTe8v.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">리액터 패턴은 이벤트 디멀티플렉서에서 I/O 요청이 완료되었을 때, 이벤트와 이벤트에 해당하는 핸들러를 이벤트 큐에 넣고 이벤트 루프를 통해 이러한 핸들러를 실행시키는 방식으로 작동한다.
여기서 이벤트 루프가 존재를 드러내기 시작한다. 이러한 이벤트 루프의 기본적인 작동 방식이 현재 우리가 알고 있는 Node.js libuv 라이브러리의 이벤트 루프의 기반이 되었다.<br><img src="https://i.imgur.com/V1c7vQl.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Libuv의 공식문서를 보면 Libuv는 이벤트루프를 통해 Handle과 Request 두 가지를 다룬다고 나와있다.
Handle의 경우 작동 과정에서 다루는 콜백, TCP 서버 연결 콜백 등의 IO를 다루게 되고, Request는 Handle이 작동하는 과정에서 필요한 작업들을 요청하는 단기간 작업들을 다룬다.while there are still events to process: e = get the next event if there is a callback associated with e: call the callback
이벤트 루프는 반복적으로 이러한 작업들에 대해서 단일 스레드인 nodejs와 연결하고 이를 비동기적으로 수행한다.
비동기적으로 IO작업을 수행하기 위해서는 여타 단일 스레드 비동기 I/O접근방식과 같이 논블로킹 소켓에서 사용되며, 이 과정에서 필요한 polling은 각 OS에서 사용 가능한 최적의 메커니즘을 통해 작동한다. 해당 메커니즘의 경우 Windows의 경우 IOCP, Linux의 경우 Epoll 등이 있다.
대표적인 IO polling 메커니즘인 Linux의 Epoll에 대해서도 짚고가자.Epoll은 리눅스에서 개발된 I/O 통지 모델이다. 멀티플렉싱 기법으로 동작하는 select 함수의 단점(느린 멀티플렉싱 등)을 보완하기 위해 나온 OS 레벨에서 지원하는 멀티플렉싱 함수이다.
파일 디스크럽터를 커널이 관리하면서 CPU에서 파일 디스크럽터의 상태 변화를 감시하고, 비동기 I/O 이벤트를 처리하는데 사용된다.
파일 디스크립터(File Descriptor)
유닉스 계열 시스템에서 프로세스가 특정 파일에 접근할 때 사용하는 추상적인 값
프로세스가 실행 중에 파일을 Open하면 커널은 해당 프로세스의 파일 디스크립터 숫자 중 사용하지 않는 가장 작은 값을 할당해준다. 그 다음 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.
표준입력 0 / 표준출력 1 / 표준에러 2는 고정임
int epfd = epoll_create1(0); 새로운 epoll 인스턴스를 생성하고 파일 디스크립터(fd)를 반환
매개변수 size 플래그를 전달 struct epoll_event event;
event.events = EPOLLIN;
event.data.fd = socket_fd;
epoll_ctl(epfd, EPOLL_CTL_ADD, socket_fd, &amp;event); epoll 인스턴스에 파일 디스크립터를 추가, 수정 또는 삭제
매개변수 epfd : epoll 인스턴스의 파일 디스크립터
op: 수행할 작업 EPOLL_CTL_ADD: 새 파일 디스크립터를 epoll 인스턴스에 추가
EPOLL_CTL_MOD: 기존 파일 디스크립터를 수정
EPOLL_CTL_DEL: 파일 디스크립터를 삭제 fd: 감시할 파일 디스크립터
struct epoll_event *event: 감시할 이벤트와 데이터를 설정하는 구조체로 관찰 대상의 관찰 이벤트 유형 EPOLLIN : 수신할 데이터가 있음
EPOLLOUT : 송신 가능함
EPOLLPRI : 중요 데이터 발생
EPOLLRDHUD : 연결 종료 또는 Half-close 발생
EPOLLERR : 에러 발생
EPOLLET : 엣지 트리거 방식으로 설정(디폴트는 레벨 트리거) 엣지 트리거 : 특정 상태가 변화하는 시점에서 감지
레벨 트리거 : 특정 상태가 유지되는 동안 감지 EPOLLONESHOT : 한번만 이벤트 받기 struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1); epoll 인스턴스에 등록된 파일 디스크립터들 중 이벤트가 발생한 것을 기다림
매개변수 epfd: epoll 인스턴스의 파일 디스크립터
events: 발생한 이벤트들이 저장된 배열
maxevents: 감시할 수 있는 최대 이벤트 수
timeout: 이벤트가 발생할 때까지 대기하는 시간(밀리초). -1로 설정하면 무한 대기 <br><img src="https://i.imgur.com/p0BTiqc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
아무튼 이렇게 IO polling을 통해 이벤트를 감시하고, IO 이벤트에 대해서 처리를 커널단에서 해주는데, 파일 I/O나 DNS 함수(getaddrinfo, getnameinfo) 같은 경우는 커널단에서 지원해주지 않는다. 그렇기 때문에 Libuv는 워커 스레드 풀을 두고, 워커 스레드를 할당하여 해당 작업을 처리하도록 한다. 해당 작업은 스레드 풀에서 블로킹 방식으로 접근 및 작업을 처리한다.결국 모든 작업은 이벤트루프 를 중심으로 내외적으로 이루어지는 것이다.
이벤트 루프 안에서 비동기 작업이 일어나는 경우 I/O Polling의 작업이나 워커스레드가 할 수 있는 비동기 작업 등에 대해서는 함수를 실행한 뒤 바로 리턴받는다. 이후에 각 비동기 작업이 끝난 후 받는 callback을 각 이벤트에 맞는 queue에 넣어주고 이벤트 루프가 돌다가 이 큐에 콜백이 들어온 것을 감지하고 실행시키는 것이다.<br><img src="https://i.imgur.com/U5C6EN6.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
전체적인 구조가 잘 도식화되어있는 것 같아서 사진을 가져왔다. 이런 식으로 이벤트 루프는 싱글 스레드로 동작하지만 비동기 작업에서는 IO Polling을 커널에서, 파일 IO와 같은 작업은 별도의 워커스레드를 통해 구현하여 싱글스레드인데도 비동기적으로 동작시키기 때문에 블로킹I/O보다 좋은 효율을 내게 된다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://sjh836.tistory.com/149" target="_self">https://sjh836.tistory.com/149</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://rammuking.tistory.com/entry/Epoll%EC%9D%98-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95" target="_self">https://rammuking.tistory.com/entry/Epoll%EC%9D%98-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95</a>]]></description><link>부스트캠프/멤버십/5주차/node.js-libuv에-대한-고찰.html</link><guid isPermaLink="false">부스트캠프/멤버십/5주차/Node.js Libuv에 대한 고찰.md</guid><pubDate>Sun, 22 Sep 2024 14:11:05 GMT</pubDate><enclosure url="https://i.imgur.com/o1TK327.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/o1TK327.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이벤트 루프와 비동기]]></title><description><![CDATA[이벤트 루프는 특정 이벤트나 메시지가 발생할 때까지 대기하다가 이벤트가 발생하면 디스패치하는 디자인 패턴이다.
각 운영체제에서도 각각의 이벤트 루프가 다양한 방식으로 활용되고 있으며, 자바스크립트의 경우는 싱글스레드 언어이기 때문에 node.js를 통해 하나의 호출스택만 사용하는 구조에서 동시성을 구현하기 위해 사용하는 디자인 패턴이다.
동시성: 서로 다른 사건이 동시에 일어나는 것
고전적으로는 이 동시성을 위해 멀티스레드를 열고 작업이 완료될 때까지 스레드의 실행을 차단하는 방법을 사용했다. 하지만 여기에선 쓰레드를 열었음에도 idle time, 즉 유효한 시간이 각각의 쓰레드에게 발생하기 때문에 이는 곧 자원의 낭비로 이어진다.이어 나온 방식은 논블로킹의 이벤트 디멀티플렉싱메커니즘이다.
<img src="https://i.imgur.com/o1TK327.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
멀티플렉서가 요청들을 하나로 묶고 디멀티플렉서가 요청을 싱글 스레드에 나눔으로써 모든 요청들을 관리하고 요청이 완료되기 전까지 블로킹, 완료가 된 후에는 이벤트큐에 푸시하는 방법 또한 사용했다.
이러한 메커니즘에 특화된 디자인 패턴으로는 리액터 패턴이 있다.<br>
<img src="https://i.imgur.com/uQBTe8v.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">리액터 패턴은 이벤트 디멀티플렉서에서 I/O 요청이 완료되었을 때, 이벤트와 이벤트에 해당하는 핸들러를 이벤트 큐에 넣고 이벤트 루프를 통해 이러한 핸들러를 실행시키는 방식으로 작동한다.
여기서 이벤트 루프가 존재를 드러내기 시작한다. 이러한 이벤트 루프의 기본적인 작동 방식이 현재 우리가 알고 있는 Node.js 등의 이벤트 루프의 기반으로 작동한다. 그럼 이러한 작동 방식에서 기본적인 구조인 Event Queue, Loop, Handler에 대해서 알아보자.이벤트 큐는 메시지와 이벤트를 보내는 시점과 처리하는 시점을 다르게 하기 위한 비동기형 디자인패턴으로 관찰자 패턴의 형태이다.
이벤트가 계속해서 들어오면 이러한 이벤트를 처리하기 위해 프로그램은 이벤트 루프를 통해 이벤트 핸들러를 담은 이벤트를 실행한다.while(running){ Event event = getNextEvent();
}
수도코드를 보면 아직 처리하지 않은 사용자 입력을 가져오고 실행을 반복하느느 구조를 지닌다.
이러한 요청 안에는 클로저, 즉 해당 이벤트가 끝난 뒤 실행하는 함수인 이벤트 핸들러가 담겨져 있기 때문에 작업이 끝난 후 별도의 스레드에서 실행된다. 그렇기 때문에 이벤트루프는 이러한 작업을 핸들러에게 위임하고 바로 애플리케이션의 다음 IO를 받을 수 있도록 하는 비동기성을 가진다. 이를 통해 애플리케이션과의 상호작용이 가능한 것이다.<br><img src="https://i.imgur.com/z609IYv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">EventQueue에 있는 이벤트는 이벤트루프가 deque를 통해 받아서 이벤트를 처리하는 방식으로 동작한다. 여기서 중요한 점은 앞에서도 말했듯 해당 이벤트 핸들러를 ‘받아서’ 이벤트를 처리한다는 점이다.이러한 이벤트 핸들러는 이벤트가 모두 실행된 후 실행되게 되는데, 이 때 실행되는 이벤트 핸들러는 원래의 이벤트 큐가 아닌 별도의 스레드에서 실행시키면서 비동기적인 특성을 유지할 수 있다.해당 패턴은
요청을 들어온 순서대로 저장
요청 보내는 곳에서는 요청을 큐에 넣은 뒤에 결과를 기다리지 않고 리턴
요청을 처리하는 곳에서는 큐에 들어있는 요청을 나중에 처리
의 과정을 지닌다. 이러한 과정은 비단 nodejs의 libuv 뿐만 아니라 다양한 곳에서도 여러 방식으로 활용되고 있다. 특히 운영체제에서 많이 쓰이는데, 다양하게 일어나는 이벤트 요청에 대해서 스레드는 한정적이기 때문에 고정적인 스레드 수를 가지는 스레드 풀을 만들어 이를 이벤트 루프와 함께 활용하면서 스레드 풀에서의 스레드가 놀지 않도록 계속해서 이벤트를 넣어주고, 실행이 끝나면 핸들러를 실행하는 식의 이벤트 루프 패턴을 사용한다. 이를 Worker Thread라고 한다.<br><img src="https://i.imgur.com/IedMcfk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> WorkerThread와 Event Loop와의 관계는 플랫폼마다 다르지만 기본적인 원리는 똑같다.
- node의 libuv
- emitter + queue
- 모바일 main thread
- event / operation queue
- coroutine
이벤트가 들어왔을 때, 이를 큐에 쌓아놓고 있고 이를 처리하는 루퍼가 반복되면서 주기적으로 큐의 이벤트를 꺼내 특정한 콜백(클로저)를 호출해주는 방식이다.
ㄱ<br><img src="https://i.imgur.com/JsQtIsR.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
동작할 클로저를 객체 단위로 만듦(Operation class)
operation이라는 작업 단위로 순차적으로 처리하고, 이를 동시에 처리해줄 worker를 얼마나 둘지 설정해둘 수 있음
전형적인 eventLoop를 동작시키는 추상화된 동작 방식
<br><img src="https://i.imgur.com/p0BTiqc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
싱글 스레드에서 루프를 두는 스타일이지만 timer나 I/O pool 등에 대한 클로저가 개별적으로 설정되어 있는 형태
이를 돌아가면서 각 단계마다 블록을 걸면서 순차적으로 돌아가면서 확인
IO가 일어나는, 즉 다른 worker Thread가 돌아가는 구조라면, 다른 OS의 worker thread와 동작하는 경우들은 개별적인 다른 쓰레드가 있고, 그 쓰레드들이 콜백을 주는 형태
<br><img src="https://i.imgur.com/ysQnI5I.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
IOS, Android에서는 실행하는 앱 별로 다른 쓰레드가 생김
그 쓰레드별로 메인 run loop(event Loop)가 생기고, 앱이 끝나면 해당 이벤트 루프 또한 끝남
터치 이벤트, IO이벤트 등을 이벤트 루프에서 확인하고 화면을 그리게 됨
<br><img src="https://i.imgur.com/X5bOprp.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Android에서도 Context 단위로 쓰레드가 유지가 되고, 그 안에 루퍼가 있음 Context 단위는 Activity, Service, Fragment, animations, onClick 등.. 루퍼가 핸들러를 호출하는 구조
결국 모든 비슷한 형태의 비동기 형태의 이벤트 루퍼
<br><img src="https://i.imgur.com/hwB2x4L.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
타임 아웃이 될 때마다 등록해놓은 콜백을 실행하는 구조
타이머 애니메이션을 처리하는데 있어서 스레드가 필요한가?가 중요한 포인트
타이머들이 쓰레드가 필요없이 메인 쓰레드에서 동작하는 경우가 있음 node의 이벤트 루퍼가 대표적인 예. 다른 쓰레드에 타이머를 놓게 되면 애니메이션에 의해 타이머가 멈추거나, 타이머 때문에 애니메이션이 멈추는 경우도 있음
타이머가 어느 쓰레드에서 실행되는지 확인하는 것이 중요
]]></description><link>부스트캠프/챌린지/이벤트-루프와-비동기.html</link><guid isPermaLink="false">부스트캠프/챌린지/이벤트 루프와 비동기.md</guid><pubDate>Sun, 22 Sep 2024 12:14:43 GMT</pubDate><enclosure url="https://i.imgur.com/o1TK327.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/o1TK327.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 12865] 평범한 배낭]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.acmicpc.net/problem/12865" target="_self">https://www.acmicpc.net/problem/12865</a>한 달 뒤 입대하는 준서를 위해서..준서가 여행에 필요하다고 생각하는 N개의 물건에 대해 가져갈 수 있는 조합의 총 가치를 구한 다음에 여기서 최고의 가치를 지니는 조합을 리턴하면 된다.N개의 물건과 최대 K의 무게라는 조건이 붙는다.내가 처음에 선택했던 방식은 완전탐색방식이었다. let input = require("fs").readFileSync("/dev/stdin").toString().split("\n"); const [N, K] = input[0].split(" "); const stuffs = input.slice(1); let result = []; function takeStuff(left, val, allStuffs, result) { allStuffs.forEach((stuff, idx) =&gt; { const [w, v] = stuff.split(" ").map((t) =&gt; parseInt(t)); if (left - w &gt;= 0) takeStuff( left - w, val + v, allStuffs.filter((_, i) =&gt; i !== idx), result ); }); result.push(val); return;
} takeStuff(K, 0, stuffs, result);
console.log(Math.max(...result)); 해당 문제를 하위의 문제들로 나누어보면하나의 물건을 선택 -&gt; 총 무게에서 해당 무게를 뺀 무게에서 가능한 물건들을 모두 구하기해당 조건을 계속해서 반복해가면서, 바닥조건이 보일 때까지 반복하여 가치를 구해야 한다.
이러한 조건을 만족하기 위해서는 기존 내가 선택한 물건들에 대해서 어떤 물건을 이미 선택했는지를 알아야 하고, 현재까지 누적된 가치 또한 알아야 하기 때문에 나는 재귀적인 방식을 통해서 가치를 누적하면서도 모든 경우의 수에 대해서 배열에 넣어 해당 배열의 최댓값을 구하면 된다고 생각했다.하지만 이러한 완전탐색은 답은 맞지만 시간이 오래걸린다는 단점이 있다.따라서 해당 문제를 다이나믹 프로그래밍으로 다시금 접근해야 한다.let input = require("fs").readFileSync("/dev/stdin").toString().split("\n"); const [N, K] = input[0].split(" ").map(Number);
const stuffs = input.slice(1).map((line) =&gt; line.split(" ").map(Number)); const dp = Array(K + 1).fill(0); for (let i = 0; i &lt; N; i++) { const [w, v] = stuffs[i]; for (let j = K; j &gt;= w; j--) { dp[j] = Math.max(dp[j], dp[j - w] + v); }
} console.log(dp[K]);
해당 방식은 dp 테이블을 만들고 해당 테이블을 활용하는 방식이다.최대 K의 무게를 지닐 수 있을 때 가질 수 있는 최대의 가치를 dp[n] 에 기록해놓는다.
이후 만들어진 dp 테이블에 대해서 모든 물건들에 대해서 반복을 돌게 되는데, 하지만 이러한 물건에 대해서 그대로 dp 테이블을 도는 것이 아닌, 거꾸로 dp 테이블의 끝에서부터 해당하는 물건의 무게까지 dp 테이블을 돈다.
거꾸로 dp 테이블을 도는 이유는, 0부터 dp 테이블을 돌게 된다면 애초에 dp테이블의 w 이전 값들에 대한 값들은 전부 0이 될 수밖에 없다. n의 무게에서 최대로 가질 수 있는 가치를 기록해놓는 테이블이기 때문에 n 이전의 무게는 w가 더 무겁기 때문에 가치가 갱신될 것이 없다.테이블을 도는 과정에서 dp[n]에 있는 수는 Math.max를 통해 최댓값을 기존 dp에 있는 값과의 비교를 통해 가치가 현재가 더 크다면 업데이트를, 더 크지 않다면 기존 값을 선택해서 dp테이블의 값을 갱신시킨다. ]]></description><link>알고리즘/[백준-12865]-평범한-배낭.html</link><guid isPermaLink="false">알고리즘/[백준 12865] 평범한 배낭.md</guid><pubDate>Sun, 22 Sep 2024 12:08:56 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 주차 요금 계산]]></title><description><![CDATA[입차와 출차요금표입차된 후 출차 x -&gt; 23:59
00:00 ~ 23:59 입출차 내역을 바탕으로 차량별 누적 주차 시간 계산 및 요금 일괄 정산누적 주차 시간
기본 시간 이하 -&gt; 기본 요금
기본 시관 초과 -&gt; 기본 요금 + 초과한 시간에 대해서 단위 시간마다 단위 요금 시간 나눈 값에 올림 ]]></description><link>알고리즘/[프로그래머스]-주차-요금-계산.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 주차 요금 계산.md</guid><pubDate>Fri, 20 Sep 2024 07:31:36 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 행렬 테두리 회전하기]]></title><description><![CDATA[rows x columns 크기의 행렬
한 줄씩 순서대로 적혀있는 숫자들
이 행렬에서 직사각형 모양의 범위를 선택해 테두리 부분만 시계 방향으로 회전(x1,y1,x2,y2) -&gt; x1행 y1열부터 x2행 y2열까지의 직사각형에서 테두리 숫자들을 한칸씩 시계방향으로 회전
움직이는 것들(테두리에 있는 수들) x1, x2행의 y1~y2까지 모든 수들 x1~x2행의 y1과 y2들
어떻게 회전시킬 것이냐? y1, y2의 위치일 경우 y1, y2, 오른쪽 상단 -&gt; x1행의 y2일 경우 -&gt; x1 + 1행의 y2위치 오른쪽 하단 -&gt; x2-1행의 y2일 경우 -&gt; x2행의 y2위치로 순서대로 x,y의 배열 만들어놓기
queries forEach로 받기 save에 이동시킬 수 저장해놓기 ]]></description><link>알고리즘/[프로그래머스]-행렬-테두리-회전하기.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 행렬 테두리 회전하기.md</guid><pubDate>Thu, 19 Sep 2024 02:54:13 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 두 원 사이의 정수 쌍]]></title><description><![CDATA[r1과 r2가 주어지면, r1에 해당하는 원과 r2에 해당하는 원 사이의 공간에 x좌표와 y좌표가 모두 정수인 점의 개수를 리턴하는 문제일단 r1 &lt; r2의 관계이기 떄문에 R1과 r2사이의 정수 좌표는 8개를 디폴트로 하고 시작한다
상하좌우 x좌표와 y좌표에 걸쳐있는 쪽은 무조건 사이에 있으면서도 반지름이 정수이기 때문에 x좌표와 y좌표 모두 걸쳐져 있는 좌표가 정수로 되어있기 때문이다
그렇다면 그 사이에 있는 것들이 문제인데..<img src="https://i.imgur.com/LZDU4AA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
요렇게 생긴 두 원의 사이에서 해당 원은 무조건 원점을 기준으로 하는 원이기 때문에 4가지의 영역 모두 사이에 있는 정수 x, y좌표가 서로의 부호만 다를 뿐이지 사실상 절대값으로 따지면 모두 같은 위치이다.<br><img src="https://i.imgur.com/5oOg924.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
따라서 굳이 하나하나 다 구하기 보다는, 한쪽을 구해놓고 x4를 하는 편이 합리적으로 보인다.
그럼 이제 남은 문제는 이 사이의 값을 어떻게 구할 것이냐인데,,
더 큰 원을 지나는 x좌표와 y좌표를 모두 구한다? 1,000,000까지 반지름의 길이가 될 수 있는데 이걸 모두 구하는 것은 비합리적이라고 생각해서 일단 보류 큰 원 안의 정수 좌표들에서 작은 원의 조건을 뺀 다음 거리를 계산해서 원 세기 작은 쪽의 원의 반지름만큼의 길이를 가진 정사각형부터 시작한다면, 조건의 수를 확실히 줄일 수 있다 2번 방식대로 풀 경우,
작은 원의 반지름을 구해서 정사각형의 각 변부터 시작 (큰 원의 반지름 - 작은 원의 반지름)
x좌표와 y좌표를 하나씩 올려가면서 큰 원 안에 들어오는지 확인 큰 원 안에 들어오는 경우는 피타고라스의 정리를 이용하여 구한 대각선이 큰 원의 반지름보다 작아야 함 a^2 + b^2 = r^2
r^2 -a^2 = b^2]]></description><link>알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 두 원 사이의 정수 쌍.md</guid><pubDate>Wed, 18 Sep 2024 11:49:00 GMT</pubDate><enclosure url="https://i.imgur.com/LZDU4AA.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/LZDU4AA.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[프로그래머스] 방금그곡]]></title><description><![CDATA[자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악 찾기반복 재생 -&gt; 끝과 처음이 이어서 재생된 멜로디일 수도 있음
중간에 음악을 끊을 경우 곡이 다를 수도 있음
=&gt; 기억한 멜로디를 재생 시간과 제공된 악보를 보면서 비교
음악제목, 재생되고 끝난시간, 악보
음 -&gt; C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개
악보의 총 음 개수를 구한다
시 -&gt; 분으로 바꾼 뒤, 얼마만큼 재생이 되었는지 분단위로 파악한다
분단위로 파악한 뒤에는 기존 음악의 멜로디에 반복된 수만큼 악보 또한 반복해준 악보를 배열에 저장한다
배열을 돌면서 해당 문자열이 포함되어 있는지 검색한다
이 과정에서 #이 포함된 음정이 있을경우 이를 어떻게 포함해서 문자열에 만드느냐?]]></description><link>알고리즘/[프로그래머스]-방금그곡.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 방금그곡.md</guid><pubDate>Tue, 17 Sep 2024 09:52:09 GMT</pubDate></item><item><title><![CDATA[week4_3일차_PR]]></title><description><![CDATA[
옵저버 패턴 적용 - notify시 페이지별 컴포넌트 리렌더링
MVC 패턴 재구조화(싹 뜯어고침)
테스트 코드 작성 Jest 테스트코드
javascript class
옵저버 패턴
MVC 패턴
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/4-aba822d7763544a5ad64778df911c630?pvs=4" target="_self">https://luxurious-share-af6.notion.site/4-aba822d7763544a5ad64778df911c630?pvs=4</a> RangeError: Maximum call stack size exceeded 33 | } 34 | set title(title) { &gt; 35 | this.title = title; | ^ 36 | } 37 | set detail(detail) { 38 | this.detail = detail;
getter 함수와 setter 함수를 사용함에 있어서 자꾸 생성자를 통해 인스턴스를 만들려고 했지만 setter함수를 실행함으로써 에러가 발생했다.

무엇이 문제인지 테스트코드를 통해서 차근차근 분석해보았다.class Card { constructor({ id, author, created_at, title, detail, task_column, priority, }) { this.id = id; this.author = author; this.created_at = created_at; this.title = title; this.detail = detail; this.task_column = task_column; this.priority = priority; }
Card Class의 constructor는 새로운 객체를 만드는 과정에서 this.id = id, author 등을 실행한다.
title를 예로 들어보자면, this.title = id를 실행하는 과정이 사실상 id에 할당하는 과정과 같다는 점이다. set title(title) { this.title = title; }
이전에 내가 썼던 setter 함수이다.
보면 생성자에서 할당하는 과정과 같다.
그렇기에 this.title = title이라는 할당문은 setter함수를 실행시키고, 함수에서는 다시금 this.title = title을 실행시키면 setter 함수를 재귀적으로 호출하는 구조가 되어버렸다.이를 해결하기 위해 찾아본 결과 클래스의 getter,setter함수에서는 주로 property를 대시바(_)를 넣어 구분한다고 한다.get title() { return this._title; }
set title(title) { this._title = title
}
그냥 내가 함수덕후라 클래스를 많이 안 사용해봐서 멍청이슈였던걸로..처음에는 각각의 모든 컴포넌트에 대해서 리팩토링을 한 뒤, 컴포넌트 별로 상태를 관리할 수 있는 리액트의 useState, setState와 같이 유틸함수를 만들어 사용해볼까 하는 생각을 했었다.하지만 우리가 만들고 있는, 또한 내가 만든 프로젝트의 구조에서 옵저버 패턴을 각 컴포넌트마다 적용하는 것은 아래와 같은 이유에서 오버엔지니어링이라고 생각했다.
애플리케이션의 비즈니스 로직, 시나리오에 따라 지속해서 변경될 수 있고, 이를 시각적으로 표현해야 하는 데이터를 '상태'라고 생각했다. 해당 상태의 정의로 나의 프로젝트를 보았을 때, 정보 갱신이 이루어질 때는 api를 호출했을 때 이외의 상황에서는 개별적으로 상태 관리를 할 필요가 없어진다. 이에 굳이 필요할까? 하는 생각이 들었다.
따라서 나는 어떤 방식으로 현재 시각적으로 표현되어 있는 데이터들을 어떤 방식으로 옵저버를 관리하며, 정보 갱신이 일어났을 때 옵저버블에게 notify할 수 있을까? 를 고민했다....
function Main() { const observable = new Observable(); function render() { new Header(observable); new Mainsection(observable); fab.render(observable); EventManager.attachEvent("/main"); } return { render };
} export default Main(); 나는 컴포넌트 단위, 페이지 단위로 함수형을 만들고, 마치 컴포넌트처럼 렌더링하도록 로직을 구성했다.
여기서 나는 정보 갱신이 이루어졌을 때 함께 렌더링과 정보를 다시금 fetch해올 수 있는 컴포넌트에 대해서만 observable을 구독한 후에, api 호출 부분에서 기존에 가졌던 리렌더링 로직 대신 콜백함수로 observable에게 notify해주는 함수를 넣어주는 방식으로 리팩토링했다.function Section(observable) { observable.subscribe(render); async function render() { try { const { data, path } = await fetch(); console.log("section render:", data); const compiledFunction = window.pug.compile(template, { basedir: path, }); document.getElementById("sections").innerHTML = ""; data.forEach((section) =&gt; { const html = compiledFunction({ section: section }); // 렌더링된 HTML document.getElementById("sections").innerHTML += html; addTodo.render(section.classify); if (section.cards) card.render(document.getElementById(section.classify), section.cards); }); addcolumn.render(); } catch (error) { alert("카드 정보를 불러오던 중 에러가 발생했습니다."); } } render(); return { render, };
} export default Section; 이처럼 정보 갱신이 이루어진 후에, fetch를 다시 해옴으로써 정보를 확정적으로 보여줄 수 있는 db에서 가져와 띄워주는 render 함수를 옵저버블에 구독해주고, 갱신이 이루어졌을 때, 메인페이지의 경우 히스토리 창 안의 내용들과 카드들에 대해서 다시금 fetch해오고 정보를 최신 정보로 리렌더링 시킬 수 있도록 설계하였다.안녕하세요 멘토님!
저는 수,목 동안 서버의 구조를 리팩토링하는 작업을 주로 진행했습니다.
화요일 멘토님이 리뷰해주신 것을 보고 제 코드를 다시금 보니 기존에 모델에 대한 이해가 높지 않아 한 도메인에 대한 단일 비즈니스 로직이라고 생각을 했었던 점과 컨트롤러의 역할 자체가 서비스 로직을 담고 있었다는 점이 문제라고 생각했습니다.이에 개선한 서버의 구조를 간단히 말씀드리자면
컨트롤러 : 요청과 응답에 대한 단순 응답/요청 객체를 클라이언트/서비스에 전달
서비스: 일련의 비즈니스 로직들을 전부 수행
레포지토리 : db에 직접적인 접근 및 조작을 하는 계층으로 데이터 객체를 넘겨받고 데이터 객체를 리턴함
모델 : 해당 도메인에 대한 데이터를 객체로 다루며, 해당하는 데이터의 객체를 서비스에서 레포지토리로 전달하면서 데이터의 갱신을 담당
의 구조로 개선해 보았습니다.
개선한 구조에 대해서 멘토님의 간단한 피드백과 전체적인 코드에 대한 피드백 주시면 감사하겠습니다 :)
2주일동안 고생하셨습니다!
]]></description><link>부스트캠프/멤버십/4주차/week4_3일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/4주차/week4_3일차_PR.md</guid><pubDate>Thu, 12 Sep 2024 12:54:32 GMT</pubDate></item><item><title><![CDATA[week4_4일차_PR]]></title><description><![CDATA[
에러처리 보완 ✅ 2024-09-12
서버 요청 객체 유효성 검사 Validation Error 추가
에러별로 명시 명확화 클라이언트 에러화면 띄우기 각 코드에 따라 다른 메세지 띄우기 컬럼 추가 기능
테스트 코드 추가 express async middleware
FLUX 패턴
요청과 응답 객체
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/4-aba822d7763544a5ad64778df911c630?pvs=4" target="_self">https://luxurious-share-af6.notion.site/4-aba822d7763544a5ad64778df911c630?pvs=4</a>
클라이언트의 오류의 경우 각각의 오류에 대해 어떻게 처리해줘야 하는지에 대해 고민이 있었다.http 메서드를 실행하는 부분을 apicall이라는 유틸 함수로 만들었지만, 해당하는 함수를 이용하여 api를 호출하는 부분의 경우를 try~catch문으로 잡는다면 해당 유틸함수는 http 요청과 처리 두 가지 역할을 모두 한다는 점이 걸리기도 했고, http를 요청하고 받은 오류 중에서는 401 unauthorized나 400 Bad Request 등 400번대의 에러는 catch문으로 잡지 못한다는 단점이 있었다.import errorModal from "../errorModal/index.js"; function apiCall() { async function get(uri, eventHandler) { console.log("api_get", uri); const response = await fetch(uri, { method: "GET", }); if (!response.ok) handleError(response.status); const { data, path } = await response.json(); if (eventHandler) return eventHandler(); return { data, path }; } async function post(uri, body, eventHandler) { console.log("api_post", uri); const response = await fetch(uri, { method: "POST", headers: { "Content-Type": "application/json", }, body: JSON.stringify(body), }); if (!response.ok) handleError(response.status); if (eventHandler) return eventHandler(); } async function deleteMethod(uri, eventHandler) { console.log("api_delete", uri); const response = await fetch(uri, { method: "DELETE", }); if (!response.ok) handleError(response.status); if (eventHandler) return eventHandler(); } async function patch(uri, body, eventHandler) { console.log("api_patch", uri); const response = await fetch(uri, { method: "PATCH", headers: { "Content-Type": "application/json", }, body: JSON.stringify(body), }); if (!response.ok) handleError(response.status); const data = await response.json(); if (eventHandler) eventHandler(); return data; } function handleError(statcode) { const status = { 400: "내용을 다시 확인해주세요!", 401: "사용자 정보를 확인할 수 없어요ㅠ.ㅠ", 404: "요청한 데이터를 찾을 수 없어요ㅠ.ㅠ", 500: "서버 오류가 발생했어요 ㅠ.ㅠ", default: "예상치 못한 오류가 발생했어요 ㅠㅠ", }; throw new Error(status[statcode]); } return { post, get, deleteMethod, patch, };
} export default apiCall(); 이에 api를 요청하는 함수에서 try~catch문을 사용하고, api call의 경우는 fetch를 한 후 response.ok를 통해 200번대의 상태 코드로 반환되는 것들과 400번대의 오류를 구분하여 400번대 status code를 받았을 경우엔 error에 적절한 메시지를 넣어 던짐으로써 api 호출 함수의 catch문에서 잡을 수 있도록 하였다.import pug from "../utils/pugCompile.js";
import template from "./ui/index.js"; function errorModal(message) { function onCickHandler() { const button = document.querySelector( ".errorConfirmWrapper__button--conFirmButton" ); button.addEventListener("click", () =&gt; { document.querySelector(".errorModalBackground").remove(); }); } function render(message) { const component = pug.compiledToFunction(template); const modalWrapper = document.createElement("div"); modalWrapper.innerHTML = component({ message: message }); document.body.appendChild(modalWrapper); } render(message); onCickHandler(); return { render, };
} export default errorModal;
에러에서는 메세지를 catch문에서 error의 메세지를 errorModal에 넘기게 되면, 해당 메시지로 된 모달을 렌더링시키고 이에 맞는 이벤트 리스너를 등록해주는 로직을 함수형으로 실행될 수 있도록 하였다.]]></description><link>부스트캠프/멤버십/4주차/week4_4일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/4주차/week4_4일차_PR.md</guid><pubDate>Thu, 12 Sep 2024 12:27:27 GMT</pubDate></item><item><title><![CDATA[REST API]]></title><description><![CDATA[Representational State Transfer API의 약자로, 로이 필딩의 논문에서 소개되었다.REST API는
자원(Resource) - URI
행위(Verb) - HTTP METHOD
표현(Representations)
로 구성된다.
URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일REST는 무상태성 성격을 갖는다.
작업을 위한 상태 정보를 저장하고 관리하지 않기 때문에 세션 정보나 쿠키 정보를 별도로 저장하고 관리하지 않아 들어오는 요청만을 단순히 처리한다.
세션이나 쿠키를 관리하지 않음으로써 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해진다.HTTP의 웹표준을 그대로 사용하기 때문에 기존 인프라를 그대로 사용하는 캐싱 기능 등을 적용 가능하다. REST API 메시지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조로 되어 있다.REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션이나 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 구분되어 의존성이 줄어들 뿐만 아니라 클라/서버가 개발해야 할 내용이 명확해진다REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 한다.REST API 설계에 있어서 고려해야 할 중요 항목들은 몇 가지가 있다.GET /members/delete/1 리소스 명은 동사보다 명사 사용
자원을 표현하는데 집중
DELETE /members/1
GET /members
POST /members
PUT /members
<img src="https://i.imgur.com/brCZvOz.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">위와 같이 uri에 delete를 명시하는 것이 아닌 HTTP Method를 통해 이러한 자원에 대해 어떠한 행위, 즉 어떠한 조작을 할 것인지를 명시할 수 있도록 한다.http://restapi.example.com/animals/mammals/whales
왼쪽에서 오른쪽으로 갈수록 하위 계층을 나타내도록 해야 한다.
추가적으로
마지막 문자에 슬래시 포함하지 않음
하이픈을 통해 Url 가독성 높이기
언더바(_) 사용하지 않기
URI 경로에는 소문자 사용
파일 확장자는 URI에 포함 X (헤더를 통해 나타내기)
등이 있다.
REST 리소스 간에 연관 관계가 있을 경우 /리소스명/리소스ID/관계가 있는 다른 리소스명 의 순서대로 표현할 수 있도록 한다.GET: /users/{userid}/phone
GET: /users/{userid}/favorite/phone
이와 같이 관계명이 복잡할 경우에는 서브 리소스에 추가적으로 명시도 가능하다Collection은 복수, Document는 단수로 사용한다.
Collection vs. Document
Collection은 여러 개의 리소스를 모아 놓은 집합이고, Document는 이러한 Collection 내의 개별 리소스를 나타낸다.
ex) sports(Collection) - Soccer(Document)
]]></description><link>부스트캠프/챌린지/rest-api.html</link><guid isPermaLink="false">부스트캠프/챌린지/REST API.md</guid><pubDate>Wed, 11 Sep 2024 16:31:13 GMT</pubDate><enclosure url="https://i.imgur.com/brCZvOz.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/brCZvOz.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_4주차_마스터클래스]]></title><description><![CDATA[데이터를 눈으로 볼 수 없음. 뷰를 통해서 보는데 뷰는 다양한 형태
store(model) -&gt; view
모델이 여러개일 경우 이런저런 관계가 될 수 있음
애플리케이션이 간단할 때는 적합하지 않은 오버엔지니어링
복잡한 경우에는 모델과 뷰를 나눔
왜 나누느냐? 변경때문
서로 바뀔 때마다 바뀌어야 하기 때문에 모델과 뷰를 분리(변경이 자주 되는 부분을 분리)
여러개의 복잡한 관계 -&gt; 통신이 복잡해짐 -&gt; 중개자(Controller)를 두고 모델과 뷰를 나눠 의존도를 낮춤
store와 view를 어떻게 분리할 것인가? 에 대한 이야기view간에 바로 통신
todo라는 store를 분리해서 변경이 일어날 경우, store에 알려주고(통신이 일어남) -&gt; store가 다른 뷰에 알려줌view -&gt; store -&gt; view 관계의 흐름
변경을 일으키는 존재는 뷰나 컨트롤러를 통해 조작하고 통보해주고, 자동으로 렌더링
render함수를 등록class Observable { constructor() { this._observers = new Set(); } subscribe(observer) { this._observers.add(observer); } unsubscribe(observer) { this._observers.delete(observer); } notify(data) { this._observers.forEach(observer =&gt; observer(data)); }
} 생성자 구독 리스트를 보관 구독 뷰는 모델을 구독 해지
통보 구독 리스트를 돌면서 실행 M-V 관계에서 옵저버 패턴 적용
Model이 Observable이 되고 View가 Observer가 됨.
상태관리 뷰에서 상태를 분리
상태관리만 라이브러리에서 관리
프레임워크들이 상태에 대한 처리를 도와주기는 하는데 대부분이 옵저버 패턴과 유사함
store-view관계에서 뷰가 많을수록 옵저버 패턴이 유릭함 class TodoModel extends Observable { constructor() { super(); this.todos = []; } addTodo(todo) { this.todos = [...this.todos, todo]; this.notify(this.todos); // Observer들에게 업데이트된 todos 전달 }
}
프로토타입 체이닝을 통해 사용
데이터를 Immutable하게 변경
store가 옵저버를 구독하고 있다가 로그뷰에 쌓임
다른 뷰에서도 통신하여 업데이트에러처리의 목표 정하기
exception 에러처리
어떠한 상황에서 어떻게 하기 위함인지? 에 대한 목표를 가져야 함
에러 메커니즘에 대한 이해도 좋지만 목표 또한 중요
에러는 호출되는 지점에서 받기
콜백 안에서 실행한 비동기 코드는 잡지 못함
404는 코드지만 에러가 아님function renderError({ errorMsg }) { alert(errorMsg);
} async function getData() { try { const res = await fetch('https://httpstat.us/404'); if (!res.ok) { const status = res.status; if (status === 404) { renderError({ errorMsg: `요청주소에 문제가 있어요 ㅠ.ㅠ : ${status}` }); } else if (status === 401) { renderError({ errorMsg: `넌 누구니 ?? 🧐 : ${status}` }); } else { renderError({ errorMsg: `서버에 요청 중 문제가 생겼어요 &gt;.&lt; : ${status}` }); } return; } const data = await res.json(); renderPage(data); } catch (error) { // 네트워크 오류 renderError({ errorMsg: `네트워크 에러 발생: ${error.message}` }); }
} getData(); 여기서 400대 에러는 대부분 에러가 아님
status로 분기하여 에러를 처리해야함
메커니즘 던지는게 뭔지, 누가 받는지
try/catch문의 사용
비동기 코드는 안잡힘
await new Promise하는 방법으로 에러를 잡을 수 있음 모노레포
뷰 -&gt; 함수(역할을 줄이기 위함)
클래스 -&gt; 여러가지 기능의 복합체서버 안에 세션이 존재
세션이란? 서버에서 유지하는 사용자 연결 정보
사용자가 N명이 있을 경우 N개의 세션
세션의 경우 선택사항.게임의 관점에서
채널 -&gt; 서버 / 방 -&gt; 세션
매칭이되면 stateful한 연결 세션 아이디를 해시맵 | 오브젝트의 키값을 이용해 세션을 찾음
set cookie를 통해 브라우저의 쿠키 저장소에 저장
클라이언트를 요청을 보낼 때 헤더에 담아 보냄
same site에만 cookie가 유효함
프로토콜 도메인 포트 등 모두 같아야 함인증 -&gt; 권한부여 response를 json 형태의 바디로 보내줌
저장할 수 있는 곳 -&gt; 로컬스토리지나 세션스토리지
토큰은 요청에 따라서 미들웨어를 통해 세션 정보를 알아옴
리프레시와 엑세스JSON Web Token
세션을 쓸 수도 있고 안쓸 수도 있음
JWT는 토큰에 정보를 담을 수 있음
서버에 세션을 저장할 필요도 없이 그대로 해석할 수 있음
토큰에는 외부에서 봐도 괜찮은 정보(위변조를 알 수 있음)를 담음세션 없이 닉네임을 저장
-&gt; 확인해서 id,닉네밍 등을 토큰으로 만들어서 보내줌(JWT의 엑세스 토큰으로 만들어서 씀)
서버는 받아서 토큰을 받은 다음에 verify해야 함 signiture를 가지고 검증인프라 -&gt; 서버
개발 -&gt; 서버의 운용 -&gt; IDC(Internet Datat Center)에 서버를 입주시킴 -&gt; 서버에 아파치 설치 -&gt; WAS 설치 -&gt; 프록시(proxy)
포워드 프록시 외부에서 접근할 떄 서버의 주소를 모르게 함
사용자가 직접 서버로 요청을 했는데, 서버로 보내는 요청을 가로채서 처리 리버스 프록시 사용자가 프록시에 요청을 하면, 프록시가 전달해서 회신 서버가 하나 더 추가될 경우
-&gt; db를 분리해서 스위치(네트워크 2계층)을 사용해서 네트워크 통신
-&gt; 네트워크의 오버헤드
긴 쿼리 하나 사용 성능이 좋을 때가 많음
원하는 것만 가져오기 쿼리 자체가 복잡하고 잘 짜기 어려움
가독성과 유지보수가 낮음 짧은 쿼리 여러개 사용
- db랑 네트워크 통신 과정에서 Db의 부하가 적음
- 네트워크 부하의 가능성이 있긴 함
- 중간에 데이터가 더 커질 가능성
- 객체지향적
커서 기반 페이징(더보기)
서버 3대(기업의 최소한도)
-&gt; DB 이중화(필수)
-&gt; 복제된 DB는 장애가 났을 때 사용서버 4대
DB 이중화 + 웹 서버 추가(Nginx + WAS server + DB 2대)
리버스 프록시 -&gt; 사용자 요청이 Nginx로 들어감
Nginx+Was , Nginx + Was, DB1, DB2
사용자의 요청을 위해서는 로드 밸런서(L4,L7)가 필요. 라운드로빈으로 처리
L4 -&gt; 4계층(tcp) L7 -&gt; 7계층(http)
sticky session
우리나라에서 많이 사용
Read Replica를 통해 읽기 요청을 분산
세션을 복제하여 broadcast 하거나 별도의 세션 Db를 운용
<img src="https://i.imgur.com/yHPzfmy.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
프론트는 S3에 빌드된 결과물을 버킷에 넣고 CDN을 통해 들어옴
API Gateway<br>
<img src="https://i.imgur.com/9tfGkPj.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">msa -&gt; 자기만의 API와 db가 따로 있음 -&gt; 서버관리가 복잡해짐 -&gt; 쿠버네티스나 도커를 사용nvm으로 nodejs 설치
git clone으로 기존 레포 받아오기
git branch로 타겟브랜치 확인
npm install
npm start
보안그룹에 인바운드 3000번 추가
npm start
which bash &gt;&gt; deploy.sh
vi deploy.shgit fetch git pull LOCAL=`git rev-parse HEAD`
REMOTE=`git rev-parse origin/dev` if[[$LOCAL==$REMOTE]]; then echo "No need to deploy" exit 0
fi PID = `lsof -t -i :3000`
kill -9 $PID npm install
nohup npm start &amp; ...
crontab -e
vi
*/5 * * * mon-fri /path &gt;&gt; /home/ubuntu/log.txt 2&gt;&amp;1 #2번은 에러의 경우 같이 표준출력으로 갈 수 있도록 cd express-sample-deploy
터미널을 닫으면 sighupbash shell이 명령어를 실행하는 원리
pstree 명령어
systemd -&gt; 모든 프로세스의 조상
bash아래에 Pstree에 달려있기 때문에
bash가 fork -&gt; 2개
부모는 자식에게 명령어 실행하도록 fork됐던 pstree로 변신
복제 fork 실행 exec
deploy 명령어를 실행할 때도 npm start가 bash의 자식 프로세스 부모는 sshd
종료하면서 sshd의 자식프로세스를 모두 종료
터미널이 닫히면 sighup 발생
kill -&gt; 시그널을 보내는 명령어인데 defaultl가 sigterm
sig kill -&gt; 강제종료
sighup -&gt; 나 꺼지니까 너도 같이 꺼져
시그널의 디폴트 행동은 그냥 종료가 기본 동작이기 떄문에 터미널이 꺼지면 sighup이 자식 프로세스에게 퍼지고 자식 프로세스도 함께 죽어버림
nohup을 통해 자식 프로세스가 죽지 않고 백그라운드로 nohup npm start &amp;
죽일땐
ps -ef | grep npm
pid 찾아서 죽이기
or lsof -t -i :3000
-&gt; PID=lsof -t -i :3000
kill -9 $PID
or ps -ef | grep express | cut -d " " -f1cat nohup
npm start &amp;git rev-parse HEAD
git rev-parse origin/dev<br>
<img src="https://i.imgur.com/tm9bTIL.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>부스트캠프/멤버십/4주차/멤버십_4주차_마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/4주차/멤버십_4주차_마스터클래스.md</guid><pubDate>Wed, 11 Sep 2024 06:57:05 GMT</pubDate><enclosure url="https://i.imgur.com/yHPzfmy.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/yHPzfmy.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week4_2일차_PR]]></title><description><![CDATA[
커스텀 에러로 서버 에러 처리 ✅ 2024-09-10
기존 모델, 레포지토리, 컨트롤러 기능을 다시금 확인하고 기능에 맞게 리팩토링 ✅ 2024-09-10
옵저버 패턴으로 상태관리 설계 커스텀 에러 정리 ✅ 2024-09-10
상태관리 ✅ 2024-09-10
옵저버 패턴 ✅ 2024-09-10
Connection Pool의 경우 db에 연결된 Connection을 미리 만들어두고 Pool에 보관하였다가 필요할 때 Connection을 가져다가 사용한 후, 다시 Pool에 반환하는 기법이다.이러한 Connection Pool을 사용한 방식에서 한 컨트롤러에서 여러번 db에 접근할 때 Promise.all 을 사용하지 않은 이유에 대한 질문이 나왔다. async function getCard(username) { try { const cards = await cardModel.getCard(username); const columns = await columnModel.getColumn(username); const data = columns.map((col) =&gt; { return { classify: col.classify, cards: cards.filter((card) =&gt; card.task_column === col.classify), }; }); return data; } catch (error) { // 나중에 커스텀 에러로 고치기 throw new Error("에러"); } }
이러한 Promise.all의 경우 모든 비동기 처리에 대해서 수행을 병렬적으로 실행한다는 장점이 있었다. 하지만 이를 mysql에서 사용할 수 있을까에 대한 제대로 된 지식이 부족하여 제대로 대답하지 못했다.
찾아본 결과 Mysql은 멀티스레드 기반이기 때문에 connection 자체가 이러한 병렬 처리에 대해서 connection pool을 두고 병렬적으로 처리하는 프로미스 여러개일 경우를 각각의 connection이 두고 처리하는 방식이었기 때문에 Promise.all을 사용해도 상관 없을 뿐더러 추가적으로 성능 향상까지 가능할 수 있기 때문에 바꿔주었다.export default (function () { async function getCard(username) { try { const [cards, columns] = await Promise.all([ cardModel.getCard(username), columnModel.getColumn(username), ]); const data = columns.map((col) =&gt; { return { classify: col.classify, cards: cards.filter((card) =&gt; card.task_column === col.classify), }; }); return data; } catch (error) { // 나중에 커스텀 에러로 고치기 throw new Error("에러"); } }
이번에 커스텀 에러를 사용함으로써 어디에서 에러가 발생시키고, 어디서 받아야 할지에 대한 고민이 많았다.기존의 경우 데이터를 fetch 해오는 모든 경우(db연결, 레포지토리 등)에 대해서 try-catch문을 사용했지만 정작 이러한 catch문에서 console로 출력만 시킬 뿐 이에 대한 에러처리가 되어있지 않아 해당 프로미스를 호출하는 함수 내에서는 제대로 catch하지 못하는 문제가 발생했다.
따라서 이러한 에러를 언제 던지고 어디에서 이러한 에러를 받는지를 다시금 생각해야 할 필요성이 대두되었다.고민한 결과 db쪽에서 대부분 오류가 나는 현 상황을 고려하여 쿼리 실행문
connection 실행문
을 기준으로 커스텀 에러를 나누어 던지도록 설계했다.
const getConnection = async () =&gt; { try { const connection = await sql.getConnection(); return connection; } catch (error) { throw new DBConnectionError(error.message); }
}; export const transaction = async (logic, query) =&gt; { const connection = await getConnection(); try { await connection.beginTransaction(); const result = await logic(connection, query); await connection.commit(); return result; } catch (error) { console.log("error: rollback:", error.message); await connection.rollback(); throw new QueryError(error.message); } finally { console.log("release connection"); connection.release(); }
};
쿼리 실행문의 경우 transaction에서 try-catch문에서 쿼리를 실행하는 중 오류가 발생하면 QueryError를 던짐으로써 query를 실행하는 과정에서의 에러를 잡아 따로 던져주었고, try-catch문 밖에서 활용해야 하는 connection의 경우 async function getCard(...args) { try { const data = await transaction(cardRepository.getCardByUsername, args); return data; } catch (error) { handleDBError(error); } }
각 모델에서 트랜잭션을 하는 일련의 과정에서 생기는 DBConnectionError와 QueryError를 모두 여기서 캐치하여 하나의 에러로 감싸는 형태로 고안했다.export class DBConnectionError extends Error { constructor(message) { super(message); this.name = "DBConnectionError"; }
}
export class QueryError extends Error { constructor(message) { super(message); this.name = "QueryError"; }
} export class DBError extends Error { constructor(message, cause) { super(message); this.status = 500; this.cause = cause; this.name = "DBError"; }
} export function handleDBError(err) { if (err instanceof QueryError) { throw new DBError("Server Error", err); } else if (err instanceof DBConnectionError) { throw new DBError("Server Error", err); } else { throw new DBError("Server Error", err); }
} 이렇게 각각의 부분에 대해 연결에서 생기는 오류와 쿼리문을 실행할 때 생기는 커스텀 에러를 만들고, 이 둘을 모두 묶어 하나의 에러로 관리할 수 있는 DBError를 만들어 이를 던져 Controller에서 받을 수 있도록 하였다. async function getCard(username) { try { ... } catch (error) { throw error; } }
컨트롤러에서 받은 에러의 경우 현재까지는 DBError밖에 없지만, 나중에 ValidationError와 같은 예외들을 잡아 던질 수 있기 때문에 컨트롤러는 각 종류의 에러를 받아 다시금 router에게 던진다.router.get("/", isLoggedIn, async (req, res, next) =&gt; { try { let todoData = await cardController.getCard(req.user.username); res.status(200).json({ data: todoData, path: process.env.DIRNAME }); } catch (error) { next(error); }
});
router에서 다시금 잡은 에러는 next를 통해 다음 미들웨어로 넘어가게 하는데, 다음 미들웨어는 에러 처리를 위한 미들웨어이다.export default function errorMiddleWare(app) { app.use((err, req, res, next) =&gt; { console.error(err); res.status(err.status).json(err.message); });
}
에러 미들웨어의 경우 아직까지는 간단하게 구현하였다. error의 property로 설정한 status코드와 에러 메세지를 반환하도록 하였다.안녕하세요 멘토님. 고생 많으십니다.
어제오늘동안 저는 MVC 패턴에 대해 다시금 학습하고 이를 직접 프로젝트에 적용해보는 시간을 가졌습니다. 하지만 해당 패턴을 공부하면서도 아직까지도 이를 제대로 설계했는지 확신이 들지 않아 이러한 부분을 리뷰 요청 드리려 합니다.제가 리뷰 요청드리는 부분은 다음과 같습니다.이번에 서버의 구조를 바꾸면서 각 디렉토리 구조 또한 아래와 같이 바꾸었습니다
Controller 라우터 디렉토리 각 api 요청에 대한 라우터를 도메인별로 설정 도메인별 controller 파일 model에 해당 데이터를 제어하도록 전달 각 도메인별 비즈니스 로직을 수행하고, 여러 도메인별 비즈니스가 겹쳐져 있는 경우 해당 컨트롤러에서 제어하여 알맞은 데이터를 리턴하도록 변환 Model 도메인별 모델파일을 담음
레포지토리에 의존하여 데이터에 접근하는 단일 비즈니스 로직을 수행
레포지토리 디렉토리 db에 직접적으로 접근하여 데이터를 제어함 View 레이아웃을 제외하고 클라이언트 측에서 모두 처리 따라서 현재 구조는 api 요청 -&gt; router -&gt; controller(통합 비즈니스 로직) -&gt; model(개별 비즈니스 로직) -&gt; repository 순으로 접근하여 데이터에 접근하고 제어하는 과정을 거치게 됩니다.
또한 이 과정에서 db에 접근하여 쿼리를 수행하던 중 생기는 에러와 db에 connection을 생성하는 과정 중에 생긴 에러를 커스텀 에러로 처리하여 router에서 받은 뒤, 미들웨어를 통해 에러를 response로 보내도록 설계하였습니다.
설계한 구조와 에러처리 부분에 대해서 보완할 부분 피드백 주시면 감사하겠습니다!]]></description><link>부스트캠프/멤버십/4주차/week4_2일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/4주차/week4_2일차_PR.md</guid><pubDate>Tue, 10 Sep 2024 11:33:56 GMT</pubDate></item><item><title><![CDATA[커스텀 에러 만들기]]></title><description><![CDATA[서버와 클라이언트 모두 프로젝트 과정에 있어서 에러처리는 중요하다.
try~catch 문을 통해 우리는 에러를 잡고, throw를 통해서 에러를 던지기도 한다.
하지만 error의 constructer로 들어가는 인자는 message 하나로, 모든 에러를 Error로만 사용하면 어떤 에러가 발생하는지에 대한 예측이 힘들 뿐더러, 메세지 하나로 에러의 모든 사항에 대해 말해야 하기 때문에 매번 메세지를 넣어야 하는 번거로움이 생긴다.
이러한 문제를 해결하기 위해 기존의 Error를 상속받아 커스텀 에러 클래스를 만듦으로써 어디에서 에러가 발생했는지를 명확하게 명시하고 관리해야 한다.class Error { constructor(message) { this.message = message; this.name = "Error"; // (name은 내장 에러 클래스마다 다릅니다.) this.stack = &lt;call stack&gt;; // stack은 표준은 아니지만, 대다수 환경이 지원합니다. }
}
기존의 에러는 이런 식으로 생겼다. message, name, stack 프로퍼티만을 가진다.
이 에러의 간단한 구조는 나중에 super()를 통해 상속받는 클래스의 생성자를 호출하기도 쉽다export class DBError extends Error { constructor(message) { super(message); this.name = "DBError"; }
}
이런 식으로 DB에러의 경우는 Error 객체의 name property를 바꿔줌으로써 어디서 문제가 생겼는지에 대해서 명확히 할 수 있다.]]></description><link>부스트캠프/챌린지/커스텀-에러-만들기.html</link><guid isPermaLink="false">부스트캠프/챌린지/커스텀 에러 만들기.md</guid><pubDate>Tue, 10 Sep 2024 04:48:55 GMT</pubDate></item><item><title><![CDATA[week4_1일차_PR]]></title><description><![CDATA[
MVC 패턴 ✅ 2024-09-09
커스텀 에러 ✅ 2024-09-09 커스텀 에러로 서버 에러 처리
SQL문 수정 ✅ 2024-09-09
MVC 패턴을 보다 세부적으로 설계해서 model 고치기 ✅ 2024-09-09 nginx
커스텀 에러
MVC 패턴
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/4-aba822d7763544a5ad64778df911c630?pvs=4" target="_self">https://luxurious-share-af6.notion.site/4-aba822d7763544a5ad64778df911c630?pvs=4</a>
<br><img src="https://i.imgur.com/nqMwAVH.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
MVC 패턴의 경우 Model, VIew, Controller가 주가 되어 이 세가지 요소를 통해서 느슨한 결합을 이루게 된다.(service, repository 등은 그때마다 취사선택해서 사용하는 것으로 보인다)
이 느슨한 결합은 Contoller가 중간자로서의 역할을 제대로 수행해야만 결합 관계가 느슨해지게 되는데, 나와 같은 경우 Model과 Controller의 관계가 모호했다.먼저 나의 Controller의 경우, Route와 Repository가 모두 해당 디렉토리 안에 들어가있었으며, model은 repostiory를 통해서 직접적으로 db에 연결하는 과정을 다루어야 하지만 나는 그대로 routes에서 레포지토리에 접근했으며, model은 내가 원하는 데이터의 가공 정도만을 기능했다. 하지만 사실상 나의 구조에서의 MVC 패턴은 꼬인 관계가 되어버렸다. 이에 MVC 패턴을 더 충실히 따르면서도 느슨한 결합을 유지할 수 있도록 다시 설계했다.
Controller 라우터 디렉토리 각 api 요청에 대한 라우터를 도메인별로 설정 도메인별 controller 파일 model에 해당 데이터를 제어하도록 전달 Model 도메인별 모델
레포지토리에 의존하여 데이터를 가져옴
레포지토리 디렉토리 db에 직접적으로 접근하여 데이터를 제어 View 레이아웃을 제외하고 클라이언트 측에서 모두 처리 따라서 현재 구조는 api 요청 -&gt; router -&gt; controller -&gt; model -&gt; repository 순으로 접근하여 데이터에 접근하고 제어하는 과정을 거치게 된다.]]></description><link>부스트캠프/멤버십/4주차/week4_1일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/4주차/week4_1일차_PR.md</guid><pubDate>Mon, 09 Sep 2024 09:21:15 GMT</pubDate><enclosure url="https://i.imgur.com/nqMwAVH.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/nqMwAVH.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_4주차_주간계획]]></title><description><![CDATA[
MVC 패턴
커스텀 에러 커스텀 에러로 서버 에러 처리
MVC 패턴을 보다 세부적으로 설계해서 model 고치기 옵저버 패턴 클라이언트를 옵저버 패턴을 활용한 spa로 리팩토링 미들웨어
테스트코드 미들웨어를 활용하여 기존 코드 리팩토링
테스트 코드 작성 테스트 코드 전체적인 코드 흐름을 보고 고칠 것들 고치기
]]></description><link>부스트캠프/멤버십/4주차/멤버십_4주차_주간계획.html</link><guid isPermaLink="false">부스트캠프/멤버십/4주차/멤버십_4주차_주간계획.md</guid><pubDate>Mon, 09 Sep 2024 07:04:14 GMT</pubDate></item><item><title><![CDATA[멤버십_4주차_학습정리]]></title><link>부스트캠프/멤버십/4주차/멤버십_4주차_학습정리.html</link><guid isPermaLink="false">부스트캠프/멤버십/4주차/멤버십_4주차_학습정리.md</guid><pubDate>Mon, 09 Sep 2024 03:53:46 GMT</pubDate></item><item><title><![CDATA[멤버십_4주차]]></title><description><![CDATA[<a data-href="멤버십_4주차_학습정리" href="부스트캠프/멤버십/4주차/멤버십_4주차_학습정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_4주차_학습정리</a><br>
<a data-href="멤버십_4주차_주간계획" href="부스트캠프/멤버십/4주차/멤버십_4주차_주간계획.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_4주차_주간계획</a><br>
<a data-href="멤버십_4주차_마스터클래스" href="부스트캠프/멤버십/4주차/멤버십_4주차_마스터클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_4주차_마스터클래스</a><br>
<a data-href="멤버십_4주차_특강" href=".html" class="internal-link" target="_self" rel="noopener nofollow">멤버십_4주차_특강</a><br>
<a data-href="멤버십_4주차_체크포인트" href=".html" class="internal-link" target="_self" rel="noopener nofollow">멤버십_4주차_체크포인트</a><br><a data-href="week4_1일차_PR" href="부스트캠프/멤버십/4주차/week4_1일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week4_1일차_PR</a><br>
<a data-href="week4_2일차_PR" href="부스트캠프/멤버십/4주차/week4_2일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week4_2일차_PR</a><br>
<a data-href="week4_3일차_PR" href="부스트캠프/멤버십/4주차/week4_3일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week4_3일차_PR</a><br>
<a data-href="week4_4일차_PR" href="부스트캠프/멤버십/4주차/week4_4일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week4_4일차_PR</a>]]></description><link>부스트캠프/멤버십/4주차/멤버십_4주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/4주차/멤버십_4주차.md</guid><pubDate>Mon, 09 Sep 2024 03:53:36 GMT</pubDate></item><item><title><![CDATA[aws 배포]]></title><description><![CDATA[aws 배포를 하게됐다
이전까지는 프론트만 배포하는걸 해봤었는데, 프론트와 서버를 합친 풀스택으로 프로젝트를 배포해보는 좋은 경험을 얻게 되었다.
서버는 express, db는 mysql, 클라이언트는 서버사이드 렌더링 + 클라이언트 사이드 렌더링으로 된 프로젝트로, 내가 실질적으로 서버를 가동시켜야 하는 것은 mysql과 express가 있었다.
mysql같은 경우는 mysql-server를 통해 쉽게 db를 계속 돌릴 수 있었다.
하지만 express의 경우 한번도 안해봤다는게 문제,,,라서 나중에라도 까먹을까봐 배포한 과정을 적어놓으려 한다.
거두절미하고 스타트인스턴스 생성 과정에서는 생성 후에 미리 탄력적 ip(elastic ip)를 만들어 할당해놓자.
나중에 만들지 않으면 다시금 접속하는 과정이 귀찮다.ec2 콘솔의 메뉴에서 Elastic IP addressses -&gt; Allocate Elastic IP address 를 통해 고정적으로 IP를 할당해준다. 설정하지 않을 경우 인스턴스 재실행마다 ip가 바뀔 수 있기때문에 고정적인 ip를 사용하는 것이 낫다
<img src="https://i.imgur.com/bFiJ458.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">탄력적 IP가 만들어졌으면 Actions -&gt; Associate Elastic IP Address 를 통해 인스턴스에 할당해준다.ssh 연결은 ec2 인스턴스를 사용한다면 꼭 필요하다
매번 aws 들어가서 할 것도 아니고 애초에 설정 자체가 어렵지 않다
ec2 생성할 때 만든 키페어를 가지고ssh -i 키페어.pem Username@PublicIP
를 통해 연결해준다.<br>
<img src="https://i.imgur.com/O8ONpKJ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
그럼 이런 식으로 연결이 된다의 경우 이 링크를 참고도 이 링크를 참고git clone 레포지토리 주소
나는 private repository로도 한번 만들어 봤는데, 이러한 레포지토리를 clone하기 위해서는 계정 정보 인증이 필요하다.나는 access token을 부여해서 해당 토큰을 비밀번호로 사용하는 방식을 택했다.settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Fine-grain tokens에 들어가 새롭게 토큰을 발급해주고, 적당한 권한을 설정해준 뒤에 git clone할 때 유저네임을 입력 후 비밀번호 입력란에 발급된 토큰을 입력해주면 clone할 수 있다.mvm(node.js 버전 매니저)를 이용해서 node와 딸려오는 npm을 다운로드 할 수 있다.# installs nvm (Node Version Manager)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash # download and install Node.js (you may need to restart the terminal)
nvm install 20 # verifies the right Node.js version is in the environment
node -v # should print `v20.17.0` # verifies the right npm version is in the environment
npm -v # should print `10.8.2`
$ sudo apt-get update
$ sudo apt-get install nginx
아래는 잘 설치되었나 버젼 확인하는것
$ sudo nginx -v
공식 NGINX 리포지토리에서 미리 빌드된 우분투 패키지 설치
$ sudo wget https://nginx.org/keys/nginx_signing.key nginx stop: 빠른 종료
nginx quit: 정상종료
nginx reload: 구성파일 다시 로드
nginx reopen: 로그파일 다시열기
nginx restart: 재시작
nginx를 설치하고 제대로 작동을 시키기 위해서는 nginx의 환경을 설정해줘야 한다.sudo vi /etc/nginx/sites-available/default
nginx.conf를 통해 Include된 서버 설정 관편 파일을 vi 에디터를 통해 수정해준다.server { listen 80 default_server; listen [::]:80 default_server; ... server_name 서버이름 location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. proxy_pass http://127.0.0.1:3000; proxy_http_version 1.1; }
...
} server_name 서버이름; 이 서버 도메인으로 들어오는 요청을 처리한다.
해당 도메인으로 접근할 때 Nginx가 이 설정을 사용한다 location / { ... } location /은 모든 루트 경로 (/)로 들어오는 요청을 처리 proxy_pass http://127.0.0.1:3000; 들어오는 요청을 127.0.0.1:3000으로 프록시(전달)한다
나는 서버를 돌릴 때 3000 포트로 돌렸기 때문에 3000포트로 프록시를 전달하도록 했다 proxy_http_version 1.1;
- Nginx가 프록시 요청을 보낼 때 HTTP 1.1 버전을 사용하도록 지정
변동 사항을 적용시키기 위해서는 재시작 해준다.
sudo systemctl restart nginx
pm2는 프로세스 관리자로 Node.js로 만들어진 프로그램의 프로세스를 편리하게 관리할 수 있도록 도와주며 아래와 같은 기능을 제공한다.
프로그램 종료시 자동 재시작
코드 변경 시 프로세스 재시작
로그 화면 지원
먼저 전역적으로 Pm2 사용을 위해 설치해준다.
$ npm install pm2 -g
슬만한 명령어는 이정도가 있다
pm2 start [name] : 시작
pm2 list : 목록
pm2 stop id|name|namespace|all|json|stdin : 종료
pm2 delete id|name|namespace|all|json|stdin : 제거
pm2 start [name] --watch : 코드 변경시 프로세스를 재시작
pm2 log : 로그 확인
]]></description><link>부스트캠프/멤버십/3주차/aws-배포.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/aws 배포.md</guid><pubDate>Sun, 08 Sep 2024 13:39:41 GMT</pubDate><enclosure url="https://i.imgur.com/bFiJ458.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/bFiJ458.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_3주차_체크포인트]]></title><description><![CDATA[
Promise 패턴을 활용한 코드 사용(setTimeout 또는 fetch API)
-then과 catch 메서드를 활용해서 구현 fetch API를 활용해서 GET/POST 요청 보내기 성공 async 함수를 활용 렌더링 작업에서 template literal 방식을 적극 활용
반복적인 DOM 탐색 작업을 줄이려는 시도 해체활용(destructuring) 문법활용
spread operator, rest parameter, optional chaining 중 한가지 이상 사용 경험 배열의 고차함수, 비동기 함수(setTimeout, addEventlistener, then)에 전달되는 콜백함수를 별도로 분리해서 선언 함수이름은 동사+명사 형식, 변수는 명사로 '의도'를 충분히 알 수 있는 네이밍으로 구현
들여쓰기가 3-4단계로 되어 있는 코드를 줄이려는 본인만의 시도 Promise패턴의 resolve, reject, then메서드를 중심으로 동작과정을 설명해 보세요. promise는 fulfilled(완료), pending(대기), rejected(거부)의 상태로 나뉜다. 프로미스 객체를 반환하게 되면 무조건 pending 상태로 시작하게 되는데, pending 상태에서 거부와 완료 상태로 나누어 해당 결과가 나올때까지 비동기적으로 기다린 후 이러한 결과에 대해서 then 안에 이벤트 핸들러를 실행해줌으로써 promise작업이 resolve된 후 비동기적으로 이벤트를 실행한다. 하지만 resolve가 아닌 reject가 될 경우에는 catch문으로 가서 해당 예외에 대한 처리를 하거나, 에러 핸들러를 then에 같이 넣어줌으로써 비동기적으로 reject가 일어난 후 이벤트를 실행시키는 방향으로 동작시킬 수도 있다. 쿠키와 세션으로 로그인 및 인증 구현 외부 모듈 설치 없이 기본 Node.js와 Express 만으로 인증 구현 또는 passport의 동작을 이해하고 passport-local을 이용해서 로그인 구현 가상 서버에 배포 수행 별도의 자동화 도구를 사용하지 않고 직접 리눅스 명령어를 이용해서 배포 수행 인증(Authentication)과 인가(Authorization)가 무엇인지 설명해 보세요.
인증은 식별된 사용자가 자기 자신임을 인증하는 과정이며, 해당 과정에서 해당 사용자에 대해 사실이라고 주장하는 부분에 대해 검증하는 단계이다. 반면 인가의 경우는 신원에 따라 접근 권한을 부여하는 것으로, 인증과 인가는 서로 다른 개념이다.
세션이 무엇인지 설명해 보세요. 세션은 클라리언트로부터 오는 일련의 요청을 하나의 상태로 보고 그 상태를 일정하게 유지하는 기술이다. 이러한 세션의 단위는 클라이언트가 웹 서버에 접속하고 있는 상태별로 단위를 가진다.
세션은 웹 서버에 클라이언트의 상태를 유지하기 위한 정보를 저장 및 유지하고, 클라이언트에 고유 ID를 부여한 다음 요청이 오면 이에 대해 인증하는 과정을 거친다. 웹 로그인 과정에서 쿠키가 필요한 이유를 설명해 보세요. 웹 로그인 과정에서 쿠키는 정보를 유지하기 위해 필요하다. 세션은 연결된 자체만으로는 이를 제대로 확인할 수 없기 때문에 식별 가능한 정보를 가지고 해당 유저가 현재 세션을 유지하고 있는지에 대해서 확인할 방법이 필요하다. 이를 위해서 사용하는 것이 쿠키이다.
쿠키는 사용자의 컴퓨터, 즉 브라우저에 저장하는 작은 기록을 담고 있는데, 이러한 정보를 로그인 요청이나 다른 api 요청 과정에서 함께 보내면서 매 요청마다 인증 및 인가를 검사하는 과정을 거쳐야 한다. 이렇게 서버에서만이 아니라 클라이언트에서도 유지되어야 하는 세션ID와 같은 것들을 사용자의 브라우저에 저장시킴으로써 세션을 유지시키고, 브라우저로 요청으로부터 적당한 정보를 제공받아 서버는 이에 따른 처리를 할 수 있다. bash 셸에서 linux 명령어를 실행할 경우 OS 내부에서 일어나는 일을 설명해 보세요. 명령어 실행 과정은 가장 먼저 명령어를 파싱하면서 해석하는 과정을 거친다. 파싱을 통해 적절한 명령어를 실행하고 이 과정에서 리눅스 명령어에 해당하는 내장 명령어가 있다면 이를 실행하지만 없다면 환경변수를 참조하여 해당 경로에서 실행파일을 찾는다.
명령어를 찾은 후에는 새로운 프로세스가 생성된다. 해당 과정에서 자식 프로세스를 통해 이러한 실행 파일에 대해 실행하거나 명령어에 따른 작업을 수행한다. 작업이 끝난 후에는 자식 프로세스를 종료시키고 부모 프로세스 또한 자식 프로세스의 상태를 보고 종료시키며, 종료시킨 후에는 프롬프트로 돌아가게 된다. SSH로 접속한 클라이언트를 종료하자 서버 프로세스도 함께 종료되었습니다. 왜 그런 걸까요? 이러한 현상의 이유는 시그널에 의해 발생되는 것으로, ssh로 접속한 클라이언트가 종료될 시에 해당 서버에 sighup이라는 시그널을 보내게 되는데, 이 설정을 받으면 서버의 프로세스들도 종료하는 설정이 되어있어 서버의 프로세스도 함께 종료되는 것이다. 이를 위해서는 nohup 명령어를 통해 ssh 연결 종료가 발생하더라도 sighup 시그널을 받지 않도록 해야한다. <a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@captain-yun/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A5%BC-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-%EC%9B%90%EB%A6%AC-feat.%EC%85%B8" target="_self">https://velog.io/@captain-yun/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A5%BC-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-%EC%9B%90%EB%A6%AC-feat.%EC%85%B8</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://computing-jhson.tistory.com/126" target="_self">https://computing-jhson.tistory.com/126</a>]]></description><link>부스트캠프/멤버십/3주차/멤버십_3주차_체크포인트.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/멤버십_3주차_체크포인트.md</guid><pubDate>Sun, 08 Sep 2024 12:11:54 GMT</pubDate></item><item><title><![CDATA[mysql Join]]></title><description><![CDATA[JOIN은 데이터베이스 내의 여러 테이블에서 가져온 레코드를 조합하여 하나의 테이블이나 결과 집합으로 표현해 준다.
관계형 데이터베이스에서는 가장 많이 쓰이는 기능으로, 집합의 개념으로 이해하고 보면 쉽다<img src="https://i.imgur.com/ubMaryV.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/T8Vp6Vh.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
조인하는 테이블의 ON절의 조건이 일치하는 결과만 출력한다.
교집합이라고 생각하면 편하다
mysql에서는 JOIN, INNER JOIN, CROSS JOIN이 같은 의미로 사용 된다
select a.userid, name
from users as a inner join history as b
on a.userid = b.userid
where a.userid = "1"
두 개의 테이블을 비교할 때는 각 테이블을 식별하는 변수? 를 as로 지정한 뒤에 조인을 할 때 접근자를 통해서 각 테이블을 식별할 수 있도록 한다!select a.userid, name
from users a, history b
where a.userid = b.userid and a.userid ="1"
<br><img src="https://i.imgur.com/yq2y9Eg.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/rX0UgX8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
두 테이블이 합쳐질 때 왼쪽/오른쪽을 기준으로 방향을 정하고, 정한 방향의 컬럼은 모두 가져온다
한마디로 on 조건에서 설정한 조건에서 한 방향의 데이터를 다 가져온다는 소리다
OUTER JOIN은 LEFT/RIGHT OUTER JOIN, FULL OUTER JOIN이 있다.
대부분 LEFT OUTER JOIN을 많이 사용하는데, 왼쪽을 방향으로 잡는 이유는 데이터를 읽는 구조 등의 연관이 있다.처음에 조인할 때 쓸 테이블을 왼쪽에 두고 LEFT JOIN하는 방식으로 하게 되면 데이터 또한 왼쪽 -&gt; 오른쪽으로 엑세스하기 때문에 일반적으로 우리가 글을 읽는 방식처럼 위 -&gt; 아래의 순서대로 데이터를 읽게 된다. 그렇기 때문에 보다 일반적인 방식으로 LEFT JOIN을 사용하여 가장 많은 열을 가져와야 할 테이블을 왼쪽에 우선적으로 적어준다-- 예) 1학년 학생의 이름과 지도교수명을 출력하라. 단, 지도교수가 지정되지 않은 학생도 출력되게 하라. SELECT STUDENT.NAME, PROFESSOR.NAME FROM STUDENT LEFT OUTER JOIN PROFESSOR -- STUDENT를 기준으로 왼쪽 조인
ON STUDENT.PID = PROFESSOR.ID WHERE GRADE = 1
-- 예) 1학년 학생의 이름과 지도교수명을 출력하라. 단, 지도교수가 지정되지 않은 학생도 출력되게 하라. SELECT STUDENT.NAME, PROFESSOR.NAME FROM STUDENT RIGHT OUTER JOIN PROFESSOR -- PROFESSOR를 기준으로 오른쪽 조인
ON STUDENT.PID = PROFESSOR.ID WHERE GRADE = 1
3개의 테이블을 조합해야 할 때는 outer join을 연속으로 3번 사용하면 된다.-- 3개의 테이블을 join하고 한국에대한 정보만 뷰로 생성해라 create view allView as ( select A.Name, A.CountryCode from city A left join country B on A.countrycode = B.code -- 테이블 2개 조인 완료 left join countrylanguage C on B.code = C.countrycode -- 테이블 3개 조인 완료 where A.countrycode in ('KOR'); )
<br><img src="https://i.imgur.com/KsP0LXn.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">full outer join은 두 테이블의 합집합이다.
하지만 full outer join같은 경우 대부분 db가 지원하지 않기 때문에 Union을 활용하여 간접적으로 구현한다.-- full outer join
select * from topic FULL OUTER JOIN autor on topic.auther_id = authoer.id -- 같은구문
(select * from topic LEFT JOIN autor on topic.auther_id = authoer.id)) UNION (select * from topic RIGHT JOIN autor on topic.auther_id = authoer.id))
UNION은 여러 개의 SELECT문의 결과를 하나의 테이블이나 결과 집합으로 표현할 때 사용한다.
⚠️ 이 때 각각의 SELECT문으로 선택된 필드의 개수와 타입은 모두 같아야 하며, 필드의 순서 또한 같아야 한다.
⚠️ 기본 집합 쿼리에는 중복 제거가 자동 포함되어 있다.
SELECT 필드이름 FROM 테이블이름
UNION
SELECT 필드이름 FROM 테이블이름
UNION은 DISTINCT 자동 포함이라 중복되는 레코드를 제거하기 때문에, 중복되는 레코드까지 모두 출력하고 싶다면 ALL 키워드를 붙이면 된다.SELECT 필드이름 FROM 테이블이름
UNION ALL
SELECT 필드이름 FROM 테이블이름
<br><img src="https://i.imgur.com/xtQFPFY.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">EXCLUSIVE LEFT JOIN은 A의 여집합과 같은 느낌이다.
조건에 해당하는 것을 제외하고 특정 테이블에 있는 레코드만 가져온다.
EXCLUSIVE JOIN도 LEFT/RIGHT가 나뉘어져 있는데, 방향에 따라 한쪽의 데이터만 가져온다SELECT * FROM table1 A LEFT JOIN table2 B
ON A.ID_SEQ = B.ID_SEQ WHERE B.ID_SEQ IS NULL -- 조인한 B 테이블의 값이 null만 출력하라는 말은, 조인이 안된 A 레코드 나머지값만 출력하라는 말
자체 조인(SELF JOIN)은 테이블 자기 자신을 조인하는 것이다.<br>
<img src="https://i.imgur.com/usk4Gfy.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">SELECT E.NAME as Name, M.NAME as Secret_Santa
FROM Santa E, Santa M -- inner join
WHERE E.Santa_Color = M.Color; JOIN시 먼저 엑세스돼서 ACCESS PATH를 주도하는 테이블
어디의 데이터부터 출발해서 값을 찾느냐에 따라 성능을 좌지우지한다. 대표적인 예로
(조건을 만족하는)5000만건의 데이터 A 테이블 (조건을 만족하는)1000건의 데이터 B 테이블 이 두개가 있을 때 조인 과정에서 A테이블에 먼저 엑세스하면 5000만번을 탐색하고
B테이블에 엑세스하면 1000번의 엑세스만으로 탐색이 완료된다는 차이를 든다.
따라서 우리는 조인을 할 때 보다 적은 데이터의 양이 들어갈 확률이 높은 테이블에 대해서 드라이빙 테이블로 설정해야 할 필요성이 있다.(물론 관계도 고려해야겠지만)규칙 기반 옵티마이저(Rule-Based Optimizer)에서는 연산자, 인덱스 유무, 조건절 형태 등 정해진 규칙의 우선순위에 따라 실행 계획을 생성한다. 인덱스를 이용한 액세스 방식이 전체 테이블 액세스 방식보다 우선순위가 높음 조인 칼럼에 대한 인덱스가 양쪽 테이블에 모두 존재할 때, 우선순위가 높은 테이블을 선택 조인 칼럼에만 인덱스가 존재하는 경우에는 인덱스가 없는 테이블을 먼저 선택하여 조인 수행 만약 조인 테이블의 우선순위가 동일하지않다면, FROM 절에 나열된 테이블의 역순으로 수행
하지만 최근에는 비용기반 옵티마이저(Cost-Based Optimizer)를 채택한다.
비용기반 옵티마이저는 쿼리를 수행하는데 소욕되는 예상 비용을 바탕으로 실행 계획을 생성한다.실행 계획은 인덱스를 기준으로 나뉜다.
인덱스가 있을 경우 인덱스가 있는 테이블은 데이터 조회 시 풀 스캔이 일어나지 않기 때문에 인덱스가 있는 테이블을 DRIVEN TABLE로 두면 드라이빙 테이블이 드리븐 테이블에 대해서 반복적으로 풀 스캔을 하지 않아 더 빠르기 때문이다.
따라서 인덱스의 유무를 기준으로 결정 규칙을 나눠보면
두 칼럼 모두 각각 인덱스가 있을 경우 레코드 건수에 따라 적은 레코드 수를 가진 테이블을 드라이빙 테이블로 한 칼럼에만 인덱스가 있는 경우 인덱스가 없는 테이블의 반복된 풀 스캔을 막기 위해 인덱스가 없는 테이블을 드라이빙 테이블로 선택 두 칼럼 모두 인덱스가 없을 경우 스캔되는 레코드 수에 따라 적절한 드라이빙 테이블 선택
드리븐 테이블을 풀스캔 으로 동작하게 된다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-JOIN-%EC%A1%B0%EC%9D%B8-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EA%B8%B0%EC%89%BD%EA%B2%8C-%EC%A0%95%EB%A6%AC" target="_self">https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-JOIN-%EC%A1%B0%EC%9D%B8-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EA%B8%B0%EC%89%BD%EA%B2%8C-%EC%A0%95%EB%A6%AC</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://devuna.tistory.com/36" target="_self">https://devuna.tistory.com/36</a>]]></description><link>부스트캠프/멤버십/3주차/mysql-join.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/mysql Join.md</guid><pubDate>Sun, 08 Sep 2024 12:10:02 GMT</pubDate><enclosure url="https://i.imgur.com/ubMaryV.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/ubMaryV.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week3_주말계획]]></title><description><![CDATA[
배포
멘토님이 올려주신 피드백 반영하기 커스텀 에러 만들기
json중복으로 사용해서 send하는 부분 고치기
model 자체가 가지는 역할을 명시하고, 이에 대해서 설계하기 ]]></description><link>부스트캠프/멤버십/3주차/week3_주말계획.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/week3_주말계획.md</guid><pubDate>Fri, 06 Sep 2024 17:21:25 GMT</pubDate></item><item><title><![CDATA[멤버십_3주차]]></title><description><![CDATA[<a data-href="멤버십_3주차_학습정리" href="부스트캠프/멤버십/3주차/멤버십_3주차_학습정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_3주차_학습정리</a><br>
<a data-href="멤버십_3주차_주간계획" href="부스트캠프/멤버십/3주차/멤버십_3주차_주간계획.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_3주차_주간계획</a><br>
<a data-href="멤버십_3주차_마스터클래스" href="부스트캠프/멤버십/3주차/멤버십_3주차_마스터클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_3주차_마스터클래스</a><br>
<a data-href="멤버십_3주차_특강" href="부스트캠프/멤버십/3주차/멤버십_3주차_특강.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_3주차_특강</a><br>
<a data-href="멤버십_3주차_체크포인트" href="부스트캠프/멤버십/3주차/멤버십_3주차_체크포인트.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_3주차_체크포인트</a><br><a data-href="week3_1일차_PR" href="부스트캠프/멤버십/3주차/week3_1일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week3_1일차_PR</a><br>
<a data-href="week3_2일차_PR" href="부스트캠프/멤버십/3주차/week3_2일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week3_2일차_PR</a><br>
<a data-href="week3_3일차_PR" href="부스트캠프/멤버십/3주차/week3_3일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week3_3일차_PR</a><br>
<a data-href="week3_4일차_PR" href="부스트캠프/멤버십/3주차/week3_4일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week3_4일차_PR</a><br>
<a data-href="week3_주말계획" href="부스트캠프/멤버십/3주차/week3_주말계획.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week3_주말계획</a>]]></description><link>부스트캠프/멤버십/3주차/멤버십_3주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/멤버십_3주차.md</guid><pubDate>Fri, 06 Sep 2024 17:20:15 GMT</pubDate></item><item><title><![CDATA[Passport의 로컬 인증전략]]></title><description><![CDATA[passport 모듈을 사용하여 로컬에서 인증을 관리하는 로직을 구현해보자.
Passport 모듈을 사용한 로그인 인증 전략은 로컬과 각종 소셜 로그인 등으로 구성되어 있다.
해당 글은 Inpa님의 글을 참고하면서 제가 구현했던 로그인 인증 전략에 대해서 정리하는 글입니다
router.post("/login", isNotLoggedIn, (req, res, next) =&gt; { passport.authenticate("local", (authError, user, info) =&gt; { if (authError) { console.error(authError); return next(authError); } if (!user) { // 해당하는 인증 정보를 찾기 못했을 경우 401 에러 반환 return res.status(401).json(info); } //req의 login 두번째 인자 -&gt; 에러 핸들링 return req.login(user, (loginError) =&gt; { if (loginError) { console.error(loginError); return next(loginError); } // 로그인 성공시 200 응답하기 return res.status(200).json({ message: "successfully login" }); }); })(req, res, next);
});
로그인 요청은 가장 먼저 설정한 라우터를 통해 들어오게 된다. 여기서 두 번째로 설정해둔 미들웨어는 isNotLoggedIn으로 해당 유저가 로그인한 상태를 확인하는 미들웨어이다.export const isNotLoggedIn = (req, res, next) =&gt; { if (!req.isAuthenticated()) { next(); } else { const message = encodeURIComponent("로그인한 상태"); res.redirect(`/?error=${message}`); }
};
이렇게 로그인이 된 경우에는 헤더에 로그인 정보가 함께 오기 때문에 req 객체의 isAuthenticated 함수를 통해 로그인 여부를 체크할 수 있다.
해당 함수는 boolean 값을 반환하기 때문에 if else문으로 로그인하지 않은 경우는 next()를 통해 다음 미들웨어를 호출할 수 있게 해 주었고, else의 경우네는 로그인한 상태이기 때문에 redirect를 시켜주었다.해당 미들웨어를 거친 뒤에 예외처리에서 걸러지지 않았다면 next()를 통해 다음 미들웨어로 이동하도록 한다.
다음 미들웨어가 실행되면 다시 위의 코드 다음으로 올라와서 router.post 안의 콜백 함수를 실행시키게 되는게, 가장 먼저 콜백함수 한에는passport.authenticate()가 있다. 여기서 authenticate() 메소드를 실행하게 되는데, passport/localStrategy.js 파일에 내가 따로 설정해놓은 passport 미들웨어가 있다.function localStrategy() { passport.use( new LocalStrategy( { usernameField: "username", passwordField: "password", }, async (username, password, done) =&gt; { try { const user = await transaction(User.findOne, username); if (user) { const result = await bcrypt.compare(password, user.passwd); if (result) { done(null, user); } else { done(null, false, { message: "비밀번호가 일치하지 않음" }); } } else { done(null, false, { message: "해당하는 유저 정보가 없습니다." }); } } catch (error) { console.error(error); done(error); } } ) );
} export default localStrategy; LocalStrategy는 passport.use를 통해 미들웨어를 설정한 것을 볼 수 이싿.
미들웨어 안에는 LocalStrategy 객체를 생성하고, 들어오는 로그인 정보를 검증하는 과정을 거친다.
여기서 transaction은 내가 mysql connection과 release를 하나로 묶어놓은 함수이다. 해당 함수에 내가 써놓은 쿼리를 실행하는 함수와 필요한 정보를 인자로 넣으면 transaction은 mysql과 연결한 뒤 해당 쿼리문을 수행한다.
로그인 비밀번호는 해시값으로 암호화 되어있기 때문에 bcrypt.compare을 통해서 가져온 db의 비밀번호와 비교한다.비밀번호를 비교한 뒤 해당하는 유저가 맞거나 틀리거나의 여부에 상관없이 done 함수를 호출한다.
done()이 실행되면 해당 미들웨어가 끝나고 다시 이전에 진행하던 함수로 돌아가는데, 돌아가는 함수는 아까 authenticate 함수 내의 다음 미들웨어를 실행한다.done의 인자로 주었던 세 가지의 값들은 이 콜백 함수의 세 가지 인자에 들어가게 된다. (authError, user, info) =&gt; { if (authError) { console.error(authError); return next(authError); } if (!user) { // 해당하는 인증 정보를 찾기 못했을 경우 401 에러 반환 return res.status(401).json(info); } //req의 login 두번째 인자 -&gt; 에러 핸들링 return req.login(user, (loginError) =&gt; { if (loginError) { console.error(loginError); return next(loginError); } // 로그인 성공시 200 응답하기 return res.status(200).json({ message: "successfully login" }); }); }
해당 미들웨어는 만약 여기서 유저를 찾지 못했다거나 로그인이 됐을 경우를 처리해준다.
해당 함수는 콜백 함수를 리턴하게 되는데, 이 과정에서 방금 받았던 로그인 정보에 대해서 에러가 있었을 시 처리를 하고 req의 login 메소드를 호출하면, passport는 설정해놨던 passport.serializeUser()를 호출시킨다.export default function () { passport.serializeUser((user, done) =&gt; { done(null, user.username); }); passport.deserializeUser(async (username, done) =&gt; { try { const user = await transaction(User.findOne, username); done(null, user); } catch (error) { done(error); } }); local();
}
Serialize(직렬화)란?
데이터 스트림으로 만들어진 객체로, 객체 자체를 영속적으로 보관할 떄 사용하는 파일형태로 작성되어 네트워크를 통해 전송한다.
간단하게 직렬하는 바이트 형태로 바꾸는 작업이다.
자매품으로 Deserialize는 이렇게 데이터 스트림으로 만들어진 객체를 반대로 다시금 해석하고, 원래의 형태로 되돌리는 역할을 한다
serialzieUser를 통해 로컬에 PK로 두고 로그인을 식별 가능한 최소한의 값(메모리 최적화)만을 가지고 있도록 한다. done()함수의 두번째 인자로 넣으면 된다.
serializeUser가 끝난 후에는 밑으로 가서 바로 deserializeUser를 실행하낟. 해당 미들웨어에는 알아서 유저가 들어가게 되기 때문에 나는 거기서 유저를 다시금 db에서 찾아서 done의 두번째 인자로 user를 넣어줌으로써 req 객체에 user 객체를 등록시킬 수 있다.로그인 성공/실패의 여부와는 별개로 desrializeUser에서 실행하는 done은 같은 req.login미들웨어로 다시 돌아오고 해당 결과는 return req.login(user, (loginError) =&gt; { if (loginError) { console.error(loginError); return next(loginError); }
요 부분의 loginError로 들어가게 된다.
여기서 done의 인자가 로그인 성공시 두개인데 왜 여기서 받는 인자는 하나냐면 두 번째 인자의 경우에는 req 객체에 user 객체만 등록하는 것일 뿐 돌아오면서 해당 콜백의 인자로 넣어주는게 아니기 때문에 첫 번째 인자만 넘어오게 된다. 그래서 로그인 성공시 done의 첫번쨰 인자가 null이고, 실패 시에는 첫번째 인자가 error인 것이다.이렇게 로그인이 완료된 후에 응답을 보낼 때는 // app.js
passportConfig();
app.use( session({ resave: false, saveUninitialized: false, secret: process.env.SECRET_KEY || crypto.randomBytes(32).toString("hex"), cookie: { httpOnly: true, secure: false, }, })
);
app.use(passport.initialize());
app.use(passport.session()); 해당 미들웨어들을 순서대로 실행시켜준다.
여기서 passportConfig는 아까 serialize, deserialize가 있는 함수이다!
로그인이 완료되면 응답을 보낼 때 여기서 session에 cookie 설정을 하고 보내면(set-cookie를 해준다) 알아서 클라이언트의 쿠키에 세션 정보가 저장되고, 클라이언트에서 요청을 보낼 때 알아서 머리에 쿠키를 담아 보낸다
httpOnly Cookie
자바스크립트를 통해 쿠키에 접근할 수 없게 되어 악성 스크립트를 통해 쿠키값에 접근하는 것을 막아준다. secure Cookie
네트워크 감청을 막기 위한 쿠키 세팅이다. 암호화된 쿠키를 넘겨준다
하지만 https가 아닌 http에서는 사용할 수 없다
그렇다면 머리에 쿠키를 담고 보내는 클라이언트 녀석은 나중에 api를 요청할 때 어떤 방식으로 유저임을 확인할까?로그인 이후에는 클라이언트가 머리에 쿠키를 달고 api를 요청하면서 등장하면 서버는 이 쿠키를 떼어 해당 세션 아이디에 해당하는 유저네임을 뽑고, 그 유저네임을 통해 db에 해당 유저가 여전히 존재하는지를 확인한다. 이 과정에서 모든 요청에 passport.session 미들웨어가 passport.deserializeUser 메서드를 항상 실행하면서 벌어지는 일인데, 아까 봤던 대로 deserializeUser는 db에서 사용자를 조회하고 조회된 사용자 전체 정보를 req 객체에 등록하는 역할을 한다.그래서 항상 로그인한 뒤에는 알아서 db에서 유저 정보 뽑아서 req 객체로 넣어주니, 우리는 라우터에서 이 req 객체의 user 객체를 통해서 접근하고 유저 정보에 맞는 정보만을 뽑아서 줄 수 있다!]]></description><link>부스트캠프/멤버십/3주차/passport의-로컬-인증전략.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/Passport의 로컬 인증전략.md</guid><pubDate>Thu, 05 Sep 2024 13:03:30 GMT</pubDate></item><item><title><![CDATA[멤버십_3주차_주간계획]]></title><description><![CDATA[
드래그앤 드롭 정보 db에 반영(우선순위: 1)
column 추가 기능(우선순위: 2)
redo,undo 기능(우선순위: 3)
카드가 없을 때, 카드 column이 뜨지 않는 현상 고치기(쿼리문 수정)(우선순위: 0)
로그인 스타일 수정(우선순위: 4) move post api 구현 및 연결(하는중) ✅ 2024-09-05
erd 재구조화 ✅ 2024-09-02
카드 삭제 post api 구현 및 연결 ✅ 2024-09-02
카드 수정 patch api 구현 및 연결 ✅ 2024-09-02 history설계 ✅ 2024-09-05
history 테이블 설계
action별 history에 대해 레코드 추가 설정
각 card 메서드에 대한 history 업데이트 로직 fab 버튼 구현 ✅ 2024-09-05
fab 버튼 컴포넌트 파일
스타일 구현 서버 - 로그인 구현 ✅ 2024-09-05
프론트 - 로그인 화면 및 세션 관리 구현 ✅ 2024-09-05
spa로 로그인 구현 ✅ 2024-09-04
로그인 화면
로그인 에러시 안내문구
로그인 성공시 메인으로 이동 에러 핸들링 ✅ 2024-09-04
로그인 에러 상태별로 처리
throw error를 통한 에러 전파 카드가 없을 때, 카드 column이 뜨지 않는 현상 고치기(쿼리문 수정) ✅ 2024-09-05
드래그 앤 드롭시 db에 order 반영 ✅ 2024-09-05
정렬 애니메이션 ✅ 2024-09-05 서버 배포
리팩토링
]]></description><link>부스트캠프/멤버십/3주차/멤버십_3주차_주간계획.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/멤버십_3주차_주간계획.md</guid><pubDate>Thu, 05 Sep 2024 11:26:56 GMT</pubDate></item><item><title><![CDATA[week3_4일차_PR]]></title><description><![CDATA[
카드가 없을 때, 카드 column이 뜨지 않는 현상 고치기(쿼리문 수정) ✅ 2024-09-05
드래그 앤 드롭시 db에 order 반영 ✅ 2024-09-05
정렬 애니메이션 ✅ 2024-09-05 sql join ✅ 2024-09-05
<img src="https://i.imgur.com/9YCbK92.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="max-width: 100%;">
기존의 경우 모든 카드들의 정보를 ```sql
select * from todo_cards where username = ? ```
와 같은 방식으로 모든 카드들의 정보를 가져와 model에서 이를 column 별로 나누어 가공한 뒤 다시금 클라이언트에 response body를 넣어 response를 보내주는 방식으로 설계했었습니다.하지만 이러한 sql문의 문제는 todo_cards의 모든 정보를 가져오기만 할 뿐, column들에 대한 정보를 따로 가져오지 않았으므로 task_column 테이블에 만약 어떠한 카드도 없을 경우 todo_cards에는 아무것도 없는 column의 정보는 나오지 않기 때문에 이를 join하는 방식을 통해서 해결했습니다. const query = ` SELECT todo_cards.task_column, todo_cards.card_id, todo_cards.author, todo_cards.title, todo_cards.detail, todo_cards.created_at, task_columns.username, task_columns.col_name FROM todo_cards right OUTER JOIN task_columns ON todo_cards.task_column = task_columns.col_name WHERE task_columns.username = ? `;
이런 식으로 task_column을 right join하여 task column에는 있지만 todo_cards에는 없는 것들 또한 가져와서 다시금 처리를 해주도록 만들었습니다.저는 대부분의 컴포넌트가 api호출이 이루어진 후 해당 컴포넌트에 대해서는 다시 get요청을 불러와 가져온 정보로 리렌더링을 한다는 것을 전제로 하고 있기 때문에 드래그 앤 드롭 시에 db에 order을 어떻게 반영해야 할지 고민이 되었습니다.그러던 중 greenhopper 방식을 블로그 글에서 찾게 되었고, 이를 어떻게 하면 db와 클라이언트 모두에 적용시켜 매끄러운 사용자 경험을 가질 수 있을지에 대해서 고민한 결과입니다.document .getElementById("sections") .addEventListener("drop", async (event) =&gt; { try { const cardId = event.dataTransfer.getData("data"); const targetCard = document.getElementById(cardId); handleSoftMove(event, cardId); await handleMoveActionsToServer(cardId, targetCard); } catch (error) { console.log(error); } });
drop 이벤트가 발생이 되면 해당 드래그의 대상이 되는 타겟으로부터 dataTransfer를 이용해 해당하는 카드의 고유 식별 ID를 가져오고 해당 컴포넌트를 변수에 할당했습니다.function handleSoftMove(event, cardId) { let closest = getEventTarget(event); if (!closest) return; closest.style.borderBottom = "none"; const cardToMove = document.getElementById(cardId); if (closest.tagName === "SECTION") closest = closest.querySelector(".todoList"); closest.className === "todoList" ? closest.insertAdjacentElement("afterbegin", cardToMove) : closest.insertAdjacentElement("afterend", cardToMove); } function getEventTarget(event) { let closest = event.target.closest("ul &gt; div"); if (!closest) closest = event.target.closest("section"); return closest; }
변수에 할당된 뒤에는 타겟에 대해서 getEventTarget함수를 통해 가장 가까운 요소를 가져오게 됩니다.
0순위로는 각 카드의 가장 큰 container인 div element를 closest를 통해 찾고, 1순위로는 해당하는 위치의 칼럼에 대해서 찾아 리턴합니다.
찾은 위치에 대해서 조건문을 통해 section(column)의 경우 -&gt; 가장 첫번째 위치로 넣기 위해 바로 card들을 담는 부모 요소의 ul로 지정하는 요소를 재할당합니다.
가장 가까운 곳이 card일 경우 -&gt; 해당 카드의 다음 위치에 추가합니다.
이렇게 softmove를 먼저 수행하게 됩니다.
softmove를 수행하는 이유는 두 가지가 있습니다.function getPriortyAfterMove(target) { let next = 0, prev = 0; if ( target.nextSibling &amp;&amp; target.nextSibling.nodeType === Node.ELEMENT_NODE ) { const nextElement = target.nextSibling; if (nextElement.tagName === "DIV") { next = parseInt(nextElement.dataset.priority, 10) || 0; } } if ( target.previousSibling &amp;&amp; target.previousSibling.nodeType === Node.ELEMENT_NODE ) { const prevElement = target.previousSibling; if (prevElement.tagName === "DIV") { prev = parseInt(prevElement.dataset.priority, 10) || 0; } } if (next &amp;&amp; prev) return Math.floor((next + prev) / 2); else if (prev) return prev + 100; else return 100; } getPriorityAfterMove함수에서 각각 카드의 element에 저장해두었던 우선순위인 priority를 가져와 계산하기 위해서입니다.
softmove를 통해 미리 db에 반영되기 전의 상태를 그려놓고 다시금 렌더링을 시키면 보다 사용자 경험을 증진시킬 수 있다고 생각했습니다.
이렇게 softmove가 이루어진 후에는 api 호출 -&gt; 서버의 라우터 -&gt; 레포지토리를 이용해 이동한 column의 이름과 우선순위를 변경함으로써 적절한 위치에 우선순위를 기반으로 렌더링시켜 리렌더링 시에도 위치가 똑같이 나오도록 구현했습니다.기본적인 레이아웃 자체는 서버사이드 렌더링으로 구현을 했지만, 각각의 컴포넌트들은 클라이언트 사이드 렌더링으로 구현을 했었습니다.하지만 이렇게 클라이언트 사이드 렌더링으로 구현하는 과정에서 views 폴더의 index.js파일은 엔트리 포인트를 가리키고, app에서 각 페이지에 대해서 렌더링을 시키도록 했었는데 이 과정에서 만약 로그인이 추가될 경우 경로를 입력할 수 없는 express.render의 특성상 서버사이드 렌더링 방식으로 다시금 다른 페이지로 이동시키려면 index.js와 login.js 파일 모두를 두는 방법밖에 생각이 나지 않았습니다.하지만 이렇게 하게 되면 기존의 디렉토리 구조 자체가 무색해질 뿐더러, 기존에 사용하던 Pages 디렉토리는 전혀 필요없는 디렉토리가 되어버리기 때문에 이를 활용할 방법을 고민해보았습니다.// /app/app.js
import navigation from "../shared/utils/navigation.js"; function entryPoint() { const pathName = window.location.pathname; console.log(pathName); navigation.navigate(pathName);
} window.onpopstate = navigation.onPageChanged;
document.addEventListener("DOMContentLoaded", entryPoint);
기존에 mainpage만 있던 때는 메인 페이지만을 렌더링 시키는 함수를 실행시키는 정도로 app.js를 사용했지만, 로그인 페이지가 추가됨에 따라 이를 pathname에 따라 필요한 페이지를 렌더링 시키도록 방식을 바꿨습니다.app.get("/", isLoggedIn, (req, res, next) =&gt; { res.render("index");
}); app.get("/login", isNotLoggedIn, (req, res, next) =&gt; { res.render("index");
});
따라서 서버에서도 pathname은 다르지만, 모든 페이지들이 entryPoint에서 일어나는 것을 알 수 있습니다.
이렇게 spa 방식으로 만들면 좋은 점은 아무래도 index만을 엔트리 포인트로 잡기 때문에 다른 pathname으로 접속했을 경우는 전부 클라이언트 사이드에서 제어가 가능하다는 점입니다. 따라서 서버가 렌더링하는 것은 기존 index의 레이아웃에 불과하기 때문에 api까지 사용해야 하는 서버의 역할이 분담되는 효과를 가진다고 생각했습니다.다시 app.js로 돌아오면, pathname에 따라 spa를 구현하기 위해서는 navigation 객체가 필수적이었습니다. 왜냐하면
pathname 관리
기존 레이아웃을 재사용하면서 body의 내용만 달라지게 하는 방식
페이지 이동에 따른 페이지별 이벤트 핸들러 붙이기/떼기
등의 조건을 갖춰야 했기 때문에 이를 navigation 객체를 만들어 페이지를 이동하는 로직을 담당하도록 했습니다
// /shared/utils/navigation.js
import Main from "../../pages/main/index.js";
import Login from "../../pages/login/index.js";
import EventManager from "../../feature/index.js"; export default (function navigation() { const navigator = { "/": Main.render, "/login": Login.render, }; function navigate(pathname, prev) { document.body.innerHTML = ""; history.pushState({ pathname: prev }, null, pathname); navigator[pathname](); } function onPageChanged(event) { document.body.innerHTML = ""; EventManager.detachEvent(event.pathname); navigator[window.location.pathname](); } return { navigate, onPageChanged, };
})(); navigation 객체는 어디서나 페이지 이동에 쓰여야 로직이기 때문에 fsd 계층 중에 shared 계층이 알맞은 자리일 것이라 생각해서 넣어주었습니다
해당 navigation객체는 등록된 pathname에 따라
기존 레이아웃에서 body를 초기화
history.pushState 를 활용하여 이전 주소값을 가지고 뒤로가기를 눌렀을 경우 이에 대해서 다시금 올바른 페이지를 렌더링 할 수 있도록 로직 구성
페이지별 렌더링 함수 실행
의 과정을 거칩니다.
onPageChanged는 기존 페이지가 다른 페이지로 이동할 때마다 실행될 수 있도록 window에 등록해놓은 이벤트핸들러인데, 이는 페이지가 바뀔 때마다 다시금 초기화시키고, 해당 페이지의 해당하는 이벤트 핸들러들을 종합해놓은 모듈을 head에서 떼어냄으로써 에러가 발생하지 않도록 구현했습니다.
// /feature/index.js
export default (function EventManager() { const route = { "/login": "/feature/login/index.js", "/main": "/feature/main/index.js", }; function attachEvent(pathname) { const script = document.createElement("script"); script.src = route[pathname]; script.type = "module"; document.head.appendChild(script); } function detachEvent(pathname) { const script = document.head.querySelector( `script[src="${route[pathname]}"]` ); if (script) script.remove(); } return { attachEvent, detachEvent };
})(); 메인페이지의 이벤트를 종합하여 등록하기만 해주던 feature/index.js는 페이지가 추가됨에 따라 페이지별로 디렉토리를 만들어 depth를 한단계 늘리는 대신에, 페이지별로 index.js를 따로 만들어 해당 페이지에 등록되어야 할 이벤트 위임과 핸들러들을 종합하여 등록할 수 있도록 해주었으며, 이를 절대경로로 설정하여 head의 script로 넣어주는 방식을 사용했습니다.저번 리뷰에서 말씀해주신 history 테이블을 이용한 redo, undo 조언을 참고하여 history 테이블을 다시 구상함에 있어서 애매한 부분이 있어 질문드리고 싶습니다.-- `history` 테이블
CREATE TABLE `history` ( `history_id` int auto_increment, `username` varchar(10) NOT NULL, `action` varchar(10) NOT NULL, `column_name` varchar(20) NULL, `title` varchar(20) NULL, `detail` varchar(500) NULL, `from_column` varchar(20) NULL, `to_column` varchar(20) NULL, `created_at` timestamp NULL, `card_id` int NOT NULL, `prev_priority` int NULL, PRIMARY KEY(`history_id`), FOREIGN KEY (`username`) REFERENCES `user` (`username`) on delete cascade on update cascade
); history는 모든 action에 대해 저장해야 합니다.
하지만 각각의 action들에 대해서 필수적으로 가져야 하는 정보는 조금씩 다릅니다.
카드 이동 -&gt; 이전 칼럼, 카드 id, 간 후의 칼럼
카드 삭제 -&gt; 삭제 전 카드의 모든 내용
카드 추가 -&gt; 카드 id
카드 수정 -&gt; 이전 카드의 모든 내용
이를 어떻게 관리하면 좋을까에 대해서 생각해봤는데, 필수적으로 가져야 하는 값만 NOT NULL로 두고, 다른 칼럼에 대해서는 NULL로 설정해놔 없어도 되는 경우에는 NULL값으로 둘 수 있도록 해놨습니다.
하지만 이렇게 각각 히스토리가 가지는 종류가 여러개인데, 이러한 정보를 한가지 테이블에 모두 두는 것이 맞을까 고민이 됩니다.
이전에는 JSON형식으로 유동적인 정보에 대해서 전부 JSON으로 저장하도록 했는데, JSON을 통해 저장하는 것은 관계형 데이터베이스의 기본 원리와는 좀 벗어나는 방식이라는 피드백을 들었습니다.
그러면서도 이번 스터디그룹 리뷰 시간에서는 이에 대해 JSON으로 하신 분들도 계시는데, 유동적인 정보를 관리해야 하기 때문에 별로 상관이 없다고 생각하셨다는 분도 계셔서 무엇이 RDB의 활용성을 높일 수 있는 방식일지가 헷갈리는 것 같습니다. 이에 대해서 멘토님의 고견을 여쭙고 싶습니다.]]></description><link>부스트캠프/멤버십/3주차/week3_4일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/week3_4일차_PR.md</guid><pubDate>Thu, 05 Sep 2024 11:25:42 GMT</pubDate><enclosure url="https://i.imgur.com/9YCbK92.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/9YCbK92.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week3_3일차_PR]]></title><description><![CDATA[
spa로 로그인 구현 ✅ 2024-09-04
로그인 화면
로그인 에러시 안내문구
로그인 성공시 메인으로 이동 에러 핸들링 ✅ 2024-09-04
로그인 에러 상태별로 처리
throw error를 통한 에러 전파 패스포트 모듈 ✅ 2024-09-04
로그인 로직 ✅ 2024-09-04
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/3-1f7fcdb0591241f487bdfa6f74f1200a?pvs=4" target="_self">https://luxurious-share-af6.notion.site/3-1f7fcdb0591241f487bdfa6f74f1200a?pvs=4</a>기본적인 레이아웃 자체는 서버사이드 렌더링으로 구현을 했지만, 각각의 컴포넌트들은 클라이언트 사이드 렌더링으로 구현을 했었다.하지만 이렇게 클라이언트 사이드 렌더링으로 구현하는 과정에서 views 폴더의 index.js파일은 엔트리 포인트를 가리키고, app에서 각 페이지에 대해서 렌더링을 시키도록 했었는데 이 과정에서 만약 로그인이 추가될 경우 경로를 입력할 수 없는 express.render의 특성상 서버사이드 렌더링 방식으로 다시금 다른 페이지로 이동시키려면 index.js와 login.js 파일 모두를 두는 방법밖에 생각이 나지 않았다.하지만 이렇게 하게 되면 기존의 디렉토리 구조 자체가 무색해질 뿐더러, 기존에 사용하던 Pages 디렉토리는 전혀 필요없는 디렉토리가 되어버리기 때문에 이를 활용할 방법을 고민해보았다.// /app/app.js
import navigation from "../shared/utils/navigation.js"; function entryPoint() { const pathName = window.location.pathname; console.log(pathName); navigation.navigate(pathName);
} window.onpopstate = navigation.onPageChanged;
document.addEventListener("DOMContentLoaded", entryPoint);
기존에 mainpage만 있던 때는 메인 페이지만을 렌더링 시키는 함수를 실행시키는 정도로 app.js를 사용했지만, 로그인 페이지가 추가됨에 따라 이를 pathname에 따라 필요한 페이지를 렌더링 시키도록 방식을 바꿨다.app.get("/", isLoggedIn, (req, res, next) =&gt; { res.render("index");
}); app.get("/login", isNotLoggedIn, (req, res, next) =&gt; { res.render("index");
});
따라서 서버에서도 pathname은 다르지만, 모든 페이지들이 entryPoint에서 일어나는 것을 알 수 있다.
이렇게 spa 방식으로 만들면 좋은 점은 아무래도 index만을 엔트리 포인트로 잡기 때문에 다른 pathname으로 접속했을 경우는 전부 클라이언트 사이드에서 제어가 가능하다는 점이다. 따라서 서버가 렌더링하는 것은 기존 index의 레이아웃에 불과하기 때문에 api까지 사용해야 하는 서버의 역할이 분담되는 효과를 가진다.다시 app.js로 돌아와서, pathname에 따라 spa를 구현하기 위해서는 navigation 객체가 필수적이었다. 왜냐하면
pathname 관리
기존 레이아웃을 재사용하면서 body의 내용만 달라지게 하는 방식
페이지 이동에 따른 페이지별 이벤트 핸들러 붙이기/떼기
등의 조건을 갖춰야 했기 때문에 이를 navigation 객체를 만들어 페이지를 이동하는 로직을 담당하도록 했다.
// /shared/utils/navigation.js
import Main from "../../pages/main/index.js";
import Login from "../../pages/login/index.js";
import EventManager from "../../feature/index.js"; export default (function navigation() { const navigator = { "/": Main.render, "/login": Login.render, }; function navigate(pathname, prev) { document.body.innerHTML = ""; history.pushState({ pathname: prev }, null, pathname); navigator[pathname](); } function onPageChanged(event) { document.body.innerHTML = ""; EventManager.detachEvent(event.pathname); navigator[window.location.pathname](); } return { navigate, onPageChanged, };
})(); navigation 객체는 어디서나 페이지 이동에 쓰여야 로직이기 때문에 fsd 계층 중에 shared 계층이 알맞은 자리일 것이라 생각해서 넣어주었다
해당 navigation객체는 등록된 pathname에 따라
기존 레이아웃에서 body를 초기화
history.pushState 를 활용하여 이전 주소값을 가지고 뒤로가기를 눌렀을 경우 이에 대해서 다시금 올바른 페이지를 렌더링 할 수 있도록 로직 구성
페이지별 렌더링 함수 실행
의 과정을 거친다.
onPageChanged는 기존 페이지가 다른 페이지로 이동할 때마다 실행될 수 있도록 window에 등록해놓은 이벤트핸들러인데, 이는 페이지가 바뀔 때마다 다시금 초기화시키고, 해당 페이지의 해당하는 이벤트 핸들러들을 종합해놓은 모듈을 head에서 떼어냄으로써 에러가 발생하지 않도록 설계했다.
// /feature/index.js
export default (function EventManager() { const route = { "/login": "/feature/login/index.js", "/main": "/feature/main/index.js", }; function attachEvent(pathname) { const script = document.createElement("script"); script.src = route[pathname]; script.type = "module"; document.head.appendChild(script); } function detachEvent(pathname) { const script = document.head.querySelector( `script[src="${route[pathname]}"]` ); if (script) script.remove(); } return { attachEvent, detachEvent };
})(); 메인페이지의 이벤트를 종합하여 등록하기만 해주던 feature/index.js는 페이지가 추가됨에 따라 페이지별로 디렉토리를 만들어 depth를 한단계 늘리는 대신에, 페이지별로 index.js를 따로 만들어 해당 페이지에 등록되어야 할 이벤트 위임과 핸들러들을 종합하여 등록할 수 있도록 해주었으며, 이를 절대경로로 설정하여 head의 script로 넣어주는 방식을 사용했다.]]></description><link>부스트캠프/멤버십/3주차/week3_3일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/week3_3일차_PR.md</guid><pubDate>Wed, 04 Sep 2024 14:40:14 GMT</pubDate></item><item><title><![CDATA[멤버십_3주차_특강]]></title><description><![CDATA[Readability가 중요함
개발자 -&gt; 고객의 가치를 만들어내는 사람
개인의 노력 -&gt; 사회의 노력보다는 데드라인에 대한 문제
외부에서 주어진 시간을 짧은 시간 안에 해야함 -&gt; 투쟁 또는 도망
소프트웨어 개발은 논리력을 유지해야 하는 작업인데 시간의 압박을 받으면서 논리력을 쓰기가 어려움 -&gt; 인터넷 검색을 하고 읽고 이해하면서 보완하는 것이 아닌, 그대로 복사붙여넣기 하고 되는 것처럼 보일 때까지 함
깔끔한 코드의 개발자
필요한 코드의 개발(TDD)
리팩토링 용이한 코드
타인들의 성장을 도와주는 역할도 중요함
꾸준히 할 수 있는 방법을 찾기 - 동기부여
커뮤니티 활동 친목 x 성장을 위한 ]]></description><link>부스트캠프/멤버십/3주차/멤버십_3주차_특강.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/멤버십_3주차_특강.md</guid><pubDate>Wed, 04 Sep 2024 10:41:02 GMT</pubDate></item><item><title><![CDATA[멤버십_3주차_마스터클래스]]></title><description><![CDATA[낙관적 업데이트 + 기존의 방식
post -&gt; 다시 get 해와서 하는직전 미리 렌더링 시켜놓고, get 요청 후 업데이트 메서드 체이닝의 사용
강한 결합으로 플로우를 볼 수 있음 가독성이 좋음 라우터 -&gt; 맥북 내의 가상서버 인터넷이 될 경우 -&gt; 사설망 -&gt; 사설망의 ip를 받아 맥북에서 사용하는데 이를 거쳐서 인터넷 가져오는 방식
NAT와 브릿지 네트워크
네트워크 기초 책 -&gt; 모두의 네트워크, 혼자 공부하는 네트워크, 성공과 실패를 결정하는 1%의 네트워크 원리 컴퓨터에서 인터넷을 하기 위해 ip를 가져야 함
사설 ip를 가지고는 인터넷이 안되지만 공유기의 public ip를 통해서 인터넷을 함
공유기로 받아온 다음에 우리가 알고 있는 대상 기계로 보냄우분투가 가상의 랜카드를 통해서 다이렉트로 공유기와 통신인터넷은 잘 되는데 맥북과 안될 때 -&gt; 가상의 랜카드를 하나 더 붙여서 맥북과 통신etc host를 변경
<img src="https://i.imgur.com/h5bo3By.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
ssh-keygen을 통해 rsa key pair를 만듬
공개 키 -&gt; 자물쇠
비밀 키 -&gt; 공개키를 여는 열쇠
서버에 전달할 때는 자물쇠<br>
<img src="https://i.imgur.com/rEx611k.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
shtp로 쓸 수도 있음
cyberduck<br>
<img src="https://i.imgur.com/hl3bWJ0.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
public 키가 복사됨. 이를<br>
<img src="https://i.imgur.com/D2y0QoX.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
여기에 내 키를 추가
echo -&gt; echo 뒤에 오는 매개변수의 내용을 표준 출력
표준 입력 0 표준 출력 1 표준 에러 2
파일을 하나 열면 file descrupter에서 3번부터 할당됨<br><img src="https://i.imgur.com/Uz23QWd.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
&gt; -&gt; 리다이렉션
&gt;&gt; -&gt; append mode
cat -&gt; 해당 텍스트 파일의 내용을 표준 출력으로<br>
<img src="https://i.imgur.com/mdqU5n3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
안전하고 편한 방법<br><img src="https://i.imgur.com/iF4iEBA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
public key의 비밀키를 주고받을 때 사용<br><img src="https://i.imgur.com/0FQZ40t.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/cDex0BD.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
vim-nox설치
spacevim
vimgolf간단하게 -&gt; npm http-server 설치
vscode에서 ssh 연결해서 실행해서 테스트해볼 수도 있음
직접 설치(권장, 하드웨어 확인)
가상 머신을 이용해 설치(CPU, OS에 따라 난이도가 달라짐)
도커 사용
윈도우라면 WSL2사용 openssh 사용
네트워크 설정 잘하기
ssh-keygen으로 키를 생성하고 공개키를 리눅스 서버에 복사 좁은 의미의 리눅스: 라이누스 토르발즈가 관리하는 커널
넓은 의미의 리눅스 : 리눅스 배포판 Ubuntu - debian이라는 배포판을 쓰기 쉽게 만든 것 xubuntu, kubuntu, lubuntu - 경량된 버전
mint linux
arch Linux redhat - 유료
rocky - 무료, 구 centOS pedora - redhat이 무료판으로 만든 것으로 베타테스트용 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=SdCa80N2EP4" target="_self">https://www.youtube.com/watch?v=SdCa80N2EP4</a> 인증(Authentication) 식별된 사용자가 자기 자신임을 보이는 것
그 주장이 사실인지 아닌지를 확인하는 절차
인증을 통과했다 -&gt; 해당하는 사용자의 주장이 사실이라는 것이 증명되었다
비민번호를 통해 인증
db에는 비밀번호의 해시값이 들어있고, 이를 확인
단방향 해시, 복호화되어있어야 함 인가(Authorization) 신원에 따른 권한 부여
인증받은 유저, 그렇지 않은 사용자들에 자원에 대한 접근 권한 부여
uri -&gt; 고유한 자원을 식별하는 식별자, 특정한 자원 하나
crud -&gt; 해당하는 리소스에 대한 생성, 읽기, 수정, 삭제 권한
 세션(session)이란 서버에서 유지하는 사용자와의 연결
웹은 stateless함
사용자 정보를 처리하기 위해서 유저마다 유지하는 정보
쿠키를 통해 보냄 쿠키값을 세팅하는 주체 -&gt; 서버가 response에 set Cookie를 해서 sid를 설정
클라이언트는 쿠키를 브라우저의 어딘가에 저장 SQLite 데이터베이스 형식으로 저장
brute force 공격을 막을 수 없도록 해시된 값으로 보냄 세션에는 보통 사용자 아이디나 권한 정도 최근 인증 방식 oauth2
JWT 로그인 폼 -&gt; express에서 서버에서 해당하는 db에서 읽어옴 -&gt; 정상적이면 쿠키 응답, 실패했을 경우 실패 페이지로 보내기
]]></description><link>부스트캠프/멤버십/3주차/멤버십_3주차_마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/멤버십_3주차_마스터클래스.md</guid><pubDate>Wed, 04 Sep 2024 05:58:50 GMT</pubDate><enclosure url="https://i.imgur.com/h5bo3By.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/h5bo3By.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week3_2일차_PR]]></title><description><![CDATA[
history설계 ✅ 2024-09-03
history 테이블 설계
action별 history에 대해 레코드 추가 설정
각 card 메서드에 대한 history 업데이트 로직 쿠키와 세션 학습 ✅ 2024-09-03
서버 로그인 작업 ✅ 2024-09-04
서버에서 passport 사용하여 로그인 및 세션관리(진행중) XSS 공격
sql Trigger
쿠키와 세션
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/3-1f7fcdb0591241f487bdfa6f74f1200a?pvs=4" target="_self">https://luxurious-share-af6.notion.site/3-1f7fcdb0591241f487bdfa6f74f1200a?pvs=4</a>실행의 경우 npm install
npm start
를 통해 실행하시면 됩니다!(.env 파일의 경우는 슬랙으로 송부드리겠습니다)어제 올린 PR에서는 Undo, Redo를 고려한 history의 저장 관계와 이에 대해서 undo와 redo를 어떻게 수행할 것인가에 대한 고민을 적었습니다.1. mysql 자체에서 트리거를 사용한 히스토리 기록 - Mysql에서 지원하는 트리거(Trigger)은 특정 조건이 만족하면 저절로 실행되는 일종의 장치로, 한번 설정을 해놓으면 이벤트리스너와 비슷한 방식으로 동작을 계속 감시하면서 조건에 해당하는 동작이 수행되는 순간 실행되는 특징을 가진다. - 트리거를 사용하여 히스토리를 기록할 때, 히스토리는 자동으로 데이터베이스에 추가되기 때문에 undo, redo를 고려하는 입장에서 이를 설계해보자면 - undo, redo를 수행하면 히스토리에서 해당하는 유저의 히스토리에서 가장 최근의 히스토리를 제거한다. - 히스토리가 제거될 때 실행되는 트리거를 등록하여 트리거를 통해 history의 undo를 수행한다. - 그러나 redo를 수행할 때는 지금 생각한 정도로는 history에 대한 History 테이블을 다시 만드는 방법밖에는 생각나지 않는데, history 테이블을 두 개 두는 것이 상식상으로는 괜찮아 보이지 않아서 고민이다.
2. 온메모리에서 deque를 통한 history 저장 - mysql의 트리거를 사용하지 않고 따로 history에 Insert를 통해서 넣어주는 방식이다. - deque에서 5개의 개수제한을 놓고, action이 이루어질 때마다 하나씩 push해주되, 개수를 넘어가면 하나씩 dequeue해주면서 이에 대해 실질적으로 db에 반영해주는 방식이다. - 이렇게 설계할 경우, 온메모리에서 deque를 하나 두고 Undo와 redo에 대해서 action마다 수행하는 로직을 브라우저 상에 놓고 관리하게 된다. - 일반적으로 undo, redo는 새로고침이나 창을 나갔다가 다시 접속할 시에 없어지게 되므로, 새로고침이나 창 닫기 등의 행위를 이벤트리스너를 등록해놓고 있다가 해당 이벤트가 발생하면 flush를 통해서 모든 history의 내용을 반영하는 로직으로 작동시킨다. - 하지만 이러한 방식으로 갈 경우, history에 대한 예외 로직이 이루어지지 않아 만약 창을 껐을 시에 이벤트가 제대로 동작하지 않는다면 history의 갱신이 이루어지지 않으므로 이는 db의 손상을 일으킨다.
3. db에 action때마다 직접 넣되, 하나씩 빼서 undo, redo - 이 경우, action에 대한 api 호출을 하면서 해당 api를 처리하는 로직에서 히스토리 업데이트 + aciton에 대한 수행 자체를 하나의 트랜잭션으로 인식하여 사용해야 한다. - 각각의 action에 대한 히스토리의 레코드를 직접 쿼리문을 통해 넣어준다. - redo의 경우 undo한 것을 빼서 온메모리에서 stack 형식으로 저장하고 있다가 다시 실행할 경우 이에 대한 로직을 설계하여 다시금 돌아갈 수 있다. - redo의 경우 굳이 새로고침이나 창을 껐을 때, 복구시킬 의무는 없다고 생각한다. undo 또한 db에서 계속 끌어다가 복구할 수는 있겠지만은 굳이 이걸 전부 할 수 있도록 허용해주면 db에 부담이 갈 수 있기 떄문에 브라우저 내부에서 개수를 정해놓고 이를 막는 방식이 나을 것 같다고 판단했다. - 나는 히스토리와 action의 수행이 하나의 트랜잭션으로 판단해야만 정상적인 db의 갱신이 이루어지기 때문에 이 방식이 제일 합리적이라고 생각한다.
그때 생각한 방안은 세 가지가 있었는데요,
mysql 자체에서 트리거를 사용한 히스토리 기록
온메모리에서 deque를 통한 history 저장
db에 action때마다 직접 넣되, 하나씩 빼서 undo, redo
처음에는 히스토리와 action 자체가 하나의 트랜잭션이라고 생각해야 한다고 생각했기 때문에 이를 보다 세심하게 관리할 수 있는 3번을 고민했었습니다. 2번의 방식에서 data flush에 대한 위험성을 줄인 버전이기 때문입니다.하지만 그럼에도 불구하고 온메모리로 history에 대해서 관리하는 것에 대한 부담을 완전히 제거하기는 어렵다고 생각합니다. 세부적인 history 내역을 온메모리로 관리하는 것이 과연 안전하다고 할 수 있을까? 에 의문을 가졌습니다. 메모리에 있는 history의 내용이 변경될 가능성도 포함하고 있기 때문에 데이터의 일관성을 유지하기 어렵다는 점과 브라우저의 메모리를 낭비하는 것 자체가 비효율적으로 느껴지기 때문입니다.그래서 이에 대한 해결책으로 1번의 방안과 3번의 방안을 합쳐 활용하는 방식이 어떨까 생각했습니다.
action이 일어나면 mysql 자체에서 트리거를 사용한 히스토리 기록을 업데이트 하고, 히스토리를 db에서 하나씩 빼어 쓰는 형태입니다.트리거를 사용하여 히스토리를 기록할 때, 히스토리는 자동으로 데이터베이스에 추가되도록 해놓고, undo, redo가 나중에 추가될 경우에는 해당 유저에 해당하는 히스토리를 undo할 경우에는 가장 최신의 히스토리를 db에서 빼내어 이에 대한 action을 되돌리는 코드를 작성하면 될 것 같고, redo의 경우에는 어차피 action을 되돌리는 코드를 쓸 경우 또한 action이 card에 이루어질 것이기 때문에 이를 다시금 빼내어 undo를 undo 하는 방식으로 하면 될 것 같다고 생각했습니다.아래는 제가 작성한 트리거입니다.(mysql workbench에서 수행했습니다)delimiter $$ create trigger todo_submit_history
after insert on todo_cards
for each row
begin insert into history (username, card_id,action, column_name, title) values(NEW.author,new.card_id,"submit", NEW.task_column, NEW.title);
end$$ delimiter $$ create trigger todo_move_or_edit_history
after update on todo_cards
for each row
begin if OLD.task_column != NEW.task_column then insert into history(username, action, card_id,title, from_column, to_column) values(OLD.author, "move", old.card_id, old.title,old.task_column, new.task_column); else insert into history(username,card_id,action,title,detail) values(old.author,old.card_id,"edit", old.title, old.detail); end if;
end$$ delimiter $$ create trigger todo_delete_history
after delete on todo_cards
for each row
begin insert into history(username,card_id, title, detail, column_name, created_at) values(old.author, old.card_id, old.title,old.detail,old.task_column,old.created_at);
end$$
이러한 고민 과정에서 제가 드리고 싶은 질문은, 제가 선택한 방법이 효율적이고 안전한가?에 대해 여쭙고 싶습니다. undo와 redo를 고려하여 trigger를 설계했지만, 서버 -&gt; db에서 하나씩 꺼내어 해당 action에 맞춘 undo 로직 -&gt; 다시 서버로 반영하는 과정에서 db에 대한 부담이 없는가?에 대한 의문이 제대로 해소되지 못한 상태입니다. 이에 대해서 피드백 해주시면 감사하겠습니다!저도 하다보니 디렉토리가 너무 많아진 탓에 구분하시기 힘드실 수 있으실 것 같아 간단히 말씀드리려 합니다.
저는 클라이언트 사이드 렌더링을 많이 활용하고자 각각의 컴포넌트들에 대해서 fsd 패턴을 참고하여 컴포넌트들을 폴더별로 나눈 뒤에 다시금 해당 컴포넌트에 필요한 api나 스타일시트 등에 대해서는 가까운 자리에 배치했고, 이벤트 위임을 통한 로직은 feature에 큰 컴포넌트(widget)별로 구분한 뒤 index를 통해 스크립트를 통합하여 불러오는 방식으로 설계하였습니다.전체적인 디렉토리 구조는 아래와 같습니다.📦views ┣ 📂app ┃ ┣ 📜app.css ┃ ┣ 📜app.js ┃ ┗ 📜app.scss ┣ 📂asset ┣ 📂entities ┃ ┣ 📂addTodo ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂style ┃ ┃ ┣ 📂template ┃ ┃ ┗ 📜index.js ┃ ┣ 📂card ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂component ┃ ┃ ┣ 📂style ┃ ┃ ┣ 📂template ┃ ┃ ┗ 📜index.js ┃ ┣ 📂history ┃ ┃ ┣ 📂script ┃ ┃ ┣ 📂style ┃ ┃ ┣ 📂ui ┃ ┃ ┗ 📜index.js ┃ ┣ 📂historyItem ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂style ┃ ┃ ┣ 📂ui ┃ ┃ ┗ 📜index.js ┃ ┗ 📂section ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂component ┃ ┃ ┣ 📂style ┃ ┃ ┗ 📜index.js ┣ 📂feature ┃ ┣ 📂header ┃ ┃ ┣ 📜historyHandler.js ┃ ┃ ┣ 📜index.js ┃ ┃ ┣ 📜rendering.js ┃ ┃ ┗ 📜sortHandler.js ┃ ┣ 📂mainsection ┃ ┃ ┣ 📜addCardHandler.js ┃ ┃ ┣ 📜deleteCardHandler.js ┃ ┃ ┣ 📜editCardHandler.js ┃ ┃ ┣ 📜index.js ┃ ┃ ┣ 📜moveCardHandler.js ┃ ┃ ┗ 📜rendering.js ┃ ┗ 📜index.js ┣ 📂pages ┃ ┗ 📂main ┃ ┃ ┣ 📂css ┃ ┃ ┣ 📂ui ┃ ┃ ┗ 📜index.js ┣ 📂shared ┃ ┣ 📂deleteConfirm ┃ ┃ ┣ 📂component ┃ ┃ ┣ 📂css ┃ ┃ ┗ 📜index.js ┃ ┣ 📂fab ┃ ┃ ┣ 📂style ┃ ┃ ┗ 📜index.js ┃ ┣ 📂utils ┣ 📂widgets ┃ ┣ 📂header ┃ ┃ ┣ 📂component ┃ ┃ ┣ 📂style ┃ ┃ ┗ 📜index.js ┃ ┗ 📂mainsection ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂style ┃ ┃ ┣ 📂ui ┃ ┃ ┗ 📜index.js ┗ 📜index.pug
예를 들어, 각각의 section들을 불러오는 mainsection의 경우, /widgets/mainsection/index.js에서 해당 하는 하위 컴포넌트들을 의존 관계로 묶어 렌더링 하는 방식으로 설계했습니다.// /widgets/mainsection/index.js
import section from "/entities/section/index.js";
import pug from "/shared/utils/pugCompile.js"; function Mainsection() { const template = `style | @import url('/widgets/mainsection/style/mainsection.css')
main#sections`; function render() { const mainsection = pug.compileHTML(template); document.getElementById("html__body--pageContainer").innerHTML += mainsection; section.render(); } return { render, };
} const mainsection = new Mainsection();
export default mainsection; 그렇기 떄문에 mainsection을 렌더링시키는 함수를 만들어 해당 함수에서는 기존에 pug 파일을 컴파일하여 반환된 HTML element들을 DOM Api를 통해 직접 지정한 위치에 그려갑니다.// entities/section/index.js
import fetch from "./api/index.js";
import card from "/entities/card/index.js";
import addTodo from "/entities/addTodo/index.js"; function Section() { const template = `style | @import url('/entities/section/style/section.css')
section(id=section.classify) .main__div--topbar .section__div--titleWrapper span.titleWrapper__span--title #{section.classify} span.titleWrapper__span--count #{section.cards.length} .section__div--buttonWrapper img(src="/asset/plus.svg", alt="add", data-action="add", data-target=section.classify) img(src="/asset/close.svg", alt="delete") ul.todoList`; async function render() { const { data, path } = await fetch(); console.log(data); const compiledFunction = window.pug.compile(template, { basedir: path, }); document.getElementById("sections").innerHTML = ""; data.forEach((section) =&gt; { const html = compiledFunction({ section: section }); // 렌더링된 HTML document.getElementById("sections").innerHTML += html; addTodo.render(section.classify); card.render(document.getElementById(section.classify), section.cards); }); } return { render, };
} const section = new Section();
export default section; 이렇게 렌더링 중간에 데이터를 fetching해와야 하는 부분은 컴포넌트마다 설정하여 데이터를 가져온 후에 가져온 데이터를 기반으로 렌더링하게 됩니다. 만약 카드 추가나 삭제와 같은 행위 또한 이벤트를 호출하면 해당 section 전체를 위 함수의 render() 함수를 통해서 리렌더링하는 방식을 구상하여 구현해 보았습니다.제가 원하는 대로 컴포넌트마다 각각에 대해 데이터를 json 형식으로 가져오고, 받아온 데이터를 기반으로 templating 및 painting 작업을 클라이언트에서 한다는 점에서 클라이언트 사이드 렌더링이 어느정도 구현되었다고 생각합니다.리렌더링의 경우 DOM API를 사용해서 다시금 초기화하고 그려내는 방식 자체가 너무 raw하다는 생각이 들었습니다. DOM 작업의 경우 고비용인데 반해 이를 계속 데이터 갱신이 이루어질 때마다 다시금 http 요청을 보내고 렌더링 단위인 전체 column에 대해 리렌더링하는것이 자원 낭비라고 생각이 들었습니다.
하지만 이러한 비용을 아끼고자 카드 추가, 삭제와 같은 경우 받아온 json 데이터를 통해 하나만의 카드를 추가하거나 삭제하는 soft한 방식의 추가나 삭제의 경우 동시 접근해서 수정이나 다른 곳에서 같은 계정의 column의 작업에 대해 반영사항을 불러오지 못한다는 점에서 전체적인 column의 데이터를 다시 get해와서 리렌더링 하는 것이 합리적이라는 생각 또한 들어 어떤 방식이 더 맞을까에 대한 고민이 계속 되는 것 같습니다. 이에 대한 멘토님의 고견을 여쭙고 싶습니다!]]></description><link>부스트캠프/멤버십/3주차/week3_2일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/week3_2일차_PR.md</guid><pubDate>Wed, 04 Sep 2024 00:27:08 GMT</pubDate></item><item><title><![CDATA[sql 트리거]]></title><description><![CDATA[트리거(Trigger)는 테이블에서 어떤 이벤트가 발생했을 때 자동으로 실행되는 함수와 같은 존재다.자바스크립트의 이벤트 리스너처럼 어떤 테이블에서 특정한 이벤트가 발생했을 때 실행시키고자 하는 추가 쿼리 작업들을 자동으로 수행할 수 있게끔 트리거를 미리 설정해주는 것이다.정말 간략하게 예를 들어보자면, A 테이블에 1이라는 숫자가 입력됐을 때, 자동으로 B 테이블에도 1을 복사해주고 싶을 때 트리거를 이용해 설정해 놓았다면 자동으로 B에도 1이라는 숫자가 입력되게 할 수 있습니다.<img src="https://velog.velcdn.com/images/odh0112/post/8dbbda7b-059a-4cab-ac75-51494f665cdf/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
INSERT, UPDATE, DELETE 문에 대해&nbsp;한 번만&nbsp;실행
AFTER 트리거 : 쿼리 이벤트 작동한 후
BEFORE 트리거 : 쿼리 이벤트가 작동하기 전 -&gt; 미리 데이터를 확인 가능할 때
<br><img src="https://velog.velcdn.com/images/odh0112/post/64e5363f-9df4-48f0-bb0b-b6aae6236ef1/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
테이블 안의 영향을 받은 행 각각에 대해 실행
변경 전 or 변경 후의 행은 각각&nbsp;OLD, NEW라는 가상 줄 변수를 사용하여 읽어옴 OLD : 기존 데이터, delete로 삭제 된 데이터 또는 update로 바뀌기 전의 데이터 NEW : 새로운 데이터, insert로 삽입된 데이터 또는 update로 바뀐 후의 데이터 INSERT - 새롭게 데이터가 추가되는 것이므로 이전 데이터는 존재하지 않아 OLD X, NEW O 입니다.
UPDATE - 기존에 있던 데이터를 새로운 데이터로 변경하는 작업이기 때문에 OLD O, NEW O 입니다.
DELETE - 기존에 있던 데이터를 지우는 작업이므로 OLD O, NEW X 입니다. DELIMITER $$ CREATE TRIGGER before_to_after -- before_to_after라는 Trigger 이름
AFTER INSERT ON before_num -- {BEFORE | AFTER} {INSERT | UPDATE | DELETE}중 언제 어떤 작업을 할 지 정해줍니다.
FOR EACH ROW -- 아래 나올 조건에 해당하는 모든 row에 적용한다는 의미 BEGIN -- Trigger가 실행되는 코드 IF NEW.number THEN -- 새로운 number가 입력됐을 때, INSERT INTO after_num(id, number) VALUES(NEW.id, NEW.number); -- `VALUES(NEW.id, NEW.number)`의 데이터를 after_num의 id, number에 삽입 END IF;
END $$ BEGIN ~ END 사이에 조건문과 실행문을 작성
delimiter(구문 문자, 문법의 끝) 명시(대부분 $$를 많이 씀)
Trigger before_to_after는&nbsp;AFTER INSERT ON before_num가 실행되면 자동으로 트리거가 작동하는 구조이기 때문에, before_num 테이블에 새로운 데이터를 삽입해주면 됩니다.INSERT INTO before_num(number) VALUES(1); 앞서 만들었던 Trigger 이름과 명령 등 정보들을 확인
SHOW triggers;
<br><img src="https://velog.velcdn.com/images/odh0112/post/a62e280a-9aab-4f78-8eca-6d74ee2f7bc6/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">-- 전부 삭제
DELETE TRIGGERS; -- 하나만 삭제
DROP TRIGGET 트리거이름; 변수 선언은&nbsp;DECLARE&nbsp;명령을 이용해 사용
BEGIN ~ END 사이에 작성
-- DECLARE 선언 방법 BEGIN DECLARE 변수 타입 {디폴트값} . . .
END
IF (조건) THEN
ELSEIF (조건) THEN
ELSE
ENDIF
]]></description><link>부스트캠프/멤버십/3주차/sql-트리거.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/sql 트리거.md</guid><pubDate>Tue, 03 Sep 2024 10:00:05 GMT</pubDate><enclosure url="https://velog.velcdn.com/images/odh0112/post/8dbbda7b-059a-4cab-ac75-51494f665cdf/image.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://velog.velcdn.com/images/odh0112/post/8dbbda7b-059a-4cab-ac75-51494f665cdf/image.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[쿠키와 세션]]></title><description><![CDATA[쿠키와 세션에 대해 알기 위해서는 HTTP 프로토콜의 특성에 대해 알 필요가 있다. HTTP 프로토콜의 특성에 대해 가지는 결점을 보완하기 위해 나온 것이 쿠키와 세션이기 때문이다.
Client-Server 구조 각각의 서버와 클라이언트는 독립되어 있는 상태이다
클라이언트는 서버에 요청을 보내고 응답이 올 때까지 대기하며, 서버는 클라이언트에서 받은 요청에 대한 결과를 만들어 응답을 한다(Request&lt;-&gt;Response) Connectionless(비연결성) 계속해서 연결을 유지한는 TCP/IP와는 달리 HTTP 프로토콜은 클라이언트에서 서버에 요청(Request)을 보내면 서버는 클라이언트에 응답(Response)을 하고&nbsp;연결을 끊는 특징을 가지고 있다. 이를 통해 최소한의 자원으로 서버를 유지할 수 있도록 한다.
하지만 트래픽이 많거나 큰 규모의 서비스를 운영할 경우, 비연결성은 한계를 보인다. HTTP 1.0이 각각의 자원을 다운로드 하기 위해 연결과 종료를 반복하는 등의 3 Way Handshake(연결 -&gt; 요청/응답 -&gt; 종료 과정에서 일어나는 시간 지연때문에 이를 해결하고자 HTTP1.1부터는 지속 연결(Persistant Connections)가 가능해졌다. stateless(무상태성) 서버는 클라이언트의 상태를 저장하지 않는다 이처럼 HTTP 프로토콜의 특성을 고려할 때, 비연결성과 무상태성의 특성을 유지하면서도 서버와 클라이언트가 통신을 하면서 로그인이나 장바구니 등등 계속해서 상태를 간직해야 하는 부분이 불가능하다. 따라서 이러한 약점을 보완하고자 나온 개념이 쿠키와 세션이다.HTTP의 일종으로 사용자가 어떤 웹 사이트를 방문할 경우, 해당 사이트가 사용하고 있는 서버에서&nbsp;사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다.
HTTP에서 클라이언트의 상태정보를 쿠키 형태로 클라이언트 PC에 저장하였다가&nbsp;필요 시 정보를 참조하거나 재사용할 수 있다.
Key-Value쌍으로 구성
쿠키이름, 쿠키값, 만료시간, 전송할 도메인명, 전송할 경로, 보안연결여부, HttpOnly여부로 구성
도메인 당 20개의 쿠키를 가질 수 있음
하나의 쿠키는 4KB(= 4096 byte)까지 저장이 가능
<img src="https://i.imgur.com/0xyg0F8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
클라이언트가 서버에 로그인 요청
서버는 클라이언트의 로그인 요청의 유효성을 확인하고(아이디와 비밀번호 검사) 응답헤더에&nbsp;set-cookie:&nbsp;를 통해 쿠키를 추가하여 응답
클라이언트는 이후 서버에 요청할 때 전달받은 쿠키를 자동으로 요청헤더에 추가하여 요청한다. 헤더에 쿠키값을 자동으로 추가하여 주는데 이는 브라우저에서 처리해줌 쿠키의 기한이 정해져있지 않고 명시적으로 지우지 않는다면 반 영구적으로 쿠키가 남아있음 세션 관리(Session Management) 로그인, 사용자 닉네임, 접속 시간, 장바구니 등의 서버가 알아야할 정보들을 저장 개인화(Personalization) 사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있다. 트래킹(Tracking) 사용자의 행동과 패턴을 분석하고 기록 이러한 쿠키의 경우 클라이언트에서 수정할 수 있기 때문에 위변조의 위험이 항상 존재한다.
이에 쿠키값을 암호화해야하며, 민감하거나 중요한 정보를 담지 않도록 해야 한다.일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술이다.
여기서 일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.
즉, 브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해주는 기술을 세션이라고 한다.
웹 서버에&nbsp;웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.
웹 서버에 저장되는 쿠키(세션 쿠키 / session cookie)이다.
브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되기 때문에&nbsp;쿠키보다 비교적 보안적으로 우수하다.
저장 데이터에 제한이 없다.(서버 용량 허용 범위 내에서)
각 클라이언트에&nbsp;고유 세션 ID(Session ID)를 부여한다. 세션 ID를 통해 클라이언트를 구분하여 각 요구에 맞는 서비스를 제공한다.
<br><img src="https://velog.velcdn.com/images/octo__/post/43cd0113-e3d4-4139-9bf9-4c3d06e050ad/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
클라이언트가 서버에 로그인 요청
서버는 클라이언트의 로그인 요청의 유효성을 확인하고(아이디와 비밀번호 검사)&nbsp;unique한 id를 session ID로 생성하여 저장한다.
서버가 응답할 때&nbsp;응답헤더에 세션 ID를 쿠키에 추가하여 응답합니다.
클라이언트는 이후 서버에 요청할 때 전달받은 세션 ID를 쿠키에 자동으로 요청 헤더에 추가하여 요청한다.
서버에서는 요청 헤더의 세션 ID 값을 저장된 세션저 장소에서 찾아보고 유효한지 확인 후 요청을 처리하고 응답한다.
사용자나 다른 누군가에게 노출되면 안되는 보안적으로 중요한 정보들을 서버 안에서 다루기 위해 사용한다.세션의 내용은 서버에 저장되기 때문에 계속하여 늘어날 경우 서버에 부하가 발생할 수 있다.
또한 세션에 대한 정보가 서버에 있어 쿠키에 비해 비교적 속도가 느리다.
쿠키:&nbsp;클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드디스크
세션:&nbsp;서버의 메모리에 저장 쿠키: 저장할 때 expires 속성을 정의해 무효화시키면&nbsp;삭제될 날짜 지정 가능
세션: 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화되어&nbsp;정확한 시점을 알 수 없음 쿠키: 클라이언트에 저장되고, 클라이언트의 메모리를 사용하기 때문에&nbsp;서버 자원을 사용하지 않음
세션: 서버에 저장되고, 서버의 메모리로 로딩되기 때문에&nbsp;세션이 생길 때마다 리소스를 차지함 쿠키: 클라이언트도 모르게 접속되는 사이트에 의해 설정될 수 있기 때문에 쿠키로 인한 문제가 발생하는 것을 막기 위해&nbsp;한 도메인 당 20개, 한개의 쿠키 당 4KB로 제한
세션: 클라이언트가 접속하면 서버에 의해 생성되므로&nbsp;개수나 용량 제한 없음
]]></description><link>부스트캠프/멤버십/3주차/쿠키와-세션.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/쿠키와 세션.md</guid><pubDate>Tue, 03 Sep 2024 09:55:31 GMT</pubDate><enclosure url="https://i.imgur.com/0xyg0F8.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/0xyg0F8.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[xss 공격]]></title><description><![CDATA[XSS 공격은 웹 해킹 공격 중 하나이다.
Cross Site Scripting의 약자로 CSS와 겹치지 않게 XSS 공격이라고 부른다.XSS는 게시판이나 웹 메일 등에 자바스크립트 코드를 삽입하여 개발자가 고려하지 않은 기능을 작동시킬 수도 있는 치명적인 공격이다.Reflected XSS는 스크립트가 포함된 공격용 악성 URL을 만들어 사용자가 해당 URL을 클릭했을 때 정보를 흭득하는 방식으로 공격이 이루어진다.
<img src="https://i.imgur.com/PIo0PxZ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">URL을 만들어서 클릭해서 실행되게 하는 방식으로&nbsp;특정인을 대상으로&nbsp;한다
URL&nbsp;파라미터 데이터가 그대로 서버 응답에 삽입되어 오는 곳에서 발생하며(요청과 응답 페이지가 동일해야 함) , 데이터 전달은&nbsp;GET 방식이여야 한다(POST 방식은 공격에 활용할 여지가 없음)<br><img src="https://i.imgur.com/yxoWQUn.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Stored XSS는&nbsp;취약한 웹 서버에 악성 스크립트를 심어놓고, 사용자가 접근하면 해당&nbsp;스크립트가 실행되는 공격이다.보통 서버에서 필터링을 하기 때문에 공격을 우회하기 어렵지만, 한 번 성공하면 관리자 입장에서는 눈치채기 힘들고&nbsp;광범위한 피해를 줄 수 있다는 것이 특징이다. &nbsp; 데이터가&nbsp;저장되고,&nbsp;출력되는 곳 (저장되는 페이지와 출력되는 페이지는 달라도 상관 없음)
-&nbsp;접근하는 모든 사람에게 공격이 가능하기 때문에 광역기 수준의 위험도를 가짐
<br><img src="https://i.imgur.com/8epYE3J.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Reflected XSS와 Stored XSS 공격이 서버의 취약점을 이용해서 악성 스크립트가 포함된 응답 페이지를 전달하는 것이다. 반면 DOM XSS는 서버와 관련없이 클라이언트 단에서 파라미터를 처리할 때 발생한다.&nbsp;DOM XSS 공격은 사용자가 공격자가 조작한 URL을 클릭하는 순간, 악성 스크립트가 실행되면서 사용자 브라우저를 공격하는 방법이다.XSS 공격에 대응하는 방법은, 주로 XSS의 접근 방식을 보완하면 된다.
XSS는 사용자의 입력 값에서부터 발생하여, HTML Entity로 입력 값 조작을 방지하는 것이 근본적인 대방책이다.
&lt;&gt;";&amp;와 같은 HTML 예약어에 대해서 정규표현식 등으로 검사한 뒤에 스크립트가 실행될 수 있는 환경을 만듦으로써 공격자의 우회 방식을 방어할 수 있다.]]></description><link>부스트캠프/멤버십/3주차/xss-공격.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/xss 공격.md</guid><pubDate>Tue, 03 Sep 2024 04:45:26 GMT</pubDate><enclosure url="https://i.imgur.com/PIo0PxZ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/PIo0PxZ.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week3_1일차_PR]]></title><description><![CDATA[
erd 재구조화 ✅ 2024-09-02
move post api 구현 및 연결(진행중) 🛫 2024-09-02
삭제 post api 구현 및 연결 ✅ 2024-09-02
수정 patch api 구현 및 연결 ✅ 2024-09-02 클로저
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/3-1f7fcdb0591241f487bdfa6f74f1200a?pvs=4" target="_self">https://luxurious-share-af6.notion.site/3-1f7fcdb0591241f487bdfa6f74f1200a?pvs=4</a>
ERD를 짜는 과정에서 계속해서 필요할까? 필요하지 않을까? 에 대한 확신을 스스로도 가지지 못했다고 생각한다.나의 경우 기존에 username과 user_id를 따로 두는 식으로 관리를 하고, user_id의 경우 task_column에서 참조하고, todo_cards에서는 user 테이블의 username을 참조하는 방식으로 ERD를 설계했다.
하지만 이에 대해서 user_id와 username을 참조하는 곳이 다를 때, author을 username을 통해서 가져와야 하는데 username을 user의 테이블에서 가지고 올 경우 task_column의 경우는 task_columns 테이블의 col_name을 참조하면서도 user_id의 경우는 user 테이블에서 가져오는 것이 의존 관계가 서로 결합되어 두 테이블이 변경 시마다 일일이 갱신시키게 하는 것이 비효율적이라고 생각했다.따라서 이에 대한 해결책으로 기존에 user_id를 무조건 써야 한다는 생각을 버리고 username을 중복되지 않은 기본 키로 설정한 후에 task_columns또한 username을 받고, 이를 참조하는 todo_cards 테이블 또한 task_columns 테이블만을 참조하게 하도록 의존 관계를 바꾸어 보았다.<br><img src="https://i.imgur.com/mKCZO5w.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">기획서에는 move(이동), change(변경), submit(등록)에 대한 history가 명시되어 있다.(삭제와 같은 action도 고려해볼 만 하지만 아직은 이를 생각할 단계가 아니기 때문에 이에 대한 내용은 생략한다)
문제는 이러한 action들이 이루어질 때, 히스토리는 어느 시점에서 함께 업데이트 되어야 하는가? 에 대한 고민이 있다.
mysql 자체에서 트리거를 사용한 히스토리 기록 Mysql에서 지원하는 트리거(Trigger)은 특정 조건이 만족하면 저절로 실행되는 일종의 장치로, 한번 설정을 해놓으면 이벤트리스너와 비슷한 방식으로 동작을 계속 감시하면서 조건에 해당하는 동작이 수행되는 순간 실행되는 특징을 가진다.
트리거를 사용하여 히스토리를 기록할 때, 히스토리는 자동으로 데이터베이스에 추가되기 때문에 undo, redo를 고려하는 입장에서 이를 설계해보자면 undo, redo를 수행하면 히스토리에서 해당하는 유저의 히스토리에서 가장 최근의 히스토리를 제거한다.
히스토리가 제거될 때 실행되는 트리거를 등록하여 트리거를 통해 history의 undo를 수행한다.
그러나 redo를 수행할 때는 지금 생각한 정도로는 history에 대한 History 테이블을 다시 만드는 방법밖에는 생각나지 않는데, history 테이블을 두 개 두는 것이 상식상으로는 괜찮아 보이지 않아서 고민이다. 온메모리에서 deque를 통한 history 저장 mysql의 트리거를 사용하지 않고 따로 history에 Insert를 통해서 넣어주는 방식이다.
deque에서 5개의 개수제한을 놓고, action이 이루어질 때마다 하나씩 push해주되, 개수를 넘어가면 하나씩 dequeue해주면서 이에 대해 실질적으로 db에 반영해주는 방식이다.
이렇게 설계할 경우, 온메모리에서 deque를 하나 두고 Undo와 redo에 대해서 action마다 수행하는 로직을 브라우저 상에 놓고 관리하게 된다.
일반적으로 undo, redo는 새로고침이나 창을 나갔다가 다시 접속할 시에 없어지게 되므로, 새로고침이나 창 닫기 등의 행위를 이벤트리스너를 등록해놓고 있다가 해당 이벤트가 발생하면 flush를 통해서 모든 history의 내용을 반영하는 로직으로 작동시킨다. 하지만 이러한 방식으로 갈 경우, history에 대한 예외 로직이 이루어지지 않아 만약 창을 껐을 시에 이벤트가 제대로 동작하지 않는다면 history의 갱신이 이루어지지 않으므로 이는 db의 손상을 일으킨다. db에 action때마다 직접 넣되, 하나씩 빼서 undo, redo
- 이 경우, action에 대한 api 호출을 하면서 해당 api를 처리하는 로직에서 히스토리 업데이트 + aciton에 대한 수행 자체를 하나의 트랜잭션으로 인식하여 사용해야 한다.
- 각각의 action에 대한 히스토리의 레코드를 직접 쿼리문을 통해 넣어준다.
- redo의 경우 undo한 것을 빼서 온메모리에서 stack 형식으로 저장하고 있다가 다시 실행할 경우 이에 대한 로직을 설계하여 다시금 돌아갈 수 있다.
- redo의 경우 굳이 새로고침이나 창을 껐을 때, 복구시킬 의무는 없다고 생각한다. undo 또한 db에서 계속 끌어다가 복구할 수는 있겠지만은 굳이 이걸 전부 할 수 있도록 허용해주면 db에 부담이 갈 수 있기 떄문에 브라우저 내부에서 개수를 정해놓고 이를 막는 방식이 나을 것 같다고 판단했다.
- 나는 히스토리와 action의 수행이 하나의 트랜잭션으로 판단해야만 정상적인 db의 갱신이 이루어지기 때문에 이 방식이 제일 합리적이라고 생각한다.
아직까지는 세 가지 고민을 하면서 구현중인데, move까지 구현이 된다면 이에 대해서 history를 다시금 생각해보고 구현 및 연결할 예정이다.
]]></description><link>부스트캠프/멤버십/3주차/week3_1일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/week3_1일차_PR.md</guid><pubDate>Mon, 02 Sep 2024 14:40:50 GMT</pubDate><enclosure url="https://i.imgur.com/mKCZO5w.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/mKCZO5w.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_3주차_학습정리]]></title><description><![CDATA[ move post api 구현 및 연결
erd 재구조화
삭제 post api 구현 및 연결
수정 patch api 구현 및 연결
]]></description><link>부스트캠프/멤버십/3주차/멤버십_3주차_학습정리.html</link><guid isPermaLink="false">부스트캠프/멤버십/3주차/멤버십_3주차_학습정리.md</guid><pubDate>Mon, 02 Sep 2024 06:35:36 GMT</pubDate></item><item><title><![CDATA[클린 코드와 코드 리뷰]]></title><description><![CDATA[
코드와 코딩에 대한 근본적인 생각
코드와 코딩이란 무엇인가?
처음에 개념이 잘못 잡혀있는 상태에서 달려나가다보면 시간을 허비할 수 있음. 첫 단추를 잘 꿰는 시간
<img src="https://i.imgur.com/S4jClJl.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
<br><img src="https://i.imgur.com/rxvRAJv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
클린 코드라는 책을 잘못 읽어 오해하고 있는데 이를 잘 읽기 위한 관점을 제시<br>
<img src="https://i.imgur.com/0xJzBrx.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
어려운 순간들을 회피하지 말고 직면할 것
<br><img src="https://i.imgur.com/aqoB6Kf.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
코드리뷰할 때 코드가 클린하지 않다는 이유로 리젝하는 경우가 많음
클린 코드와 코드 리뷰를 많이 엮어서 생각하는 사람이 많음
깨끗한 코드에 대한 이야기를 다룬 책들이 많아짐 클린이라는 의미가 여러 의미로 해석되어 많은 해석들이 만들어짐<br>
<img src="https://i.imgur.com/0FfjTlp.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/KPvkaHe.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
맹목적으로 클린 코드에 대해 지키려고 하면서 생기는 문제들
책을 잘못 읽어 코드 결벽증이 생기는 사람들이 많음
좋은 개발 원칙들을 너무 강하게 적용하려고 하다 보니 생기는 문제들
지나친 코드 강조 클린 코드는 코드 자체에 대해 한정되지 않은 책임에도 불구하고 코드에만 집중하는 경향 <br><img src="https://i.imgur.com/ffIlIUx.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
클린은 "깨끗하다"는 의미가 아님
책에서 나온 클린의 의미는 4번째에 가까움. 명료하고 명쾌한 것
여기에 집중하다보니 집중하기 힘들고 클린한 상태가 될 때까지 계속 고쳐서 진도가 안 나감
<br><img src="https://i.imgur.com/yEo6Mzd.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
코드의 가독성은 잘 읽힌다는 것을 넘어서 결함이 없도록 하는 코드
가독성? -&gt; 너무 단순해서 결함이 없는 것이 당연하다는 것<br>
<img src="https://i.imgur.com/prCcWs1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
클린코드에 대해 부정하는 사람들
좀 더 명확한 어휘의 사용이 필요하다고 지적하는 사람들
<br><img src="https://i.imgur.com/66fvmfl.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
프로그래머가 지향해야 하는 바 -&gt; 단순히 동작 뿐만 아니라 유지보수하기 좋아야 함
어디를 어떻게 고치면 되겠다 하는 코드
코드를 통해서 학습할 기회
품질과 생산성은 반대되는 가치처럼 보이지만 많은 영역에서 품질이 일정수준을 넘어서면 생산성은 따라서 올라감
<br><img src="https://i.imgur.com/WPUbaZQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
원칙과 패턴의 의미
원칙 패턴에서 많이 신경을 쓰기만 하고 그 뒤애서는 크게 신경쓰지 않음<br>
<img src="https://i.imgur.com/V20AVDV.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
다섯 가지 단계의 기술 습득
입문자 상황에 맞는 지식을 꺼낼 수 없음 초급자 지엽적으로 들여다보는 시야
상황에 맞는 지식을 꺼낼수는 있음
똑같은 실력에서 멈춤 중급자 전체적으로 보고 문제를 인식함 숙련자 문제를 해결할 때, 일단 함
도구가 손에 익어서 자유롭게 함. <br><img src="https://i.imgur.com/busPold.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
원칙과 패턴을 통해 훈련하라
모르는데도 오바하려는 등의 행동
클린이라는 말을 오해하지 말자
<br><img src="https://i.imgur.com/9UVql04.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
7번 이후에서부터 코드와 관련 없는 것들<br>
<img src="https://i.imgur.com/kxa6Pc9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
기획부터 테스트까지 프로젝트의 일련의 과정 자체가 원초적으로 어떤 것을 만들어내는 방식 자체를 소프트웨어에 적용
인간의 이해할 수 없는 것을 코드로 변환하는 사람 -&gt; 코더
<br><img src="https://i.imgur.com/ySjqCQu.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
코딩이라는 것이 설계의 일부<br>
<img src="https://i.imgur.com/tTqH1jQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
설계의 과정으로써 코딩이 들어가야 함
설계와 시공이 분리되는 것처럼, 소프트웨어에서의 시공은 컴파일러가 하는 것임
컴파일만 하면 되기 때문에 너무 엄격하게 설계할 필요가 없음
<br><img src="https://i.imgur.com/OUENVMv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/vKnf1Vm.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
기계가 실행하는 명령의 집합
코드는 설계 문서이고, 사람이 읽어야 함<br>
<img src="https://i.imgur.com/pK4xGZb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
계층적으로 나누어진 목차
소프트웨어를 어떻게 설계할 것이냐에 대한 이야기를 포함함
코딩은 설계다<br>
<img src="https://i.imgur.com/WC0TX70.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/AVjNr6n.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
유지보수성을 늘리는 방법
factoring -&gt; 인수분해
코드를 만들면 한곳에 떡져있거나 컴포넌트별로 잘 구성되어 있을 수 있음. 소프트웨어를 어떻게 정리할 것인가를 위해 구성 요소를 잘 분해해야 할 필요성이 있는데, 이러한 점이 팩터링. 분해하고 설계하는 것
리팩터링은 곧 재설계<br>
<img src="https://i.imgur.com/7eK9j8R.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
테스트 코드가 있으면 변경이 쉬워진다.
리팩토링을 테스트와 함께 하면 더 쉬워짐<br>
<img src="https://i.imgur.com/owBT2U9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
테스트코드 -&gt; 안전장치 내가 잘 돌아가는 코드인데 잘못 고칠 수도 있음
이러한 위험성을 위한 안전장치
스트레스 적게 안심하게 일을 할 수 있음
테스트코드와 리팩터링은 함께 맞물려서 돌아감 <br><img src="https://i.imgur.com/EFSGFlU.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
리팩토링 전 코드를 깔끔하게 쓰는 습관<br>
<img src="https://i.imgur.com/XYqmeIE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
계속해서 설계와 유지보수를 하면서 코드를 만드는 사이클이 커가짐
<br><img src="https://i.imgur.com/A1dnPaL.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
TDD -&gt; 코드를 만들기 전에 테스트를 작성 테스트를 통과하기 위한 최소한의 코드
리팩토링을 통한 개선
계속 개선함으로써 설계를 나중에
사이클이 빠르게 돌아가면서 리팩토링과 코딩이 동시에 진행됨 <br><img src="https://i.imgur.com/1Wg1H0b.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/bdbLzMt.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
결국엔 아키텍처조차 리팩토링 될 수 있음
클린 코드 -&gt; 단순한 코드의 표현에 대한 얘기가 아님
<br><img src="https://i.imgur.com/hZPLfeH.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
소프트웨어를 다른 관점으로 보기<br><img src="https://i.imgur.com/dUn12q6.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
소프트웨어는 키우는 것
키워나가면서 계속해서 발전하는 방식
그 관점에서 코드를 봐야 함
계속 반복하면서 소프트웨어를 키워 나가는 과정
<br><img src="https://i.imgur.com/qHBqHXd.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
클린 코드를 작성할 수 있는 사람이 되어라
<br><img src="https://i.imgur.com/kfVZA9Z.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
클린 코더가 되어야 함
클린 코더가 작성하려고 노력하는 과정이 곧 클린 코드<br>
<img src="https://i.imgur.com/ExSbsLR.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
기법만이 전부가 아님
<br><img src="https://i.imgur.com/tUm5W2c.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
중요한 것은 일관성 유지, 지식 공유, 협력과 소통
<br><img src="https://i.imgur.com/YfIEymQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
코드 PR날리거나 머지할 때 동료에게 코드를 받아 승인을 받거나 개선할 수 있는 단서를 받기
<br><img src="https://i.imgur.com/aiiENtb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내가 코드를 작성할 때, 다른 사람을 위해서 코드를 작성해야 함
피드백 -&gt; 싫은 소리 듣는다고 생각함
리뷰에 대한 부담감
<br><img src="https://i.imgur.com/RerJVdM.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내 장점을 강화하면서 단점이 문제가 되지 않기 위해 조정하는 과정
너무 부정적으로만 생각함
학교는 커리큘럼이 있지만 사회는 정답이 없음. 아무도 알려주지 않음.
학교에서는 정해진 길을 착실하게 밟으면 됐지만 이제는 직접 탐색해야 함
탐색해야 할 때 이행하듯 직선으로 가는 것이 아닌, 전략을 다르게 잡아야 함
이제까지 하던 습관대로 하던대로 이행하려고 하게 되면 문제가 됨
<br><img src="https://i.imgur.com/T0QJ4ee.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
무지하다는 것
메타 인지
객관적으로 들여다보기
피드백 받기 내가 성장하기 위해 필요함
내가 성장하고 싶고, 이를 위해 주변 사람을 이용해서 나의 성장에 사용하는 건전한 사고방식
나 자신이 성장을 추구하고 성장하겠다고 하는 자세가 되어있다면, 싫은 소리도 수월함
싫은 소리를 듣더라도 건전하게 수용함으로써 성장 <br><img src="https://i.imgur.com/EKi0UUC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
성장형 사고방식 하기
<br><img src="https://i.imgur.com/wEw5Qmk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/ilDz3fy.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
코드리뷰에 대한 테크닉에 대한 영상
<br><img src="https://i.imgur.com/K9NRvgo.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
소프트웨어 엔지니어링 분야가 만들어질 때 나온 논문들
다익스트라 -&gt; 프로그래밍은 인간적인 행동으로 인식됨 인간의 인위적인 능력의 한계 등이 소프트웨어 개발에도 해결해야 할 문제임 결국 소프트웨어 엔지니어링은 우리가 인간이기 떄문에 필요함
<br><img src="https://i.imgur.com/x93quIK.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/GiLEBjK.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.cs.utexas.edu/~EWD/transcriptions/EWD01xx/EWD117.html" target="_self">https://www.cs.utexas.edu/~EWD/transcriptions/EWD01xx/EWD117.html</a>
코드를 많이 보면 능력이 보면 능력이 키워지지만 엉터리 코드를 보면 능력이 좋아지지 않음
좋은 코드를 많이 보면서 보는 능력 키우기(오픈 소스 보기)
done is done 더 이상 할 일이 없다
리팩토링까지 끝남
계획을 세울 때 버퍼를 잡아두는 것이 좋음
평균적으로 머지를 할 때 피드백을 받는 것을 상정하고 계획하기 함수를 만들 때는 목적이 분명해야 함 적당한 크기를 갖되, 목적이 분명하게
목적이 불분명하면 합치고, 아니면 나누는 작업
애매모호할 때 지나치게 나누는 것보다는 합치기
코드의 길이를 한 화면을 덮지 않도록 만들기
한 화면에 모든 코드가 보이도록
가로, 세로가 내 시야를 넘지 않도록 ]]></description><link>부스트캠프/멤버십/2주차/클린-코드와-코드-리뷰.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/클린 코드와 코드 리뷰.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/S4jClJl.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/S4jClJl.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[클로저]]></title><description><![CDATA[내 기준 '자바스크립트를 조금 할 줄 안다'의 기준은 클로저와 커링에 대한 이해도라고 생각한다(그런 의미에서 나는 걍 코드싸개임이 분명하다).
<img src="https://i.imgur.com/2EqfV3e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
하지만 자바스크립트를 사용하는 프레임워크 대부분이 함수형 프로그래밍으로 되어 있고, 프론트엔드라면 함수 안에 함수가 들어있는 형태를 익숙해질 필요가 있다.암튼 정리 시작
클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다
여기서 중요하게 보아야 할 키워드는 '함수가 선언된 렉시컬 환경'이다.const x = 1 function outerFunc(){ const x = 10 function innerFunc(){ console.log(x); //10 } innerFunc();
}
outerFunc();
outerFunc 함수 내부에서 중첩 함수 InnerFunc가 정의되고 호출되었다.
이때 중첩함수 InnerFunc의 상위 스코프는 외부 함수 outerFunc 의 스코프로, innerFunc 내부에서 자신을 포함하고 있는 외부 함수 outerFunc의 x 변수에 접근할 수 있다.
하지만 중첩된 함수가 아니라면 innerFunc는 outerFunc함수의 변수에 접근할 수 없다.이 이유는 자바스크립트가 렉시컬 스코프를 따르는 언어이기 때문이다.
렉시컬 스코프(정적 스코프)란?
외부 렉시컬 환경에 대한 참조에 저장할 참조값
함수를 어디에 정의했는지에 따라 상위 스코프를 정할 수 있는 자바스크립트의 스코프
이처럼 선언된 함수(호출 위치x)의 위치에 따라서 상위 스코프가 정해지는 것이다.
따라서 위 예제의 outerFunc()를 보면 해당 함수는 가장 바깥에서 실행되었기 때문에 해당 함수의 스코프는 전역으로 볼 수 있다.위에서 말한 것처럼 함수가 정의된 환경(위치)와 호출되는 환경(위치)는 다를 수 있다.
따라서 렉시컬 스코프가 가능하기 위해서는 함수가 자신이 정의된 환경, 즉 상위 스코프를 기억해야 한다.
그렇기 때문에 함수는 자신의 내부 슬롯 [[environment]]에 자신이 저장된 환경(상위 스코프의 참조)을 저장해 놓는다.가장 바깥의 함수의 경우 전역 렉시컬 환경을 참조하도록 맨 처음 함수 정의 평가가 실행될 때 저장되지만, 함수 안의 내부 함수는 바깥쪽 함수가 실행될 때 해당 외부 함수 렉시컬 환경의 참조가 저장된다. 이 부분이 이해가 가지 않는다면 함수가 호출될 때 실행되는 내부 로직을 보면 된다.함수는 호출될 때 함수 내부로 코드의 제어권이 이동하며, 함수 코드를 평가한다.
함수 실행 컨텍스트 생성
함수 렉시컬 환경 생성 -&gt; 요기서 상위 스코프를 결정한다 함수 환경 레코드 생성
this 바인딩
외부 렉시컬 환경에 대한 참조 결정 const x = 1; function outer(){ const x = 10; const inner = () =&gt; { console.log(x); } return inner } const innerFunc = outer();
innerFunc() //10
예제를 통해 보자.
해당 환경에선 중첩 함수로 inner() 가 들어가 있다. 그리고 outer()는 실행되면서 해당 함수를 반환하고 생명주기를 마감하지만, 막상 inner를 실행했을 때는 10이 나온다.이 이유는 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 중첩 함수는 이미 생명주기가 종료한 외부 함수의 변수를 참조할 수 있기 때문이다. 이러한 중첩 함수를 클로저라고 부른다.이러한 클로저의 경우는 계속해서 외부 함수의 렉시컬 환경을 기억하고, 참조하고 있으며, 이는 계속해서 해당 중첩함수가 존재하는 한 유지된다. 해당 렉시컬 환경을 내부 함수가 참조하고 있기 때문에 가비지 컬렉션의 대상이 되지 않기 때문이다.그렇다면 어찌됐든 가장 상위 스코프도 전역 렉시컬 환경을 참조하고 있기 때문에 클로저가 아니냐! 라고 하면 아니다. 이론적으로는 맞지만 일반적으로 쓰이는 경우는 해당 함수가 상위 렉시컬 환경의 변수를 참조하고 있느냐? 가 클로저임을 구분하는 중요한 기준이 된다.추가적으로 이러한 클로저에 의해 참조되는 상위 스코프의 변수를 자유변수(free variable)이라고 부른다.따라서 클로저를 다른 말로 하자면 '함수가 자유 변수에 의해 닫혀있다(closed)'라는 의미이다. 여기서 닫히다라는 표현은 대상과 같은 범주 안에 속한다라는 의미로, 또 닫혀있다라는 말을 풀어보면 '자유변수에 묶여있는 함수라고 볼 수 있다.클로저는 자바스크립트의 야무진 기능으로, 함수형 프로그래밍에 많이 활용된다.클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다.
이 말인 즉슨, 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용한다는 것이다.let x = 1; function increase(){ return ++x
}
만약에 전역 변수 x의 상태를 바꾸는 함수를 이렇게 만들었다고 치면, 얘는 누구나 변경할 수 있다. 이러한 경우에 같은 함수를 계속 호출하다가도 중간에 누가 바꿔서 NaN 값이 떠버리는 때에는 바로 에러뜬다는 의미이다.그렇기 때문에 카운트 상태 변경 함수 안의 렉시컬 환경에 변수를 선언한 다음 사용하는 것이 정보의 은닉화에 유리하다.const increase = function () { let x = 0; return ++num
} increase()//1
increase()//1
increase()//1
근데 요런식으로 만들면 함수가 호출될 때마다 초기화가 이루어지기 때문에 이전 정보를 유지하지 못한다.
그래서 클로저를 활용한다.const increase = (function () { let x = 0; return function(){ return ++num; }
}())
이런 식으로 클로저를 활용하면, 해당 함수는 상위 렉시컬 환경인 increase 함수의 x 변수값을 계속해서 참조하면서 카운트 상태를 업데이트 할 수 있다.이런 점을 봤을 때, 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고, 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지시킬 수 있다.생성자 함수를 통해 만들어보자const Counter = (function () { let num = 0; function Counter(){ this.num = 0; //&lt;-- 얘처럼 프로퍼티로 놓으면 은닉 안됨 } Counter.prototype.increase = function () { return ++num; } Counter.prototype.decrease = function () { reuturn &gt; 0 ? --num : 0; } return Counter;
}())
...
const counter = new Counter();
console.log(counter.increase()) //1
console.log(counter.increase()) //2
console.log(counter.increase()) //3
console.log(counter.increase()) //4
이런 식으로 만들면 num은 계속해서 증가하지만, 우리가 접근할 수는 없고, increase()나 decrease() 메서드로만 접근할 수 있다.추가적으로 프로토타입을 통해 increase, decrease 메서드를 상속받은 인스턴스를 만들어 해당 메서드를 실행시키는 방법은 이 각 메서드가 모두 자신의 함수 정의가 평가되어 함수 객체가 될 때 실행 중인 실행컨텍스트인 즉시 실행 함수 실행 컨텍스트의 렉시컬 환경을 기억하는 클로저기 때문에 즉시 실행 함수의 자유 변수 num을 사용할 수 있다.하지만 this바인딩을 통해 함수의 프로퍼티로 놓게 된다면 은닉되지 않으므로 접근할 수 있는 값이 되어 은닉성이 사라지기 때문에 주의해야 한다.아무튼 이러한 부분은 함수형 프로그래밍이 지향하는 바와 같은데, 외부 상태 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에서 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높일 수 있는 킹갓제너럴 클로저를 많이 활용한다.//카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저 반환
function makeCounter(aux) { let counter = 0; return function () { counter = aux(counter); return counter; };
} // 보조함수들
function increase(n) { return ++n;
} function decrease(n) { return --n;
} const increaser = makeCounter(increase);
console.log(increaser()); // 1
console.log(increaser()); // 2 const decreaser = makeCounter(decrease);
console.log(decreaser()); //-1
console.log(decreaser()); //-2 해당 코드는 함수형 프로그래밍을 잘 활용한 코드로, makeCounter 함수를 고차함수로 만들어 보조 함수를 인자로 전달받고 함수를 반환하도록 하였다.
makeCounter 함수가 반환하는 함수는 자신이 생성됐을 때의 렉시컬 환경인 makeCounter 함수의 스코프에 속한 counter 변수를 기억하는 클로저이다. 이를 실행하면 makeCounter 함수의 실행 컨텍스트가 생성되고 함수 객체를 생성하여 반환한 후 소멸되는 과정을 반복한다.하지만 계속해서 보조 함수를 넣은 고차함수가 계속해서 반환하는 함수를 실행할 때마다 makeCounter가 만든 렉시컬 환경의 스코프 환경은 참조되고 있는 상태이기 때문에 소멸되지 않고 렉시컬 환경의 스코프에 속하는 counter 변수가 기억하는 변수를 계속해서 갱신할 수 있는 것이다.여기에서는 increase, decrease를 인자로 받은 각각의 독립된 렉시컬 환경을 선언했지만, 만약 둘 다 가능한 카운터를 만들기 위해서는 고차함수를 두번 사용하지 않고 한번만 사용함으로써 두 렉시컬 환경을 합쳐주어야 한다.//카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저 반환
const counter = (function () { let counter = 0; return function (aux) { counter = aux(counter); return counter; };
})(); // 보조함수들
function increase(n) { return ++n;
} function decrease(n) { return --n;
} console.log(counter(increase)); //1
console.log(counter(increase)); //2
console.log(counter(increase)); //3
console.log(counter(increase)); //4
console.log(counter(decrease)); //3
console.log(counter(decrease)); //2
console.log(counter(decrease)); //1
console.log(counter(decrease)); //0 클로저에서 주의해야 할 점 중 하나는 전역변수 var의 사용이다.
es6 문법이 나오기 전까지는 var가 모든 변수 선언을 대체하고 있었는데 이러한 var 키워드의 문제는 함수 레벨 스코프를 갖는다는 점이다.var funcs = []; for (var i = 0; i &lt; 3; i++) { funcs[i] = () =&gt; { return i; };
} funcs.forEach((j) =&gt; { console.log(j()); // 3 3 3
}); 위 코드처럼 i를 var로 선언한 다음 배열에 각각 i를 리턴하도록 하는 함수를 넣어주게 되면, 전역 변수 i를 계속해서 참조하고 있는 상태이기 때문에 배열이 다 돌고 난 후의 i값인 3만 계속해서 출력한다. 해당 함수가 아닌 그 상위의 i값을 보고 출력하는 함수의 형태로 되어있기 때문이다.이를 위해서는 크게 두 가지의 방법이 있다.var funcs = []; for (var i = 0; i &lt; 3; i++) { funcs[i] = ((id) =&gt; { return function () { return id; }; })(i);
} funcs.forEach((j) =&gt; { console.log(j()); // 3 3 3
}); id를 인자로 받는 함수를 만들고, 거기에 리턴값으로 함수를 새로 선언하여 넣어준 뒤 해당 렉시컬 환경의 id를 가져오는 방식으로 바꿔준다. 또한 해당 함수를 실행시키면서 i의 값을 넣어주면 i의 값은 id의 인자로 받아들이며 복사되기 때문에 각각의 렉시컬 환경을 가지는 객체들을 배열마다 만들 수 있다.아까의 문제는 var 키워드로 선언한 i가 함수 레벨 스코프이기 때문에 발생한 문제지만, let은 블록 레벨 스코프이기 때문에 훨씬 편하다. for문의 변수 선언문에서 let 키워드로 선언한 변수를 활용하면 for문의 코드 블록이 반복 실행될 때마다 for문 코드 블록만의 렉시컬 환경이 생성되기 때문에 해당 블록 내에서 선언한 함수의 경우 해당 함수의 상위 스코프는 새롭게 생성되던 렉시컬 환경을 참조하기 때문이다. var funcs = []; for (let i = 0; i &lt; 3; i++) { funcs[i] = () =&gt; { return i; };
} funcs.forEach((j) =&gt; { console.log(j()); // 0 1 2
}); 이렇게 각각의 배열에 할당된 함수가 독립적인 렉시컬 환경을 가지고 있기 때문에 for문이 돌면서 갱신된 i의 값을 각각 다르게 기억하고 있음을 알 수 있다.var funcs = Array.from({ length: 3 }, (_, i) =&gt; () =&gt; i); funcs.forEach((j) =&gt; { console.log(j()); // 3 3 3
}); 고차함수를 사용하면 여러모로 좋은 점이 많다. 5줄이 넘어갈 수도 있는 코드를 한 줄로 줄인다는 점이 참 매력적이다.
Array.from은 두 번째 인자로 mapfn을 받는데, 이 콜백함수는 각각의 배열 요소들을 돌면서 콜백 함수를 실행시킨다.
이 과정에서 콜백함수 내에서 i라는 인덱스 값을 받아 i를 반환하는 함수를 선언하기 때문에 각 배열에 할당된 각 i는 독립적인 렉시컬 환경을 가지게 된다.클로저는 캡슐화와 보안에 뛰어난 효과를 지녔으며, 자바스크립트 함수형 프로그래밍의 정수와 같은 느낌이라고 생각한다.그렇기 때문에 클로저를 통해서 렉시컬 환경을 이해하고, 이를 활용하는 수준이 곧 함수형 프로그래밍 코드의 퀄리티를 높인다고 생각한다. 앞으로 코드를 작성함에 있어서 조금 더 심화적으로 활용을 이어나가면서 익숙해져야겠다.]]></description><link>부스트캠프/챌린지/클로저.html</link><guid isPermaLink="false">부스트캠프/챌린지/클로저.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/2EqfV3e.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/2EqfV3e.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[트랜잭션과 비즈니스 로직]]></title><description><![CDATA[컴퓨터 과학에서의 트랜잭션은 더 이상 분할이 불가능한 업무 처리의 단위를 의미하며 데이터베이스에서 트랜잭션은 데이터베이스의 상태를 바꾸는 일종의 작업 단위이다. 데이터베이스를 예로 들어보면 이해가 쉽다. 은행에서 돈을 인출/입금하는 행위의 경우
돈을 인출 -&gt; 기존의 잔고에서 인출한 만큼의 금액 차감
돈을 입금 -&gt; 입금 계좌의 잔고가 입금한 금액만큼 증가
와 같은 순서로 업무 처리가 이루어지는데, 만약 이 과정중에 하나라도 결여가 생겨 입금이 되었는데 돈이 들어오지 않았다든지, 인출했지만 돈이 빠져나가지 않았다면 치명적인 결과를 초래한다.
그렇기에 해당 인출/입금은 두 개의 작업을 따로 나누는 것이 아니라, 하나로 처리해야 할 필요성이 있다. 즉, 둘 다 실패하거나 성공하거나 둘 중 하나여야 한다는 것이다.
이렇듯 더이상 분해할 수 없는 업무 처리의 단위를 트랜잭션이라고 한다.
위에서 데이터베이스에서 트랜잭션은 데이터베이스의 상태를 바꾸는 일종의 작업 단위라고 했다.
따라서 데이터베이스의 관점에서 트랜잭션이랑 모든 쿼리 명령어들이라고 생각할 수 있다.
SQL 명령문을 실행하면 해당 명령문에 따라 데이터의 상태를 바꾸게 되는데, MySQL의 경우 데이터의 상태가 바뀔 때마다 내부적으로 자동적으로 데이터베이스에 영구적으로 반영(commit)하게 된다.<img src="https://i.imgur.com/PHoRCIr.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">따라서 새로운 명령문이 들어오면 명령에 대해서 실행하고 데이터베이스에 반영하는 과정 자체가 하나의 트랜잭션으로 분류되며, 이 과정 중 하나라도 문제가 생기게 되면 그대로 폐기한다위와 같은 사진은 트랜잭션 상태를 나타낸 것으로, 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 흐름이다.
보면 부분완료(Partially Committed)가 된 상태라고 해도 여기서 트랜잭션이 비정상적으로 종료된다면 Rollback연산을 통해 기존의 작업을 철회(Abort)하는 것을 볼 수 있다. 따라서 트랜잭션은 committed될 때까지 끝이 아닌 것이다.
Rollback
트랜잭션의 처리 과정에서 발생한 변경 사항을 취소
트랜잭션이 시작되기 이전 상태로 돌아감
트랜잭션의 특징은 대표적으로 4가지의 특징이 있다. START TRANSACTION; -- 트랜잭션 시작 select * from members; -- 초기 상태 보여줌
insert into members values(1, '쿠', '크다스', '크라운제과' '?', '대한민국'); -- 데이터 수정
select * from members; -- 수정 상태 보여줌 COMMIT -- 트랜잭션을 DB에 적용 select * from members; -- 적용된 결과 조회
START TRANSACTION; -- 트랜잭션 시작 insert into members values(5, '쿠', '크다스 동생', '크라운제과', '?', '대한민국'); -- 데이터 수정
select * from members; -- 수정 상태 보여줌 ROLLBACK -- 트랜잭션을 취소하고 START TRANSACTION 실행 전 상태로 롤백함 select * from members; -- 조회
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC" target="_self">https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC</a>]]></description><link>부스트캠프/챌린지/트랜잭션과-비즈니스-로직.html</link><guid isPermaLink="false">부스트캠프/챌린지/트랜잭션과 비즈니스 로직.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/PHoRCIr.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/PHoRCIr.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지_Day_3_학습저장소]]></title><description><![CDATA[
트리 형태 데이터 구조 설계 및 구현 요구조건 분석
데이터 타입 선택
각 속성 선택 Parser 설계 및 구현
세부기능 function 설계 displayJSON()
elementByAttribute()
reportByClass() 성능 테스트
XML 샘플은 HTML, Andoid Layout, Property List의 형태가 주어졌다.
지원하는 XML 태그 스펙부터 살펴보았다.
도입부(Prolog) 앞이 ?로 시작 &lt;?xml&gt;
XML에 대한 정보 주석(Comment) 앞이 !로 시작 &lt;!DOCTYPE&gt;
주석으로 처리, 저장X 요소 (Element) 모든 요소는 시작 태그로 시작해서 종료 태그로 끝남
시작 태그와 종료 태그 사이에 다른 값(content)이나 element를 포함 가능
값이 없어도 되는 &lt;/br&gt;과 같은 태그들도 있음(자체종결태그)
시작태그 &gt;좌측 부분에 태그의 속성 명시 가능 'XML'과 '트리 형태 데이터 구조'를 보고 가장 처음 생각났던 것은 리액트의 가상돔(virtual DOM)이다. 가상 DOM은 실제 DOM의 가벼운 복사본으로 메모리 상에 존재하며, JavaScript 객체 형태로 존재하기 때문에 이러한 구조를 생각하면서 데이터 구조를 설계하면 되겠다 생각했다. 여기서 주어진 데이터 구조만 좀만 변형하면 될 것 같다.
prolog&nbsp;항목 : Map XML 메타 데이터를 기록한다.
{ "version" : "1.0" , "encoding" : "utf-8" } elements&nbsp;항목 : Array 최상위 태그 요소부터 위에서 아래로 순서대로 태그 단위로 기록한다. element&nbsp;태그 : Map element&nbsp;항목에 태그 이름
attributes 항목 : Array 태그의 모든 속성을 attribute 구조로 저장한다. attribute&nbsp;속성 : Map name&nbsp;속성 이름
value&nbsp;속성 값 위와 같은 정보를 포함하는 데이터 구조라고 했으니 여기서 해당 element의 이름이나 트리 구조를 명확히 알 수 있도록 children을 넣어주면 될 것 같다.
..라고 생각했으나 다음 배경지식에서 스택이 나온걸 보아 의도는 스택을 통해서 어떻게 트리구조를 표현하는지에 대해서도 중요하게 보는 것 같다. 자료구조의 활용도 중요하니 이번엔 스택을 최대한 활용해보기로 했다.XML 클래스는 prolog가 있는 XML도 있고 없는 XML도 있다.
이러한 부분을 고려하여 설계를 해야할 것 같다.
해당 XML은 루트가 아닌, 해당 문서 자체를 포괄하기 때문에 따로 노드를 넣어줄 때는 루트만 넣어주고 루트 안에 다른 element들이 들어가면 될 것 같다.export class XML { constructor(prolog = []) { this.prolog = prolog; this.root = null; this.nodes = {}; }
} 루트에는 모든 Element들과 각 태그별로 수를 관리한다.
해당 Elements에는 모든 Map 형태로 된 모든 Element들을 관리하는데, 여기서 서브트리에 대한 문제가 생긴다.
재귀함수가 아닌 스택으로 표현하기 위해서는 하위 트리를 구분하는 무언가가 있어야 한다.
그렇기 때문에 똑같이 &lt; 문자열을 추가해서 구분하면 어떨까? 생각했다. 위에서 하나씩 다시 뽑으면 닫히는 태그에서 시작해서 열리는 태그로 끝나니까 이걸 조건문으로 걸어놓으면 무한루프에 빠질 일이 없다고 생각했다.class Root { constructor(name, content = "", attributes = []) { this.name = name; this.content = content; this.attributes = attributes; this.elements = []; }
}
Element는 각 요소만의 속성, 태그 안의 값들을 관리한다.
서브트리에는 하위 서브트리를 포함하며, Node 클래스로 되어있다.
해당 클래스의 element 속성에는 element의 이름과 attrbutes 속성이 있어 속성이름: 속성값 으로 된 attributes들을 저장한다.
일단은 함수로 구현해보았다.function initElement(name, content, attributes) { return { name: name, content: content, attributes: attributes, };
}
어떻게 이러한 태그들이 뒤섞여 있는 많은 예외에서 잘 태그를 걸러내고, 알맞게 구조 안에 넣는 것이 아마 가장 큰 문제일 것 같다.
나 또한 이를 어떻게 하면 좋을까 생각했는데, 현재 생각난 단계를 말해보자면
readfileSync로 파일 통채로 읽기
&lt; 앞과 &gt;뒤에 무조건 \n 붙이기
줄바꿈 기준으로 split하기
split해서 받은 배열을 돌면서
1. &lt;!로 시작할 경우 무시
2. &lt;?로 시작할 경우 새로운 Root 인스턴스 생성
3. 이 외에 &lt;로 시작하는 경우
1. 새로운 element의 시작과 동시에 하위 element임을 구분하는 '&lt;' 를 elements 배열에 함께 추가
2. 자체종결성을 가진 경우 -&gt; 해당 element를 바로 집어넣음
3. element 안 텍스트인 경우 -&gt; content에 추가
4. 여는 태그와 닫는 태그가 따로 존재할 경우 -&gt; 다음 배열이 똑같은 &lt;구분자 와 같을 때까지 하위 element임을 구분하는 '&lt;'를 추가하고 배열 돌기
5. 나가면서 '&gt;' 를 배열에 추가
를 구상했다.
따로 태그를 통해 구분하게 된다면 보다 나중에 꺼내서 JSON 형식이 아니라 다시금 XML 형식으로도 바꿀 수도 있기 때문에 활용성을 높이고자 태그를 추가했다.
elements에는 각 element들의 자식부모 관계를 보다 명확히 보고자 stack 변수를 따로 두어 어디에서 괄호를 닫을지 판단한 후 괄호를 닫았다.
<img src="https://i.imgur.com/gTiVNgk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/IgQ6DQ7.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/6Yil37O.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/9sqxpUG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/uXYRYOA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/huPfNZw.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/WNt6nv3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">모두 구현을 성공했다!<br>
<img src="https://i.imgur.com/NbbjzG3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">사실 세부기능은 뭐 별거 없다.
만들어진 데이터를 가지고 원하는 값만 뽑아내면 되므로 그리 어렵지 않았다.저장한 데이터 구조를 표준 JSON 형식으로 변환해서 문자열로 리턴한다.
JSON 형식으로 변환하는 것은 JSON.stringify를 이용하면 손쉽게 문자열로 변환할 수 있다.
클래스를 돌면서 값들을 모두 return시켜주면 모두 합쳐진 문자열을 받을 수 있다.export function displayJSON(xml) { return JSON.stringify( xml, (key, value) =&gt; { if (value instanceof Map) { return Object.fromEntries(value); } if (value instanceof Root) { return { name: value.name, content: value.content, attributes: value.attributes.map((attr) =&gt; { if (attr === "&lt;" || attr === "&gt;") return attr; else return Object.fromEntries(attr); }), elements: value.elements, }; } return value; }, 2 );
}
<br><img src="https://i.imgur.com/jKNoXns.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/snIXx6k.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/EwvRtNe.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
HTML문을 사용해서 실행시켜봤다.
정상적으로 작동한다!파싱한 트리에서 attribute.name 값을 기준으로 모든 element를 찾아서 배열로 리턴한다.
해당 함수에 대한 설명은 다소 모호한 부분이 있다. 슬랙에서도 보니 사람마다 해석하는 바가 조금씩 다른 것 같다.
내 기준에서 attribute.name값을 기준으로 모든 element를 찾는다는 말은 모든 element 중에서 해당 attribute.name값을 포함하는 element를 모두 찾아서 배열로 리턴한다고 이해했다.export function elementByAttribute(xml, attribute) { const elements = xml.root.elements; let result = []; for (const elem of elements) { if (typeof elem === "string") continue; if (elem.attributes.length === 0) continue; for (const attr of elem.attributes) { if (attr.get("name").includes(attribute)) { result.push(elem); break; } } } return result;
}
그래서 그냥 해당 element들을 돌면서 attribute의 이름이 포함되면 배열에 담아 리턴하는 방식으로 구현했다.function main() { let file = fs.readFileSync("./test.txt").toString(); file = clearSpace(file); file = addSpace(file).split("\n"); let xml, root; let stack = []; for (const line of file) { [root, stack, xml] = preprocessing(line, root, xml, stack); } // console.log(displayJSON(xml)); console.log(elementByAttribute(xml, "android")); // console.log(reportByClass(xml));
} main();
main 함수를 따로 만들어 여기에서 모든 전처리와 함수 사용이 이루어지도록 했다.<br><img src="https://i.imgur.com/JybJz5o.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">android attribute 이름을 포함한 모든 element들을 잘 가지고 오고 있음을 볼 수 있다.파싱한 트리에서 element 종류별로 개수를 카운트해서 리턴한다.
나는 처음에 데이터 구조를 만들 때 어차피 개수를 따로 카운트하여 xml 클래스의 nodes 객체에 담아두었기 때문에 구현하는데 큰 어려움이 없었다.export function reportByClass(xml) { return xml.nodes;
}
<br><img src="https://i.imgur.com/f1D4e5l.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
잘 가져오고 있음을 볼 수 있다.
이거 개수 세는 것도 참 힘들었지만 나름 하면서 전처리 과정을 보다 잘 이해할 수 있었기에 훌륭한 과제였다!]]></description><link>부스트캠프/챌린지/챌린지_day_3_학습저장소.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지_Day_3_학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/gTiVNgk.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/gTiVNgk.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지_Day_3_학습정리]]></title><description><![CDATA[문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 과정이다.
주어진 문서를 가지고 브라우저가 바로 해당 문서를 조작할 수 없고, 이러한 문서에 대해 어휘분석과 구문 분석 과정을 거쳐 파싱 트리를 구축한다.
이 과정에서 오류가 있는 노드들은 파싱 트리에 추가되지 않고, 일치하는 노드만 추가시킨다.DOM은 XML 문서를 나타내는 객체들의 인터페이스를 표준으로 정해놓은 것으로, DOM 파서는 바로 XML 문서로부터 DOM 구조를 생성한다.
그렇게 만들어진 대표적인 DOM 구조가 HTML이다.
<img src="https://i.imgur.com/2PlZiwg.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이렇게 만들어진 DOM은 트리 형태로 아래로 내려가면서 뻗어나가는 구조를 가진다.
해당 구조는 객체 안에 다른 객체들이 들어가 있는 방식으로 설계되어 있다.
브라우저의 DOM에 변경이 일어나면 변경된 DOM과 기존 DOM을 비교한 뒤, 변경이 일어난 부분을 업데이트 시키는 과정을 '리렌더링'이라고 한다.
XML 문서에 대한 구조적 접근에 용이하다
문서의 일부분에 대한 업데이트가 자주 필요할 때 용이하다 메모리 사용이 많음
속도가 느림
SAX는 문자열을 앞에서부터 차례로 읽어가면서 요소, 속성이 인식될 때마다 Event를 발생시킨다. 각각의 Event에 대하여 핸들러를 구현하는 프로그래밍이다.
앞에서부터 차례로 하나의 긴 문자열을 읽어 가는 것처럼 읽어가면서 이벤트 핸들러(콜백함수)를 작동시켜 구조화시키는 방식이다.
문서의 일부분 데이터 변환이나 유효성 처리에 유효하게 쓰인다.
순차 처리에 유용하다
XML 문서 구조가 간단하다
메모리가 적게 들고 속도가 빠르다 문서 일부분에 대한 임의의 접근 불가능
이벤트나 작업 상태를 직접 보관해야 한다.
문백 정보의 유지가 없다
내용 수정이 불가능하다
DOM은 전체 문서를 메모리상에 올려놓고 처리하기 떄문에 수정과 추가가 용이하지만, SAX의 경우에는 처음부터 끝까지 순차적으로 문자열을 돌면서 처리하기 때문에 문자열 하나하나만이 메모리에 올라가 메모리 사용이 적지만 특정 요소를 찾아 수정하는 기능은 불가능하다.Extensible Markup Language(XML)의 약자이다.
공유 가능한 방식으로 데이터를 정의하고 저장할 수 있는 확장성 높은 마크업 언어이다.
웹 사이트, 데이터베이스 및 타사 애플리케이션과 같은 컴퓨터 시스템 간의 정보 교환을 지원한다.
사전 정의된 규칙을 사용하면 수신자가 이러한 규칙을 사용하여 데이터를 효율적으로 정확하게 읽을 수 있으므로 모든 네트워크에서 데이터를 XML 파일로 손쉽게 전송할 수 있다.데이터 태그에 대하여 속성, 값들을 보다 효율적으로 처리할 수 있어 많이 사용된다.주요 장점으로는
비즈니스 간 트랜잭션 지원
데이터 무결성 유지 데이터 손실 방지
일관된 데이터 저장 검색효율성 향상 검색 크롤러가 XML 문서에 대해 정확하게 분류가 가능해 검색에 뜰 확률이 높다.
리액트가 검색효율성이 낮은 이유도 일반적인 DOM이 아닌 Virtual DOM을 사용해서 이기도 하다 유연한 애플리케이션 설계
- XML은 이미 많이 사용되기 때문에 XML 데이터 지원 툴이 많아 처리가 용이하다.
-
등이 있다.
HTML(HyperText Markup Language)은 대부분의 웹 페이지에서 사용되는 언어이다. 웹 브라우저는 HTML 문서를 처리하여 멀티미디어 페이지로 표시합니다. W3C는 웹 사이트 개발자가 일관성과 품질을 위해 구현하는 HTML 및 확장 가능한 마크업 언어(XML) 표준을 모두 확립했다.
용도 HTML의 용도는 데이터를 표시하는 데 사용되지만 XML은 데이터를 저장하고 전송할 수 있다. 태그 HTML에는 미리 정의된 태그가 있지만 사용자는 XML에서 고유한 태그를 만들고 정의할 수 있다. 구문 규칙
XML은 대/소문자를 구분하지만 HTML은 구분하지 않는다. &lt;book&gt; 대신 &lt;Book&gt;으로 태그를 작성하면 XML 구문 분석기에서 오류가 발생한다.
JavaScript Object Notation (JSON)은 Javascript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷이다.
Javascript 객체 문법과 매우 유사하지만 딱히 Javascript가 아니더라도 JSON을 읽고 쓸 수있는 기능이 다수의 프로그래밍 환경에서 제공되어 API로 데이터를 전송할 때 일반적으로 사용한다.&nbsp;
JSON은 문자열 형태로 이루어져 있다.
이러한 특성은 네트워크를 통해 전송할 때 유용하다. { "squadName": "Super hero squad", "homeTown": "Metro City", "formed": 2016, "secretBase": "Super tower", "active": true, "members": [ { "name": "Molecule Man", "age": 29, "secretIdentity": "Dan Jukes", "powers": ["Radiation resistance", "Turning tiny", "Radiation blast"] }, { "name": "Madame Uppercut", "age": 39, "secretIdentity": "Jane Wilson", "powers": [ "Million tonne punch", "Damage resistance", "Superhuman reflexes" ] }, { "name": "Eternal Flame", "age": 1000000, "secretIdentity": "Unknown", "powers": [ "Immortality", "Heat Immunity", "Inferno", "Teleportation", "Interdimensional travel" ] } ]
}
js와 다른 점이라고 한다면 객체의 key값에 따옴표 ""를 붙인다는 것 말고는 크게 다른 점이 없다.
js에서는 JSON.stringify()라는 메서드가 존재하며, js의 값이나 객체를 JSON 문자열로 손쉽게 변환할 수 있다. JSON.stringify(value[, replacer[, space]]) value JSON 문자열로 변환할 값. replacer 문자열화 동작 방식을 변경하는 함수, 혹은 JSON 문자열에 포함될 값 객체의 속성들을 선택하기 위한 화이트리스트(whitelist)로 쓰이는&nbsp;String&nbsp;과&nbsp;Number&nbsp;객체들의 배열. 이 값이 null 이거나 제공되지 않으면, 객체의 모든 속성들이 JSON 문자열 결과에 포함된다. space 가독성을 목적으로 JSON 문자열 출력에 공백을 지정 &nbsp;XML도 데이터 교환에 많이 쓰였던 데이터 구조이다.
JSON도 데이터 교환에 사용되지만, JSON은 XML보다 새롭고 유연하며 널리 사용되는 옵션이다.&nbsp;
데이터 직렬화 방식이다.
표준화된 방식으로 데이터 교환이 가능하다
통일된 데이터를 가지고 다르게 표현이 가능하여 모든 언어에서 만들기 용이하다.
트리구조로 되어 있다.
다른 API 표현하는 데이터 방식보다 읽기 편하다.
플래폼 상관없이 사용 가능 XML은 트리 패턴으로 데이터를 나타내지만, JSON은 객체와 비슷한 키-값 페어를 사용해서 트리 구조를 나타낸다.
JSON이 객체를 쉽게 정의할 수 있어 사용성이 좋다.
XML 구문 분석기로 인해 느려지는 판면,, JSON의 경우 보다 빠르게 구문 분석이 가능하다.
JSON은 문자열, 숫자, 객체 등의 boolean값을 지원할 수 있다.
XML에서는 boolean값을 지원하지 않는다.
XML은 태그 구조로 이루어져 있어 보다 복잡한 경향이 있다.
XML 방식보다 JSON이 보안에 좋다. XML 구조는 외부 엔터키 삽입이나 무단 수정에 취약하다. 유연하다.
JSON은 주석이 없지만 ,XML은 !로 주석을 붙일 수 있음
태그 중첩이 복잡하게 얽혀있음
태그로 정해져있는 부분이라 가독성이 떨어짐
JSON은 탭으로 구분이라 보다 가독성이 좋음 고급 언어의 프로그램을 어떤 특정한 컴퓨터에서 직접 실행 가능한 형태의 프로그램으로 번역
고급어 -&gt; 기계어
<br><img src="https://i.imgur.com/gdN8A4e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
어휘 분석 -&gt; 구문 분석 -&gt; 중간 코드 생성 -&gt; 코드 최적화 -&gt; 목적코드 생성의 단계를 거친다.function compiler (originCode) { var ast = syntaxAnalyzer (tokens) var targetcode = codeGenerator (ast) return targetCode
}
이와 같이 의사코드로 작성할 수 있다.어떤 구문을 토큰화 하는 역할을 한다.
토큰은 어휘 분석의 단위를 뜻하며, 단어/단어구/문자열 등 의미있는 단어로 정해진다.
identifier : 식별하기 위한 이름 keyword : 미리 지정한 예약어
separator : 글자를 구분하는 문자
operator : 연산을 위한 심볼
literal : 숫자, 논리, 문자
comment : 줄 또는 블록 코멘터리
<br><img src="https://i.imgur.com/tst2z5j.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Tokenizer로 인해 쪼개진 토큰들의 의미를 분석하는 역할을 한다.
Tokenizer -&gt; Lexer 의 단계를 거쳐 의미를 분석하는 과정을 Lexical Analyze라고 한다.<br><img src="https://i.imgur.com/aUgA7tB.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Lexical Analyze된 데이터를 구조와하는 기능ㅎ이다.
여기서 데이터가 올바른지 검증하는 역할인 구문 분석(Syntax Analyze) 또한 이루어질 수 있다.
Parser에 의해 도출된 결과는 AST(Abstract Syntax Tree) 형태로 생성된다.<br><img src="https://i.imgur.com/gnpHIHO.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
분석된 구문을 트리의 형태로 나타내는 자료구조이다.
이렇게 만들어진 트리는 다시 code generator로 들어가 실행하게 된다.
컴파일러의 Lexer에서 토큰을 찾아내는데 있어서 기준이 되는 표현식
정규 언어를 기술하는 수학적 표현
정규 표현식 E라면 L(E)는 E를 정의하는 언어 정규표현식과 오토마타는 Equivalent함. 모든 정규표현식에 대해서 동일한 언어를 만족하는 오토마톤 구성 가능
오토마톤이 주어지면 동일한 언어를 만족하는 정규표현식 구성 가능 정규표현식과 오토마톤의 상호 변환 RE(정규표현식) -&gt; e-NFA -&gt; NFA -&gt; DFA 순서로 생성 가능
DFA(오토마톤) -&gt; NFA -&gt; e-NFA -&gt; 정규표현식 순서로 생성 가능 불리언 or | : gray | grey 그룹 () 소괄호 : gr(a|e)y 반복횟수 ?(0 또는 1번) : colou?r
** (0 또는 반복) : gogle (1번 이상 반복) : go+gle {n} : 정확히 n번
{min, max} : 최소 min 만큼, 최대 max만큼
. (모든 문자와 일치) : a.
[[] (문자 집합 요소 중에 하나와 일치) : [a-z]
\[^] (문자 집합 요소 제외하고 일치) : [^b]at
\\ (바로 다음 문자 이스케이프): a\. 상태(State)들의 유한한 집합(Set)
주어진 규칙(Rule)에 따라 특정 상태에서 다른 상태로 전이(transition) 상태는 노드로 표시
상태 전이는 방향 있는 화살표(directed edge)
전이 규칙은 화살표 옆에 레이블(Label)
<br><img alt="스크린샷 2024-07-21 오후 3.35.33.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.35.33.png" target="_self">
<br>해당 과정을 오토마타 표현을 했을 때<img alt="스크린샷 2024-07-21 오후 3.36.40.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.36.40.png" target="_self">
각 문자를 확인하면서 나오는 상태에 대해서 표현 결정적이기 때문에 다음 상태로 넘어갈 수 있는 것들이 명확한 것들을 의미 상태들 -&gt; 노드(Nodes)
상태 전이 함수 -&gt; 화살표(Arcs)
시작 상태는 start로 표기한 화살표가 가리키는 상태
최종 사상태는 이중 동그라미로 표시<br>
<img alt="스크린샷 2024-07-21 오후 3.39.37.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.39.37.png" target="_self">
<br><img alt="스크린샷 2024-07-21 오후 3.40.46.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.40.46.png" target="_self">
DFA를 표로 만들어 어떤 입력이 들어오느냐에 따라서 시작 -&gt; 도착 상태를 표로 만든 것
배열로 만들어 구현 재귀 함수로 구현
입력이 문자열인 경우 상태 전이 함수
- 문자열을 구성하는 문자를 한 개씩 처리해서 최종 상태에 도달<br>
<img alt="스크린샷 2024-07-21 오후 3.44.03.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.44.03.png" target="_self"> 모든 종류의 오토마타는 '언어를 정의한다' A라는 오토마톤(automatone)이면 L(A)는 A의 언어를 의미
L(A)는 DFA A로 인식가능한 언어
시작 상태부터 최종 상태까지 경로 라벨링(labeling) 문자열 집합
해당 문자열을 상태에 따라 다 처리하고 나면 최종 상태에 도달 DFA 중에서도 특정한 언어로, DFA가 존재하고 DFA(L)을 만족하는 문자열
해당 DFA는 오직 L에 있는 문자열만 만족함
대우에 의한 증명 + 귀납적 증명이 된 언어 하나의 입력 문자에서 여러 상태로 이동 가능한 오토마타
여러 상태로 이동 가능해서 비결정적(non-determinism)이라고 함
<br>예) 01로 끝나는 문자열을 만족하는 NFA<img alt="스크린샷 2024-07-21 오후 3.48.39.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.48.39.png" target="_self"> 먼저 0을 입력하여 상태 B로 갔다가 B에서 맞는 상태가 아니면 백트래킹이 생겨 돌아가는 형태 <br>예) web과 ebay를 인식하는 단어<img alt="스크린샷 2024-07-21 오후 3.50.34.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.50.34.png" target="_self"> <br>해당 상태에서 web의 단어에서는 'webay'일 경우 web이 아닌 'ebay'로 인식해야 하기 때문에 백크래킹을 해야 할 필요성이 생긴다.<img alt="스크린샷 2024-07-21 오후 3.52.17.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.52.17.png" target="_self">
이러한 상태의 전이를 표현하기에는 배우 복잡해지는 형태가 됨
따라서 NFA는 프로그램으로 직접 대응해서 구현이 불가능하다는 특징이 있음 DFA만 프로그램으로 구현이 가능하다 NFA는 DFA와 동등(equivalent)하다. 인식하는 언어의 범위가 동일
NFA는 DFA로 변환 가능하다. NFA로 디자인하면 상태 전이 설계가 단순해진다.
<br><img alt="스크린샷 2024-07-21 오후 3.54.32.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.54.32.png" target="_self">
각 가능한 한글의 조합에 대해 오토마타를 표현한 그림
<br><img alt="스크린샷 2024-07-21 오후 4.11.30.png" src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.11.30.png" target="_self">
제2,3 유형이 중요
제3유형은 DFA로 표현이 가능하고, 정규 문법을 가져야 함
세 가지 중 하나만 알아도 해당 언어를 표현할 수 있음
출처<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://trumanfromkorea.tistory.com/79" target="_self">https://trumanfromkorea.tistory.com/79</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://m.blog.naver.com/nextwebresearchlab/223155182748" target="_self">https://m.blog.naver.com/nextwebresearchlab/223155182748</a>]]></description><link>부스트캠프/챌린지/챌린지_day_3_학습정리.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지_Day_3_학습정리.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/2PlZiwg.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/2PlZiwg.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지_Day_7 학습저장소]]></title><description><![CDATA[
요구조건 분석 ✅ 2024-07-23
정규표현식 설계 ✅ 2024-07-23
Path 클래스 설계 ✅ 2024-07-23
path 함수 설계 및 구현 ✅ 2024-07-23
Jest 학습 ✅ 2024-07-24
appendComponent 함수 설계 및 구현 ✅ 2024-07-24
deleteLastComponent 함수 설계 및 구현 ✅ 2024-07-24
path 함수 설계 및 구현 ✅ 2024-07-24
Path 문자열을 분석해서 처리하는 라이브러리를 구현하는 문제이다.
Path와 URL 규격을 이해하고, 이를 기반으로 경로 Path를 처리해야 한다.
문자열을 초기 매개변수로 전달하면 Path 객체를 생성하며, UNIX,Windows 스타일 구성 방식을 모두 지원해야 한다.
UNIX, WIndows 스타일의 경로를 받아 이에 대해 처리해주는 과정이 필요하며, 이를 다시 UNIX, Windows 스타일로 재조합할 수 있어야 한다.각 예시를 보면 생성되는 객체의 Property는 모두 같다.//UNIX
const path = new Path("/home/user/boost/camp/challenge/day8/problem.md"); //path.root = "/"
//path.base = "problem.md"
//path.ext = ".md"
//path.name = "problem"
//path.lastDirectory = "day8"
//path.components = ["/", "home", "user", "boost", "camp", "challenge", "day8", "problem.md"] //path.absoluteString = "/home/user/boost/camp/challenge/day8/problem.md"
//path.existFile = True
//path.fileSize = 1024 //Windows
const path = new Path("C:\\home\\user\\boost\\camp\\challenge\\day8\\problem.md"); //path.root = "C:\"
//path.base = "problem.md"
//path.ext = ".md"
//path.name = "problem"
//path.lastDirectory = "day8"
//path.components = ["C:\", "home", "user", "boost", "camp", "challenge", "day8", "problem.md"] //path.absoluteString = "C:\home\user\boost\camp\challenge\day8\problem.md"
//path.existFile = True
//path.fileSize = 968 UNIX : /로 시작한다
Windows : {드라이브}:\\로 시작한다.
해당 경로가 가르키는 최종 위치를 표시한다.
슬래시들로 구분한 가장 마지막이며, 파일이름.확장자의 형태로 되어 있다.해당 파일의 확장자를 의미한다.
온점(.)을 포함하여 문자열이 들어가야 한다.해당 파일의 이름을 의미한다.해당 파일의 최하위 위치를 의미한다.
components에서 파일 바로 앞의 문자열을 의미하기도 한다.모든 경로에 대해 문자열들로 이루어진 배열이다.
배열의 순서는 각 경로에 대해서 이다.전체 경로명이다.
직접 저장하면 안되고 위에서 분석한 내용으로 조합해서 만들어야 한다.생성 시점을 기준으로 파일이 존재하는지 여부를 판단한다.생성 시점을 기준으로 파일의 크기를 가져온다.정규표현식의 경우 UNIX와 Windows 정규표현식을 따로 만들고, 이에 대해 검사에서 맞는 운영체제를 넘겨주면, 각 운영체제마다 작동을 다르게 만들려고 한다.export const UNIX_REGEX = /^\/[\w\/\-]+\/([\w\-]+(\.[a-zA-Z0-9]+){1,})$/;
체크한 케이스
맨 앞이 /로 시작
중간엔 /와 다른 문자들만 들어가야 함
마지막엔 /파일(문자, 숫자, _만 가능).확장자(문자만 가능)
export const WINDOWS_REGEX = /^[a-zA-Z\-]:[\\](?:[\w]+[\\])*[\w\-]+(\.[a-zA-Z0-9]+){1,}$/;
체크한 케이스
맨 앞이 {드라이브}\\로 시작
중간엔 \\와 다른 문자들만 들어가야 함
마지막엔 \\파일(문자, 숫자, _만 가능).확장자(문자만 가능)
각 운영체제에서 UNIX는 Path를 콜론, Windows는 ;세미콜론으로 구분한다.
해당 경로에서 만약 :가 나오게 된다면 해당 경로에서 파일을 검색하고, 이후의 경로에서 파일을 검색해서 나오는 파일을 리턴해야 한다.export const REMOVE_FILENAME = /(?&lt;=.*)\.[a-zA-Z0-9]+$/;
파일병 지우기의 경우 base에서 앞에 있는 모든 문자들을 지운 다음에 마지막에 .확장자만 나올 수 있도록 후방탐색자를 통해 찾아주었다.export const REMOVE_EXT = /(\.[a-zA-Z\.]+)/g;
확장자를 지우는 정규표현식은 name에 대해서 알아야 하기 때문에 .뒤로 가는 모든 문자들을 지우도록 했다.export const REGEX_FILENAME = /[^\\/]*([\w]+)\.([a-zA-Z0-9]+)$/;
해당 정규표현식은 replace 함수에 넣어 파일이름.확장자를 제외한 모든 것들을 삭제시키고 파일이름.확장자만 가져오기 위해 설계한 정규표현식이다.
생성자를 통해 생성하면서 정규표현식 체크
processing 함수를 통해 Unix,Windows 구분 + 경로를 split하여 각 속성값 업데이트
정규표현식 검사에 맞는 운영체제를 검사하여 파싱하는 곳에 옵션으로 넣어주어 파싱
파싱한 문자를 stringify에 넣으면 JSON.stringify하여 출력
파일 경로에 대한 처리가 끝났으면 실제 경로에 파일이 있는지 검색
해당 파일을 찾아 사이즈(실체)의 여부에 따라 존재값 할당
import { REMOVE_EXT, REMOVE_FILENAME, UNIX_REGEX, WINDOWS_REGEX,
} from "./regex";
import { PathType } from "./pathtype";
import { statSync } from "fs"; export class Path implements PathType { base: string = ""; components: string[] = []; dir: string = ""; ext: string = ""; lastDirectory: string = ""; name: string = ""; os: string = ""; root: string = ""; constructor(path: string) { this.processing(path); } checkFile(path: string): number { throw new Error("Method not implemented."); } public get absoluteString(): string { let slash = this.os === "UNIX" ? "/" : "\\"; return this.root + this.components.slice(1).join(slash); } public get fileSize(): number { try { return statSync(this.absoluteString).size; } catch (error) { return 0; } } public get existFile() { try { if (this.fileSize &gt; 0) return true; return false; } catch (error) { return false; } } public stringify(): string { let text = `{ root: '${this.root}',\n dir: '${this.dir}',\n base: '${this.base}',\n ext: '${this.ext}',\n name: '${this.name}',\n }`; return text; } public processing(path: string): void { try { let isUNIX = this.checkOS(path); if (isUNIX) { this.parsingUnix(path); } else { this.parsingWindows(path); } } catch (error) { console.log(error); } } public checkOS(path: string): boolean { if (UNIX_REGEX.test(path)) { this.os = "UNIX"; return true; } else if (WINDOWS_REGEX.test(path)) { this.os = "Windows"; return false; } return false; } public parsingUnix(path: string): void { this.components = path.split("/"); this.dir = this.components.slice(0, this.components.length - 1).join("/"); this.components[0] = "/"; this.root = "/"; this.base = this.components[this.components.length - 1]; this.ext = this.base.match(REMOVE_FILENAME)?.[0] ?? ""; this.name = this.base.replace(REMOVE_EXT, ""); this.lastDirectory = this.components[this.components.length - 2]; } public parsingWindows(path: string): void { this.components = path.split("\\"); this.dir = this.components.slice(0, this.components.length - 1).join("\\"); this.root = this.components[0]; this.components[0] += "\\"; this.base = this.components[this.components.length - 1]; this.ext = this.base.replace(REMOVE_FILENAME, ""); this.name = this.base.replace(REMOVE_EXT, ""); this.lastDirectory = this.components[this.components.length - 2]; } public appendComponent(folderPath: string) { this.components.splice(this.components.length - 1, 0, folderPath); this.lastDirectory = folderPath; } public deleteComponent() { this.components.splice(this.components.length - 2, 1); this.lastDirectory = this.components[this.components.length - 2]; }
}
처음엔 Readonly속성으로 추가해야하는 absoluteString, fileSize, existFile에 대한 고민이 많았다.
처음에는 readonly 타입을 추가해줬었는데, 이렇게 하다보면 다음 문제에서 해당 클래스 인스턴스의 주소를 추가해줬을 때 absoluteString이 바뀌지도 않고, 그렇다고 readonly인 값을 바꿀 수도 없다.import { Path } from "./path";
import { REGEX_FILENAME } from "./regex"; export function path(path: string) { let splittedPath; let fileName; if (path[0] === ":" || path[0] === "/") { fileName = path.match(REGEX_FILENAME)?.[0]; path = path.replace(REGEX_FILENAME, ""); splittedPath = path.split(":"); console.log(splittedPath); } else { fileName = path.match(REGEX_FILENAME)?.[0]; path = path.replace(REGEX_FILENAME, ""); splittedPath = path.split(";"); } let searchResult = pathSearch(splittedPath, fileName); if (searchResult) { return searchResult; } console.log("해당하는 파일이 없습니다."); return;
} function pathSearch(splittedPath: string[], fileName: string | undefined) { for (let i = 0; i &lt; splittedPath.length; i++) { let file; if (i === splittedPath.length - 1) { file = new Path(splittedPath[i] + fileName); } else { file = new Path(splittedPath[i] + "/" + fileName); } if (file.fileSize &gt; 0) return file; }
}
path 함수에서는 여러개가 콜론 또는 세미콜론으로 구분될 수 있으니 이러한 경우를 찾아 각 OS마다 처리방식이 상이하다.
각 OS마다 정규표현식을 통해 파일 이름과 확장자까지 받고, path 문자열에서는 지워준다.
이렇게 파일 이름이 지워진 각 문자열을 콜론 또는 세미콜론으로 split하면 마지막을 제외한 경로의 마지막엔 슬래시가 붙어있지 않기 때문에 따로 붙여주고 객체를 생성하여 사이즈가 있는지, 즉 존재하는 파일인지를 확인했다.
존재하지 않을 경우 다시 path 함수로 돌아가 아무것도 리턴시키지 않는다.Path { base: 'path.ts', components: [ '/', 'Users', 'miguel', 'Desktop', 'naver', 'challenge', 'day7', 'path.ts' ], dir: '/Users/miguel/Desktop/naver/challenge/day7', ext: '.ts', lastDirectory: 'day7', name: 'path', os: 'UNIX', root: '/', absoluteString: '/Users/miguel/Desktop/naver/challenge/day7/path.ts', fileSize: 3036, existFile: true
}
객체 찾았을 때 결과 ts-node "/Users/miguel/Desktop/naver/challenge/day7/main.ts"
{ root: '/', dir: '/Users/miguel/Desktop/naver/challenge/day7', base: 'path.ts', ext: '.ts', name: 'path', }
console.log(a?.stringify())했을때 결과
제대로 나온당아 내가 왜 이거 지금 봤지 하 public appendComponent(folderPath: string) { this.components.splice(this.components.length - 1, 0, folderPath); this.lastDirectory = folderPath; } public deleteComponent() { this.components.splice(this.components.length - 2, 1); this.lastDirectory = this.components[this.components.length - 2]; }
appendComponent와 deleteComponent 메소드는 중간의 경로를 바꿔주는 것이기 때문에 components의 값과 lastDirectory의 값만 변경해주면 된다.
absoluteString은 get 메소드에서 components들에 대해 조합해서 리턴해주는 메소드로 설계했기 때문에 변경이 되더라도 따로 해당 값에 접근하여 변경하지 않아도 되기 때문에 read-only 조건을 충족한다.import { Path } from "./path"; describe("파일 분석 비교 테스트", () =&gt; { var path1 = new Path("/Users/miguel/Desktop/naver/challenge/day7/path.ts"); var path2 = new Path( "/Users/miguel/Desktop/naver/challenge/day7/path.test.ts" ); test("서로 다른 파일 크기 비교", () =&gt; { expect(path1.fileSize).toBeGreaterThan(path2.fileSize); }); test("서로 다른 파일 파일명만 비교", () =&gt; { expect(path1.absoluteString).toEqual(path2.absoluteString); }); test("서로 다른 파일 내용 비교", () =&gt; { expect(path1).toEqual(path2); });
});
path.ts와 path.test.ts파일을 비교해보았다. npm test &gt; day7@1.0.0 test
&gt; jest console.log Path { base: 'path.test.ts', components: [ '/', 'Users', 'miguel', 'Desktop', 'naver', 'challenge', 'day7', 'path.test.ts' ], dir: '/Users/miguel/Desktop/naver/challenge/day7', ext: '.ts', lastDirectory: 'day7', name: 'path', os: 'UNIX', root: '/' } at Object.&lt;anonymous&gt; (path.ts:112:9) FAIL ./path.test.ts 파일 분석 비교 테스트 ✓ 서로 다른 파일 크기 비교 (1 ms) ✕ 서로 다른 파일 파일명만 비교 (2 ms) ✕ 서로 다른 파일 내용 비교 (3 ms) ● 파일 분석 비교 테스트 › 서로 다른 파일 파일명만 비교 expect(received).toEqual(expected) // deep equality Expected: "/Users/miguel/Desktop/naver/challenge/day7/path.test.ts" Received: "/Users/miguel/Desktop/naver/challenge/day7/path.ts" 11 | }); 12 | test("서로 다른 파일 파일명만 비교", () =&gt; { &gt; 13 | expect(path1.absoluteString).toEqual(path2.absoluteString); | ^ 14 | }); 15 | test("서로 다른 파일 내용 비교", () =&gt; { 16 | expect(path1).toEqual(path2); at Object.&lt;anonymous&gt; (path.test.ts:13:34) ● 파일 분석 비교 테스트 › 서로 다른 파일 내용 비교 expect(received).toEqual(expected) // deep equality - Expected - 2 + Received + 2 @@ -1,16 +1,16 @@ Path { - "base": "path.test.ts", + "base": "path.ts", "components": Array [ "/", "Users", "miguel", "Desktop", "naver", "challenge", "day7", - "path.test.ts", + "path.ts", ], "dir": "/Users/miguel/Desktop/naver/challenge/day7", "ext": ".ts", "lastDirectory": "day7", "name": "path", 14 | }); 15 | test("서로 다른 파일 내용 비교", () =&gt; { &gt; 16 | expect(path1).toEqual(path2); | ^ 17 | }); 18 | }); 19 | at Object.&lt;anonymous&gt; (path.test.ts:16:19) Test Suites: 1 failed, 1 total
Tests: 2 failed, 1 passed, 3 total
Snapshots: 0 total
Time: 0.928 s, estimated 1 s
Ran all test suites.
이런 식으로 비교하여 서로 다른 파일 내용을 비교하고, 파일명, 크기들에 대해서 테스트를 진행했다.
.test.ts와 같은 경우도 정규표현식을 통해 필터링해주었기 때문에 확장자인 .ts만 성공적으로 뽑아낸 것을 확인할 수 있었다.]]></description><link>부스트캠프/챌린지/챌린지_day_7-학습저장소.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지_Day_7 학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지_Day_3_문제]]></title><description><![CDATA[
XML 데이터 구조를 트리 형태 데이터 구조로 만들고, 다시 JSON으로 변환하는 도구를 만드는 것이 목표이다. 트리 형태 데이터 구조를 분석을 위한 기본 동작을 구현해야 한다. Parser가 데이터를 처리하는 방식과 만들어 내는 데이터 구조에 대해 학습해야 한다. XML 이나 JSON 형태 데이터를 분석하고 구조화해서 저장하는 것은 매우 중요한 경험으로, 원하는 데이터를 원하는 형식으로 만들기 위해서 Parser를 직접 만들어보는 것은 효과적인 학습 방법이다. 없음
여러 XML 샘플을 분석해서 요소별로 분리하는 Parser를 구현해야 한다. Parser가 어떤 데이터 흐름으로 어떻게 동작하는지 설계 결과를 작성한다. Parser가 만든 데이터 구조를 탐색해서 JSON 문자열로 출력하도록 구현해야 한다. 아래 예제 XML 코드만 처리하는 파서를 만드는 게 아니라, 어떤 형태 XML을 입력하더라도 XML 태그(혹은 토큰)을 구분해서 원하는 형태로 처리할 수 있어야 한다. 기존에 구현되어 있는 xmldom 이나 XML 파서 라이브러리나 파서용 모듈을 사용할 수 없으며, 이와 유사한 파싱을 처리해주는 외부 라이브러리를 모두 사용할 수 없다. 정규표현식은 추출하고 분석하기 위한 용도로 사용할 수 있다. (이건 선택사항이라 반드시 사용하지 않아도 된다.) XML 분석을 위해서 필요한 분석 단계별로 역할을 나눠서 처리한다. 함수가 길어지거나 너무 많은 역할을 하지 않도록 하위 함수로 나눈다. XML 태그(요소)가 중첩 가능하기 때문에 데이터를 중첩해서 생성하거나 탐색할 수 있도록 구현해야 한다. 저장하는 데이터 구조를 어떤 단위로 어떻게 저장하고 구조화할 것인가 결정하고 구현한다. 출력하는 양식은 표준 JSON 구조에 맞춰서 문자열로 출력한다. 도입부 Prolog :&nbsp;&lt;?xml&gt;&nbsp;처럼 앞이&nbsp;?로 시작하면 XML에 대한 정보. 내부에 저장할 때는 prolog 항목에 저장한다. 주석 Comment :&nbsp;&lt;!DOCTYPE&gt;&nbsp;처럼 앞에&nbsp;!로 시작하면 XML 주석으로 처리하고 저장하지 않는다. 요소 Element :&nbsp;&lt;HTML&gt;&nbsp;또는&nbsp;&lt;plist&gt;&nbsp;처럼&nbsp;&lt;&nbsp;바로 다음에 나오는 한 단어는 요소 element로 처리한다. 모든 요소는 시작 태그로 시작해서 종료 태그로 끝난다.&nbsp;&lt;HTML&gt; ... &lt;/HTML&gt; 시작 태그와 종료 태그 사이에는 값 Value 또는 다른 태그를 중첩해서 포함할 수 있다. &lt;P&gt;Hello&lt;/P&gt; &lt;P&gt;&lt;IMG SRC="camp.jpg"&gt;camp&lt;/IMG&gt;&lt;/P&gt; 값이 없어도 되는 특정한 태그들은&nbsp;&lt;/br&gt;&nbsp;형태로 시작-종료 태그를 한꺼번에 표시한다. 시작 태그&nbsp;&gt;&nbsp;좌측 부분에는 해당 태그의 속성을 명시할 수 있다.&nbsp;&lt;FONT name="Newyork"&gt;Big Apple&lt;/FONT&gt; 다음과 같은 정보를 포함하는 데이터 구조를 생성해야 한다 prolog&nbsp;항목 : Map 또는 Dictionary XML 메타 데이터를 기록한다. { "version" : "1.0" , "encoding" : "utf-8" } elements&nbsp;항목 : Array 최상위 태그 요소부터 위에서 아래로 순서대로 태그 단위로 기록한다. element&nbsp;태그 : Map 또는 Dictionary element&nbsp;항목에 태그 이름 attributes 항목 : Array 태그의 모든 속성을 attribute 구조로 저장한다. attribute&nbsp;속성 : Map 또는 Dictionary name&nbsp;속성 이름 value&nbsp;속성 값 저장한 데이터 구조를 표준 JSON 형식으로 변환해서 문자열로 리턴한다.파싱한 트리에서 attribute.name 값을 기준으로 모든 element를 찾아서 배열로 리턴한다.파싱한 트리에서 element 종류별로 개수를 카운트해서 리턴한다.&lt;!DOCTYPE html&gt;
&lt;HTML lang="ko"&gt;
&lt;BODY&gt;
&lt;P&gt;BOOST&lt;IMG SRC=\"codesquad.kr\"&gt;&lt;/IMG&gt;
&lt;BR/&gt;&lt;/P&gt;
&lt;FONT name="Seoul"&gt;CAMP&lt;/FONT&gt;
&lt;/BODY&gt;&lt;/HTML&gt;
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;TextView android:id="@+id/text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello, I am a TextView" /&gt; &lt;Spacer&gt;blank&lt;/Spacer&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello, I am a Button" /&gt; &lt;/LinearLayout&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;&lt;dict&gt;
&lt;key&gt;CFBundleExecutable&lt;/key&gt;
&lt;string&gt;boost&lt;/string&gt;
&lt;blank/&gt;
&lt;key&gt;CFBundleName&lt;/key&gt;
&lt;string&gt;camp&lt;/string&gt;
&lt;blank/&gt;
&lt;key&gt;Classes&lt;/key&gt;
&lt;array&gt;&lt;string&gt;Web&lt;/string&gt;&lt;string&gt;iOS&lt;/string&gt;&lt;string&gt;Android&lt;/string&gt;&lt;/array&gt;
&lt;/dict&gt;&lt;/plist&gt;
]]></description><link>부스트캠프/챌린지/챌린지_day_3_문제.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지_Day_3_문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지_Day2_문제]]></title><description><![CDATA[
리눅스/유닉스 환경에 대해 학습하고, 터미널로 리눅스 환경에 익숙해지는 것이 목표다. 리눅스/유닉스 개발 환경은 백엔드 개발자들에게 익숙한 개발 환경이지만 요즘은 윈도우즈나 macOS에서도 비슷한 환경을 그대로 제공한다.&nbsp;터미널로 서버 환경에 원격으로 접속해서 원하는 작업을 할 수 있도록 친숙해져야 한다.
우선 리눅스/유닉스의 역사부터 살펴보고, 리눅스를 직접 설치해서 쉘 환경에 익숙해지고 스크립트로 원하는 동작을 자동화할 수 있어야 한다. 없음
각자 컴퓨터 환경에서 사용할 수 있는 가상 환경(Virtual Machine)에서 리눅스 운영체제를 설치한다. 권장 설치 운영체제 : ubuntu 22.04 이상 리눅스를 사용하고 있거나 이미 설치한 적이 있더라도 초기화할 수 없다면 가상 환경에 새로 설치하길 권장한다. 이번 미션은 두 단계로 나눠져 있다. 스스로 할 일을 체크리스트로 만들고, 단계를 진행하면서 작업한 명령어, 스크린 캡처, 진행 과정, 실행 결과를 README.md에 업데이트한다. 스크립트 파일, 마크다운 문서와 이미지 등을 모두 포함해서&nbsp;학습저장소에 저장한다. 단, 컴파일한 바이너리 실행 파일은 포함하지 않는다. 각자 컴퓨터 환경에서 사용할 수 있는 가상 환경(Virtual Machine)에서 리눅스 운영체제를 설치한다. 권장 설치 운영체제 : ubuntu 22.04 이상 가상 환경에 원격으로 접속할 수 있도록 ssh 설정을 하고, root 계정 이외에 본인 접속할 계정을 추가한다. 본인 계정에 대한 패스워드를 설정한다. 로컬 컴퓨터에서 가상 환경 리모트 컴퓨터에 ssh로 접속해서 본인 계정으로 로그인한다. 본인 계정으로&nbsp;/scrap&nbsp;디렉토리를 생성한다. 764&nbsp;모드로 접근 권한을 바꿔서, 본인 계정에서도 쓸 수 있도록 설정한다. 가상 환경에서 터미널을 열고&nbsp;/scrap&nbsp;경로에 대해 권한을 확인하는 화면을 캡처한다. 가상 환경에 오늘 날짜 + 서울 시간대로 지정해서 로컬과 가상 환경이 동일하도록 맞춘다. 가상 환경에서 터미널을 열고 date 명령으로 오늘 날짜를 출력한 상태로, 화면을 캡처한다. 가상 환경에 node.js 를 설치하고 버전을 확인한다. 어제 작성한 day1 미션 js파일을 복사해서 실행한다. VirtualBox :&nbsp;<a data-tooltip-position="top" aria-label="https://www.virtualbox.org/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.virtualbox.org/" target="_self">https://www.virtualbox.org</a> 단, M1/M2 처럼 ARM 기반 CPU는 지원하지 않음. <br>UTM :&nbsp;<a data-tooltip-position="top" aria-label="https://mac.getutm.app/" rel="noopener nofollow" class="external-link is-unresolved" href="https://mac.getutm.app/" target="_self">https://mac.getutm.app</a>&nbsp;(맥용 가상머신 + 에뮬레이터)
유료 도구 평가판을 활용해도 된다.
<br>VMWare :&nbsp;<a data-tooltip-position="top" aria-label="https://www.vmware.com/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.vmware.com/" target="_self">https://www.vmware.com</a> 2024년 5월 VMWare도 개인 사용자는 무료로 풀림 <br>Parallels :&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="http://parallels.com/" target="_self">http://parallels.com/</a>
M1/M2 ARM 기반 CPU는 패러랠즈 체험판도 가능
<br><img src="https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/164005107517668747470733a2f2f692e737461636b2e696d6775722e636f6d2f6a374e744b2e706e67.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1640051096202Ubuntu-Server-Installation-with-LVM.png.webp" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
다른 버전의 리눅스 혹은 다른 배포판을 설치해 본다. USB 메모리 등을 이용해서 가상환경이 아닌 직접 설치를 해 본다.
]]></description><link>부스트캠프/챌린지/챌린지_day2_문제.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지_Day2_문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/164005107517668747470733a2f2f692e737461636b2e696d6775722e636f6d2f6a374e744b2e706e67.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/164005107517668747470733a2f2f692e737461636b2e696d6775722e636f6d2f6a374e744b2e706e67.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지_Day2_학습저장소]]></title><description><![CDATA[
가상 환경 설치하기 ssh 설정해서 원격 접속
사용자 추가하기
생성된 사용자로 scrap 디렉토리 생성
scrap 디렉토리 권한 변경 미션 과제 실행하기 nodejs 설치
nodejs를 이용하여 미션 파일 실행 가상환경 설치는 UTM이라는 가상머신을 설치한 후에 리눅스(우분투)를 설치한다.Ubuntu 다운 -&gt; UTM 다운 -&gt; UTM 실행하여 Ubuntu 설치 -&gt; UTM을 통한 Ubuntu 실행
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://mirror.kakao.com/ubuntu-releases/noble/" target="_self">https://mirror.kakao.com/ubuntu-releases/noble/</a>
그냥 우분투를 다운로드 받으면 엄청 오래 걸린다는데 다행히도 어떤 분이 미러사이트의 존재를 알려주셨다<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@zihooy/M1-Mac-UTM-Linux-Ubuntu" target="_self">https://velog.io/@zihooy/M1-Mac-UTM-Linux-Ubuntu</a>
해당 벨로그를 참고해서 가상환경을 설치했다.<br>
<img src="https://i.imgur.com/92le2CK.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
설치가 된 후 로그인하여 여러가지 명령어들을 실행해보았다.	sudo apt update sudo apt install openssh-server sudo systemctl status ssh
사용하는 서버 PC에 방화벽이 존재한다면 방화벽에 ssh를 추가해주어야 한다.방화벽을 사용하고 있으면 아래 명령어 결과에 active, 사용하지 않으면 inactive가 결과로 나타난다.	sudo ufw status
나는 방화벽이 없어 방화벽 추가만 해뒀다.	sudo ufw allow ssh sudo ufw reload
iterm(터미널)을 키고 ssh username@ip주소
를 치고 우분투와 연결하였다.ip a
를 우분투에서 치고 inet 옆의 ip주소를 사용하면 된다.<br><img src="https://i.imgur.com/cJCNQzx.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
ssh 연결이 되었다!기세를 몰아 서버 유저 추가까지 해봤다 1. 지정된 경로에 유저 생성 sudo useradd mh -d /home 2. 패스워드 설정 sudo passwd 유저ID 3. 유저 추가 확인하기 sudo vi etc/passwd
<br><img src="https://i.imgur.com/lyOnUBA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
/home 경로에 mh가 정상적으로 추가되었다.
사용자를 추가한 다음 터미널에 켜져 있는 원래 있던 유저를 끄고 새롭게 만든 유저로 연결시켜 주었다.<br>
<img src="https://i.imgur.com/y3Bfjkf.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">scrap 폴더를 mh 사용자에서 만들려고 했는데 권한 문제가 발생하여
sudo chown -R mh /home 명령어로 권한을 부여했다. (sudo 빼서 한번 실패)<br>
<img src="https://i.imgur.com/bcDQUsx.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">chmod 764 scrap 명령어를 통해서 해당 폴더에 대해 권한을 부여했다.
764 권한의 경우 8진수로 된 명령어로, 각 숫자가 의미하는 바는 권한을 주는 대상이다. 764의 경우는
소유자(owner): 읽기(r), 쓰기(w), 실행(x) 권한 (7 = 4+2+1)
그룹(group): 읽기(r), 쓰기(w) 권한 (6 = 4+2)
기타 사용자(others): 읽기(r) 권한 (4)
로 권한을 부여하겠다는 것이다.
<br><img src="https://i.imgur.com/KE7gfkV.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">ubuntu 내의 시간을 hwclock -w와 timedatectl set-timezone Asia/Seoul , rdate -s time.bora.net명령어를 실행하여 서울의 시간으로 맞춰주었다.<br>
<img src="https://i.imgur.com/yQx4oih.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/Yas62Nr.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
터미널에서도 똑같이 잘 뜬다.curl을 설치하고 sudo apt install nodejs를 통해 nodejs를 다운받았다.
설치하면서 npm 또한 다운로드 받아주었다.<br>
<img src="https://i.imgur.com/m39x8iG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이후 vim mission_1.js 를 통해 터미널의 우분투에서 js 파일을 만들고 코드를 복사하여 실행시켰다.
정상적으로 결과가 나오는 것을 볼 수 있다.<br>
<img src="https://i.imgur.com/R8vk3Aa.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
리눅스 쉘 스크립트 명령어 연습
쉘 스크립트 과제 설계 &amp; 구현 케이스1 설계 &amp; 구현
케이스2 설계 &amp; 구현
케이스3 설계 &amp; 구현 crontab 설정 및 동작 방식
# 현재 CPU 사용률 계산
CPU_USING=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}')
CPU 사용률의 경우 top을 통해 조회가 가능하다.
파이프대로 말하자면
top을 통해 조회해서 나온 결과 중에서 첫번째 줄을 다음 파이프로 넘긴다
grep을 통해 Cpu(s)를 포함한 뒤의 문자열들을 가져와 다음 파이프로 넘김
sed를 통해 id(사용하지 않는 cpu의 비율)의 값을 정규표현식을 통해 걸러낸다.
해당 값을 100에서 빼서 현재 사용중인 cpu의 비율을 계산한다. 해당 cpu 사용률이 만약 70%가 될 경우, cpu가 연속으로 70%이상일 때를 기록하는 변수를 잡고, 1분마다 실행되므로 3을 넘게 되면 웹 훅을 실행하도록 설계산
# 횟수 초과(3번) + CPU 사용률이 또 70%가 넘었을 경우 웹훅 실행
if [ $CPU_USING -gt $ACTIVE_CPU_THRESHOLD ] &amp;&amp; [ $CPU_THRESHOLD_COUNT -ge $THRESHOLD_COUNT ]; then curl -X POST -H 'Content-type: application/json' --data '{"text":"J238 CPU is now ALARM: usage is over 70%"}' $WEBHOOK_URL
elif [ $CPU_USING -gt $ACTIVE_CPU_THRESHOLD ]; then CPU_THRESHOLD_COUNT=$((CPU_THRESHOLD_COUNT + 1)) echo "$CPU_THRESHOLD_COUNT $(awk '{print $2}' "$LOG") $(awk '{print $3}' "$LOG") $(awk '{print $4}' "$LOG")" &gt; "$LOG"
else CPU_THRESHOLD_COUNT=0 echo "$CPU_THRESHOLD_COUNT $(awk '{print $2}' "$LOG") $(awk '{print $3}' "$LOG") $(awk '{print $4}' "$LOG")" &gt; "$LOG" fi 횟수의 경우 로그에 저장하고 계속해서 가져오는 방식으로 설계
횟수를 초과하지 않았지만 사용률이 기준보다 이상이면 카운트 올리기
CPU 사용률이 70% 아래로 떨어지면 다시 카운트를 0으로 되돌리기
# 현재 메모리 사용률 계산
MEMORY_USING=$(free | grep Mem | awk '{print $3/$2 * 100}')
파이프대로 설계했을 때
free를 통해 조회해서 나온 결과를 파이프로 보냄
Mem을 포함하는 row만 뽑아내어 다음 파이프로 보냄
awk를 통해 $3(현재 사용중인 메모리)/$2(총 메모리) 에 100을 곱해서 비율을 계산한다. 해당 메모리의 active 메모리 사용량이 50%가 될 경우, 메모리가 연속으로 50%이상일 때를 기록하는 변수를 잡고, 1분마다 실행되므로 3을 넘게 되면 웹 훅을 실행하도록 설계
free 명령어를 통해서 현재 메모리의 사용률에 대해 알 수 있다.
# 누적횟수 초과(3번) + 메모리 사용률이 또 50%를 넘겼을 때 웹훅 실행
if [ $MEMORY_USING -gt $ACTIVE_MEMORY_THRESHOLD ] &amp;&amp; [ $MEMORY_THRESHOLD_COUNT -ge $THRESHOLD_COUNT ]; then curl -X POST -H 'Content-type: application/json' --data '{"text":"J238 MEMORY is now ALARM: usage is over 50%"}' $WEBHOOK_URL
elif [ $MEMORY_USING -gt $ACTIVE_MEMORY_THRESHOLD ];then MEMORY_THRESHOLD_COUNT=$((MEMORY_THRESHOLD_COUNT + 1)) echo "$(awk '{print $1}' "$LOG") $MEMORY_THRESHOLD_COUNT $(awk '{print $3}' "$LOG") $(awk '{print $4}' "$LOG")" &gt; "$LOG"
else MEMORY_THRESHOLD_COUNT=0 echo "$(awk '{print $1}' "$LOG") $MEMORY_THRESHOLD_COUNT $(awk '{print $3}' "$LOG") $(awk '{print $4}' "$LOG")" &gt; "$LOG"
fi 횟수의 경우 로그에 저장하고 계속해서 가져오는 방식으로 설계
횟수를 초과하지 않았지만 사용률이 기준보다 이상이면 카운트 올리기
CPU 사용률이 70% 아래로 떨어지면 다시 카운트를 0으로 되돌리기
RX,TX는 가져오는게 까다로워 이걸 함께 가져오기보다는 따로 가져와서 계산을 했다.ACTIVE_RXTX_THRESHOLD_MB=10485760 PREV_RX_USED=0
PREV_TX_USED=0 # RXTX_LOG 파일이 존재하는지 확인하고, 존재하면 이전 RX/TX 값을 읽음
if [ -f "$RXTX_LOG" ]; then PREV_RX_USED=$(awk '{print $1}' "$RXTX_LOG") PREV_TX_USED=$(awk '{print $2}' "$RXTX_LOG")
fi # 현재 RX/TX 사용량 계산 (MB 단위로 변환)
RX_USING=$(ifconfig | grep 'RX' | grep bytes | head -n 1 | awk '{print $5}')
TX_USING=$(ifconfig | grep 'TX' | grep bytes | head -n 1 | awk '{print $5}') # RX/TX 사용량 차이 계산
RX_DIFF=$((RX_USING - PREV_RX_USED))
TX_DIFF=$((TX_USING - PREV_TX_USED))
RXTX_DIFF=$((RX_DIFF + TX_DIFF)) if [ $RXTX_DIFF -gt $ACTIVE_RXTX_THRESHOLD_MB ]; then echo "두 값이 임계치 이상입니다" echo "$RX_DIFF, $TX_DIFF"
else echo "이하임" echo "$RXTX_DIFF"
fi # 현재 RX/TX 사용량을 로그 파일에 저장
echo "$RX_USING $TX_USING" &gt; "$RXTX_LOG"
사실상 RX/TX 계산이 까다로워서 대부분의 코드를 차지했다.
주요 로직은
미리 0으로 초기화시켜놓고 로그에서 RX,TX 가져오기
RX/TX 각각 차이를 계산하여 더한 다음, 10MB보다 큰지 확인
마지막에는 새로 가져온 RX/TX 값을 로그로 기록하기
로 설계했다.
ifconfig 명령어를 사용하면 RX/TX의 byte값을 뽑아올 수 있어 해당 명령어로 파이프를 보내
RX/TX 라인 뽑아서 옆으로 보내기
bytes 가 포함된 부분을 뽑아서 옆으로 보내시
해당 줄에서 다른 lo(가상 이더넷 장치라고 한다.)를 제외해야 해서 첫 줄만 뽑아서 파이프로 보내기
bytes로 표현된 숫자만 추출 (5번째)
로 하였다.
위 코드는 if else문 연습과 제대로 작동하는지 확인하기 위해 잠깐 만들어 놓았다. 네트워크 RX, TX 사용량이 1분당 10MB이상 사용되었다면, 웹 훅을 보내도록 설계
해당 조건은 한번 이상 기준량을 초과하면 바로 웹훅을 보내야 하므로 따로 카운트를 만들지 않음
# 이전보다 10MB 이상 더 크게 차이날 때 웹훅 실행
if [ $RXTX_DIFF -gt $ACTIVE_RXTX_THRESHOLD_MB ]; then curl -X POST -H 'Content-type: application/json' --data '{"text":"J238 NETWORK RX/TX is now ALARM: usage per Minute is over 10MB"}' $WEBHOOK_URL
fi
crontab -e를 통해 내가 만든 쉘스크립트를 매 분마다 실행시켜 줄 수 있도록 앞에 * * * * *를 붙였다.
1분정도 지나고 다시 로그를 보니 RX/TX가 바뀐 것을 보아 정상적으로 작동되고 있음을 알 수 있었다.Stress를 설치하여 메모리와 CPU 부하 테스트를 진행한 결과 로직대로 잘 움직여 3번 이상부터는 알람이 간 것을 확인했다!<br>
<img src="https://i.imgur.com/HDTGAsU.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>부스트캠프/챌린지/챌린지_day2_학습저장소.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지_Day2_학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/92le2CK.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/92le2CK.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지_Day2_학습정리]]></title><description><![CDATA[웹 서버에 배포를 해야하는 환경에서는 로컬에서 작업한 것을 리모트 컴퓨터에 복사해야 하는 상황이 생긴다.
<img src="https://i.imgur.com/prLuNOE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
배포를 할 경우 우리가 항상 컴퓨터를 켜놓고 서버를 돌리지 않는 이상 24시간 돌아가는 서버를 구현하기에는 무리가 있기 때문이다.<br><img src="https://i.imgur.com/Jnrggtd.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이러한 배포를 도와주는 것이 리모트컴퓨터 말고 가상환경을 사용하는 경우도 있다.
이 가상환경은 물리적으로 존재하는 컴퓨터가 아닌, 다른 컴퓨터가 만들어내는 가상의 컴퓨터이다.
이러한 가상 환경은 3가지 종류를 가지고 있다.
에뮬레이션 모든 기능을 소프트웨어적으로 구현 가상화 주요 부품의 구현에서 하드웨어적 지원을 받음 반가상화 100% 완벽한 에뮬레이션과 가상화를 포기하고 가상머신 내 설치될 OS에 수정을 가하거나 전용 드라이버를 사용하여 하드웨어에 직접 접근 해당 가상환경은 구현 방식에 따라 성능과 범용성에서 차이가 난다.
퍼포먼스(속도)
에뮬레이션 &lt; 가상화 &lt; 반가상화 범용성의 경우
반가상화 &lt; 가상화 &lt; 에뮬레이션
로컬 환경은 개발자가 개발 및 테스트를 위해 자신의 개인 컴퓨터나 로컬 서버에서 사용하는 환경이다. 개인 컴퓨터 또는 로컬 서버를 사용하며
직접 접근 가능
테스트 및 디버깅 용이
개발 속도와 유연성이 높음
등의 장점이 있다. 가상 환경은 하드웨어 상에 가상으로 생성된 독립적인 실행 환경을 말하며 주로 여러 이유로 인해 별도의 격리된 환경을 필요로 할 때 사용된다. 이러한 경우는 위에서 말했던 배포 문제가 주가 된다.
가상 환경은
가상화 기술 사용으로 하나의 기기에서 여러개를 독립적 시행
환경 격리(독립성이 높아짐)와 관리가 용이함
서버 운영 및 확장성이 높음
테스트와 배포에 용이함
등의 장점을 가지고 있다. 웹 개발자의 경우 배포에 주로 사용하면서 Jenkins, Travis CI, Github Actions와 같은 배포를 용이하게 해주는 배포 파이프라인을 설정하는데 용이하며, 이를 통해 보다 쉬운 애플리케이션 유지보수가 가능해진다.두 환경의 차이점에는
접근성과 관리 로컬 -&gt; 개발자가 직접 접근하여 도구나 설정 관리
가상 -&gt; 시스템 리소스 보호관리 용도와 활용 로컬 -&gt; 개발 초기 단계에서 개발 및 테스트에 사용 가상 -&gt; 서버 운영 및 다양한 환경을 테스트 및 배포 유연성과 성능
- 로컬 -&gt; 개발속도와 유연성이 높음
- 가상 -&gt; 서버관리와 성능 최적화에 유리
가 있다.
이 가상환경에서 많이 쓰이는 OS인 Linux는 서버관리에 최적화된 OS로 알려져 있다. 그래서인지 이러한 Linux의 배포판인 우분투의 쉘스크립트를 이용해서 배포를 자동화시키는 방법 또한 다양하다.
우리가 원격 저장소(Github)에 올린 것들을 pull해와서 우분투의 환경 내에서 해당 프로젝트의 종속성을 설치하고, 빌드를 한 후에 환경변수 등을 세팅하여 배포를 보다 자동화시킬 수 있는 방법이 된다.// 가상환경 내에서 프로젝트를 받아 저장
cd /home/ubuntu/github/client git fetch local=$(git rev-parse HEAD)
echo $local target=$(git rev-parse origin/main)
echo $target if [ $local != $target ]
then git stash git pull origin main echo '풀 완료' npm install echo "npm install 완료" npm run build echo "빌드 완료"
fi
를 사용하면 다음 이미지와 같이 출력된다.<br>
<img src="https://velog.velcdn.com/images/es_seong/post/60636f0b-efdc-4a9e-854b-c7184d6b1d39/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">여기서 다음과 같이 일곱가지로 구분할 수 있다.<br>
<img src="https://velog.velcdn.com/images/es_seong/post/5817b8fd-25e0-488c-86bc-28a8e5d3bb15/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">좌측 부터 파일 유형, 허가권, 링크 수, 소유자 / 소유그룹, 파일크기, 변경일시, 파일명으로 구분된다.- : 일반 파일
d : 디렉토리
l : 심볼릭 링크
b : 블록 장치 파일
c : 문자 장치 파일
p : 파이프
s : 소켓총 아홉개의 문자로 이루어져 있으며, 세 개씩 끊어서 해석하면된다.r : 읽기 권한 (4)
w : 쓰기 권한 (2)
x : 실행 권한(1)rwx에 대해 권한이 없을 경우 해당 자리를 -로 대체한다.이미지에서 rw-r--r--으로 되어있다.
rw- / r-- /r--로 구분할 수 있다.첫 번째 그룹은&nbsp;파일 소유자의 권한을 나타낸다.
두 번째 그룹은&nbsp;파일 소유 그룹의 권한을 나타낸다.
세 번째 그룹은&nbsp;다른 사용자의 권한을 나타낸다.
해당 권한에 대한 표현은 숫자로도 가능하다chmod 777 test.sh
위에 권한 옆 숫자가 각 권한이 나타내는 8진수이다.
해당 8진수를 통해서 세가지 권한 그룹에 대한 권한을 3개의 숫자만으로 표현을 할 수 있다.
예시로 chmod 764를 하게 된다면
7 (r+w+x, rwx)
6 (r+w, rw-)
4 (r,r--)
라고 해석하여 권한을 부여할 수 있다.
쉘 스크립트는 쉘 명령어를 담은 스크립트로 일반적인 프로그래밍 언어와 비슷한 느낌이다. 하지만 우분투 내에서 텍스트에디터(nano, vi, vim)을 통해서 써야 한다는 점이 좀 킹받는다.
쉘 스크립트의 첫 줄을 쉬방(#!)으로 시작하며 스크립트가 어떤 인터프리터를 사용해서 실행될지를 나타낸다.
변수 등호 앞뒤로 공백없이 작성
변수의 값을 참조하려면 $변수이름 하거나 ${변수이름}으로 사용한다. name="mh"
echo $name 환경변수 환경변수는 사용자의 프로파일, 시스템설정, 쉘 세션 등 전반적인 환경에서 사용되는 변수이다.
대문자로 표기하는게 컨벤션이다.
주요 환경변수 PATH: 실행 파일의 경로
HOME: 사용자의 홈 디렉토리
USER: 현재 사용자의 이름 환경변수 export 설정할 때는 export 변수명=값으로 설정할 수 있다. export만 치면 현재 설정되어 있는 환경변수를 볼 수 있다. source 스크립트파일 을 통해 스크립트를 실행한다
api key와 같은 보안에 중요한 값들은 무지성으로 원격저장소에 넣을 수 없기 때문에 셸에서 환경변수를 설정해주어 노출되지 않도록 해줄 수 있다.
set 모든 셸 변수와 함수의 이름과 값을 설정/재설정하기 위한 입력이다.
읽기 전용 변수는 재설정 불가능
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin" target="_self">https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin</a> env 현재 환경 변수를 표시하거나 환경 변수를 변경한 후에 프로그램을 실행하는 유틸리티이다.
env [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]&nbsp;형태를 가진다.
-i option을 사용하면 환경변수를 모두 지운 후에 프로그램 실행이 가능하다. 셸 스크립트의 실행 방식은 여러가지가 있다.#!/bin/bash
echo "HELLO" #권한을 바꿔야 실행이 된다.
$ chmod 권한 hello.sh
$ ./hello.sh $
셸에서 입력과 출력의 방향을 바꾸는 명령어이다.
파일을 읽어서 표준 입력으로 전달하거나 표준 출력을 파일로 저장한다. 표준입력 0 : 키보드 표준입력 1 : 터미널 표준입력 2 : 터미널 화면 : 표준 출력을 지정 파일로(overwrite) : 파일 쓰기(insert) &lt; : 파일 읽기 2&gt; : 표준 에러를 지정 파일로 2&gt;&amp;1 : 표준 에러를 표준 출력으로 1&gt;&amp;2 : 표준 출력을 표준 에러로 # 파일 입력
$ command &lt; infile # 파일 출력 $ command &gt; outfile
$ command &gt;&gt; outfile
$ command &gt;&amp; outfile
$ command &gt;&gt;&amp; outfile 파이프는&nbsp;command1 | command2와 같은 형태로 사용되고, command1의 표준 출력을 command2의 표준 입력으로 전달한다
&amp;를 붙이면 표준 에러도 함께 전달한다$ command1 | command2
$ command1 |&amp; commnad2 # file.txt의 내용을 읽어서, grep의 입력으로 전달 $ cat file.txt | grep a CPU -&gt; top us : 프로세스의 유저 영역에서의 CPU 사용률 sy : 프로세스의 커널 영역에서의 CPU 사용률
ni : 프로세스의 우선순위(priority) 설정에 사용하는 CPU 사용률
id : 사용하고 있지 않는 비율
wa : IO가 완료될때까지 기다리고 있는 CPU 비율
hi : 하드웨어 인터럽트에 사용되는 CPU 사용률
si : 소프트웨어 인터럽트에 사용되는 CPU 사용률
st : CPU를 VM에서 사용하여 대기하는 CPU 비율 Memory -&gt; free SWAP메모리는 주 메모리 Mem이 거의 사용되었을 때 사용되는 메모리로, 주로 Mem을 보면 된다.
total : 총 메모리 양
free : 사용가능한 메모리 양
used : 사용중인 메모리 양
buff/cache : IO와 관련되어 사용되는 버퍼에 사용되는 메모리 buff : 커널 버퍼에서 사용되는 메모리
cache : 디스크의 페이지 캐시 RX/TX -&gt; ifconfig
대부분 해당 명령어를 통해 각 사용률을 본다.
변수를 미리 만들어놓고 해당 변수에 내가 키보드로 입력한 값을 넣는다.$ read INPUT
Hello
$ echo $INPUT for loop for - do-done의 구조를 지닌다 while [조건] loop while-do-done의 구조를 지닌다 #1. 더하기
expr 2 + 2 #2.빼기
expr 10 - 5 #3. 곱하기
expr 4 \* 3 #4. 나누기
expr 4 / 5 #5. 나머지
expr 6 % 5 # 변수 초기화
num1=10
num2=5 # 덧셈 연산
sum=$((num1 + num2))
echo "덧셈 결과: $sum" # 뺄셈 연산
diff=$((num1 - num2))
echo "뺄셈 결과: $diff" # 곱셈 연산
mul=$((num1 * num2))
echo "곱셈 결과: $mul" # 나눗셈 연산
div=$((num1 / num2))
echo "나눗셈 결과: $div" # 나머지 연산
mod=$((num1 % num2))
echo "나머지 결과: $mod" -eq : 두 수가 같음(equal) if [ "$a" -eq "$b" ] -ne : 두 수가 같지 않음(not equal) if [ "$a" -ne "$b" ] -gt : 왼쪽이 오른쪽보다 더 큼(greater than) if ["$a" -gt "$b" ] -ge : 왼쪽이 오른쪽보다 더 크거나 같음(greater than or equal) if [ "$a" -ge "$b" ] -lt : 왼쪽이 오른쪽보다 더 작음(less than) if [ "$a" -lt "$b" ] -le : 왼쪽이 오른쪽보다 더 작거나 같음(less than or equal) if [ "$a" -le "$b" ] [ 부등호는 이중 소활호 (()) 에서 사용할 수 있다. ]
&lt; : 왼쪽이 오른쪽보다 더 작음 if (( "$a" &lt; "$b" )) &lt;= : 왼쪽이 오른쪽보다 더 작거나 같음 if (( "$a" &lt;= "$b" )) &gt; : 왼쪽이 오른쪽보다 더 큼 if (( "$a" &gt; "$b" )) &gt;= : 왼쪽이 오른쪽보다 더 크거나 같음 if (( "$a" &gt;= "$b" )) if-elif-else-fi의 구조를 지닌다.
만약 조건을 건다면 뒤에 then이 붙어야 하고, 조건식 바깥에는 대괄호와 세미콜론이 필요하다.#!/bin/bash if [ 조건식 ] # 조건식에는 아래 비교 연산자를 활용
then 명령어
elif [ 조건식 ]
then 명령어
else 명령어
fi # 아래처럼 줄여서 사용도 가능하다. if [ 조건식 ]; then 명령어
elif [ 조건식 ]; then 명령어
else 명령어
fi # 이중 괄호로 조건식을 묶으면 산술 연산자(&gt;,&lt; 등)를 사용할 수 있다. if (( 조건식 )); then 명령어
elif (( 조건식 )); then 명령어
else 명령어
fi 문자열 비교 괄호 양 끝에 공간이 있다는 것을 중요하게 기억해야 한다. [[ $a == $b ]] [[ $a == hello* ]] [[ $a != $b ]]
존재 여부를 판단하거나 파일 혁싱 등을 검사할 때 좋다.# 파일이 있고 디렉터리인지
[ -d file ] # 파일이 있고 일반 파일인지
[ -f file ] # 파일이 있고 읽기 권한이 있는지
[ -r file ] # 파일이 있고 실행 권한이 있는지
[ -x file ] # 문자열이 있는지
[ -z string ]
이건 뭔 약자인가 했는데 기능 디자인한 사람 이름이라고 한다(킹받네)
awk는 파일로부터 레코드를 선택하고 선택된 레코드에 포함된 값을 조작하거나 데이터화하는 것을 목적으로 사용한다.
awk는 명령을 통해 다양하게 할 수 있는 것들이 있다.
텍스트 파일의 전체 내용 출력
파일의 특정 필드만 출력
특정 필드에 문자열을 추가해서 출력
패턴이 포함된 레코드 출력
특정 필드에 연산 수행 결과 출력
필드 값 비교에 따라 레코드 출력<br>
<img src="https://i.imgur.com/HYTYkvE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
awk는 &nbsp;입력 데이터로부터 주어진 패턴을 포함하는 라인을 찾기 위해 파일의 내용을 탐색한 다음, 패턴에 일치하는 라인이 발견되면 해당 라인에 대해 지정된&nbsp;액션을 실행하는 로직을 가지고 있다. 덕분에 인덱스를 넣어 값을 뽑아낼 수도 있고, 데이터화하기 좋게끔 필드를 출력할 수도 있다.
여기서 필드란 awk에서 분류하는 기준으로 공백 문자로 구분되는 것들이며, 라인 단위를 레코드(record) 라고 한다. # 기본 구조 pattern { action } # 세부 구조 awk [OPTION...] [awk program] [ARGUMENT...] OPTION -F : 필드 구분 문자 지정. -f : awk program 파일 경로 지정. -v : awk program에서 사용될 특정 variable값 지정. awk program -f 옵션이 사용되지 않은 경우, awk가 실행할 awk program 코드 지정. ARGUMENT 입력 파일 지정 또는 variable 값 지정.
활용법에 대해 아주 야무지게 설명을 해준 분이 계셔서 그대로 들고 왔다.crontab은 자동화를 도와주는 기능으로, 내가 설정한 시각마다 원하는 스크립트 파일이나 명령어를 실행시킬 수 있다.# 크론탭 편집
$ crontab -e # 크론탭 내용 보기
$ crontab -l # 크론탭 지우기
$ crontab -r # 크론탭 재시작하기
$ service cron restart
또한 시각도 세부적으로 하나씩 설정해줄 수 있다. 심지어 요일까지 가능하다!* * * * *
분(0-59) 시간(0-23) 일(1-31) 월(1-12) 요일(0-7) # 매분 test.sh 실행
* * * * * /home/script/test.sh # 특정 시간 실행
# 매주 금요일 오전 5시 45분에 test.sh 를 실행
45 5 * * 5 /home/script/test.sh # 반복 실행
# 매일 매시간 0분, 20분, 40분에 test.sh 를 실행
0,20,40 * * * * /home/script/test.sh # 범위 실행
# 매일 1시 0분부터 30분까지 매분 tesh.sh 를 실행
0-30 1 * * * /home/script/test.sh # 간격 실행
# 매 10분마다 test.sh 를 실행
*/10 * * * * /home/script/test.sh # 조금 복잡하게 실행
# 5일에서 6일까지 2시,3시,4시에 매 10분마다 test.sh 를 실행
*/10 2,3,4 5-6 * * /home/script/test.sh
출처)<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://recipes4dev.tistory.com/171" target="_self">https://recipes4dev.tistory.com/171</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://jdm.kr/blog/2" target="_self">https://jdm.kr/blog/2</a>]]></description><link>부스트캠프/챌린지/챌린지_day2_학습정리.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지_Day2_학습정리.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/prLuNOE.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/prLuNOE.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지_Day5_학습저장소]]></title><description><![CDATA[
요구조건 분석 ✅ 2024-07-22
Board 클래스 설계 및 구현 ✅ 2024-07-22
Game 클래스 설계 및 구현 ✅ 2024-07-22
Ultron 클래스 설계 및 구현
BlackWidow 클래스 설계 및 구현
Hulk 클래스 설계 및 구현
CaptainAmerica 클래스 설계 및 구현
IronMan 클래스 설계 및 구현
HawkEye 슨배님 클래스 설계 및 구현
Thor 클래스 설계 및 구현 5 * 6 (row 5, column 6) 행에서 최소 0개에서 3개 캐릭터만 배치 현재 남아있는 캐릭터 확인 후 체력 점수 총합 출력
모든 말의 위치를 간접적으로 알 수 있음
메소드 display() -&gt; A행부터 E행까지 전체를 행 단위로 리턴 문자열 배열 x 데이터 구조 리턴
Board에서 return한 데이터 구조를 바탕으로 출력 형식을 담당하는 객체에서 문자열 배열로 바꾸고 출력
각 캐릭터 2문자 =&gt; 여기에서 주목해야 할 점은 display()함수이다. display 함수의 설명에 A행부터 E행까지 전체를 행 단위로 리턴하라고 했지만, 출력을 위한 문자열 배열이 아니어야 한다. 이말인 즉슨 board에서 2차원 배열로 각 캐릭터의 위치를 관리하게 된다면 display 함수를 호출할 때 출력을 위한 문자열 배열로 리턴할 수밖에 없기 때문에 2차원 배열을 지양하라는 의도로 이해했다.
따라서 나는 각각의 캐릭터 위치를 객체를 통해 알 수 있도록 하는 방식이 보다 적합해 보였다.this.board = { A:{ 1: null, 2: null, 3: null, 4: null, 5: null, 6: null }, B:{ 1: null, 2: null, 3: null, 4: null, 5: null, 6: null } ... E까지
}
이러한 구조로 된 보드를 생각해 보았다. 이렇게 된다면 각 행 단위로 문자열이 아닌 타입을 포함하는 데이터 구조를 리턴할 수 있다.
사용자와 컴퓨터 반복 입력
자신의 차례가 아니면 다시 입력
공격하는 나의 캐릭터와 상대편 목표 지점을 차례로 입력받아서 공격 캐릭터 문자(2자리) -&gt; 공격 위치(2자리) 형태 공격한 곳에 상대편 캐릭터가 있다면 HIT, 없으면 MISS 출력 HIT -&gt; 공격 포인트만큼 HP 감소
HP가 0이 되면 해당 캐릭터 사라짐 상대편이 자신을 공격해서 5번 HIT마다 나의 특정 캐릭터를 다른 위치로 이동 가능
입력값이 ?이면 상대편 보드에서 가장 캐릭터가 많이 배치된 row 출력 1번만 가능(boolean) 랜덤한 10개 캐릭터 고르고 위치에 배치(중복 가능)
Ultron은 항상 3개 배치
BW, CA, TH는 최소한 1개씩 배치
HK는 최대 1개만 배치가 가능
BW, IM, HE는 최대 2개까지 배치가 가능 특정 위치에 특정 캐릭터를 생성하는 함수를 구현한다 이 함수는 초기 위치가 아니면 생성하지 않는다.
이미 해당 위치에 다른 말이 있으면 생성하지 않는다.
캐릭터 종류별로 최대 개수보다 많이 생성할 수는 없다.
Ultron 캐릭터는 최대 3개. Avengers는 최대 2개까지 가능하다.
생성하지 않는 경우는 exception 예외처리로 상위에서 어떤 예외상황인지 판단한다. 특정 위치에 특정 캐릭터를 생성하는 함수를 구현한다. 바로 직접 조건 생성함수와 다르게 어떤 캐릭터든지 어느 위치에 놓아도 상관없다.
이미 해당 위치에 다른 말이 있으면 생성하지 않는다. 최대 개수도 고려하지 않는다. 입력받은 특정 위치를 공격할 때는 Board에서 제공하는 함수를 사용한다. 내가 공격하려는 캐릭터를 전달하고,
공격하는 to 위치에 캐릭터가 있을 때만 동작한다.
해당 자리에 캐릭터가 있으면 규칙에 따라 남은 HP를 반환하고, HP가 0이 되거나 위치에 캐릭터가 없으면 0을 반환한다. 해당 함수들은 조건 생성과 무조건 생성, 공격 함수로 Board에 들어가야 할 메소드들이다.
위치 배치 조건을 보면 각 캐릭터에게 부여된 최소, 최대, 필수 캐릭터 개수가 주어진다.
특히 필수 캐릭터 개수가 주어진 Ultron의 경우 3개, BW, CA, TH를 1개씩 배치해야 하므로 6개가 필수적인 캐릭터 개수이다. 최소, 최대, 필수 캐릭터에 대한 검증, 위치에 대한 검증이 필요하다.
내가 이해한 바로는 두 개의 생성 함수의 역할은
특정 캐릭터 초기 조건 생성 함수 -&gt; 개수를 판단하여 조건에 맞는(최소, 최대, 필수 검증) 캐릭터를 선택한 후 특정 캐릭터 무조건 생성 함수로 전달
특정 캐릭터 무조건 생성하기 함수 -&gt; 받은 캐릭터에 대해 무작위로 위치를 생성하고 배치. 만약 해당 칸에 캐릭터가 있다면 다른 위치를 재생성
이다.
따라서 특정 캐릭터 초기 조건 생성 함수가 특정 캐릭터 무조건 생성하기 함수의 상위 함수가 되어 함수 안에서 함수를 호출하는 형태로 생각하였다. 위치값을 저장할 Position 타입 -&gt; 별도의 데이터 구조를 만들어야 함. row의 경우 -&gt; A -&gt; E까지
column의 경우 -&gt; 1부터 6까지
row와 column 값은 enum으로 선언 // enum의 경우 uppercase로 표기
const POSITION = { ROW: { A: 0, B: 1, C: 2, D: 3, E: 4 }, COL: { 1: 0, 2: 1, 3: 2, 4: 3, 5: 4, 6: 5 }
} 캐릭터는 확실하게 구분되어야 한다. 상태값으로 지정한다면 생성할 때 결정하고 변경
타입으로 구분한다면 다형성으로 동작
-&gt; 편을 구분하는 경우 어차피 플레이어와 컴퓨터 두 가지로밖에 구분이 되지 않기 때문에 boolean값을 이용하여 isPlayer Property를 추가하면 될 것 같다. 이동 : 좌우
HP: 400
공격력: 40
한도: 3개(무조건 3개) 이동: 전후좌우
HP: 400
공격력: 10
한도: 2개(최소 1개 이상) 이동: 대각선
HP: 600
공격력: 40
한도: 2개 이동: 위아래
HP: 800
공격력: 50
한도: 1개 이동: 불가능(호크아이 슨배임,,,,)
HP: 500
공격력: 20
한도: 2개 이동: 모든 방향 다 가능(퀸)
HP: 900
공격력: 50
한도: 2개(최소 1개 이상) 이동: 전후좌우
HP: 700
공격력: 30
한도: 2개(최소 1개 이상)
각 캐릭터는 HP, 공격력, 이동(이 속성은 나중에 공격하는 메소드마다 공격 범위를 정하면 될 것 같아서 계속 생각 중이다.) 속성을 지닌다. 한도의 경우 맨 처음 캐릭터를 생성할 때 따로 테이블을 두고 관리를 하면 될 것 같아서 굳이 추가할 필요는 없을 것 같다.캐릭터마다 공통적으로 HP, 공격력이라는 property를 가지고 있기 때문에 공통적인 속성을 가진 부분은 Avengers class에 상속시킨 형태로 코드를 보다 가독성있게 할 수 있지 않을까 생각해보았다.class Avengers { constructor(hp,atk){ this.hp = hp, this.atk = atk }
}
...
class Thor extends Avengers { attack() { //각 영웅별 공격하기 함수 }
}
가장 먼저 Board 클래스이다.this.board = { A:{ 1: null, 2: null, 3: null, 4: null, 5: null, 6: null }, B:{ 1: null, 2: null, 3: null, 4: null, 5: null, 6: null } ... E까지
}
Board 클래스에는 이러한 형식으로 된 보드를 미리 만들어 놓으려고 한다.
하지만 클래스에 이렇게 우구장창 때려넣으면 코드가 더러울 것 같아 가독성을 높이고자 따로 init하는 클래스를 만들고 상속시키려 한다.class initBoard { constructor() { this.board = { A: rowInit(), B: rowInit(), C: rowInit(), D: rowInit(), E: rowInit(), }; }
} const rowInit = () =&gt; { return { 1: null, 2: null, 3: null, 4: null, 5: null, 6: null, };
}; 처음 board가 만들어질 때 랜덤한 캐릭터를 10개 가진 채로 board가 나와야 한다.
그러므로 해당 board에 특정 캐릭터 초기 조건 생성하기 함수와 특정 캐릭터 무조건 생성하기 함수를 적절히 실행하여 board에 넣어주도록 하자.
먼저 필수적으로 넣어줘야 하는 캐릭터들에 대해서 넣어준 뒤에, 나머지 캐릭터들을 무작위로 생성하여 넣어줘야 한다.export class InitBoard { constructor() { [this.totalHP, this.board] = initFullBoard(); }
}
const initFullBoard = () =&gt; { let board = { count: { A: 0, B: 0, C: 0, D: 0, E: 0 }, A: rowInit(), B: rowInit(), C: rowInit(), D: rowInit(), E: rowInit(), }; return initCharactersInBoard(board);
};
const rowInit = () =&gt; { return { 1: null, 2: null, 3: null, 4: null, 5: null, 6: null, };
};
가장 먼저 해야할 것은 각각의 row에 대해 인덱스를 만들어 주는 일이다.
이 과정은 그저 객체생성하는 함수를 만들어 배열에 할당하면 되므로 간단하다. // 랜덤으로 위치 정하기
const getRandomLoaction = () =&gt; { const row = Math.floor(Math.random() * 5); const column = Math.floor(Math.random() * 6); return [row, column];
}; // 특정 캐릭터 무조건 생성하기 함수
const locateCharacters = (character, board, characterTable) =&gt; { let row, col; while (true) { [row, col] = getRandomLoaction(); row = POSITION.ROW[row]; col = POSITION.COL[col]; if (!board[row][col] &amp;&amp; board["count"][row] &lt; 3) break; } board[row][col] = generateCharacterInstance( character, `${row}${col}`, characterTable ); board["count"][row]++; return board;
}; const generateCharacterInstance = (character, position, characterTable) =&gt; { let instance; switch (character) { case "Ultron": instance = new Ultron(position); break; case "BlackWidow": instance = new BlackWidow(position); break; case "Hulk": instance = new Hulk(position); break; case "IronMan": instance = new IronMan(position); break; case "HawkEye": instance = new HawkEye(position); break; case "Thor": instance = new Thor(position); break; case "CaptainAmerica": instance = new CaptainAmerica(position); break; default: throw new Error("없는 어벤저스입니다."); } characterTable[character].push(instance); return instance;
};
여기부터는 구현하는데 상당히 까다로웠던 함수들이다.
해당 함수는 생성 함수 중 '특정 캐릭터 무조건 생성하기 함수' 이다.
앞서 말했던 것처럼, 무조건 생성 함수의 경우 개수에 고려없이 생성하는 함수이므로 파라미터에 이름만 받아 빈 공간을 찾은 뒤 클래스를 할당하는 방식으로 구현하였다.자바스크립트에서는 Enum이 없으므로 따로 Enum 객체를 만들어 넘긴 위치에 따라 객체의 property로 갈 수 있도록 교체해 주었다.// 필수로 들어가야 하는 어벤저스 넣는 함수
const locateMinCharacters = (board, characterTable) =&gt; { locateCharacters("Ultron", board, characterTable); locateCharacters("Ultron", board, characterTable); locateCharacters("Ultron", board, characterTable); locateCharacters("CaptainAmerica", board, characterTable); locateCharacters("BlackWidow", board, characterTable); locateCharacters("Thor", board, characterTable);
}; const getRandomCharacter = () =&gt; { return Math.floor(Math.random() * 7);
}; // 특정 캐릭터 초기 조건 생성하기 함수
const initCharactersInBoard = (board) =&gt; { let characterTable = initCharacterTable(); let characterCount = AVENGERS_COUNT(); let curr = 6; let totalHP = 3200; locateMinCharacters(board, characterTable); while (curr &lt; 10) { let characterIdx = getRandomCharacter(); let character = AVENGERS_INFO[characterIdx]; if (characterCount[character.name] + 1 &lt;= character.limit) { totalHP += character.hp; curr++; characterCount[character.name]++; locateCharacters(character.name, board, characterTable); } } return [totalHP, board, characterTable];
}; 특정 캐릭터 초기 조건 생성하기 함수에서는 앞서 말한 대로 위치는 하위 함수인 '특정 캐릭터 무조건 생성하기 함수'에 일관하고 해당 함수에서는 최소 n개 이상 들어가야 하는 어벤저스 넣기
특정 캐릭터를 랜덤으로 뽑고, 또 그러한 캐릭터가 각 캐릭터의 limit을 넘지 않는지 확인
limit를 넘지 않는 캐릭터를 뽑기
뽑은 캐릭터를 '특정 캐릭터 무조건 생성하기 함수'를 통해 할당
board에 할당한 뒤 totalhp와 board 업데이트
해서 만들어진 board와 HP를 리턴한다.
해당 함수에서도 각 영웅의 명수를 셀 수 있는 AVENGERS_COUNT와 해당 어벤저스의 정보를 담은 AVENGERS_INFO Enum을 사용하였다.
추가적으로 나중에 attack할 경우를 대비하여 characterTable에도 참조값을 공유하는 클래스를 넣어뒀다.export const AVENGERS_COUNT = () =&gt; { return { Ultron: 3, BlackWidow: 1, CaptainAmerica: 1, Thor: 1, HawkEye: 0, IronMan: 0, Hulk: 0, };
}; const InitAvengersInfo = (name, limit, hp) =&gt; { return { name: name, limit: limit, hp: hp, };
}; export const AVENGERS_INFO = { 0: InitAvengersInfo("Ultron", 3, 400), 1: InitAvengersInfo("BlackWidow", 2, 400), 2: InitAvengersInfo("Hulk", 1, 800), 3: InitAvengersInfo("CaptainAmerica", 2, 700), 4: InitAvengersInfo("IronMan", 2, 600), 5: InitAvengersInfo("HawkEye", 2, 500), 6: InitAvengersInfo("Thor", 2, 900),
};
Enum은 이러한 형식으로 되어 있어 각각의 limit에 접근해 조건을 검사하고, hp를 뽑아 totalHP를 업데이트한다.이렇게 initBoard 클래스가 생성되면 이를 상속하는 Board 클래스를 따로 두었다.import { InitBoard } from "./initboard.mjs"; export class Board extends InitBoard { constructor(isPlayer) { super(); this.isPlayer = isPlayer; this.hitCount = 0; } // 상태 출력 display() { let data = Object.values(this.board).slice(1); console.log(data); data = data.map((row) =&gt; Object.values(row)); return data; } // 공격하기 attack(character, to) { this.hitCount++; let userCharacter = this.characterTable[character]; if (userCharacter.length === 0) { return "MISS"; } else { for (let char of userCharacter) { if (char.attack(to)) { return `HIT${this.hitCount}`; } } return "MISS"; } } move(from, to) { if (this.board[from[0]][from[1]] &amp;&amp; !this.board[to[0]][to[1]]) { if (this.board[from[0]][from[1]].move(to)) { console.log("이동에 성공했습니다."); return; } } else { console.log( "이동할 위치에 영웅이 있거나 이동시킬 위치에 영웅이 없습니다." ); } }
} 공격의 경우 무조건 성공과 실패여부에 상관없이 hitCount가 늘어나기 때문에 가장 앞에 추가해주었다.
공격을 할 때는 기존에 추가해뒀던 characterTable을 활용하였다.
일단 오류가 날 만한 상황들에 대해 조건을 걸었다.
해당 영웅이 하나도 없을 때
공격에 실패할 때
각 조건을 걸어준 다음 가장 먼저 공격을 해서 성공하는 경우에 return하도록 해주었다.
이동의 경우에도 조건이 있다.
지정한 from 위치에 영웅이 있는지
있다면 가려는 to 위치에 영웅이 있는지
이 두가지 조건을 모두 만족해야 영웅이 이동할 수 있고, 영웅의 move 메소드를 실행시켰다.
import { Board } from "./board.mjs";
import { AVENGERS_SHORTNAME, POSITION } from "./constants.mjs";
import { displayProcessing } from "./utils.mjs"; // gameState = {
// 0: "DEFAULT(attack)",
// 1: "MOVE",
// 2: "END",
// }; export class Game { constructor() { this.player = new Board(true); this.computer = new Board(false); this.state = 0; this.showComputerBoard = false; } // 플레이어 상태 display display(user) { let data = user.display(); data = displayProcessing(data); console.log(`HP = ${user.totalHP}\n`); console.log(`받은 데미지 = ${user.damage}\n`); console.log(` |01|02|03|04|05|06|\n`); data.forEach((row, index) =&gt; { console.log(`${POSITION.ROW[index]}|${row.join("|")}|\n`); }); console.log(` |01|02|03|04|05|06|\n`); } // attack할 경우 attack(character, to) { this.player.attack(character, to, this.computer); if ( this.computer.board[to[0]][to[1]] &amp;&amp; this.computer.board[to[0]][to[1]].hp &lt;= 0 ) { this.computer.dead.push(this.computer.board[to[0]][to[1]]); this.computer.board[to[0]][to[1]] = null; } this.computer.computedAttack(this.player); if (this.player.hitCount % 5 === 0 &amp;&amp; this.player.hitCount &gt; 0) this.state = 1; if (this.player.dead.length &gt; 1 || this.computer.dead.length &gt; 1) this.state = 2; } result() { if (this.player.dead.length &gt;= 2) { this.player.dead.forEach((char) =&gt; { console.log(AVENGERS_SHORTNAME[char.name]); }); console.log("컴퓨터가 승리했습니다."); } else { this.computer.dead.forEach((char) =&gt; { console.log(AVENGERS_SHORTNAME[char.name]); }); console.log("플레이어가 승리했습니다"); } } // 이동 기회가 주어졌을 경우 move(from, to) { this.player.move(from, to); this.state = 0; }
} Game 클래스같은 경우에 player와 computer를 놓고 각 명령어마다 둘 다 처리될 수 있도록 설계했다. computer의 경우에는 자동으로 위치를 선정하고, 그 위치에 대해 attack 처리를 해야 하기 때문이다.
실행하는 board의 attack함수는 아래와 같다. attack(character, to, user) { let success = false; character = AVENGERS_SHORTNAME[character]; let userCharacter = this.characterTable[character]; if (userCharacter.length === 0) { console.log("MISS"); return; } else { for (let char of userCharacter) { if (char.attack(to, user)) { success = true; } } } if (success) { user.hitCount++; console.log(`HIT(${user.hitCount})`); } else console.log("MISS"); } //컴퓨터가 공격할 때 -&gt; 무조건 맞게끔 computedAttack(user) { let success = false; let characterIdx = getRandomCharacter(); let character = AVENGERS_INFO[characterIdx].name; let to = getRandomPosition(); console.log( `컴퓨터가 입력합니다&gt; ${AVENGERS_INFO[characterIdx].shortname}-&gt;${to}` ); if (this.characterTable[character].length === 0) { console.log("MISS"); return; } else { for (let char of this.characterTable[character]) { if (char.attack(to, user)) { success = true; } } } if (success) { user.hitCount++; console.log(`HIT(${user.hitCount})`); } else console.log("MISS"); }
나같은 경우는 영웅이 여러명일 경우에 어떤 영웅을 선택해야 할까? 에 대한 기준이 모호했다. 따라서 그냥 존재하는 영웅들을 영웅별로 관리하고, 해당 이름의 영웅들이 전부 다 공격하게 했다. result() { if (this.player.dead.length &gt;= 2) { this.player.dead.forEach((char) =&gt; { console.log(AVENGERS_SHORTNAME[char.name]); }); console.log("컴퓨터가 승리했습니다."); } else { this.computer.dead.forEach((char) =&gt; { console.log(AVENGERS_SHORTNAME[char.name]); }); console.log("플레이어가 승리했습니다"); } }
result 함수의 경우 종료 조건을 정해야 했는데, 나같은 경우는 울트론 3마리까지 잡기 귀찮아서 가장 먼저 캐릭터 2명을 잡는 플레이어가 이기는 것으로 선정했다.
이를 위해 각 Board에서 property로 배열을 선언하여 캐릭터가 죽을 때마다 해당 영웅의 정보를 push해서 나중에 꺼낸 다음 이름만 출력하는 식으로 설계했다.이 메소드는 상태가 2값, 즉 끝나는 상태로 바뀔 때 실행되도록 해놨는데, 이를 판단하여 상태값을 바꾸는 때는 Game 클래스에서 attack이 실행될 때마다 판단하여 상태값을 바꿔주었다. // Game 클래스의 attack 메소드 attack(character, to) {
... if (this.player.dead.length &gt; 1 || this.computer.dead.length &gt; 1) this.state = 2; }
해당 클래스에서 가장 중요한 점은 게임의 상태를 숫자로 표현하여 각 숫자마다 gameLoop에서 switch문을 통해 받아들어야 할 값과 질문을 구분한 것이다. 이러한 상태의 구분을 통해 보다 상황에 맞도록 switching하기 용이해졌다.display 함수의 경우 기존 가지고 있던 Board 클래스의 board 데이터를 가지고 처리한다. display() { let data = Object.values(this.board).slice(1); data = data.map((row) =&gt; Object.values(row)); return data; }
Display 함수에서 첫번째 카운터를 제외하고 잘라 데이터를 displayProcessing으로 보낸다.//utils.js
export function displayProcessing(rows) { rows = rows.map(rowProcessing); return rows;
} function rowProcessing(row) { return row.map((elem) =&gt; { if (!elem) return ".."; else return elem.name; });
} utils.js라는 파일을 만들어 여기에서 각종 데이터 처리에 필요한 함수들을 담아두었다.
이렇게 받은 객체 데이터를 다시금 바꾸어 출력형식을 위한 배열로 바꾼 후에 출력시켜 주었다.import { Game } from "./game.mjs";
import readline from "readline";
import { handleAttack, handleMove } from "./utils.mjs"; const rl = readline.createInterface({ input: process.stdin, output: process.stdout,
}); function playGame() { console.log("어벤저스 보드를 초기화했습니다.\n"); let game = new Game(); game.display(game.player); gameLoop(game);
} function gameLoop(game) { switch (game.state) { case 0: rl.question("명령을 입력하세요: ", (line) =&gt; { handleAttack(line, game); game.display(game.player); gameLoop(game); }); break; case 1: rl.question( "이동할 기회가 있습니다. 이동 위치를 입력하세요: ", (line) =&gt; { handleMove(line, game); game.display(game.player); gameLoop(game); } ); break; case 2: console.log("캐릭터 둘이 죽어 게임이 종료되었습니다."); console.log("죽은 캐릭터"); game.result(); rl.close(); break; default: console.log("알 수 없는 게임 상태입니다."); rl.close(); break; }
} playGame(); 게임 인터페이스의 경우 내가 명령을 받고, 명령을 또 실행한 뒤에 다시 종료 조건까지 실행시켜야 한다. 그래서 gameLoop 함수를 만들어 계속해서 실행할 수 있도록 해주었다.
handleAttack과 handleMove의 경우 각 게임에 대해서 직접적인 attack, move 함수를 실행시키기 전에 파싱한 다음 실행시켜줄 수 있도록 하였다.export function handleAttack(line, game) { const regex = /^[A-Z]{2}-&gt;[A-Z][0-9]$/; if (line === "?") { if (game.showComputerBoard) { console.log("게임에서는 한 번만 컴퓨터의 상태를 볼 수 있습니다."); return; } console.log("컴퓨터 상태 보기"); game.display(game.computer); console.log("--------------------\n"); game.showComputerBoard = true; return; } if (regex.test(line)) { let [character, to] = line.split("-&gt;"); game.attack(character, to); } else { console.log("형식이 올바르지 않습니다."); }
} export function handleMove(line, game) { const regex = /^[A-E][1-6]-&gt;[A-E][1-6]$/; if (line === "?") { if (game.showComputerBoard) { console.log("게임에서는 한 번만 컴퓨터의 상태를 볼 수 있습니다."); return; } game.display(game.computer); game.showComputerBoard = true; return; } if (regex.test(line)) { let [from, to] = line.split("-&gt;"); game.move(from, to); } else { console.log("형식이 올바르지 않습니다."); }
}
명령어를 처리하는 과정에서 ?를 통해 상대의 상태를 볼 수 있는 한번의 기회를 사용할 수 있도록 해주었다. 이 기회는 불리언값으로 관리하여 한 번 이후에는 다시 조회할 수 없다.
명령어가 아닌 경우에는 정규표현식으로 검사한 뒤에 split하여 각각의 함수를 실행시켜 주었다.사실 요구조건 분석과 설계까지만 해도 영웅들에게 공통적인 요소가 체력과 공격력밖에 없다고 생각했다. 하지만 설계를 해나가면서 영웅들이 공격할 때 해당 값에 공격력을 빼주고 board 클래스를 업데이트하는 로직이 같아 이를 같이 묶어주고, 파라미터로 객체를 받아 실행할 수 있게 해주었다.export class Avengers { constructor(hp, atk) { this.hp = hp; this.atk = atk; } attack(to, user) { if (user.board[to[0]][to[1]]) { user.board[to[0]][to[1]].hp -= this.atk; user.totalHP -= this.atk; user.damage += this.atk; return true; } else return false; }
} import { Avengers } from "./avengers.mjs"; export class Ultron extends Avengers { constructor(position) { super(400, 40); this.name = "UL"; this.position = position; } move(to, board) { if (!board[to[0]][to[1]]) { if (this.position[0] === to[0]) { board[to[0]][to[1]] = board[this.position[0]][this.position[1]]; board[this.position[0]][this.position[1]] = null; this.position = to; console.log(`영웅이${to}로 이동했습니다.`); } } else { console.log("이동할 곳에 다른 영웅이 있습니다."); } }
} 울트론의 이동 경우, 좌우로만 움직일 수 있기 때문에 row가 같으면 움직일 수 있도록 조건을 걸어주었다.import { Avengers } from "./avengers.mjs"; export class HawkEye extends Avengers { constructor(position) { super(500, 20); this.name = "HE"; this.position = position; } move(to, board) { console.log("호크아이 슨배임은 움직일 수 없습니다."); }
} 호크아이 슨배임은 여기서도...![null][https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQx1CM4Oq87kj-xjUZ01z0Vm6_8oivvufkE3Q&amp;s]import { Avengers } from "./avengers.mjs"; export class Hulk extends Avengers { constructor(position) { super(800, 50); this.name = "HK"; this.position = position; } move(to, board) { if (!board[to[0]][to[1]]) { if (this.position[1] === to[1] &amp;&amp; this.position[0] !== to[0]) { board[to[0]][to[1]] = board[this.position[0]][this.position[1]]; board[this.position[0]][this.position[1]] = null; this.position = to; console.log(`영웅이${to}로 이동했습니다.`); } else { console.log("영웅이 이동할 수 있는 범위가 아닙니다."); } } else { console.log("이동할 곳에 다른 영웅이 있습니다."); } }
} 헐크의 경우 위아래로만 움직일 수 있어 col값만 같으면 움직일 수 있도록 해주었다.import { Avengers } from "./avengers.mjs"; export class CaptainAmerica extends Avengers { constructor(position) { super(700, 30); this.name = "CA"; this.position = position; } move(to, board) { if (!board[to[0]][to[1]]) { if ( (to[0] === this.position[0] &amp;&amp; to[1] !== this.position[1]) || (to[0] !== this.position[0] &amp;&amp; to[1] === this.position[1]) ) { board[to[0]][to[1]] = board[this.position[0]][this.position[1]]; board[this.position[0]][this.position[1]] = null; this.position = to; console.log(`영웅이${to}로 이동했습니다.`); } else { console.log("영웅이 이동할 수 없는 범위가 아닙니다."); } } else { console.log("이동할 곳에 다른 영웅이 있습니다."); } }
} 캡아의 경우 상하좌우로 갈 수 있으므로 상하와 좌우 조건을 따로 걸어주었다.
상하의 경우 col값이 같으면 되고, 좌우의 경우 row값이 같으면 된다.import { Avengers } from "./avengers.mjs"; export class BlackWidow extends Avengers { constructor(position) { super(400, 10); this.name = "BW"; this.position = position; } move(to, board) { if (!board[to[0]][to[1]]) { let rowDiff = Math.abs(this.position.charCodeAt(0) - to.charCodeAt(0)); let colDiff = Math.abs(parseInt(this.position[1]) - parseInt(to[1])); if ( (rowDiff === 0 &amp;&amp; colDiff === 1) || (rowDiff === 1 &amp;&amp; colDiff === 0) ) { board[to[0]][to[1]] = board[this.position[0]][this.position[1]]; board[this.position[0]][this.position[1]] = null; this.position = to; console.log(`영웅이${to}로 이동했습니다.`); } else { console.log("영웅이 이동할 수 있는 범위가 아닙니다."); } } else { console.log("이동할 곳에 다른 영웅이 있습니다."); } }
} 블랙위도우가 상당히 까다롭다.
전후좌우 한 칸씩만 움직일 수 있기 떄문에 한쪽 방향으로 길이가 1 이상 차이가 나면 안되기 때문에 조건으로 걸었다. row값의 경우에는 유니코드 값으로 계산했다.import { Avengers } from "./avengers.mjs"; export class IronMan extends Avengers { constructor(position) { super(600, 40); this.name = "IM"; this.position = position; } move(to, board) { if (!board[to[0]][to[1]]) { let rowDiff = Math.abs(this.position.charCodeAt(0) - to.charCodeAt(0)); let colDiff = Math.abs(parseInt(this.position[1]) - parseInt(to[1])); if (rowDiff === colDiff &amp;&amp; rowDiff &gt; 0) { board[to[0]][to[1]] = board[this.position[0]][this.position[1]]; board[this.position[0]][this.position[1]] = null; this.position = to; console.log(`영웅이${to}로 이동했습니다.`); } else { console.log("영웅이 이동할 수 있는 범위가 아닙니다."); } } else { console.log("이동할 곳에 다른 영웅이 있습니다."); } }
} 아이언맨의 경우 대각선으로 갈 수 있다.
대각선의 경우에는 row,col이 움직인 거리가 같아야 한다.import { Avengers } from "./avengers.mjs"; export class Thor extends Avengers { constructor(position) { super(900, 50); this.name = "TH"; this.position = position; } move(to, board) { if (!board[to[0]][to[1]]) { let rowDiff = Math.abs(this.position.charCodeAt(0) - to.charCodeAt(0)); let colDiff = Math.abs(parseInt(this.position[1]) - parseInt(to[1])); if ( rowDiff === colDiff || (to[0] === this.position[0] &amp;&amp; to[1] !== this.position[1]) || (to[0] !== this.position[0] &amp;&amp; to[1] === this.position[1]) ) { board[to[0]][to[1]] = board[this.position[0]][this.position[1]]; board[this.position[0]][this.position[1]] = null; this.position = to; console.log(`영웅이${to}로 이동했습니다.`); } else { console.log("해당 영웅이 이동할 수 없는 곳입니다."); } } else { console.log("이동할 곳에 다른 영웅이 있습니다."); } }
} 토르의 경우 모든 방향 다 갈 수 있기 때문에 대각선과 상하좌우 모두 고려해주었다. node "/Users/miguel/Desktop/naver/challenge/day6/gameInterface.js"
어벤저스 보드를 초기화했습니다. HP = 5800 받은 데미지 = 0 |01|02|03|04|05|06| A|UL|..|..|..|..|CA| B|BW|..|UL|..|UL|..| C|TH|..|..|CA|..|TH| D|IM|..|..|..|..|BW| E|..|..|..|..|..|..| |01|02|03|04|05|06| 이동할 기회가 있습니다. 이동 위치를 입력하세요: A1-&gt;A2
영웅이A2로 이동했습니다.
HP = 5800 받은 데미지 = 0 |01|02|03|04|05|06| A|..|UL|..|..|..|CA| B|BW|..|UL|..|UL|..| C|TH|..|..|CA|..|TH| D|IM|..|..|..|..|BW| E|..|..|..|..|..|..| |01|02|03|04|05|06| 명령을 입력하세요: %
명령을 입력하세요: UL-&gt;D2
HIT(12)
컴퓨터가 입력합니다&gt; HE-&gt;B2
MISS
HP = 5220 받은 데미지 = 280 |01|02|03|04|05|06| A|BW|IM|..|..|HK|..| B|UL|..|..|BW|..|..| C|..|..|..|..|..|..| D|TH|..|CA|UL|..|..| E|..|..|..|UL|..|HE| |01|02|03|04|05|06| 명령을 입력하세요: UL-&gt;D2
HIT(13)
컴퓨터가 입력합니다&gt; HE-&gt;C1
MISS
HP = 5220 받은 데미지 = 280 |01|02|03|04|05|06| A|BW|IM|..|..|HK|..| B|UL|..|..|BW|..|..| C|..|..|..|..|..|..| D|TH|..|CA|UL|..|..| E|..|..|..|UL|..|HE| |01|02|03|04|05|06| 캐릭터 둘이 죽어 게임이 종료되었습니다.
죽은 캐릭터
BlackWidow
HawkEye
플레이어가 승리했습니다 node "/Users/miguel/Desktop/naver/challenge/day6/gameInterface.js"
어벤저스 보드를 초기화했습니다. HP = 5500 받은 데미지 = 0 |01|02|03|04|05|06| A|BW|IM|..|..|HK|..| B|UL|..|..|BW|..|..| C|..|..|..|..|..|..| D|TH|..|CA|UL|..|..| E|..|..|..|UL|..|HE| |01|02|03|04|05|06| 명령을 입력하세요: ?
컴퓨터 상태 보기
HP = 5200 받은 데미지 = 0 |01|02|03|04|05|06| A|..|..|..|..|UL|TH| B|..|..|..|..|BW|UL| C|..|..|HE|CA|..|UL| D|..|HE|..|IM|..|..| E|..|..|..|..|..|BW| |01|02|03|04|05|06| -------------------- HP = 5500 받은 데미지 = 0 |01|02|03|04|05|06| A|BW|IM|..|..|HK|..| B|UL|..|..|BW|..|..| C|..|..|..|..|..|..| D|TH|..|CA|UL|..|..| E|..|..|..|UL|..|HE| |01|02|03|04|05|06| 명령을 입력하세요: HK-&gt;B5
HIT(1)
컴퓨터가 입력합니다&gt; HE-&gt;B2
정상적으로 모든 기능이 작동된다!
![null][https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSz-vu3EyjHDUyzLVyHqgBfKUjRQrv1n7Cf6Q&amp;s]]]></description><link>부스트캠프/챌린지/챌린지_day5_학습저장소.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지_Day5_학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 회고]]></title><description><![CDATA[<img src="https://i.imgur.com/46CxYK3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
부스트캠프 챌린지를 마무리했다.사실 회고를 많이 쓰는 편은 아니었지만, 이제는 주간이나 프로젝트를 하면 내가 부족했던 부분이나 어떤 점이 좋고 어떤 점이 발전해야 하는지를 조금씩 써내려가려고 노력하는 중이다.
아무튼 챌린지를 마무리하는 기념에서 처음 부스트캠프를 시작하기 전부터 현재까지의 이야기를 써내려 가려고 한다. 반성부터 하자면 나는 사실 굉장히 오만한 개발자였다고 생각한다.
부스트캠프를 시작하기 전부터 '지금의 나 정도라도 그래도 웬만큼은 개발을 좀 안다고 할 수 있지 않을까?' 라고 건방지게 생각했다. 마치 파이썬 교양을 듣고 Hello world!를 콘솔에 찍어놓았을 때 개발에 자신감이 붙은 새내기 1학년과 같은 느낌이었다.하지만 챌린지에서 알면 알수록 정말 내가 알던 프로그래밍의 세계는 티끌만큼도 되지 않았음을 느껴버렸다.<br>
<img src="https://i.imgur.com/6nGWDnD.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
마치 이런 느낌이었다.아무튼 이렇게 챌린지를 하기 전에는 내가 할 수 있는 정보, 즉 동아리나 몇 명을 모아서 하는 자그마한 토이프로젝트를 가지고 코딩하기를 반복하면서 나도 모르게 내가 알던 부분이 전부라는 오만한 생각을 가지고 있었다고 생각한다. 사실 그 알던 부분도 제대로 알던게 아니라는 사실 또한 깨달았다.아무튼 그렇게 오만해졌던 나는 프로젝트들을 하면서 한정적인 사람들과 하면서 항상 비슷한 류의 프로젝트만 했기 때문에 기술적인 역량 자체가 정체기에 머물러 있었다. 나름대로 공부한다고 이것저것 서적을 참고하면서 리액트나 자바스크립트에 대해서 공부했지만, 사실상 이러한 개념들은 내가 제대로 활용하는 상황이 없었기 때문에 다시금 잊혀지기를 반복하면서 나름대로 슬럼프와 같은 느낌을 받았다. 이 슬럼프는 나에게 정신적으로 고통스러운 시간이었던 것 같다. 나는 발전하고 싶지만, 이걸 하면서 발전한다는 느낌을 크게 받지 못해 스트레스를 많이 받았다. 매일매일 열심히 뜀박질을 했지만, 아직도 출발 지점에 있는 것과 같은 느낌이었다.이에 다른 공부의 방향을 잡아야겠다고 생각했고, 이에 생각해낸 방법 중 하나가 부스트캠프였다. 그렇게 나는 부스트캠프 1차 테스트를 보았고, 베이직에 입과하여 과정을 수료하고 2차 테스트를 본 후에 챌린지에 입과하게 되었다.챌린지는 입과 처음부터 매우 쉽지 않았다.
기존에는 그리 보지 못했던 낯선 문제들, 나는 제대로 문제를 해석도 못 하는 것 같은데 이미 열심히 토론중인 다른 캠퍼들, 새벽까지 문제를 잡고 있어도 풀리지 않는 문제들
챌린지의 모든 것들이 내 멘탈을 집중 공략한 것만 같았다. 자괴감도 많이 느꼈던 것 같다.하지만 니체가 말했듯 나를 죽이지 못하는 것은 나를 더 강하게 만든다고, 다른 사람들도 하는데 내가 왜 못하겠어? 하는 마음으로 하다보니 정말 얻는게 많았다.<br>
<img src="https://i.imgur.com/Ovh2hwR.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
물론 그렇다고 일찍 문제를 푼건 아니다. 매일 4시간 이상 자지는 못했다^^,,,아무튼 챌린지에서 내가 성장한 부분, 개선이 더 필요한 부분 등을 말해보려 한다.과정 내내 항상 다른 사람의 코드를 보면서 코드 독해력이 크게 늘었다. 예전만 하더라도 프로젝트에서 남의 코드를 리뷰할 때 괜히 조금 읽다가 로직에 문제만 없겠다 싶으면 무지성 LGTM을 남발했었다. <br><img src="https://i.imgur.com/yYCQuJ7.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">항상 주변에서 같이 프로젝트 했던 사람들은 코드리뷰에서 코드 자체를 읽지 않았던지라, 어찌보면 나도 거기에 무의식적으로 그 사람들도 안하니까~하면서 미뤄놨었는데 이번 챌린지 과정에서 코드를 보는 눈을 좀 더 길러 이제는 다른 사람이 쓴 코드 또한 어떻게든 읽어내는 습관을 잡았다.이와 동시에 계속해서 '이 코드에서 더 발전할 부분이 있는가?'에 대해서도 계속해서 자문하면서 코드를 리뷰하려고 노력했던 것 같다. 예를 들어보자면,
불필요하게 반복되는 로직을 줄이기 위해 함수를 분리했는가?
함수가 여러 기능을 담당하는 것이 아닌, 하나의 기능만을 담당하여 처리하는가?
예외 처리에서 생각할 수 있는 것을 다 찾았는가?
에러에 대한 핸들링을 모든 경우에서 원할히 동작하도록 로직이 되어있는가?
함수의 길이가 지나치게 길지 않은가?
누군가에게 이 코드를 보여줬을 때, 이해하기 쉽도록 작성되었는가?
테스트코드를 작성하고, 코드의 정상 작동을 다양한 상황에서 검증했는가?
등등...을 많이 신경쓰면서 코드를 보다보니 나도 모르게 해당 코드를 비판적인 시선으로 바라보며 리뷰를 했던 것 같다.
하지만 이 비판적인 시선이 부정적인 것만은 아니라고 생각한다. 이 비판점을 통해서 나 또한 다른 캠퍼들에게 내가 개선이 필요한 부분에 대해 이야기를 들었었고, 나도 다른 캠퍼들의 코드를 보면서 조금 더 발전할 수 있도록 조언을 아끼지 않았다. 결과적으로는 모두가 발전한 긍정적인 피드백이라고 생각한다. 처음에는 이렇게 개선이 필요한 부분을 직설적으로 말하는 것이 그 사람에게 상처를 주지 않을까 생각했었는데, 내가 직접 피드백을 듣고난 뒤에는 내가 정말 무의식적으로 코드를 썼을 때 보이는 안 좋은 습관들을 제삼자의 입을 통해 들어 처음으로 알게 됐다. 이를 통해 내가 코드를 쓰는 방식이나 이런저런 조언들을 통해 크게 발전할 수 있었고, 아 이게 정말 동료와 함께 하는 프로그래밍이구나 깨달았다.<br><img src="https://i.imgur.com/IO6JqSt.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
boy scout rule이라는 코드 리뷰에 추천하는 룰이 있다고 한다. 항상 당신이 발견한 코드보다 더 나은 코드를 작성할 것
이러한 룰처럼, 코드 리뷰는 이전보다 더 나은 코드가 되기 위한 과정으로, 서로가 서로의 발전을 위해서 보다 객관적으로 봐주고 내가 아는 지식 선에서 보다 나은 개선방안을 찾아 공유하는 것이 얼마나 중요한 과정임을 몸소 깨달을 수 있었다. 이렇게 하다보니 왜 그렇게 개발자 커뮤니티가 커졌는지 알 것만 같다. 마치 서로의 코드를 자신의 코드 보듯이 해주어 마음도 따숩고 나의 발전을 진심으로 원하는 마음으로 해준 리뷰가 하나하나 소중해서 이렇게 받은 리뷰들을 계속 기억하고 활용하기 위해 다시금 로직을 생각하다보니 자연스럽게 발전했던 것 같다.
Don't Dissect the Frog, Build it - Nicholas Negroponte
이번 챌린지를 하면서 가장 크게 깨달았던 효과적인 학습방법이었다.
무언가를 이해할 때는, 그 대상에 대해 하나하나 학습해가는 것 또한 중요하지만, 이를 직접 만들어나가는 것이 제일 중요하다고 생각한다.비단 똑같이 만들어내는 것이 아니더라도 학습하고자 하는 대상에 대한 학습은 필수요건이며, 이렇게 쌓아올린 지식을 기반으로 내가 직접 로직을 생각해서 구현해나가는 학습 방식이 정말 효과가 좋았다고 생각한다.내가 이제까지 했던 프로그래밍 학습 방식은 보다 효과적인 학습방식이 아니었다고 생각한다. 앞에서도 말했듯 책을 보면서 학습하거나 강의의 코드를 따라 치는 학습 또한 좋지만, 이는 기본적인 베이스이다. 정말 직접 어떤 개념에 대해 이해하고 내 머리의 장기저장소로 이전시키기 위해서는 이러한 쌓아올린 베이스를 가지고 직접 활용해보면서 계속해서 머릿속에서 이해하는 것이 중요함을 느꼈다. 이제까지 학습 방식에 대해 계속해서 의문을 가지고 있던 나에게 있어서는 정말 중요한 부분을 익힌 것 같다. 한 단계 발전된 학습 방식은 보다 앞으로의 내 학습에 있어서 긍정적인 영향을 끼칠 것이라 생각한다.이 또한 프로젝트나 알고리즘 등 어떠한 문제를 해결함에 있어서 내가 사용했던 방식이 너무나도 구렸다(?)는 점을 깨닫고 개선하게 된 점 중 하나였다.나는 문제를 원래부터 잘 읽지 않았다. 이 문제가 나에게 무엇을 원하는지 분석하는 것이 문제가 아닌, 내가 이 문제를 푸는 것이 내 문제해결의 중점이 되었다. 그러다보니 다른 문제에서도 빼먹은 조건 또한 많으며, 문제를 잘못 읽어 학교 시험에서는 수두룩 점수가 깎여나갔던 적도 부지기수였지만 이를 제대로 고치지 못했다. 아니, 고치지 않았다고 표현하는 것이 맞다. 애초에 고칠 생각을 크게 하지 않았다.<br><img src="https://i.imgur.com/LXvKLK2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
마치 이렇게 문제 파악도 안하고 문제를 푸는 사람 같달까..아무튼 이런 고질적인 문제도 이번 기회에 제대로 인식하고 고쳐나가려고 했던 것 같다. 챌린지를 시작하고 나서 다른 알고리즘 문제를 풀더라도 이제는 설계부터 어떻게 해야 하는지 생각하고 이를 코드로 옮기면 어떻게 해야할 지를 생각하면서 기초를 잡아나가고, 이를 계속해서 애자일하게 고쳐 나가는 방식으로 문제에 접근했다. 예상보다 기초가 있는 문제와 없는 문제를 해결해나가는 과정은 정말 차이가 많았다. 기초가 없을 때는 문제를 하나씩 읽어가면서 계속해서 설계를 변경해나가야 했으며, 이에 따른 시간 지연이 정말 컸다. 그러다보니 이제까지 내가 알고리즘 문제를 풀 때 걸리는 시간도 오래 걸렸다고 생각했다. 이런 내 나쁜 습관들을 인지하고, 반성하며 개선하려 노력해나갔다. 이는 챌린지 과정이 끝나더라도 계속해서 인지하고 고쳐나가야 할 습관이라고 생각한다.테스트는 프론트엔드, 백엔드 모두에게 중요하다. 테스트를 세부적으로 진행하면 할수록 코드의 완성도는 높아지고, 프로젝트와 같은 경우에도 어디에서, 프론트와 백 어디에서 문제가 있는지를 보다 잘 파악할 수 있는 필수적인 요소이다. 회사에도 QA가 따로 있는 이유가 있다.하지만 그럼에도 불구하고 이제까지 내 테스트는 허접하기 그지 없었다. 잘 작동되기만 하면 된다 라는 일념 하에 작성한 내 코드는 아직까지 어떤 에러가 터질지 모르는 위험성을 가지고 현재 프로젝트가 돌아가고 있다. 지금보면 참 무모한 짓이었다. 약간 주변에 떠도는 개발자 밈을 가지고 나도 그렇게 해도 괜찮을 것 같다는 안일하고 단편적인 생각이었다.<br>
<img src="https://i.imgur.com/i1C1iTQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">코드의 복잡성이 높아질 수록 내 자신 또한 테스트 자체가 필요함을 많이 느꼈다. 직접 필요성을 느끼고 시작하는 것이야말로 효과적인 습관들이기가 아닌가 싶다. 처음으로 콘솔로 하나하나 찍어가는 것이 아닌 Jest를 사용하여 테스트를 체계적으로 실시하기 시작하면서 앞으로도 테스트 코드를 활용하여 코드를 작성하는 버릇을 들일 예정이다.챌린지를 수료하더라도 할 것이 줄어든게 아니라 더 늘어났다. CS도 그렇고 자바스크립트도 그렇고 새롭게 배우고 싶은 것들도 너무 많아졌고 이러한 학습법이나 내가 익힌 것들을 보다 나에게 반복숙달시켜 나의 일부로 받아들일 수 있도록 많은 계획을 생각중이다.아무튼 챌린지를 하면서 삐그덕거렸던 순간도 정말 많았지만, 결과적으로는 나름 열심히 내가 할 수 있는 최선을 다해 문제를 해결해나갔고, 항상 이름대로 챌린지한 문제들을 결국은 해내는 나를 보면서 나름의 내 가능성(?)을 보았다. 앞으로도 이런 불가능해보이는 문제에 대해서 끊임없이 도전하고 해낼 것이라 나를 믿는다.마치 프로그래밍계의 신형만이 된 기분이랄까.<br>
<img src="https://i.imgur.com/omVLO6m.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내 나름대로 잘 해냈고 앞으로도 노력하면 무엇이든 될 것 같다.
수료생 중 한 분이 해주신 말이 기억에 남는다.
중요한 것은 꺾여도 그냥 하는 마음
나 또한 이를 마음에 새기고 앞으로도 열심히 개발해나갈 것이다!<br>
<img src="https://i.imgur.com/LQPYOks.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>부스트캠프/챌린지/챌린지-회고.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 회고.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/46CxYK3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/46CxYK3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지 Day_4]]></title><description><![CDATA[<a data-href="챌린지 Day_4 학습저장소" href="부스트캠프/챌린지/챌린지-day_4-학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_4 학습저장소</a><br>
<a data-href="챌린지 Day_4 학습정리" href="부스트캠프/챌린지/챌린지-day_4-학습정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_4 학습정리</a><br>
<a data-href="챌린지 Day_4 문제" href=".html" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day_4 문제</a>]]></description><link>부스트캠프/챌린지/챌린지-day_4.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_4.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day_4 학습저장소]]></title><description><![CDATA[
스택 영역
힙 영역
텍스트 영역
글로벌변수 GVAR 스택 영역
힙 영역
텍스트 영역
GVAR 영역
<img alt="https://i.imgur.com/ZxcILSe.png" src="https://i.imgur.com/ZxcILSe.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
프로그램이 자동으로 사용하는 영역으로, 호출된 함수의 수행을 마치고 복귀할&nbsp;주소 및 데이터(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간
프로세스가 메모리에 로드될 때 스택 사이즈는 고정되며 함수 호출 시 생성되고, 함수 반환 시 소멸
스택사이즈가 고정이므로 재귀함수가 너무 깊거나, 함수 지역변수가 메모리를&nbsp;초과하면 Stack Overflow가 발생
영역이름대로 스택 자료구조를 사용하여 LIFO(후입선출)의 형식이다.
명령 실행 시 자동으로 증가 또는 감소하기 때문에 보통 메모리의 마지막 번지를 지정한다
data, stack 영역의 크기를 계산해 메모리 영역을 결정 프로그래머가 필요할 때마다 사용하는 동적인 영역
런타입에 크기 결정
메모리 주소 값에 의해서만 참조되고 사용됨
위의 스택과 같은 공간을 공유하며, 힙이 낮은 주소부터 할당되는데 각 영역이 상대공간을 침범하면 Stack Overflow, Heap Overflow가 발생한다.
stack 에서 변수 할당 -&gt; pointer가 가리키는 heap 영역의 임의의 공간부터 원하는 크기만큼 할당해 사용
힙&nbsp;영역은&nbsp;메모리의&nbsp;낮은&nbsp;주소에서&nbsp;높은&nbsp;주소의&nbsp;방향으로&nbsp;할당
더 이상 해당 힙 영역을 참조하는 변수가 없을 경우 소멸되며, free()&nbsp;함수로&nbsp;나중에&nbsp;할당했던&nbsp;영역을&nbsp;반납해야&nbsp;한다. 전역변수, 정적변수, 배열과 같은 구조체 등이 저장되는 공간
BSS영역과 GVAR영역으로 나뉨 BSS영역 초기화되지 않은 데이터 저장되는 영역 BVAR 초기화된 데이터가 저장되는 영역 코드 영역이라고도 불리며, 말그대로 코드가 저장되는 공간
사용자가 작성한 프로그램 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되어 있음
컴파일 타임에 결정되고 중간에 코드를 바꿀 수 없게 Read-only로 되어있음 STACK 영역 (512KB) : 어셈블리 코드를 실행하면서 호출할 때마다 필요한 값을 스택 방식으로 Push하거나 Pop하는 영역 ◦ 0x00000 부터 0x7FFFF 까지 상수로 1024 * 512 = 524,288 을 할당해놓고 만약 스택의 length가 이를 넘으면 stackoverflow 에러 추가 HEAP 영역 (512KB) : 어셈블리 코드를 실행하면서 메모리 할당 요청이 있을 때 사용할 공간을 확보하는 영역 ◦ 0x80000 부터 0x100000
TEXT 영역 (문자열배열) : 입력으로 주어지는 어셈블리 코드가 저장되는 영역 ◦ 0x100000부터 명령어 한 줄(배열 인덱스 1개)이 4바이트씩이라고 가정한다. int32Array가 각 요소를 4바이트로 잘라서 저장하므로 한 요소에 명령어 한줄이 있으면 된다.
참조할 때도(포인터를 쓸 때도) 4바이트 기준으로 하면 된다. 다음과 같이 동작하는 함수를 포함하는&nbsp;Simulator&nbsp;객체를 구현한다.
TEXT, STACK, HEAP 영역은 크기에 맞게 미리 할당한다.
TEXT 영역에서 몇 번째 명령을 실행중인지&nbsp;PC(Program Counter)&nbsp;변수를 사용한다.
STACK 영역을 위해서&nbsp;Stack Pointer변수를 두고 관리한다.HEAP 영역을 관리하는 방식은 스스로 판단한다.
이번 미션에서는 일반적인 프로세스 메모리 모델(배경 지식 참조)중에서 텍스트, 스택과 힙 영역을 위주로 구현한다. 다른 영역은 무시한다.
<br><a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Int32Array" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Int32Array" target="_self">Int32Array - JavaScript | MDN</a>setSize("INT", 4)
setSize("BOOL", 1)
locate("main", ["VAR A: BOOL[4]", "VAR B: INT", "CALL foo()", "SET B=$RETURN"])
locate("foo", ["VAR K: INT", "RETURN 10"])
step()
usage()
step()
step()
heapdump()
step()
callstack()
step()
gabageCollect()
reset() setSIze(”INT”,4) simulator.types[’INT’] =4 setSize("BOOL", 1) simulator.types[’BOOL’] = 1 locate("main", ["VAR A: BOOL[4]", "VAR B: INT", "CALL foo()", "SET B=$RETURN"])
let Text = { codes: ["VAR A: BOOL[4]", "VAR B: INT", "CALL foo()", "SET B=$RETURN"], functions: [ { name: main, variant:{ A : INT, B: INT } 최종위치: 4 } } ]
} locate("foo", ["VAR K: INT", "RETURN 10"]) let Text = { codes: ["VAR A: BOOL[4]", "VAR B: INT", "CALL foo()", "SET B=$RETURN", "VAR K: INT", "RETURN 10" ], pc: 0, //몇번째 명령 실행중인지 functions: [ { name: main, variant:{ A: BOOL, B: INT } 최종위치: 4 }, { name: foo, variant : { K: INT } } } ]
} step() pc주소에 있는 코드 실행(PC 초기값인 0) → Text.codes[pc]를 실행
VAR A: BOOL[4] 파싱해서 → malloc(BOOL, 4)를 실행
BOOL 1 → 패딩 붙여서 8로 바꾸고 → 8*4 = 32 → HeapLoc + 32 = 32
let info = { type: BOOL, // 타입 address: HeapLoc(= 0), // 힙에서의 주소 allocatedLength:32, // 할당된 길이 sp: 0 // 연결된 stackPointer
} heap.heapMemory.push(info)
stack.locMemory.push(info.address)
stack.stackPointer += 1
text.px++ usage() 스택 영역 전체크기, 사용중인 용량, 남은 용량과 힙 영역 전체크기, 사용중인 용량, 남은 용량을 순서대로 배열로 리턴
[stack.max, stack.locMemory.length *4, stack.remain, heap.max, heap.heapLoc, heap.remain] step() Text.codes[pc]를 실행 → VAR B: INT
malloc(INT, 1)
INT 4 ⇒ 패딩 붙여서 8로 바꿈 → HeapLoc + 8 = 40
let info = { type: INT, // 타입 address: HeapLoc, // 힙에서의 주소 allocatedLength: 40, // 할당된 길이 sp: 1 // 연결된 stackPointer
} stack.locMemory.push(40) ⇒ stack = [34, 40]
stack.stackPointer += 1 ⇒ 2
text.px ++ step() Text.codes[pc]를 실행 → CALL foo()
CALL ⇒ 마지막 PC를 스택에 push
마지막 pc = 2를 스택에 push → stack = [34, 40, 2], stackPointer = 3
FuncName에 해당하는 함수 주소로 PC를 옮기고 실행 PC = foo의 주소로
VAR K: INT → malloc(INT, 1) → Heaploc + 8 = 48 → stack = [34, 40, 48] → stackPointer = 4 호출에 대해 기록하고 callstack()에서 활용한다. 호출에 대해 기록????????? heapdump() 힙에 있는 상태를 문자열 배열로 표현해서 return 힙 영역 정보는 타입과 주소, 할당한 길이, 해당 주소를 참조하는 스택 포인터 변수 정보도 포함한다. 힙 영역 정보? 타입과 주소
할당한 길이
해당 주소를 참조하는 스택 포인터 변수 정보 스택은 메서드와 함수 프레임, 원시 값, 객체 포인터를 포함한 정적 데이터가 저장되는 곳이다 <br><img src="https://i.imgur.com/iSKRKjq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">let Simulator = { pointer : 0, types : { boolean: 4 }, pc:, text : { codes: [코드들], functions: [ { 이름: 함수이름, 최종위치: codes에서의 최종위치 } ] }
}; const setSize = (type, length) =&gt; { Simulator[type] = length;
} let Text = { codes: ["VAR A: INT", "VAR B: INT", "CALL foo()", "SET B=$RETURN"] functions: [ { name: main, address: 0x100000 } , { name: ‘foo’, address : 0x100000 + (4 * 4) } ]
} let heap = { max: 1024 * 512, heapLoc: 0, get remain() { return this.max - this.locMemory.length }, heapMemory: [{ { 할당된 길이: 32 type: BOOL address: heapLoc + mallocByte (힙 주소) sp: 0 value: null }
},]
}
let stack = { max: 1024 * 512, locMemory : Int32Array(), stackPointer = 0, get remain() { return this.max - this.locMemory.length }
}
<br><img src="https://i.imgur.com/FFWTDWg.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/YNVUNUB.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/f0bMxQb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/uQz7Gfi.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/98jKkcy.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/u3QQGXX.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/NogyUSz.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/mtvdIRH.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/SB9BG1j.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/YzCvN7S.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/65Cx3UC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/BZSYiDd.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
개발자 원칙 P38 "동기를 관리할 때 또 신경써야 하는 것은 에너지입니다."
-&gt; 우리가 미션을 해결하기 위해 열심히 노력하는 것도 좋지만, 계속해서 밤을 새어 가며 하는 것은 몸도 망치고 나중에 가서 힘이 빠질 가능성이 있다.
-&gt; 미션을 해결하는데 힘을 두기 보단 집중과 휴식의 밸런스를 맞춰야 한다고 생각한다.
✔️ 퀘스트 : 미션을 해결하면서 중간중간 쉬면서 생각을 정리하는 시간 가지기
✔️ 수행 기준
산책하기 : 하루종일 앉아서 코딩만 하면 힘들테니 4시간 당 최소 30분 산책하기
인증하기 : 산책하고 인증샷 찍기
생각 기록하기 : 오늘 하루는 어땠는지 다시금 생각하며 쌓인 생각들 정리하고 기록하기
✔️&nbsp; 퀘스트 :&nbsp;과제를 진행하기 전에 과제를 세분화 하여 시간계획을 세운 뒤 과제 진행하기✔️&nbsp;의도 : 계획을 짜는 것 또한 개발자의 중요한 능력이다. 계획을 짜며 본인의 능력치를 파악해보자✔️&nbsp;수행 기준
계획 하기 : 체크리스트 작성, 사전 지식 학습 , 구현, readme작성 등 세부 Task를 정하여 Task 당 할당 시간을 정한다.
수행 하기 : 각 Task들에 얼마나 시간이 소요되었는지 측정한다. (최대한 계획한것과 비슷하게 수행한다.
분석하기 : 계획과 수행 사이에서 발생한 시간 차이가 왜 났는지 분석한다.
]]></description><link>부스트캠프/챌린지/챌린지-day_4-학습저장소.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_4 학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/ZxcILSe.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/ZxcILSe.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지 Day_4 학습정리]]></title><description><![CDATA[프로세스(Process)는 '실행중인 프로그램' 이라는 간단한 의미를 가지고 있지만 사실 말만큼 그렇게 간단하지는 않다
프로그램은 보조기억장치에 단순 데이터로 위치하다가 해당 프로그램을 가져와 메모리에 적재하고 실행하면서 프로세스가 되는 것이다. 여기서 프로그램이 실행되면서 프로세스를 생성한다 고 표현한다.윈도우에서는 프로세스 탭에서 실행 중인 프로세스를 확인할 수 있고 유닉스 체계 운영체제에서는 ps 명령어로 확인할 수 있다.<img src="https://i.imgur.com/3QqcK4D.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
리눅스에서 ps를 눌렀을 때 뜨는 프로세스이다
가상 환경이라 현재는 실행중인 프로세스가 거의 없지만, 우리가 주로 사용하는 운영체제에서는 많은 프로세스가 실행되고 있다.
우리가 앞에서 실행하면서 보는 프로그램들의 프로세스는 포그라운드 프로세스라고 하고, 우리가 보지 않는 곳에서 열심히 일처리를 하는 프로세스들을 백그라운드 프로세스, 데몬(UNIX), 서비스(윈도우)등으로 불린다.프로세스는 CPU 자원을 가져와 프로그램을 실행시킨다. 하지만 CPU 자원은 한정되어 있기에 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자기에게 할당받았던 CPU를 돌려주고 다시 자신의 처리를 기다린다. 운영체제는 이 가운데에서 프로세스들의 실행 순서를 관리하고 프로세스에 CPU를 비록한 자원을 배분하는데, 여기서 이용하는 것이 프로세스 제어 블록(Process Control Block, PCB) 이라고 한다. PCB는 메모리의 커널 영역에 생성된다.운영체제는 이 PCB를 기준으로 프로세스를 식별하고 처리하는데 필요한 정보를 판단하며, PCB는 프로세스가 실행될 시점에 생성되고 종료되면서 폐기된다.PCB에 담기는 정보는 운영체제마다 차이가 있지만, 대표적인 정보는 아래와 같다.
프로세스 ID 프로세스를 식별하는 고유한 번호 레지스터 값 자신의 실행 차례가 돌아오면 원래 진행하던 작업들을 재개하기 위해 임시로 저장하는 값들. 이전까지 사용했던 레지스터의 중간값들을 모두 복원해 다시 사용한다. 프로세스 상태 CPU를 기다리는 상태, 이용중인 상태 등 CPU 스케줄링 정보 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보 메모리 관리 정보 프로세스마다 메모리에 저장된 위치가 다르므로 기록해야 한다.
베이스 레지스터
한계 레지스터
페이지 테이블 정보 사용한 파일과 입출력장치 목록 프로세스에 할당된 입출력장치
이용한 파일들의 정보 하나의 프로세스에서 다른 프로세스로 순서가 넘어가면 현재까지 계속 실행하고 있던 프로세스는 PCB의 정보들을 백업해두어 나중에 다른 프로세스들에게서 자신의 순서가 넘어왔을 때 이전에 했던 작업을 계속한다.이러한 프로세스 수행 재개에 필요한 정보를 문맥(Context) 이라고 하는데, 이렇게 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것을 문맥 교환(Context Switching)이라고 한다.<br><img src="https://i.imgur.com/8hBHL5b.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">프로세스가 커널 영역에서 PCB를 만들어 내고 사용자 영역에도 만들어 내는 메모리가 있다. 메모리 구조는 프로세스가 사용자 영역에 배치될 때의 프로세스 배치 방식이다.<br><img src="https://i.imgur.com/8WxZUWe.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
프로그램이 자동으로 사용하는 영역으로, 호출된 함수의 수행을 마치고 복귀할&nbsp;주소 및 데이터(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간
프로세스가 메모리에 로드될 때 스택 사이즈는 고정되며 함수 호출 시 생성되고, 함수 반환 시 소멸
스택사이즈가 고정이므로 재귀함수가 너무 깊거나, 함수 지역변수가 메모리를&nbsp;초과하면 Stack Overflow가 발생
영역이름대로 스택 자료구조를 사용하여 LIFO(후입선출)의 형식이다.
명령 실행 시 자동으로 증가 또는 감소하기 때문에 보통 메모리의 마지막 번지를 지정한다
data, stack 영역의 크기를 계산해 메모리 영역을 결정 프로세스 실행 과정에서 크기가 변할 수 있는 동적 할당 영역이다.
런타입에 크기 결정
메모리 주소 값에 의해서만 참조되고 사용됨
위의 스택과 같은 공간을 공유하며, 힙이 낮은 주소부터 할당되는데 각 영역이 상대공간을 침범하면 Stack Overflow, Heap Overflow가 발생한다.
stack 에서 변수 할당 -&gt; pointer가 가리키는 heap 영역의 임의의 공간부터 원하는 크기만큼 할당해 사용
힙&nbsp;영역은&nbsp;메모리의&nbsp;낮은&nbsp;주소에서&nbsp;높은&nbsp;주소의&nbsp;방향으로&nbsp;할당
더 이상 해당 힙 영역을 참조하는 변수가 없을 경우 소멸되며, free()&nbsp;함수로&nbsp;나중에&nbsp;할당했던&nbsp;영역을&nbsp;반납해야&nbsp;한다.
할당한 메모리 공간을 반환하지 않으면 할당한 공간이 메모리 내에 계속 남아 메모리 낭비를 초래하는 메모리 누수(Memory Leak)를 일으킨다. 전역변수, 정적변수, 배열과 같은 구조체 등이 저장되는 공간
일시적 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터들을 저장하는 공간이다. BSS영역과 GVAR영역으로 나뉨 BSS영역 초기화되지 않은 데이터 저장되는 영역 BVAR 초기화된 데이터가 저장되는 영역 크기가 고정된 정적 할당 영역이다. 코드 영역이라고도 불리며, 말그대로 코드가 저장되는 공간
사용자가 작성한 프로그램 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되어 있음
컴파일 타임에 결정되고 중간에 코드를 바꿀 수 없게 Read-only로 되어있음
<br><img src="https://i.imgur.com/0VvALtQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">먼저 V8에서 메모리 구조가 어떻게 구성되어 있는지 살펴보자. JavaScript가 싱글 스레드 언어인만큼, V8 역시 자바스크립트 context당 하나의 프로세스를 사용한다.
단, 서비스 워커를 사용하는 경우에만 워커의 개수만큼 프로세스를 증식한다. 실행중인 프로그램은 V8 프로세스에서 할당된 일정량의 메모리로 표현되고 이를&nbsp;Resident set이라고 한다. Resident set은 위와 같은 구조로 구성된다.힙 메모리는 메모리 영역에서 가장 큰 블록이고 가비지 컬렉션이 발생하는 곳이다.
힙 메모리 전체에서 가비지 컬렉션이 동작하는 것은 아니고 Young generation과 Old generation영역에서만 실행된다. 힙 메모리는 더 세부적으로 나눌 수 있다.
New Space 새로 만들어진 모든 객체를 저장하는 짧은 생명 주기의 객체.
안에 두 개의 작은 공간이 있으며&nbsp;Scavenger라는 마이너 GC를 통해 관리한다. New space의 크기는&nbsp;--min_semi_space_size(초기값)와&nbsp;--max_semi_space_size(최대값) V8엔진의 플래그 값을 사용해 조정할 수 있다. Old Space Old Space는 이러한 두 개의 작은 공간을 마이너 GC가 순회할 동안 “new space"에서 살아남은 객체들이 이동하는 영역
메이저 GC(Mark-Sweep &amp; Mark-Compact)가 관리한다.
두 개의 공간으로 나누어짐
Old pointer space 살아남은 객체 중 다른 객체를 가리기는 포인터를 가지는 객체 Old data space 데이터를 포함하는 객체
New space에서 살아남은 문자열, 숫자, 부동 소수점을 가진 숫자 배열 등 큰 객체 공간 다른 공간들이 들어갈 수 있는 사이즈를 초과한 객체들이 있는 곳
가비지컬렉터가 회수해가지 않음 코드 공간 Just In Time(JIT) 컴파일러가 코드 블럭을 저장하는 곳 Cell Space, property cell space, map space 셀, 프로퍼티 셀, Map 자료구조 등이 들어가는 공간
모두 같은 크기
객체를 가리키는데 일정 제약 조건이 있음 스택은 메모리 영역이고 V8마다 하나의 스택 스택은 메서드와 함수 프레임, 원시 값, 객체 포인터를 포함한 정적 데이터가 저장됨
V8의 Stack영역의 관리는 OS에 위임하여 관리한다. 전역 스코프는 스택의&nbsp;전역 프레임&nbsp;안에서 관리한다.
모든 함수호출은 스택 메모리에 프레임 블록 형태로 담긴다.
인수와 리턴 값을 포함한 모든 지역 변수는 함수 프레임 블록에 담겨서 스택에 올라간다.
Number나 String같은 원시 값들은 스택에 바로 담긴다.
class나 function들은 모두 Object이다. Object는 힙에서 생성되어서 stack에서 stack pointer를 통해 참조된다.
함수가 리턴되면, 함수 프레임 블록은 스택에서 제거된다.
객체를 명시적으로 복사하지 않는다면, 레퍼런스만 복사된다.
스택 메모리는 V8이 아닌 OS가 관리하는 반면 Heap 영역은 OS가 관리하지 않는다.
더군다나 Heap 메모리는 가장 큰 메모리 영역을 가짐과 동시에 동적인 데이터를 들고 있어야 한다.
프로그램이 커진 경우 메모리가 부족해지는 문제가 발생할 위험 역시 커진다. 가비지 컬렉터가 필요한 이유이다.힙 영역에서 포인터와 데이터를 구분하는 것은 가비지 컬렉션에서 중요한 부분이다.
V8 엔진은 Tagged pointers를 사용해서, 단어의 마지막 비트를 통해 포인터인지 데이터인지를 구분한다.Scavenger는 new generation space(객체들이 할당되는 곳)를 깔끔하게 관리하는 역할로, 1-8MB 사이의 새롭게 생긴 공간을 관리한다.
새로운 공간을 할당하는 것은 우리가 공간에 새로운 객체를 넣을 때 포인터를 함께 할당한다.
할당한 포인터가 새로운 공간의 끝에 다다르게 되면 Scaenter 가비지 콜렉터가 작동되고 Cheney's 알고리즘을 통해 보완한다.새롭게 생긴 공간은 to-space와 from-space 두 개로 나뉜다.
to-space from-space가 꽉 차면 가비지콜렉터가 보내는 곳 from-space 특정 객체가 할당되는 곳
해당 칸이 차게 되면 가비지콜렉터가 작동함 해당 공간을 순회하면서 살아있는 객체(사용중인 객체)만을 to-space로 옯기고 포인터 업데이트
올기고 남은 객체가 있다면 비운다 이 가비지 콜렉터는 기존의 공간들을 관리하는 역할이다.
해당 가비지콜렉터는 V8이 minor GC가 사이클을 돌았음에도 더이상 기존 공간들에 공간이 없다고 판단할 때 실행된다.
Scavenger 알고리즘은 큰 공간에 적합하지 않기 떄문에 Mark-Sweep-Compact 알고리즘을 사용한다. 해당 알고리즘은 Mark-Sweep-Compact의 과정을 거치기 때문에 이러한 이름이 붙었다.
<br>Mark <img src="https://velog.velcdn.com/images/seyoung8239/post/787162d9-293d-442d-a4e9-5df41abfd990/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 객체들을 돌면서 사용중이지 않은 객체와 사용중인 객체를 구분해낸다.
사용중이거나 스택 포인터(GC 루트)를 통해 도달할 수 있는 것들만을 골라낸다. <br>Sweeping<img src="https://velog.velcdn.com/images/seyoung8239/post/6f0db5fc-6bf8-4cfc-bc2f-886af7c79b73/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 가비지 컬렉터가 힙을 돌면서 사용중이지 않은, 즉 변수의 참조값이 존재하지 않는 객체들과 사용중인 객체들을 기록한다. <br>Compacting<img src="https://velog.velcdn.com/images/seyoung8239/post/29ebb38c-a418-405f-a82a-b221eb85544c/image.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> sweeping이 이루어진 후 필요한 경우를 제외하고 살아남은 객체들을 한 곳에 모아놓는다.
단편화를 줄이고 새로운 메모리 할당을 용이하게 하면서 성능을 높이기 위함이다. Mark-Sweep-Compact&nbsp;알고리즘에서도 살펴 보았듯이, 전역객채의 Referencing chain에 해당하지 않는 값들이&nbsp;garbage collection의 대상이 된다. 하지만 전역 변수와 같이 global scope에 존재하는 레퍼런스 값들은 무조건 전역객체가 레퍼런싱하게 되어, 가비지 컬렌션의 대상에 포함되지 않는다.
이러한 동작 때문에 전역변수는 메모리 누수의 위험이 있다.하나의 값을 여러 변수가 참조하는 경우, 하나의 레퍼런스 변수를 해제하더라도, 다른 레퍼런스 변수가 여전히 데이터를 참조하고 있기 때문에, 가비지 컬렉션의 대상이 되지 않는다. 이러한 이유 때문에, 다중참조에서 여러 개의 레퍼런스 변수를 해제하는 경우를 고려해야 한다.클로저를 통해 스택 영역에 담긴 지역변수는 힙 영역으로 이동된다. 따라서 클로저가 제거되기 전까지는 가비지 컬렉터의 대상이 되지 않는다.callback을 참조하는 함수가 종료되지 않는 한, callback 함수에 존재하는 모든 참조 값들은 가비지 컬렉터의 대상이 되지 않는다.
전역 변수 사용을 최소화한다.
비구조화 할당을 통해&nbsp;heap영역의 데이터를&nbsp;stack영역에서 사용한다.
클로저를 사용하는 경우 local 변수가&nbsp;heap영역으로 이동되서 관리된다. 따라서 메모리 누수의 위험을 생긴다
다중 참조를 방지하기 위해 객체를 사용할 때,&nbsp;spread&nbsp;연산자나,&nbsp;Object.assign()&nbsp;메서드를 통해&nbsp;Deep copy한다.
브라우저에 내장된 메모리 프로파일러를 사용하면, 메모리 누수를 쉽게 확인할 수 있다. 메모리 누수는 생성만 되고 반환은 안되는 상태이기 때문에, 메모리 사용량이 상승곡선을 그리면 메모리 누수를 의심 해볼만 하다.<br>
<img src="https://velog.velcdn.com/images/seyoung8239/post/36778801-50cd-4e89-ba28-7cc6cab052f3/image.R1280x0%255B1%255D" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img alt="Pasted image 20240721133934.png" src="부스트캠프/챌린지/pasted-image-20240721133934.png" target="_self">]]></description><link>부스트캠프/챌린지/챌린지-day_4-학습정리.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_4 학습정리.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/3QqcK4D.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/3QqcK4D.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지 Day_5]]></title><description><![CDATA[<a data-href="챌린지_Day5_학습저장소" href="부스트캠프/챌린지/챌린지_day5_학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지_Day5_학습저장소</a><br>
<a data-href="챌린지_Day5_릴레이노트" href=".html" class="internal-link" target="_self" rel="noopener nofollow">챌린지_Day5_릴레이노트</a>]]></description><link>부스트캠프/챌린지/챌린지-day_5.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_5.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day_7]]></title><description><![CDATA[<a data-href="챌린지_Day_7 학습저장소" href="부스트캠프/챌린지/챌린지_day_7-학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지_Day_7 학습저장소</a>]]></description><link>부스트캠프/챌린지/챌린지-day_7.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_7.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day_8]]></title><description><![CDATA[
함수형 프로그래밍 학습(함수형 프로그래밍 패러다임, 불변성, 참조투영성, 순수함수) - 2시 30분까지 ✅ 2024-07-25
MovieRank 설계 ✅ 2024-07-25
add함수 설계 및 구현 ✅ 2024-07-25
updateTicket 함수 설계 및 구현 ✅ 2024-07-25
updateTheaters 함수 설계 및 구현 ✅ 2024-07-25
delete 함수 설계 및 구현 ✅ 2024-07-25
sortBydate함수 설계 및 구현 ✅ 2024-07-25
top10Tickets 함수 설계 및 구현 ✅ 2024-07-25
findByDirector 함수 설계 및 구현 ✅ 2024-07-25
findByActor 함수 설계 및 구현 ✅ 2024-07-25
totalTheaters 함수 설계 및 구현 ✅ 2024-07-25
MovieRank 구현 ✅ 2024-07-25
테스트코드 작성 및 테스트 ✅ 2024-07-25
함수형 프로그래밍의 핵심은 아래와 같다. 순수함수 : 부수효과가 없고, 같은 값을 넣으면 항상 같은 결과를 반환(참조투명성)
불변성 : 어떤 값의 상태를(메모리에 이미 담긴 상태를) 변경하지 않는다.
이번 문제는 함수형 프로그래밍 코드를 작성하면서 이러한 핵심을 위배하지 않도록 설계하는 것이 핵심이다.
여기서 가장 문제가 됐던 점은 부수효과이다.예를 들어 add(movie)를 한다고 치자.
그렇다면 add(movie)로 새로운 movie 객체를 만들어낸다 치더라도 이러한 movie들을 연결리스트로 어떻게 구현해야 하는가? 에 대한 고민이 많았다.
연결리스트의 경우 한가지 방향이다 하더라도 Next 노드에 다른 노드를 해야하기 때문에 현재의 노드가 어디까지 있는지 알아야 하기 때문에 이러한 데이터를 넘겨주는 과정에서 부수효과가 일어나기 때문이다.부수 효과를 멀리하고 순수함수 합성을 통해 프로그래밍하는 함수형 프로그래밍의 핵심 원리를 다시 생각하고 add에 대해서 다시 생각해보았다.
가장 좋은 방법은 코드를 액션과 계산, 데이터로 분리하여 생각하고, 순수 함수를 세분화하여 합치는 형태로 만든 다음 이를 조합하는 과정으로 가야한다.
또한 변경 가능한 데이터 구조를 가진 언어에서 불변성을 유지하기 위해 카피온라이트와 방어적 복사를 활용해보자.내가 생각한 방법은 함수 안에서 함수들을 클로저를 활용하여 구현하는 방식이다. 함수 내부에서 관리하는 값을 두고, 그 값을 계속해서 업데이트 하는 과정에서 카피온라이트를 통해 내부 값을 바꾸는 것이 아닌, 새로운 함수를 반환하여 서로 참조하는 값이 다른 데이터를 리턴하도록 하여 부수효과를 없앴다. 또한 각 함수는 순수함수의 특성을 준수할 수 있도록 해당 데이터에 같은 값을 넣는다면 같은 결과가 나올 것을 최대한 고려해서 함수들을 작성했다.export function movieRank( info = { root: null, movieList: [], totalTheaters: 0 }
) { var movies = { root: info.root, movieList: info.movieList, };
...
여기에서 클로저를 활용하여 관리하는 값들은 movies 변수이다. 함수 안의 값들은 직접적으로 접근하여 변환이 불가능하기 때문에 불변성을 가진다고 판단하였다.
해당 변수의 root에는 각 Movie 노드가 들어가 있으며, 해당 클래스의 next property를 통해 연결리스트를 구현하였다. export class Movie { constructor( title, year, director, actorA, actorB, tickets, theaters, next = null ) { this.title = title; this.year = year; this.director = director; this.actorA = actorA; this.actorB = actorB; this.tickets = tickets; this.theaters = theaters; this.next = next; }
} 해당 Movie 클래스의 값을 조작하는 메소드는 따로 구현하지 않았다. 어차피 추가하는 경우를 포함한 모든 경우에 해당 클래스 자체를 조작하는 것이 제한되기 때문에 생성자만 구현해냈다.function add(movie) { let newRank = { ...movies, }; if (newRank.movieList.includes(movie.title)) return movieRank(newRank); if (!newRank.root) { newRank.root = newMovie(movie); newRank.movieList.push(movie.title); return movieRank(newRank); } let nextMovie = newRank.root; while (nextMovie.next !== null) { nextMovie = nextMovie.next; } newRank.movieList.push(movie.title); nextMovie.next = newMovie({ ...movie, prev: nextMovie }); return movieRank(newRank); }
add함수에서는 카피온라이트 방식으로 맨 처음 객체들의 값을 복사해주었다. 그런 다음 노드들을 따라가 next값이 null, 즉 끝 위치까지 이동한 뒤에 해당 빈 공간에 새로운 노드를 추가해주고, 함수 자체를 리턴시켜 주어 두 값이 다르도록 설계했다.
상식적으로 같은 영화는 중복되면 안되기 때문에 만약에 제목이 같은 영화가 add될 경우에 따로 추가해주지 않기로 했다. function updateTickets(title, tickets) { let newRank = { ...movies, }; let movie = newRank.root; let prev = null; while (movie !== null) { if (movie.title === title) { console.log("차줌"); movie = newMovie({ ...movie.info, tickets: tickets, }); if (!prev) { newRank.root = movie; return movieRank(newRank); } prev.next = movie; return movieRank(newRank); } prev = movie; movie = movie.next; } throw new Error("영화 제목과 일치하는 정보가 없습니다."); } function updateTheaters(title, theaters) { let newRank = { ...movies, }; let movie = newRank.root; let prev = null; while (movie !== null) { if (movie.title === title) { movie = newMovie({ ...movie.info, theaters: theaters, }); if (!prev) { newRank.root = movie; return movieRank(newRank); } prev.next = movie; return movieRank(newRank); } prev = movie; movie = movie.next; } throw new Error("영화 제목과 일치하는 정보가 없습니다."); }
이 두 함수는 작동 방식은 같다. 변경하는 값만 다르다.
나는 update함수에서 무엇을 보고 해당 하는 인스턴스의 값을 바꿀 것이냐? 에 대한 고민이 있었는데, 아무래도 unique한 영화 제목값을 보고 구별하는 것이 나을 것 같아서 title과 변경할 theaters를 받았다.인수로 받은 title을 노드를 하나씩 건너가면서 해당하는 title과 같은 인스턴스가 있는지를 찾고, 만약에 같은 인스턴스가 있을 경우에는 해당 값을 복사한 후에 새로운 인스턴스를 만들어 이전노드의 다음노드에 연결시켜 주었다. 이를 통해 이전 노드는 전과는 다른 새로운 인스턴스를 받은 새로운 함수를 받아 외부의 값에 영향을 주지 않음을 알 수 있다. function deleteMovie(title) { let newRank = { ...movies, }; let movie = newRank.root; let prevMovie = null; while (movie !== null) { if (movie.title === title) { if (prevMovie) prevMovie.next = movie.next; newRank.movieList.splice( newRank.movieList.findIndex((mov) =&gt; mov === title), 1 ); return movieRank(newRank); } prevMovie = movie; movie = movie.next; } throw new Error("영화 제목과 일치하는 정보가 없습니다."); }
delete함수는 다른 함수들과 같이 노드를 찾고, 해당하는 노드를 삭제하기 위해 이전 노드를 따로 관리한다.
삭제할 인스턴스가 보이면 이전노드를 해당 노드의 다음 노드와 연결시켜주면 해당하는 노드가 연결되어 있는 값이 없어 사라진다.
function sortByDate() { if (!movies.root) throw new Error("영화 데이터가 없습니다."); let dateSorted = getMoviesArray(); dateSorted.sort((a, b) =&gt; a.year - b.year); return dateSorted; } function get10Tickets() { if (!movies.root) throw new Error("영화 데이터가 없습니다."); let topSelledMovies = getMoviesArray(); topSelledMovies.sort((a, b) =&gt; b.tickets - a.tickets); return topSelledMovies.slice(0, 10).map((movie) =&gt; movie.title); } function findByDirector(director) { if (!movies.root) throw new Error("영화 데이터가 없습니다."); let directors = getMoviesArray(); return directors .filter((movie) =&gt; movie.director === director) .map((movie) =&gt; movie.title); } function findByActor(actor) { if (!movies.root) throw new Error("영화 데이터가 없습니다."); let actors = getMoviesArray(); return actors .filter((movie) =&gt; movie.actorA === actor || movie.actorB === actor) .map((movie) =&gt; movie.title); } function getMoviesArray() { let arr = []; let movie = movies.root; while (movie !== null) { arr.push(movie); movie = movie.next; } return arr; }
SortByDate, get10Tickets, findBy함수는 리턴값이 배열이다. 따라서 모든 노드를 돌아가면서 배열에 넣어줄 필요가 있기 때문에 이러한 공통적인 부분을 따로 함수로 빼뒀다.getMoviesArray함수는 해당 함수의 내부에서만 작동하며, 함수를 리턴하지 않기 때문에 외부에서 사용할 수는 없다.이러한 함수를 통해서 모든 영화 인스턴스들이 들어있는 배열을 만들고, 고차함수를 통해 해당되는 인스턴스들만 골라내어 리턴시켜 주었다. function callbackMap(result, node, idx, callback) { if (!node) return; result[idx] = callback(node); if (node.next) callbackMap(result, node.next, idx + 1, callback); } function map(callback) { if (!movies.root) throw new Error("현재 존재하는 영화들이 없습니다."); let result = {}; callbackMap(result, movies.root, 0, callback); return result; } function callbackFilter(result, node, idx, callback) { if (!node) return; if (callback(node)) { result[idx] = node; idx++; } if (node.next) callbackFilter(result, node.next, idx, callback); } function filter(callback) { if (!movies.root) throw new Error("현재 존재하는 영화들이 없습니다."); let result = {}; callbackFilter(result, movies.root, 0, callback); return result; } function callbackDisplay(node, callback) { if (!node) return; callback(node); if (node.next) callbackDisplay(node.next, callback); } function display(callback) { if (!movies.root) throw new Error("현재 존재하는 영화들이 없습니다."); callbackDisplay(movies.root, callback); }
이 세 함수들은 리턴값이 배열이면 안되기 때문에 나는 객체를 새로 만들어 재귀적으로 호출하면서 해당되는 콜백을 실행하여 알맞은 값을 인덱스: 값의 형태로 된 object를 리턴하도록 설계하였다.
따로 callback을 써서 재귀시키는 부분을 모두 함수로 따로 분리했으며, 이러한 callback~ 함수들을 통해 재귀적으로 실행하여 받은 리턴값을 최상위에서 받아 리턴시킨다.async function mainLoop() { let movieData = movieRank(); let running = true; while (running) { const line = await askQuestion( "영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q\n" ); switch (line) { case "a": movieData = await handleAdd(movieData); console.log(movieData.getInfo()); break; case "b": movieData = await handleUpdateTickets(movieData); console.log(movieData.getInfo()); break; case "c": movieData = await handleUpdateTheaters(movieData); console.log(movieData.getInfo()); break; case "d": handleSortByDate(movieData); break; case "e": handleTopTickets(movieData); break; case "f": await handleFindByDirector(movieData); break; case "g": await handleFindByActor(movieData); break; case "h": handleTotalTheaters(movieData); break; case "i": movieData = await handleDelete(movieData); console.log(movieData.getInfo()); break; case "q": running = false; rl.close(); break; default: console.log("잘못된 명령어입니다. 다시 입력해 주세요."); break; } }
} mainLoop();
프로그램 인터페이스의 경우 계속해서 명령어를 받고 실행하는 방식으로 작성해주었다.
다시금 question을 통해 필요한 값을 받는 부분이 필요한 함수들은 동기적으로 작동할 수 있도록 await 키워드를 통해 처리 순서를 정렬시켰다.각 명령에 대해 따로 해당 파일에서 만든 함수를 쓰는데, 받는 인수의 경우 함수로 생성한 객체를 주고, add와 같은 함수는 나중에 리턴받을 때 새로운 객체로 만들어져서 받는다.영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
a
영화 제목(공백 미포함), 최초 상영연도, 감독, 주연배우 2명, 관람인원, 상영관 개수를 공백 포함 입력하세요: insideout2 2024 캘시맨 에이미 마야 101112 199
{ root: Movie { title: 'insideout2', year: 2024, director: '캘시맨', actorA: '에이미', actorB: '마야', tickets: 101112, theaters: 199, next: null }, movieList: [ 'insideout2' ]
}
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
a
영화 제목(공백 미포함), 최초 상영연도, 감독, 주연배우 2명, 관람인원, 상영관 개수를 공백 포함 입력하세요: 위대한쇼맨 2017 마이클 휴잭맨 잭에프론 10022 9999
{ root: Movie { title: 'insideout2', year: 2024, director: '캘시맨', actorA: '에이미', actorB: '마야', tickets: 101112, theaters: 199, next: Movie { title: '위대한쇼맨', year: 2017, director: '마이클', actorA: '휴잭맨', actorB: '잭에프론', tickets: 10022, theaters: 9999, next: null } }, movieList: [ 'insideout2', '위대한쇼맨' ]
}
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
b
영화의 제목과 업데이트 시킬 인원을 공백을 기준으로 입력하세요: insideout2 100
차줌
{ root: Movie { title: 'insideout2', year: 2024, director: '캘시맨', actorA: '에이미', actorB: '마야', tickets: 100, theaters: 199, next: Movie { title: '위대한쇼맨', year: 2017, director: '마이클', actorA: '휴잭맨', actorB: '잭에프론', tickets: 10022, theaters: 9999, next: null } }, movieList: [ 'insideout2', '위대한쇼맨' ]
}
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
c
영화의 제목과 업데이트 시킬 상영관 수를 공백을 기준으로 입력하세요: 위대한쇼맨 29
{ root: Movie { title: 'insideout2', year: 2024, director: '캘시맨', actorA: '에이미', actorB: '마야', tickets: 100, theaters: 199, next: Movie { title: '위대한쇼맨', year: 2017, director: '마이클', actorA: '휴잭맨', actorB: '잭에프론', tickets: 10022, theaters: 29, next: null } }, movieList: [ 'insideout2', '위대한쇼맨' ]
}
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
d
[ Movie { title: '위대한쇼맨', year: 2017, director: '마이클', actorA: '휴잭맨', actorB: '잭에프론', tickets: 10022, theaters: 29, next: null }, Movie { title: 'insideout2', year: 2024, director: '캘시맨', actorA: '에이미', actorB: '마야', tickets: 100, theaters: 199, next: Movie { title: '위대한쇼맨', year: 2017, director: '마이클', actorA: '휴잭맨', actorB: '잭에프론', tickets: 10022, theaters: 29, next: null } }
]
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
e
[ '위대한쇼맨', 'insideout2' ]
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
f
감독 이름을 입력하세요: 마이클
[ '위대한쇼맨' ]
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
g
배우 이름을 입력하세요: 휴잭맨
[ '위대한쇼맨' ]
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
h
228
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
i
지울 영화 제목을 입력하세요: 위대한쇼맨
{ root: Movie { title: 'insideout2', year: 2024, director: '캘시맨', actorA: '에이미', actorB: '마야', tickets: 100, theaters: 199, next: null }, movieList: [ 'insideout2' ]
}
영화 정보 추가: a , 관람인원 업데이트: b, 상영관 개수 업데이트: c, 상영연도순 조회: d, 관람 인원 상위 10개 조회: e, 감독 이름 기준 영화 검색: f, 배우 기준 영화 검색: g, 영화 전체 상영관 조회: h, 영화 삭제: i, 종료 : q
q
![tg.png][https://blog.kakaocdn.net/dn/Uq7Bc/btrr5Vseaa0/YJIG3ziHdGreV0oTgEQoqK/img.png]함수 안의 함수들에 대해서는 모두 테스트를 마친 상태라 jest를 통한 테스트는 다른 방향을 잡고 시도해보았다.
내가 했던 테스트는 주로 '값을 함수에 넣었을 때 반환되는 값이 새로운 값인가?'에 집중해서 테스트해보았다. 또한 해당 함수 안의 값은 변경되어야 하지 않아야 하는 불변성 또한테스트에 넣어주어 함수형 프로그래밍의 특성을 중점적으로 테스트했다.import { movieRank } from "./movieRank.mjs"; describe("테스트", () =&gt; { test("생성된 클로저 비교", () =&gt; { let a = movieRank(); let b = movieRank(); expect(b === a).toBe(false); }); test("같은 필드 값을 가진 인스턴스가 다른 참조값을 가지고 있는가?", () =&gt; { let a = movieRank(); a = a.add({ title: "인사이드아웃2", year: 2024, director: "캘시 맨", actorA: "에이미 포엘러", actorB: "마야 호크", tickets: 1000, theaters: 2000, }); let b = movieRank(); b = b.add({ title: "인사이드아웃2", year: 2024, director: "캘시 맨", actorA: "에이미 포엘러", actorB: "마야 호크", tickets: 1000, theaters: 2000, }); expect(b.getInfo().root === a.getInfo().root).toBe(false); }); test("같은 함수 내의 함수를 통해 새로운 값을 받았을 때 리턴받은 두 객체는 다른가?", () =&gt; { let oldA = movieRank(); oldA = oldA.add({ title: "인사이드아웃2", year: 2024, director: "캘시 맨", actorA: "에이미 포엘러", actorB: "마야 호크", tickets: 1000, theaters: 2000, }); let newA = oldA.add({ title: "인사이드아웃2", year: 2024, director: "캘시 맨", actorA: "에이미 포엘러", actorB: "마야 호크", tickets: 1000, theaters: 2000, }); // oldA와 newA가 다른 인스턴스임을 확인 expect(newA).not.toBe(oldA); // 각각의 루트가 다른 인스턴스를 가리키는지 확인 expect(newA.getInfo() === oldA.getInfo()).toBe(false); }); test("해당 함수로 만들어진 객체가 메소드로 인해 함수 안의 값이(외부의 값) 변하지 않는가?", () =&gt; { let oldA = movieRank(); let newA = oldA.add({ title: "인사이드아웃2", year: 2024, director: "캘시 맨", actorA: "에이미 포엘러", actorB: "마야 호크", tickets: 1000, theaters: 2000, }); expect(newA.getInfo() === oldA.getInfo()).toBe(false); expect(oldA.getInfo().root).toBe(null); }); test("영화 추가 시 불변성 유지", () =&gt; { let oldA = movieRank(); oldA = oldA.add({ title: "인사이드아웃2", year: 2023, director: "캘시 맨", actorA: "에이미 포엘러", actorB: "마야 호크", tickets: 1000, theaters: 2000, }); const oldInfo = oldA.getInfo(); let newA = oldA.add({ title: "인사이드아웃3", year: 2024, director: "캘시 맨", actorA: "에이미 포엘러", actorB: "마야 호크", tickets: 1000, theaters: 2000, }); const newInfo = newA.getInfo(); expect(newA).not.toBe(oldA); expect(oldInfo).toEqual(oldA.getInfo()); expect(newInfo).not.toBe(oldInfo); expect(newA.getInfo().movieList).toContain("인사이드아웃3"); expect(oldA.getInfo().movieList).not.toContain("인사이드아웃3"); });
}); PASS ./movie.test.js 테스트 ✓ 생성된 클로저 비교 (1 ms) ✓ 같은 필드 값을 가진 인스턴스가 다른 참조값을 가지고 있는가? (1 ms) ✓ 같은 함수 내의 함수를 통해 새로운 값을 받았을 때 리턴받은 두 객체는 다른가? ✓ 해당 함수로 만들어진 객체가 메소드로 인해 함수 안의 값이(외부의 값) 변하지 않는가? ✓ 영화 추가 시 불변성 유지 (1 ms) Test Suites: 1 passed, 1 total
Tests: 5 passed, 5 total
Snapshots: 0 total
Time: 0.564 s, estimated 1 s
Ran all test suites.
]]></description><link>부스트캠프/챌린지/챌린지-day_8.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_8.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day_9]]></title><description><![CDATA[
Publisher-Subscriber 패턴과 싱글톤 패턴
동기와 비동기 작업 처리 방식 비교
비동기 함수 호출 과정
동기화 과정
멀티 스레드 방식과 스레드에서 비동기 병렬 처리 방식
특정 스레드에서 이벤트 루프를 만들어 각 이벤트를 전달하는 방식
비동기 작업을 동기화해서 기다리는 방식
비동기 작업을 그룹으로 묶어서 동기화하는 방식
노드 환경에서 이벤트 루프와 이벤트 처리(Event Emmiter) 방식
여러 Thread를 미리 만들어 Pool 형태로 관리하는 방식 EvenyManager 클래스 설계
SharedInstance 함수
Subscriber 데이터 구조와 표
Subscriber 클래스
Sender 클래스
remove 함수
postEvent 함수
stringify 함수
비동기 개선 ✅ 2024-07-26
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcn9k3Z%2FbtrdlzcOxCD%2F6ZM1wHB4YHF8KlVHP8z8i0%2Fimg.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">발행-구독 패턴은 Publisher가 Subscriber의 위치나 존재를 알 필요 없이 브로커에게 메시지를 던져놓기만 하면 되며 반대로 Subscriber 역시 브로커에 할당된 작업만 모니터링하다 작업하면 되므로 옵저버 패턴에 비해 결합도가 더 낮다. 또한 발행-구독 패턴은 브로커라는 중간 매개체가 있기 때문에 브로커에 직접 접근하여 처리할 수도 있다.<br><img src="https://lucas-image.codesquad.kr/1656053347325event-manager.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">EventManager 클래스는 싱글톤 패턴을 이용하여 공유하는 EventManager를 통해 Publisher가 EventManager에 갈 수 있는 경로를 마련한다고 생각했다.
SharedInstance라는 함수를 만들어 new 키워드를 통한 인스턴스를 생성했지만, 생성된 인스턴스가 있을 경우 기존의 인스턴스를 반환하는 방식으로 만들어 Publisher의 eventManager property에도 넣어주어 접근할 수 있게 하였다. class Publisher { constructor(name) { this.name = name; this.eventManager = sharedInstance(); }
...
}
class EventManager { static instance; constructor() { if (EventManager.instance) { return EventManager.instance; } this.subscriberInfos = []; // 구독자 목록 저장 배열 EventManager.instance = this; this.eventEmitter = new EventEmitter(); } ...
이렇게 Publisher가 직접적으로 공유하는 인스턴스를 통해 Publisher 자체의 property에서 EventManager로 갈 수 있게 해준 다음에 이벤트를 추가하는 메소드를 Publisher 안에서 만든 다음 EventMager로 전달해주어 생성되게끔 해주면서 다수의 이벤트가 있더라도 하나의 Publisher를 통해 만들 수 있는 방법을 고안했다. // subscriber 등록 (eventName, sender) add(subscriber, eventName, sender, handler) { const subscribeData = { subscriber: subscriber, eventName: eventName, sender: sender, handler: handler, }; if ( this.subscriberInfos.some((subInfo) =&gt; this.#checkValidity(subInfo, subscribeData) ) ) { return; } this.subscriberInfos.push(subscribeData); return; }
전체적으로 EventManager에서 존재하는 메소드들은 복잡한 로직으로 되어 있지 않다. 유효성(같은 이름의 이벤트 걸러주기)만 검사해준 뒤에 subscriberInfos라는 배열에 들어갈 수 있게끔 하고, 나중에 해당 배열에 대해서만 관리하면서 이벤트에 대해 처리할 수 있도록 해주었다.postEvent(eventName, sender, userInfo) { const newEvent = new Event(eventName, sender, userInfo); let result; this.subscriberInfos.forEach((subscriberInfo) =&gt; { if ( !subscriberInfo.eventName || (subscriberInfo.eventName === eventName &amp;&amp; subscriberInfo.sender.name === sender.name) || !subscriberInfo.sender ) { process.stdout.write(`${subscriberInfo.subscriber.name}: `); console.log( `${subscriberInfo.subscriber.name}: ${eventName} event from ${ sender.name } userData = ${JSON.stringify(userInfo)} ` ); result = subscriberInfo.handler(newEvent); } }); return result; }
postEvent 함수는 이미 추가시킨 이벤트에 대해서 실행시켜주는 메소드이다. 해당 메소드에서는 eventName, sender 인스턴스, userInfo 객체를 받는다. 그러면 받은 인수를 토대로 새로운 Event라는 인스턴스를 만들어주고, 이에 대해 핸들러 함수가 클로저로 실행될 수 있게끔 해주었다.이 때, 맨 처음에 eventName이 "" 빈 문자열로 되어 있으면 모든 이벤트를 실행시켜주어야 하고, Publisher의 이름이 undefined라면 모든 이벤트를 실행시켜 주어야 했다.
처음에는 이러한 배열을 만들기 전에 들어오는 값에 대해 검사를 하고, 빈 문자열의 경우와 undefined된 Publisher의 이름에 대해서 처리를 해주고 상황에 맞게 모든 이벤트들을 만들어낼까 생각을 했었는데, 이렇게 논리연산자와 고차함수의 이용을 통해서 이벤트를 실행시켜주는 편이 보다 메모리 절약이 되지 않았나 생각한다. remove(subscriber) { this.subscriberInfos = this.subscriberInfos.filter( (subscriberInfo) =&gt; subscriberInfo.subscriber !== subscriber ); }
remove함수는 filter 고차함수를 이용해 간단하게 비교하면서 걸러줄 수 있었다처음에는 stringify가 조건을 알려주는 함수라길래 무슨 말인가 했다.
어차피 이벤트를 실행하는 조건의 경우는 위에서 이벤트 실행 함수를 통해서 걸러주었기 때문에 어떤 subscriber에 어떤 event들이 들어가 있는지를 알려주는 함수정도라고 해석해싿. stringify() { this.subscriberInfos.forEach((subscriberInfo) =&gt; { console.log( `${subscriberInfo.subscriber.name} : event name = "${subscriberInfo.eventName}", sender = ${subscriberInfo.sender.name}` ); }); }
addSubscriber(subscriber, eventName, sender, handler) { const subscribeData = { subscriber: subscriber, eventName: eventName, sender: sender, handler: handler, }; if ( this.subscriberInfos.some((subInfo) =&gt; this.#checkValidity(subInfo, subscribeData) ) ) { return; } this.subscriberInfos.push(subscribeData); this.eventEmitter.on(eventName, (data) =&gt; this.postEvent(eventName, sender, data) ); return; } callEvent(eventName, data) { const result = this.eventEmitter.emit(eventName, data); if (!result) return { data: null, completed: false }; return { data: result, completed: true }; }
addSubscriber 함수는 조금 더 사용성이 좋도록 만들어진 함수이다. 기존 add 함수의 발전형이라고 생각하면 될 것 같다.
기존의 add와 마지막까지 거의 같은 구조를 지녔지만, 큰 차이점은 eventEmmiter의 유무이다. eventEmmiter를 사용하여 해당 이벤트에 대해서 실행할 수 있는 함수를 보다 간결하게 callEvent(이벤트 이름, 데이터)의 형태로 호출할 수 있도록 해주어 다른 정보들을 굳이 기재할 불편함을 감소시켰다.asyncPostEvent(eventName, sender, userInfo) { return new Promise((resolve, reject) =&gt; { const result = this.postEvent(eventName, sender, userInfo); console.log(result); if (!result) reject({ completed: false }); resolve(result); }); }
해당 함수는 postEvent와 같은 역할을 하지만 비동기 방식으로 구현된 함수이다.
차이점은 Promise를 사용했기 때문에 해당 메소드를 사용하기 위해서는 .then이나 async/await 키워드를 통해 동기 방식으로 바꿔준 후에 사용해야 한다.delayPostEvent(eventName, sender, userInfo, timeout) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(this.postEvent(eventName, sender, userInfo)); }, timeout); }); }
}
delayPostEvent는 비동기 방식으로 처리하는 postEvent 함수 버전에 시간지연까지 추가한 버전이다. setTimeout을 사용해 비동기적으로 함수를 호출하고, 해당하는 시간이 지나면 값을 resolve 시켜주었다.class Subscriber { constructor(name) { this.name = name; }
} module.exports = { Subscriber }; 휑~
굳이 인스턴스화시키지 말고 객체 형태로 만들어도 좋았을듯...?const { EventManager, sharedInstance } = require("./eventManager"); class Publisher { constructor(name) { this.name = name; this.eventManager = sharedInstance(); } postEventPub(eventName, userInfo) { return this.eventManager.postEvent(eventName, this, userInfo); } asyncPostEventPub(eventName, userInfo) { return this.eventManager.asyncPostEvent(eventName, this, userInfo); } delayPostEventPub(eventName, userInfo) { return this.eventManager.delayPostEvent(eventName, this, userInfo); }
} module.exports = { Publisher }; 얜 그나마 있는 편이다.
postEvent함수들에 대해서 먼저 Publisher의 메서드를 통해 실행하고 eventManager에 진입하여 해당하는 이벤트를 실행하는 방식으로 설계하였다.jest.setTimeout(30000);
const { EventManager } = require("./eventManager");
const { Publisher } = require("./publisher");
const { Subscriber } = require("./subscriber"); const eventManager = new EventManager();
const subscriber0 = new Subscriber("testSub0");
const publisher0 = new Publisher("testPub0"); describe("테스트", () =&gt; { test("eventManager 동일성 테스트", () =&gt; { const eventManagerA = new EventManager(); const eventManagerB = new EventManager(); expect(eventManagerA).toEqual(eventManagerB); }); test("Subscriber 등록 테스트", () =&gt; { eventManager.add(subscriber0, "test", publisher0, (newEvent) =&gt; { return "success"; }); expect(eventManager.subscriberInfos.length).toBe(1); }); test("Subscriber 중복 등록 테스트", () =&gt; { eventManager.add(subscriber0, "test", publisher0, () =&gt; { return "success"; }); expect(eventManager.subscriberInfos.length).toBe(1); }); test("postEvent 동작 테스트", () =&gt; { expect(publisher0.postEventPub("test", { content: "content" })).toBe( "success" ); }); test("remove 동작 테스트", () =&gt; { eventManager.remove(subscriber0); expect(eventManager.subscriberInfos.length).toBe(0); }); test("EventEmmiter 테스트", () =&gt; { eventEmitter.emit("addSub", "testSub0", "event", "testPub0", () =&gt; { console.log("test"); }); }); test("addSubscriber 테스트", () =&gt; { eventManager.addSubscriber(subscriber0, "emmiterTest", publisher0, () =&gt; { console.log("이벤트 등록 후 실행"); }); expect(eventManager.callEvent("emmiterTest", { data: "wwww" }).data).toBe( true ); }); test("asyncPostEvent 테스트", async () =&gt; { eventManager.add(subscriber0, "asyncPostEvent test", publisher0, () =&gt; { return "asyncPostEvent Test"; }); const result = await eventManager.asyncPostEvent( "asyncPostEvent test", publisher0, { data: "async test", } ); expect(result).toBe("asyncPostEvent Test"); }); test("delayPostEvent 테스트", async () =&gt; { eventManager.add(subscriber0, "delayPostEvent test", publisher0, () =&gt; { return "delayPostEvent Test"; }); const result = await eventManager.delayPostEvent( "delayPostEvent test", publisher0, { data: "delay test", }, 3000 ); console.log(result); expect(result).toBe("delayPostEvent Test"); }); test("비동기 동작 시나리오 테스트1", () =&gt; { const subscriberA = new Subscriber("subscriberA"); const albumModel = new Publisher("albumModel"); eventManager.addSubscriber( subscriberA, "ModelDataChanged", albumModel, (obj) =&gt; { return obj.eventName; } ); const result = eventManager.callEvent("ModelDataChanged", { data: "ModelDataChanged Event", }); expect(result.data).toBe(true); }); const testSub = new Subscriber("testSub"); test("비동기 동작 시나리오 테스트2(동기)", () =&gt; { console.log("222"); const albumTableView = new Publisher("albumTableView"); eventManager.add(testSub, "syncEvent", albumTableView, (obj) =&gt; { return obj.eventName; }); expect( eventManager.postEvent("syncEvent", albumTableView, { user: "user", }) ).toBe("syncEvent"); }); const albumTableViewController = new Publisher("albumTableViewController"); test("비동기 동작 시나리오 테스트 3(비동기)", async () =&gt; { eventManager.add(testSub, "asyncEvent", albumTableViewController, (obj) =&gt; { return obj.eventName; }); expect( await eventManager.asyncPostEvent( "asyncEvent", albumTableViewController, { user: "user", } ) ).toBe("asyncEvent"); }); test("비동기 동작 시나리오 테스트 4(지연 비동기)", async () =&gt; { console.log("444"); const dummySub = new Subscriber("dummySub"); const dummyPub = new Publisher("dummyPub"); eventManager.add(dummySub, "delayPostEvent", dummyPub, (obj) =&gt; { return obj.eventName; }); const result = await eventManager.delayPostEvent( "delayPostEvent", dummyPub, { data: "delayPostEvent", }, 10000 ); expect(result).toBe("delayPostEvent"); });
}); <br><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRD1as8cBCs00zqt00aasEmbd0uXtKMUwzJPw&amp;s" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
&gt;오늘의 꿀팁
Jest는 기본 최대 지연 시간이 5초까지로 설정되어 있다. 이를 늘리고 싶으면 코드의 최상단에 jest.timeOut(시간) 쓰면 된다<br><img src=".html" referrerpolicy="no-referrer" target="_self">
야호~<br><img src="https://pbs.twimg.com/media/FC6Wer8agAEB4c9.jpg:large" referrerpolicy="no-referrer" target="_self" class="is-unresolved">역시 누군가와 함께 한다는건 어렵지만 막상 함께 만든 결과물을 보니 너무 뿌듯하다.
역시 1+1=2이듯이 두뇌가 모이면 더 빨리, 좋은 결과물을 만드나보다
살면서 디자인패턴에 대해서 말만 들었지, 직접 공부하고 써볼 줄은 몰랐는데 내가 벌써 이런걸 공부할 때라니..]]></description><link>부스트캠프/챌린지/챌린지-day_9.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_9.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcn9k3Z%2FbtrdlzcOxCD%2F6ZM1wHB4YHF8KlVHP8z8i0%2Fimg.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcn9k3Z%2FbtrdlzcOxCD%2F6ZM1wHB4YHF8KlVHP8z8i0%2Fimg.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지 Day_1]]></title><description><![CDATA[<a data-href="챌린지 Day1_학습저장소용" href="부스트캠프/챌린지/챌린지-day1_학습저장소용.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day1_학습저장소용</a><br>
<a data-href="챌린지 Day1_학습정리용" href="부스트캠프/챌린지/챌린지-day1_학습정리용.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day1_학습정리용</a><br>
<a data-href="챌린지 Day1_문제" href="부스트캠프/챌린지/챌린지-day1_문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지 Day1_문제</a>]]></description><link>부스트캠프/챌린지/챌린지-day_1.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_1.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day_2]]></title><description><![CDATA[<a data-href="챌린지_Day2_학습저장소" href="부스트캠프/챌린지/챌린지_day2_학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지_Day2_학습저장소</a><br>
<a data-href="챌린지_Day2_학습정리" href="부스트캠프/챌린지/챌린지_day2_학습정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지_Day2_학습정리</a><br>
<a data-href="챌린지_Day2_문제" href="부스트캠프/챌린지/챌린지_day2_문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지_Day2_문제</a>\]]></description><link>부스트캠프/챌린지/챌린지-day_2.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_2.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day_3]]></title><description><![CDATA[<a data-href="챌린지_Day_3_문제" href="부스트캠프/챌린지/챌린지_day_3_문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지_Day_3_문제</a><br>
<a data-href="챌린지_Day_3_학습저장소" href="부스트캠프/챌린지/챌린지_day_3_학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지_Day_3_학습저장소</a><br>
<a data-href="챌린지_Day_3_학습정리" href="부스트캠프/챌린지/챌린지_day_3_학습정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">챌린지_Day_3_학습정리</a>]]></description><link>부스트캠프/챌린지/챌린지-day_3.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_3.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day_10]]></title><link>부스트캠프/챌린지/챌린지-day_10.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_10.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day_11]]></title><description><![CDATA[
분석 및 설계 ✅ 2024-07-29
EventQueue 클래스 설계 및 구현 ✅ 2024-07-29
EventManager 클래스 설계 및 구현 ✅ 2024-07-29
EventLoop 클래스 설계 및 구현 ✅ 2024-07-29
Post 클래스 설계 및 구현 ✅ 2024-07-29
PostMan 클래스 설계 및 구현 ✅ 2024-07-29
PostHub 클래스 설계 및 구현 ✅ 2024-07-29 분석 및 설계 ✅ 2024-07-29
EventQueue 클래스 설계 및 구현 ✅ 2024-07-29
EventManager 클래스 설계 및 구현 ✅ 2024-07-29
EventLoop 클래스 설계 및 구현 ✅ 2024-07-29
Post 클래스 설계 및 구현 ✅ 2024-07-29
PostMan 클래스 설계 및 구현 ✅ 2024-07-29
PostHub 클래스 설계 및 구현 ✅ 2024-07-29
입력 받기 ✅ 2024-07-30
배달원 스케줄링
<img src="https://i.imgur.com/9UGOMkr.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">우선 내가 생각하는 동작의 흐름은 이와 같다.
POS를 통해 택배 정보를 Event queue(POS 접수 대기 큐)에 enqueue한다.
POS 접수 대기 큐의 배송 목록은 배송 매니저가 주기적으로 큐를 확인한 뒤 만약 큐에 대기목록이 있다면 물류센터로 보냄
이벤트 루프는 주기적으로 돌면서 계속해서 물류센터에 전달된 물품 이벤트가 있는지 확인하고, 물류센터 큐의 분류 대기 상태가 될 때까지 기다렸다가 대기상태가 되면 물류센터 큐로 물류를 보낸다.
물류센터의 물류와 배송원의 상태를 boolean값으로 두고, 동작이 가능한 상태인지 확인하면서 동작이 가능할 경우 쌓여있던 이벤트를 하나씩 보냄
여기서 배달 기사나 물류센터 직원의 경우 한 번에 1개의 물품만 배달할 수 있는데, 1번의 경우에는 배달기사가 1명이라는 가정 하에 해야 하므로 기존 배달이 완료되기까지 대기한 후에 다음 배달을 출발해야 한다.이렇게 일단 설계를 하고 시작해보려 한다.const { EventQueue } = require("./eventQueue"); class POS { constructor() { this.eventQueue = new EventQueue(); } post(size, count) { this.eventQueue.enqueue(size, count); }
}
POS객체는 처음 주문을 받고 eventQueue로 해당 주문을 넘겨준다.const { Post } = require("./post");
const { PostManager } = require("./postManager"); class EventQueue { static instance; constructor() { if (EventQueue.instance) return EventQueue.instance; this.queue = []; this.postManager = new PostManager(this); EventQueue.instance = this; } enqueue(size, count) { for (let i = 0; i &lt; count; i++) { this.queue.push(new Post(size)); } this.postManager.postHub.fullpost += count; }
} module.exports = { EventQueue }; 이렇게 EventQueue 클래스의 enqueue 메소드를 통해서 해당 대기 배송 목록에 들어가게 되고, 이러한 대기 배송의 목록의 경우에는 PostManager클래스가 주기적으로 봐주면서 관리하게 된다.const { Runable } = require("./abstractClass");
const { EventQueue } = require("./eventQueue");
const { PostHub } = require("./postHub"); class PostManager extends Runable { constructor(eventQueue) { super(); this.eventQueue = eventQueue; this.postHub = new PostHub(this); this.run(); } run() { setInterval(() =&gt; { if (this.eventQueue.queue.length) { this.postHub.classifyQueue = this.postHub.classifyQueue.concat([ ...this.eventQueue.queue, "show", ]); this.eventQueue.queue = []; } }, 3000); }
} module.exports = { PostManager }; PostManager 클래스에서는 run() 메소드를 통해서 setInterval()을 실행시켜 주기적으로 목록을 보고 물류창고인 PostHub로 넘겨준다.const { Runable } = require("./abstractClass");
const { EventLoop } = require("./eventLoop");
const { Post } = require("./post");
const { Postman } = require("./postman"); class PostHub extends Runable { constructor(postManager) { super(); this.postMan = new Postman(); this.postManager = postManager; this.classifyQueue = []; this.isRunning = false; this.eventLoop = new EventLoop(this); this.fullpost = 0; } classify(post) { this.isRunning = true; console.log(`${post.size} 분류 시작`); setTimeout(() =&gt; { console.log(`${post.size} 분류 완료`); this.postMan.deliverList.push(post); this.isRunning = false; }, post.time); }
} module.exports = { PostHub }; 이렇게 만들어진 PostHub에서는 eventLoop 객체를 만들어 실행시키게 되는데, eventLoop문에서 classify를 실행시켜 분류를 해당 객체 내에서 진행하는 방식이다.
비동기 방식을 사용하기 위해 setTimeout을 통해서 물류에 해당하는 시간만큼, 후에 완료되도록 하고, 이러한 한 작업자의 상태는 boolean값으로 관리하여 해당 작업자의 상태를 보고 분류를 실행시킨다.const { Runable } = require("./abstractClass"); class EventLoop extends Runable { constructor(postHub) { super(); this.postHub = postHub; this.run(); } async run() { const running = setInterval(() =&gt; { if (!this.postHub.isRunning &amp;&amp; this.postHub.classifyQueue.length) { const post = this.postHub.classifyQueue.shift(); if (post === "show") this.showState(); else this.postHub.classify(post); } if ( !this.postHub.postMan.isRunning &amp;&amp; this.postHub.postMan.deliverList.length ) { const deliver = this.postHub.postMan.deliverList.shift(); this.postHub.postMan.deliver(deliver); } if (this.postHub.fullpost === this.postHub.postMan.delivered.length) { console.log("모든 배송이 완료되었습니다."); process.exit(); } }, 1000); } showState() { console.log( `대기중:${this.postHub.postManager.eventQueue.queue.join( "," )}/ 분류중: ${this.postHub.classifyQueue.join( "," )}/ 배송중:${this.postHub.postMan.deliverList .map((item) =&gt; item.size) .join(",")}/ 배송완료: ${this.postHub.postMan.delivered .map((item) =&gt; item.size) .join(",")}` ); }
} module.exports = { EventLoop };
EventLoop클래스에서도 주기적으로 setInterval을 통해서 주기적으로 물류 센터에 남아 있는 물류와 작업자의 상태를 보고 분류를 실행하고, 배송원의 경우에도 똑같은 방식으로 배송원의 상태와 배달 목록을 보고 배달을 처리해나갈 수 있도록 실행하는 조건문을 걸어주었다.
만약 현황이 안에 들어가있을 경우를 고려하여 showState라는 메서드를 해당 객체에 만들어주고, PostManager가 보낸 show라는 이벤트를 따로 구별하여 메서드를 실행할 수 있도록 해주었다.class Post { constructor(size) { [this.time, this.size] = this.#getSizeAndTime(size); } #getSizeAndTime(size) { let time; let sizeName; switch (size) { case 1: time = 3000; sizeName = "소형"; break; case 2: time = 7000; sizeName = "중형"; break; case 3: time = 15000; sizeName = "대형"; break; default: time = 0; sizeName = ""; break; } return [time, sizeName]; }
} module.exports = { Post }; Post 클래스의 경우 각 배송 물류에 대한 사이즈를 한글로 받아야 하기 때문에 객체로 만들어서 관리할 수 있도록 하였다.class EventQueue { static #instance; constructor() { if (EventQueue.#instance) return EventQueue.#instance; this.queue = []; this.eventLoop; } enqueue(size, count) { for (let i = 0; i &lt; count; i++) { this.queue.push(size); } } dequeue() {}
} module.exports = { EventQueue }; EventQueue는 evenloop와 종속관계에 있다. 이벤트 루프 또한 싱글 톤으로 구현하며 이를 EventQueue 내에서 eventloop의 메서드를 계속해서 실행시키며 무한루프를 구현하기 때문이다.<br><img src="https://i.imgur.com/v6BoPB3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
문제 2에서는 물류센터가 4개라고 가정하고 그 안의 배달원과 분류원을 유동적으로 조절할 수 있다.
또한 EventEmitter의 추가로 분류원/배송원/입력 등의 행위에서 각 이벤트를 내보내어 EventEmitter로 처리해야 하고, Promise의 사용으로 비동기를 지원할 수 있어야 한다.
따라서 이런 모양으로 설계해봤는데, 정답. 북두칠성!
이런 식의 비동계 설계는 처음이라 너무 골아프다<br>
<img src="https://i.imgur.com/I72L3UF.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
골아파서 고라파덕const { Runable } = require("./abstractClass");
const { emitter } = require("./eventEmitter"); class Postman { constructor(id, hub) { this.delivering = false; this.id = id; this.hub = hub; } deliver(post) { return new Promise((resolve, reject) =&gt; { emitter.emit("deliverStart", this, post); resolve( setTimeout(() =&gt; { emitter.emit("deliverFinish", this, post); }, 10000) ); }); }
} module.exports = { Postman }; 가장 크게 변한건 배송원과 분류원의 로직이다. 배송원/분류원의 경우 여러명이 있기 때문에 각 인원에 대해서 배열로 관리해야 할 필요성을 느꼈다.
또한 Promise를 사용하여 비동기 처리를 해야 했는데, 이제까지는 settimeout의 콜백에 resolve를 두고 한참 고민했는데 생각해보니 밖으로 뺀 다음에 해당 직원들의 상태를 공유할 수 있는 속성을 두고 따로 관리하면 됐다. 이러한 부분은 emitter를 통해 관리해주었다.const { emitter } = require("./eventEmitter"); class HubWorker { constructor(hub, id) { this.id = id; this.working = false; this.hub = hub; } classify(post1, post2) { let time = post1.time; if (post2) { time = post1.time &gt; post2.time ? post1.time : post2.time; } emitter.emit("classifyStart", this, post1, post2); return new Promise((resolve, reject) =&gt; { resolve( setTimeout(() =&gt; { emitter.emit("classified", this, post1, post2); }, time) ); }); }
} module.exports = { HubWorker }; 각 분류원도 인원마다 관리를 해주어야 했기 때문에 따로 클래스 객체를 만들어 관리할 수 있도록 해주었다. 여기서 특이한 점은 한 직원당 두 개의 택배를 관리할 수 있기 때문에 한개만 남았을 경우나 두 개의 택배가 들어올 경우를 조건문을 통해 따로 처리해주었다.const { Runable } = require("./abstractClass"); class EventLoop extends Runable { constructor(postHub) { super(); this.postHub = postHub; this.run(); } async run() { const running = setInterval(() =&gt; { this.#letsWorkHub(); this.#letsWorkPostman(); }, 1000); } #letsWorkHub() { while (this.postHub.classifyQueue.length) { let addedWork; if (this.postHub.classifyQueue.length &gt;= 2) { addedWork = this.postHub.classifyQueue.shift(); } const worker = this.#findHubWorker(); if (worker) worker.classify(this.postHub.classifyQueue.shift(), addedWork); else return; } } #letsWorkPostman() { while (this.postHub.postToDeliver.length) { const postman = this.#findPostMan(); if (postman) postman.deliver(this.postHub.postToDeliver.shift()); else return; } } #findHubWorker() { for (const worker of this.postHub.hubWorker) { if (!worker.working) return worker; } return false; } #findPostMan() { for (const worker of this.postHub.postMan) { if (!worker.delivering) return worker; } return false; } showState() {}
} module.exports = { EventLoop }; EventLooP는 기존과는 비슷한 방식으로 동작하지만, 여기서 추가된 점은 여러 명의 직원들이 있을 경우에 가능한 직원을 뽑아 해당하는 일을 맡겨야 했다. 이러한 부분을 고려해서 Property에 추가해놓은 상태 boolean 값을 활용하여 현재 일하고 있지 않은 직원을 찾아 해당 직원에게 일을 할당하도록 했다.const { emitter } = require("./eventEmitter");
const { EventLoop } = require("./eventLoop");
const { HubWorker } = require("./hubWorker");
const { Post } = require("./post");
const { Postman } = require("./postman"); class PostHub { constructor(postManager, hubWorker, postMen, id) { this.postMan = Array.from( { length: postMen }, (_, idx) =&gt; new Postman(idx, this) ); this.postToDeliver = []; this.postManager = postManager; this.hubWorker = Array.from( { length: hubWorker }, (_, idx) =&gt; new HubWorker(this, idx) ); this.classifyQueue = []; this.eventLoop = new EventLoop(this); this.id = id; }
} module.exports = { PostHub }; 기존에는 PostHub 클래스 안에 분류하는 메서드를 놓았지만, 이를 따로 Hubworker 클래스의 인스턴스들의 메서드로 들어가면서 해당 물류센터에서 필요한 메서드를 따로 필요없다고 생각하여 모조리 빼버렸다.const EventEmmiter = require("events");
class PostEventEmmiter extends EventEmmiter {} const emitter = new PostEventEmmiter();
emitter.on("recept", (postManager, count) =&gt; { postManager.sendToHub(); postManager.fullPosts += count;
}); emitter.on("classifyStart", (worker, post1, post2) =&gt; { console.log( `물류센터${worker.hub.id}의 작업자${worker.id}-${post1.sender}${post1.size} 분류시작` ); if (post2) console.log( `물류센터${worker.hub.id}의 작업자${worker.id}-${post2.sender}${post2.size} 분류시작` ); worker.working = true;
});
emitter.on("classified", (worker, post1, post2) =&gt; { console.log( `물류센터${worker.hub.id}의 작업자${worker.id}-${post1.sender}${post1.size} 분류종료` ); if (post2) console.log( `물류센터${worker.hub.id}의 작업자${worker.id}-${post2.sender}${post2.size} 분류종료` ); worker.hub.postToDeliver.push(post1); if (post2) worker.hub.postToDeliver.push(post2); worker.working = false;
}); emitter.on("deliverStart", (postMan, post) =&gt; { postMan.delivering = true; console.log( `물류센터${postMan.hub.id}의 배달기사${postMan.id}-고객${post.sender}${post.size}배달시작` );
});
emitter.on("deliverFinish", (postMan, post) =&gt; { postMan.delivering = false; console.log( `물류센터${postMan.hub.id}의 배달기사${postMan.id}-고객${post.sender}${post.size}배달완료` ); postMan.hub.postManager.delivered++; console.log( postMan.hub.postManager.delivered, postMan.hub.postManager.fullPosts ); if (postMan.hub.postManager.delivered === postMan.hub.postManager.fullPosts) { console.log("모든 물품이 배달되었습니다."); process.exit(); }
}); module.exports = { emitter }; EventEmitter의 경우에는 그냥 상속을 통해 기존 이벤트에미터를 상속받고, 내 인스턴스를 만든 다음 해당하는 이벤트를 모조리 한 곳에서 등록시켜주고 사용했다.
요구사항에 나와있는대로 각 작업이 시작하거나 끝날 때마다의 이벤트를 각각 등록해주어 해당하는 직원의활동 상태를 변경하거나 콘솔로 찍는 로직들로 이루어져 있다,.
나는 여기서 종료 조건을 걸었는데, EventEmitter가 배달이 완료됐을 때에서 이벤트를 발생시켜야 한대서 왜 그럴까 생각을 해봤는데 이제까지 배달한 횟수와 처음에 받았던 모든 택배들의 수를 따로 postManager에서 관리하여 준다면 종료 조건을 따로 만들 수 있기 때문이라고 생각했다. 이에 여기서 배달이 완료될 때마다 현황을 갱신하여 배달한 물품 개수와 총 개수가 같으면 프로그램을 종료하도록 했다.const { emitter } = require("./eventEmitter");
const { PostHub } = require("./postHub"); class PostManager { constructor(eventQueue, hubWorker, postMen) { this.eventQueue = eventQueue; this.postHub = Array.from( { length: 4 }, (_, idx) =&gt; new PostHub(this, hubWorker, postMen, idx) ); this.fullPosts = 0; this.delivered = 0; } sendToHub() { if (this.eventQueue.queue.length) { this.postHub.sort( (hub1, hub2) =&gt; hub1.classifyQueue.length - hub2.classifyQueue.length ); this.postHub[0].classifyQueue = this.postHub[0].classifyQueue.concat( this.eventQueue.queue ); this.eventQueue.queue = []; } }
} module.exports = { PostManager }; 기존 PostManager은 여기서 setInterval을 통해 주기적으로 큐에 있는 pos의 요청들을 가져왔다면, 여기서는 sendToHub라는 메소드로 바꿔 eventemitter를 통해서 실행시킬 수 있도록 하였다.<br><img src="https://i.imgur.com/D0bR74I.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/Hx1ugf9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/Day11-f2a66dd0e7ef45c8bea1e157e37a0998?pvs=4" target="_self">https://luxurious-share-af6.notion.site/Day11-f2a66dd0e7ef45c8bea1e157e37a0998?pvs=4</a>
자세한 것은 학습 메모를,,,
Runable 상속 빼기 ✅ 2024-07-30
Emitter를 클래스마다 상속 ✅ 2024-07-30
메서드가 아닌 이벤트를 전달하는 방식으로 리팩토링 ✅ 2024-07-30
배송원마다 전담하는 품목 설정 ✅ 2024-07-30
dashboard 클래스 만들어서 현황 관리 ✅ 2024-07-30
main split해서 받는 입력 부분 정규표현식으로 바꾸기
여러개 입력 받을 수 있도록 설정
입력한 후에 물류센터나 배송 처리 중에도 다시 입력을 받을 수 있게끔 설정 작업자가 여러개
POS 여러개 두기
배송기사가 여러개의 물품 배송하기 단위테스트 실행하기
테스트 보강하기 package-lock.json gitignore 처리 ✅ 2024-07-30
추상 클래스처럼 사용하기 위해 상속받았던 Runable을 삭제했다.
원래의 경우라면 run 메서드를 가진 클래스들에게 상속시켜 오버라이딩하는 방식의 객체지향 설계를 많이 보아서 따라하려했는데 예상과는 다르게 코드를 봐도 딱히 필요가 없어 보이는 추상클래스같아 삭제하게 되었다.const EventEmmiter = require("events");
class PostEventEmmiter extends EventEmmiter {} const emitter = new PostEventEmmiter();
emitter.on("recept", (postManager, count) =&gt; { postManager.sendToHub(); postManager.fullPosts += count;
}); emitter.on("classifyStart", (worker, post1, post2) =&gt; { console.log( `물류센터${worker.hub.id}의 작업자${worker.id}-${post1.sender}${post1.size} 분류시작` ); if (post2) console.log( `물류센터${worker.hub.id}의 작업자${worker.id}-${post2.sender}${post2.size} 분류시작` ); worker.working = true;
});
emitter.on("classified", (worker, post1, post2) =&gt; { console.log( `물류센터${worker.hub.id}의 작업자${worker.id}-${post1.sender}${post1.size} 분류종료` ); if (post2) console.log( `물류센터${worker.hub.id}의 작업자${worker.id}-${post2.sender}${post2.size} 분류종료` ); worker.hub.postToDeliver.push(post1); if (post2) worker.hub.postToDeliver.push(post2); worker.working = false;
}); emitter.on("deliverStart", (postMan, post) =&gt; { postMan.delivering = true; console.log( `물류센터${postMan.hub.id}의 배달기사${postMan.id}-고객${post.sender}${post.size}배달시작` );
});
emitter.on("deliverFinish", (postMan, post) =&gt; { postMan.delivering = false; console.log( `물류센터${postMan.hub.id}의 배달기사${postMan.id}-고객${post.sender}${post.size}배달완료` ); postMan.hub.postManager.delivered++; console.log( postMan.hub.postManager.delivered, postMan.hub.postManager.fullPosts ); if (postMan.hub.postManager.delivered === postMan.hub.postManager.fullPosts) { console.log("모든 물품이 배달되었습니다."); process.exit(); }
}); module.exports = { emitter };
기존 EventEmitter의 경우 하나의 emitter 인스턴스를 넣어놓고, 각 이벤트에 대한 콜백함수를 모두 안에 때려넣는 무식한 방식으로 코드를 작성했었다. 작성하고 보니 이벤트명 말고는 제대로 판단이 안 되는 이벤트들이 난무하여 이를 리팩토링하는 것이 우선이라고 생각했다.const { DashBoard } = require("./dashboard");
const { EventLoop } = require("./eventLoop");
const { HubWorker } = require("./hubWorker");
const { Postman } = require("./postman");
const EventEmitter = require("events"); class PostHub extends EventEmitter { constructor(postManager, hubWorker, postMen, id) { super(); this.postMan = Array.from( { length: postMen }, (_, idx) =&gt; new Postman(idx, this) ); this.postToDeliver = []; this.postManager = postManager; this.dashBoard = new DashBoard(); this.hubWorker = Array.from( { length: hubWorker }, (_, idx) =&gt; new HubWorker(this, idx) ); this.classifyQueue = []; this.eventLoop = new EventLoop(this); this.id = id; this.on("letsWork", this.letsWork); } letsWork() { while (this.classifyQueue.length) { const [work1, work2] = this.#findPostToClassify(); this.#findWorker().emit("letsClassify", work1, work2); } while (this.postToDeliver.length) { const postman = this.#findPostMan(this.postToDeliver[0].sizeNum); if (!postman) break; postman.emit("letsDeliver", this.postToDeliver.shift()); } } #findWorker() { return this.hubWorker.find((worker) =&gt; !worker.working); } #findPostMan(postSize) { const foundPostMan = this.postMan.find( (postman) =&gt; postman.id % 4 === postSize % 4 ); if (!foundPostMan) return this.postMan.find((postman) =&gt; !postman.delivering); return foundPostMan; } #findPostToClassify() { if (this.classifyQueue.length) { let work = this.classifyQueue.shift(); let addedWork; if (this.classifyQueue.length &gt;= 2) { addedWork = this.classifyQueue.shift(); } return [work, addedWork]; } }
} module.exports = { PostHub }; 가장 대표적인 물류센터 클래스를 보자.
EventEmitter를 상속해서 안에서 선언해주는 방식으로 리팩토링을 진행했고, 이러한 이벤트의 콜백함수는 메서드로 정의하여 보다 어떤 객체 안에서 어떤 이벤트를 다루는지에 대해서 명확해진 느낌을 받을 수 있었다.class EventLoop { constructor(postHub) { this.postHub = postHub; this.run(); } async run() { const running = setInterval(() =&gt; { this.postHub.emit("letsWork"); }, 1000); }
} module.exports = { EventLoop };
물류센터 클래스에서 선언한 이벤트를 활요앟기 위해 이벤트루프의 구조를 대폭 변경했다. 이제는 setInterval을 통해 주기적으로 배송과 분류 업무를 하도록 하는 이벤트를 발송하고, 해당 이벤트는 상위 객체인 물류센터 객체에서 메서드를 실행함으로써 보다 데이터의 제어 흐름을 용이하게 파악할 수 있었다. letsWork() { while (this.classifyQueue.length) { const [work1, work2] = this.#findPostToClassify(); this.#findWorker().emit("letsClassify", work1, work2); } while (this.postToDeliver.length) { const postman = this.#findPostMan(this.postToDeliver[0].sizeNum); if (!postman) break; postman.emit("letsDeliver", this.postToDeliver.shift()); } } #findWorker() { return this.hubWorker.find((worker) =&gt; !worker.working); } #findPostMan(postSize) { const foundPostMan = this.postMan.find( (postman) =&gt; postman.id % 4 === postSize % 4 ); if (!foundPostMan) return this.postMan.find((postman) =&gt; !postman.delivering); return foundPostMan; }
너무 구현하고 싶었던 배송원마다 전담하는 품목 또한 리팩토링을 통해 함께 구현해주었다.
처음에는 배송원마다 전담하는 품목을 어떻게 하면 관리할 수 있지?를 생각하다가 각 배송원에게 id값으로 처음에 배열에 넣어줄 때 인덱스값을 넣어준 것이 생각났다.이를 활용해서 1~4까지 있는 사이즈에서 하나를 전담으로 선택했어야 했는데, 4로 나눈 나머지를 생각해보면 인덱스값이 아무리 늘어나도 0~3까지만 있을 것이고, 사이즈의 경우도 0~3만을 왔다갔다 할 것이다.이를 활용하여 find 고차함수를 활용해서 전담하는 사이즈의 배송원에게 보다 우선적으로 배정해주려 하였으며, 추가적으로 만약 전담하는 배송원이 없다 하더라도 남아서 쉬고 있는 배송원에게 후순위로 배정해주려고 이러한 방식으로 스케줄링을 설계했다.const EventEmitter = require("events");
class DashBoard extends EventEmitter { static instance; constructor() { super(); if (DashBoard.instance) return DashBoard.instance; this.isPending = []; this.isClassifing = []; this.isWaitingDeliver = []; this.isDelivering = []; this.isDelivered = []; DashBoard.instance = this; this.on("addPending", this.addPending); this.on("addClassifying", this.addClassifying); this.on("addWaiting", this.addWaitingDeliver); this.on("addDelivering", this.addDelivering); this.on("addDelivered", this.addDelivered); } stringify(postArr) { return postArr .map((post) =&gt; `${post.sender}님의 ${post.size}물품`) .join(","); } showState() { console.log("----------------------------------"); console.log( `분류대기-${this.stringify(this.isPending)}\n분류중-${this.stringify( this.isClassifing )}\n배달대기-${this.stringify( this.isWaitingDeliver )}\n배달중-${this.stringify( this.isDelivering )}\n배달완료-${this.stringify(this.isDelivered)}/` ); console.log("----------------------------------"); } addPending(post) { this.isPending.push(post); this.showState(); } deletePending(targetPost) { this.isPending = this.isPending.filter((post) =&gt; post != targetPost); } addClassifying(post) { this.deletePending(post); this.isClassifing.push(post); this.showState(); } deleteClassifying(targetPost) { this.isClassifing = this.isClassifing.filter((post) =&gt; post !== targetPost); } addWaitingDeliver(post) { this.deleteClassifying(post); this.isWaitingDeliver.push(post); this.showState(); } deleteWaiting(targetPost) { this.isWaitingDeliver = this.isWaitingDeliver.filter( (post) =&gt; post !== targetPost ); } addDelivering(post) { this.deleteWaiting(post); this.isDelivering.push(post); this.showState(); } addDelivered(targetPost) { this.isDelivering = this.isDelivering.filter((post) =&gt; post !== targetPost); this.isDelivered.push(targetPost); this.showState(); }
} module.exports = { DashBoard }; 막상 전에 다 만들고 보니 현황 만들어야 하는걸 깜빡했었다.
이 또한 그렇게 어려운 것은 아니니 새롭게 만들어주었다.dashboard 클래스 또한 EventEmitter를 상속해서 해당 클래스 객체 안에서 이벤트를 선언해주고, 다른 곳에서는 이 클래스에 진입하여 이벤트를 실행함으로써 각 Post객체에 대하여 분류대기,분류중,배달대기,배달중,배달완료 상태를 업데이트할 수 있게 해주고, 나중에는 이러한 배열을 활용해서 현황을 표시해야 하기 떄문에 stringify라는 메서드를 만들어주어 문자열로 출력할 수 있도록 해주었다.이러한 dashBoard의 경우 싱글톤 패턴을 사용하여 어떤 객체에 있든지 같은 인스턴스를 공유함으로써 여러 개의 물류센터가 나눠지는 경우에도 각 배송원, 물류원 등이 활동할 때마다 이벤트를 실행시켜 같은 인스턴스의 현황을 최신화하도록 해주었다.]]></description><link>부스트캠프/챌린지/챌린지-day_11.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_11.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/9UGOMkr.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/9UGOMkr.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지 Day_13]]></title><description><![CDATA[
init 명령어
파일별로 blob 오브젝트를 생성한다.
해시값 앞에 8자리를 objects 하위 디렉토리로 생성한다.
나머지 부분을 파일명으로 (위에서 만든 해시값 앞자리 디렉토리에) 저장한다.
blob 오브젝트 파일 내용은 원본 파일을 zlib로 압축해서 저장한다. add 명령어
디렉토리에서 전체 파일 목록을 탐색하고, 각 파일 내용에 대한 sha256 해시 값을 비교한다.
commit이 없거나 직전 commit 이후 해시값이 달라진 파일 목록을 저장한다 status 명령어
add 명령으로 만들어진 변경된 파일 목록을 전체 경로와 함께 출력한다 commit 명령어
blob 오브젝트 생성
tree 오브젝트 생성
commit 오브젝트 생성
커밋 기록을 index에 추가한다. log 명령어
명령 형식은 mit log 디렉토리명 이다.
디렉토리명/.mit/index/commits 에서 커밋을 찾아서 이력을 출력한다. commit 마다 현재 tree를 확인해서 변경된 파일명을 함께 표시한다
restore 명령어
<img src="https://i.imgur.com/ZuyzvJT.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">mit init 디렉토리명 .mit 하위 디렉토리 생성 .mit 디렉토리 아래에 /.mit/objects/와 /.mit/index/ 하위 디렉토리를 생성 mit add 디렉토리명 - 디렉토리에서 전체 파일 목록을 탐색하고, 각 파일 내용에 대한 sha256 해시 값을 비교한다. - commit이 없거나 직전 commit 이후 해시값이 달라진 파일 목록을 저장한다 디렉토리에서 전체 파일 목록 살펴보기 파일을 돌면서 디렉토리가 나오면 재귀적으로 돌고, 파일명만 반복해서 으면서 commit이 없거나 직전 commit 이후 해시값이 달라진 파일 목록을 .mit/index/ 에 변경된 값을 저장 (저장 형식 - 파일 해시값 / 파일 상대 경로)예시bc2db54bb59cfb6d25308054726bc209a126f668 somethingNew/test.txt6b584e8ece562ebffc15d38808cd6b98fc3d97ea test.txt📁 디렉토리 추가된 파일(test.txt) objects index 예시: 디렉토리에 생성 test.txt ('create text')파일 예시 해시값 - 2e65efe2a145dda7ee51d1741299f848e5bf752e
git대로 생각했을 때 1. mit add 디렉토리명 2. 디렉토리명 안의 디렉토리 혹은 파일을 돈다 - 파일일 경우 -&gt; 파일에 대해 blob 파일을 만들고, 하나의 트리에 기록 - 디렉토리일 경우 -&gt; 재귀적으로 디렉토리명 안의 디렉토리 혹은 파일을 돌면서 모든 파일을 만들고, 이를 하나의 트리에 넣은 다음 그 트리의 해시값을 상위 트리에 기록 3. 해당 모든 정보들을 가진 최상위 트리(루트 트리) 개체를 하나 만들어 object 내에 저장 4. .mit/index 안에 파일을 하나 두고 여기에서 commit 개체의 tree 속성에다가 집어넣기 5. 나중에 commit이 되기 전까지 add를 하면 그게 계속 갱신됨 6. 나중에 commit을 하면 commit message와 함께 새롭게 commit 개체를 .mit/index/commits에 저장 -a -b -c -d -e -f 이런 식으로 디렉토리가 되어 있다고 가정하면 a(루트) b(파일해시값) c(tree) c -&gt; d, e(tree) e -&gt; f - .git/objects 파일 내부 .git/objects .git/objects/.DS_Store .git/objects/d0 .git/objects/d0/5bdf0ee8f1f50e60cc2244a322d58cdd0ef873 .git/objects/bc .git/objects/bc/2db54bb59cfb6d25308054726bc209a126f668 .git/objects/pack .git/objects/6b .git/objects/6b/584e8ece562ebffc15d38808cd6b98fc3d97ea .git/objects/info - index 파일 내부 (git add 명령어 실행 후 생성됨) 100644 d05bdf0ee8f1f50e60cc2244a322d58cdd0ef873 0 .DS_Store 100644 bc2db54bb59cfb6d25308054726bc209a126f668 0 somethingNew/test.txt 100644 6b584e8ece562ebffc15d38808cd6b98fc3d97ea 0 test.txt test 폴더 파일 파일 mit add 디렉토명 디렉토리 내의 파일들을 objects/2e/65... 등으로 만들어 저장 파일들을 모두 가리키는 tree를 objects 폴더에 저장 해당 트리의 해시값을 index에 저장 트리를 만든 후, 해당 트리의 해시값을 Index에 저장 논의했던 사안들 - 파일들을 모두 objects 폴더 안에 저장하고, 변동사항등을 비교한 뒤에 Index 디렉토리 안의 파일에 이러한 파일들에 대한 해시값들을 모두 기록 mit status 디렉토리명 index에 저장된 변경 파일 목록 중에서 디렉토리 명을 포함하는 파일들 모두 출력 mit commit 디렉토리명 주어진 디렉토리가 최상위 디렉토리로 되어 있을 때, 해당 디렉토리 안의 폴더들에 대해서 모두 blob 오브젝트를 생성 object 해시값 앞의 8자리를 하위 디렉토리로 생성하고, 나머지 부분을 파일명으로 저장 파일 내용은 zlib으로 압축해서 저장 파일을 저장하면서 tree 오브젝트에 저장된 모든 파일들을 기록 오브젝트는 blob마다 blob 해시값, 압축 후 파일 크기, 파일명을 전부 받고, 이를 다시 파일로 tree object 파일로 저장(SHA256) .mit/index/commits를 보고 커밋이 있으면 가장 최신의 커밋을 가져옴 가져온 커밋을 새로 만드는 commit object의 이전 트리를 가져와 넣고, 현재 트리도 넣고 .mit/objects에 blob과 동일한 형태로 파일명을 저장 해당 커밋의 해시값을 .mit/index/commits에 기록한다 mit log 디렉토리명 - 디렉토리명/.mit/index/commits 에서 커밋을 찾아서 이력을 출력한다. - commit 마다 현재 tree를 확인해서 변경된 파일명을 함께 표시한다. 1 commit (커밋 오브젝트) 0 | 1 tree hash(현재) 1 tree hash의 정보를 보여준다. (파일명, 파일 해시값) test.txt 변경했습니다. 2 commit 1 tree hash | 2 tree hash 2 tree hash의 정보를 보여준다. test1.txt 변경했습니다. index의 각 커밋 기록에 남아있는 현재 tree 해시값으로 가서 변경 내역들을 모두 출력 mit resotore 디렉토리명 {8자리|64자리 커밋해시값} - 특정한 커밋 해시값을 입력하면, 최신 커밋부터 차례대로 커밋 파일의 tree에 포함된 blob 내용을 꺼내서 파일을 복원한다. - 커밋 해시값은 앞 8자리만 입력하는 경우에도 해당 object 디렉토리에 커밋 파일이 1개만 있는 경우 그 커밋을 복원한다. - 단계별로 커밋은 index/commits 파일에서 삭제하고, 입력한 커밋해시값을 가진 커밋 정보까지만 남겨놓는다. - 복원 과정에서 필요없는 commit, tree, blob 오브젝트는 삭제하지 않는다. 8자리 폴더로 이동 -&gt; 64-8=56자리 커밋 파일 보기 해당 파일의 tree에 포함된 blob 내용을 꺼내 파일 복원 입력한 커밋해시값을 가진 커밋 정보까지 반복<br><img src="https://i.imgur.com/0HX9McR.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">init, add, commit, log까지는 모두 정상 동작함을 확인할 수 있었다.
파일 관련 클래스 만들어 정적 메서드로 관리하기 ✅ 2024-08-01
공통적으로 쓰이는 file 경로 변수 할당하여 재사용 ✅ 2024-08-01
예외처리 ✅ 2024-08-01
restore 구현하기 ✅ 2024-08-01
commit log 제대로 파일을 저장하지 않았던 문제 수정 ✅ 2024-08-01
이번 리팩토링은 구현하지 못했던 기능과 더불어 매우 만족스러웠던 결과를 가져왔다.<br>
<img src="https://i.imgur.com/gV55Tlv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
기존에 '너무 지저분한데?' 라고 생각할 만큼 난잡한 코드라서 문제가 하나 터지면 어디서 문제가 터지는지 알아내는 데만 한세월이 걸렸는데 이제는 그나마 읽을 수라도 있는 코드가 되었다.const { existsSync, mkdirSync, writeFileSync, readFileSync } = require("fs");
const { deflateSync } = require("zlib");
const cryptoJs = require("crypto-js");
const zlib = require("zlib"); class FileManager { static dirExceptionHandler(dir, hash) { if (!existsSync(`./${dir}/.mit/objects/${hash.slice(0, 8)}`)) { mkdirSync(`./${dir}/.mit/objects/${hash.slice(0, 8)}`, () =&gt; {}); } } static async jsonFileDeflate(file) { const hash = cryptoJs.SHA256(file).toString(); const blob = new Blob([JSON.stringify(file, null, 2)], { type: "application/json", }); const converted = await blob.arrayBuffer(); const deflatedFile = deflateSync(converted); return { hash, deflatedFile }; } static writeFile(dir, hash, deflatedFile) { const filePath = `./${dir}/.mit/objects/${hash.slice(0, 8)}/${hash.slice( 8 )}`; writeFileSync(filePath, deflatedFile); } static jsonFileInflate(dir, hash) { let file = readFileSync( `./${dir}/.mit/objects/${hash.slice(0, 8)}/${hash.slice(8)}` ); file = zlib.inflateSync(file).toString("utf-8"); return JSON.parse(file); }
} module.exports = { FileManager }; 기존 코드의 경우, 파일을 읽어올 때는 매 해시값을 통해 파일에 진입-&gt; zlib 압축을 해제 -&gt; JSON Parsing -&gt; 각 데이터 처리 와 같은 일련의 과정이 공통적으로 수반되었고, add와 같은 함수의 경우 SHA256 해싱 -&gt; JSON stringify -&gt; Blob객체화 -&gt; zlib 압축과 같은 복잡한 과정이 계속해서 수반되어야만 했다. 그러다보니 모든 함수들에 대부분 이러한 로직이 공통적으로 들어가게 되었고, 결국 blob, commit, tree object와 commit blob 파일을 계속해서 갱신해줘야 하는 commit 함수와 그에 맞는 기능적인 함수들이 모두 가독성이 매우 떨어질 정도로 코드가 길고 난잡했다. 어제 코드를 짜면서도 계속 생각하고 있었지만, 구현에 급급해서 하다보니 리팩토링까지 미뤘었다.
이번 리팩토링에선 FileManager라는 클래스를 두고, 해당 클래스의 인스턴스를 굳이 만들어서 사용하는 것이 아닌, 기능적으로 비슷한 과정들을 거치는 파일 압축과 해제와 관련된 파일 관련 정적 메서드들을 모두 넣어두어 필요할 때마다 해당 정적 메서드만 가져와서 쓰는 방식으로 설계하여 기존 코드를 개선했다.async function commit(directory) { const currentTreeHash = await treeCommit(directory); const prevCommitHash = getLastCommit(directory); const time = new Date(); const commitData = `${prevCommitHash} ${currentTreeHash}\n${time}`; const hash = cryptoJs.SHA256(commitData).toString(); const blob = new Blob([JSON.stringify(commitData, null, 2)], { type: "application/json", }); const converted = await blob.arrayBuffer(); const compressed = zlib.deflateSync(converted); const filePath = `./${directory}/.mit/objects/${hash.slice(0, 8)}`; if (!fs.existsSync(filePath)) { fs.mkdirSync(filePath, () =&gt; { console.log("만들어짐"); }); } // commit object fs.writeFileSync(`./${filePath}/${hash.slice(8)}`, compressed); commitUpdate(directory, hash); status(directory); await garbageCollect(directory);
}
당장 commit 안에 있는 함수들만 하더라도 각각의 함수가 해당 커밋 함수 안의 로직을 대부분 공통적으로 사용하고 있었다.async function commit(directory) { //현재 변경사항에 대해서 blob 파일을 만들어 저장하고, Tree Object를 만들어 트리의 해시값을 반환 const currentTreeHash = await treeCommit(directory); //직전 커밋 해시값을 가져옴(commit object의 가장 최근 해시값) const prevCommitHash = getLastCommit(directory); const time = new Date(); //갱신할 커밋 데이터(commit Object용) const commitData = `${prevCommitHash} ${currentTreeHash}\n${time}`; const { hash, deflatedFile } = await FileManager.jsonFileDeflate(commitData); // 해당 폴더 없으면 만들어주기 FileManager.dirExceptionHandler(directory, hash); // commit object 저장 FileManager.writeFile(directory, hash, deflatedFile); //.mit/index/commits에 있는 가장 최근값 최신화 commitUpdate(directory, hash); status(directory); await garbageCollect(directory);
}
하지만 현재는 폴더 생성 및 파일 생성, 해제 등의 기능을 가진 FileManager의 정적 메서드를 활용하여 해당 메서드가 무슨 역할을 하는지에 대해서 보다 가독성이 좋아졌으며, 코드의 길이도 비교적 줄어들어 개선되었다고 생각한다. !fs.existsSync(`./${dir}/.mit/objects/${hash.slice(0, 8)}/${hash.slice(8)}`) )
리팩토링 전에는 경로를 확실하게 보기 위해 모든 로직에 이러한 방식으로 하드코딩 해가면서 경로를 각각 넣어줬는데, 리팩토링 과정에서 이러한 공통적으로 쓰이는 경로의 문자열 등을 하나의 변수에 할당하여 재활용하는 방식으로 개선하였다.async function commitUpdate(dir, currCommitHash) { const path = `./${dir}/.mit/index/commits`; if (!fs.existsSync(path)) { const { deflatedFile } = await FileManager.jsonFileDeflate(currCommitHash); fs.writeFileSync(path, deflatedFile); return; } const file = fs.readFileSync(path); // .mit/index/commits의 커밋 해시값은 한 줄씩 기록 let commits = currCommitHash + "\n" + JSON.parse(zlib.inflateSync(file).toString("utf-8")); const { deflatedFile } = await FileManager.jsonFileDeflate(commits); fs.writeFileSync(path, deflatedFile);
}
특별히 index/commits에 들어가는 경우는 거의 없기 때문에 따로 메서드를 만들지 않고, objects 디렉토리 안에 들어가는 것들만 넣어주었으며 이러한 경우 path 변수를 사용하여 보다 코드의 가독성을 개선하였다.// 저장한 커밋 로그에서 변동사항 파일만 받아 저장시키고 Tree Object에 필요한 변동사항 배열 넘김
async function blobCommit(dir) { const data = readChanged(dir); let commitData = []; for (const blob of data) { const { hash, path, fileName, status } = blob; if (status !== "삭제됨") { const file = fs.readFileSync(path).toString(); const { hash, deflatedFile } = await FileManager.jsonFileDeflate(file); FileManager.dirExceptionHandler(dir, hash); FileManager.writeFile(dir, hash, deflatedFile); const fileSize = fs.statSync(path).size; commitData.push(`+ ${hash} ${fileSize} ${path} ${status}`); } else { commitData.push(`- ${hash} ${path} ${status}`); } } return commitData;
}
blob들에 대해서 각각 commit을 할 때 데이터에 넣어주는 과정에서 삭제의 경우만 따로 예외처리를 하면서 해당 파일을 읽어들이는 것이 아닌, 이전의 해시값을 가져와 넣어주어 나중에 복원할 때 해당 커밋들의 로그에서 해시값을 찾아내어 복원하는 방식으로 하면서 기존의 해시값을 갱신하는 경우에 예외처리를 시켜주었다.
또한 추가, 갱신, 수정의 경우 +로, 수정의 경우는 따로 -로 구분하여 보여줌으로써 사용자의 입장에서 보다 보기 좋은 커밋 로그를 볼 수 있도록 하였다.const { readFileSync, writeFileSync, existsSync } = require("fs");
const zlib = require("zlib");
const { FileManager } = require("./fileManager"); async function restore(dir, hash) { const commitHashLogs = await getcommitHashLogs(dir); // 유효성 검증을 통해 먼저 해시값에 해당하는 로그가 있는지 검사 const index = checkValidity(commitHashLogs, hash); for (let i = 0; i &lt; index; i++) { // 각 커밋의 최신 반영사항 가져오기 const treeObj = getHashObj(dir, commitHashLogs[i]); rollBack(dir, treeObj); } await updateCommitHash(dir, commitHashLogs.slice(index - 1));
} async function getcommitHashLogs(dir) { const path = `./${dir}/.mit/index/commits`; if (!existsSync(path)) throw new Error("커밋 내역이 없습니다."); const file = readFileSync(path); const commitHashLogs = JSON.parse( zlib.inflateSync(file).toString("utf-8") ).split("\n"); return commitHashLogs;
} function checkValidity(hashlogs, hash) { const index = hashlogs.findIndex((log) =&gt; log === hash); if (index === -1) throw new Error("해당 해시값에 일치하는 커밋 해시값이 없습니다."); return index;
} function getHashObj(dir, hash) { const hashObj = FileManager.jsonFileInflate(dir, hash); const treeObj = hashObj.split("\n")[0].split(" ")[1]; return treeObj;
} function rollBack(dir, hash) { let blobs = FileManager.jsonFileInflate(dir, hash); if (blobs.includes("\n")) blobs = blobs.split("\n"); if (Array.isArray(blobs)) { blobs.forEach((blob) =&gt; { if (blob[0] === "-") { const blobHashToRollBack = blob.split(" ")[1]; const path = blob.split(" ")[2]; const content = FileManager.jsonFileInflate(dir, blobHashToRollBack); writeFileSync(path, content); } }); } else { if (blobs[0] === "-") { const blobHashToRollBack = blobs.split(" ")[1]; const path = blobs.split(" ")[2]; const content = FileManager.jsonFileInflate(dir, blobHashToRollBack); writeFileSync(path, content); } }
} async function updateCommitHash(dir, hashlogs) { const path = `./${dir}/.mit/index/commits`; if (typeof hashlogs !== "object") { hashlogs = hashlogs.join("\n"); } const { deflatedFile } = await FileManager.jsonFileDeflate(hashlogs); writeFileSync(path, deflatedFile); console.log( "복원이 완료되었습니다.\n 해당 커밋 이후의 커밋들은 모두 사라집니다." );
}
/** * 1. 커밋 해시값을 입력 받아서 .mit/index/commits에서 해시값 존재 여부 판단 * 2. 이전 트리, 현재 트리가 있는데 각각 루프 * 3. 트리로 가서 blob 해시값과 파일 이름을 뽑아내고, 그걸 다시 압축해제하여 writeSync */ module.exports = { restore }; restore의 경우 구현하고 싶었지만 최소한이라도 조금 잔 다음에 해야 할 것 같아 아쉽게도 구현하지 못했던 기능이었다.
해당 기능의 경우
해당 커밋 해시값을 스택에서 인덱스 찾기 만약 커밋 해시값이 없다면 예외처리 인덱스를 받고 해당 인덱스 값 이전까지 모든 해시값에 대하여 해시 개체에 접근
해시 개체에서 오른쪽에 있는 최근 commit의 트리 해시값에 접근
최근 트리 해시값에 접근하여 각 커밋 수정사항 뽑아오기
삭제의 경우만 뽑아내어 복원 복원의 경우 줄마다 나와있는 해시값을 통해 objects 폴더의 해시값 위치에 접근하여 파일을 읽고 다시 쓰는 형태 모두 복원한 후에는 해당 해시값 까지 위에 쌓여있는 모든 해시값 제거
의 과정을 거쳐 restore을 구현해내었다.<br>
<img src="https://i.imgur.com/zwGrhg6.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
해당 화면은 테스트 화면인데, delete.txt라는 파일을 지우고 커밋한 다음에 다시 이전 커밋으로 restore시켜줌으로써 다시 delete값을 가져오는 것을 확인하였다.static async jsonFileDeflate(file) { const hash = cryptoJs.SHA256(file).toString(); const blob = new Blob([JSON.stringify(file, null, 2)], { type: "application/json", }); const converted = await blob.arrayBuffer(); const deflatedFile = deflateSync(converted); return { hash, deflatedFile }; }
...
async function blobCommit(dir) { const data = readChanged(dir); let commitData = []; for (const blob of data) { const { hash, path, fileName, status } = blob; if (status !== "삭제됨") { const file = fs.readFileSync(path).toString(); const { hash, deflatedFile } = await FileManager.jsonFileDeflate(file); FileManager.dirExceptionHandler(dir, hash); FileManager.writeFile(dir, hash, deflatedFile); const fileSize = fs.statSync(path).size; commitData.push(`+ ${hash} ${fileSize} ${path} ${status}`); } else { commitData.push(`- ${hash} ${path} ${status}`); } } return commitData;
}
기존에는 각각의 blob파일에 대해서 저장하고 해시값을 저장하는 과정에서 똑같은 해시값이 반복해서 나오는 버그가 있었다.
여기서 자꾸 막히길래 hash 스코프를 따라가다보니 data에서 가져오는 hash와 FileManager의 jsonFileDeflate에서 가져오는 hash가 있었는데, data의 경우는 딱히 변동이 없음을 확인했지만 jsonFileDeflate를 거쳐 나오는 해시값의 경우 똑같이 나오게 되는 오류가 있었다.
하나하나 뜯어가면서 보니 이 문제는 해시객체의 참조에 관한 문제였다. crypto-js라이브러리를 통해 해시값을 생성할 때, 생성되는 SHA256 객체는 문자열로 변환하지 않는 이상 해시 객체 자체를 가리키기 때문에 모두가 같은 객체를 가리키는 문제가 발생했던 것이다.
이에 SHA256을 통해 만들어지는 객체에 toString을 통해 문자열로 변환해주었고, 이후에 로그를 다시 확인해보니 정상적으로 작동된 것을 확인했다.git의 내부구조<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://bigexecution.tistory.com/171" target="_self">https://bigexecution.tistory.com/171</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://tecoble.techcourse.co.kr/post/2021-07-08-dot-git/" target="_self">https://tecoble.techcourse.co.kr/post/2021-07-08-dot-git/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://80000coding.oopy.io/7267f19f-5359-4799-a740-5d0f316fb589" target="_self">https://80000coding.oopy.io/7267f19f-5359-4799-a740-5d0f316fb589</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://storycompiler.tistory.com/7" target="_self">https://storycompiler.tistory.com/7</a>commander 라이브러리<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/Jeontaeyun/TypeScript/blob/master/node.js-or/cli/README.md" target="_self">https://github.com/Jeontaeyun/TypeScript/blob/master/node.js-or/cli/README.md</a>Blob 객체<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@minh0518/Blob%EA%B0%9D%EC%B2%B4%EB%9E%80" target="_self">https://velog.io/@minh0518/Blob%EA%B0%9D%EC%B2%B4%EB%9E%80</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/API/Blob" target="_self">https://developer.mozilla.org/ko/docs/Web/API/Blob</a>SHA256<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@ham3798/SHA-256-%ED%95%B4%EC%8B%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC" target="_self">https://velog.io/@ham3798/SHA-256-%ED%95%B4%EC%8B%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://losskatsu.github.io/blockchain/sha256/" target="_self">https://losskatsu.github.io/blockchain/sha256/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://devje.tistory.com/181" target="_self">https://devje.tistory.com/181</a>]]></description><link>부스트캠프/챌린지/챌린지-day_13.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_13.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/ZuyzvJT.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/ZuyzvJT.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지 Day_16]]></title><description><![CDATA[
설계 - 기본 인터페이스 ✅ 2024-08-05
설계 - create ✅ 2024-08-05
설계 - insert ✅ 2024-08-05
설계 - delete ✅ 2024-08-05
설계 - update ✅ 2024-08-05
설계 - select ✅ 2024-08-05
설계 - drop ✅ 2024-08-05 기본 인터페이스 ✅ 2024-08-06
create ✅ 2024-08-06
insert ✅ 2024-08-06
delete ✅ 2024-08-06
update ✅ 2024-08-06
select ✅ 2024-08-06
drop ✅ 2024-08-06
해당 학습목표는 데이터베이스 관리 시스템 학습을 위한 SQL 문법과 유사하게 파일 기반으로 테이블을 관리하고 Record를 생성, 업데이트, 삭제하는 프로그램을 만드는 것이 목표이다.이러한 데이터베이스 관리하기 위해서는 요청을 보내야 하는데, 이러한 요청을 http 요청과 응답 형식으로 구현함으로써 http 통신에 대한 이해도 또한 함양시키기 위한 문제라고 생각한다.맨 처음 설계에서 구현할 때 고민했던 부분은 읽어들이는 CSV 파일에 대해 어떻게 관리할 것이냐를 고민했다.
singer,year,song ----------- honux,2016,Gameover jk,2020,I like steak crong,2023,Milk song ivy,2021,Butter 문제의 예시에서는 CSV 파일을 주었는데, 이러한 파일에 대해서 레코드를 추가하거나 삭제 등 다양한 명령어들에 대해서 처리할 수 있어야 한다. 이를 위해서는 CSV 파일을 읽어들인 뒤에 적절한 데이터 타입으로 변환해준 다음에 관리하는 것이 보다 합리적이라고 생각했다.나의 경우는 Table클래스에 각 Column(Attribute)과 레코드를 배열로 따로 저장해두는 것을 생각했다.여기서 레코드를 객체로 따로 만들지 않은 이유는 나중에 계속해서 정보를 갱신하는 과정에서 insert할 때 순서를 가지는 프로퍼티를 하나 더 둠으로써 각 attribute가 어떠한 인덱스를 가지는지 나타내려고 한다.기본 인터페이스는 저번 mit 미션에서 사용했던 commander 패키지를 사용하여 처리하려고 한다. 내 의존성을 설치하고 실행시키면 이에 해당하는 명령어를 입력할 수 있는 인터페이스를 주고, 각 명령어를 따로 파싱하여 처리한 다음에 해당 쿼리의 명령에 따라 다른 함수 인터페이스를 제공하려고 한다.Create 요청의 경우 테이블을 생성하는 요청으로 내가 설정하려는 테이블의 Attribute(Column)을 설정한다.
CREATE table_name BTTP Column: column1=datatype Column: column2=datatype Column: column3=datatype create 요청의 경우 새롭게 csv 파일을 만들어야 하며, 형식 검사 datatype 추출해서 객체 만들기 객체 파일로 저장 의 과정을 거쳐 attribute들만 있는 CSV 파일을 저장한다.여기서 제약사항으로 9개까지만 지원하도록 하는 조건과여기서 추가적으로 datatype을 검사해서 Numeric, String만을 넣을 수 있게 해야 하고, attribute에 대해서는 나중에 해당하는 데이터타입을 검사해서 데이터를 생성해야 하므로 각 attribute 또한 객체를 만들어 key:value 형태로 데이터타입을 넣어 할 수 있게 하려고 한다.Insert 요청은 테이블에 레코드를 추가하는 메서드이다.
INSERT table_name BTTP Column: column1 Column: column2 Value: value1 Value: value2 레코드를 추가하면서 column개수를 검사하여 기존의 column 개수와 같지 않으면 예외처리를 한다.개수가 같다면 column의 순서대로 value를 넣어주면 될 것 같다.delete는 테이블의 레코드를 삭제하는 것으로, condition에 맞는 것들을 모두 삭제한다. 이 때 condition에 하나만 포함하면 되므로 attribute와 조건, 논리연산자를 추출해내어 검사한다.레코드를 변경하는 메서드로 조건에 맞는 레코드의 특정 컬럼 값을 변경하면 되므로 이 또한 attribute와 조건, 논리연산자를 추출해내어 처리하면 된다.테이블에 레코드를 검색하는 형식으로, 조건에 맞는 컬럼만 출력하면 된다.테이블 이름과 동일한 CSV파일을 통채로 삭제하면 된다.
#!/usr/bin/env node const { program } = require("commander"); const { commandInterface } = require("./interface"); program.version("0.0.1", "-v, --version").name("commander"); program.command("run").action(() =&gt; { commandInterface(); }); program.parse(process.argv); 인터페이스의 경우 시작 점에서 mhcsv run을 터미널에 입력하면 명령어 창이 나온다. 이후에 명령어들을 계속해서 실행할 수 있다.주어지는 입력은 commandInterface를 통해 실행되고 처리한다.
const readline = require("readline"); const { parsingCommand } = require("./parsing"); const { handleCommand } = require("./handlecommand"); const rl = readline.createInterface({ input: process.stdin, output: process.stdout, }); const commandInterface = (command) =&gt; { console.log("실행할 요청 파일을 입력하세요\n"); rl.on("line", (line) =&gt; { if (!line || line === "q") rl.close(); try { const { command, file } = parsingCommand(line); console.log("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n"); handleCommand(file); } catch (error) { console.log("&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); console.log(error.message); } }); }; module.exports = { commandInterface }; 나같은 경우는 명령어 창을 계속 켜놓고 해당 명령어를 그때마다 파싱하여 알맞은 커맨드에 대한 실행을 handleCommand가 담당한다.
const { readFileSync } = require("fs"); const { create } = require("./create"); const { insert } = require("./insert"); const { deleteRecord } = require("./delete"); const { update } = require("./update"); const { drop } = require("./drop"); function handleCommand(fileName) { const command = readFileSync(`./${fileName}`) .toString() .split("\n")[0] .split(" ")[0]; switch (command) { case "CREATE": create(fileName); break; case "INSERT": insert(fileName); break; case "DELETE": deleteRecord(fileName); break; case "UPDATE": update(fileName); break; case "SELECT": break; case "DROP": drop(fileName); break; default: throw new Error("400 Bad Request"); } } module.exports = { handleCommand }; 이처럼 switch/case문을 통해 각 명령어에 대해서 함수를 실행하도록 구현했다.
const { readFileSync, existsSync, writeFileSync } = require("fs"); const { getTableName } = require("./create"); class Table { constructor(tableName, types, attributes, records) { this.tableName = tableName; this.types = types; this.attributes = attributes; this.attributesLen = this.attributes.length; this.records = records; this.currIdx = this.records.length + 1; this.index = this.#getIndex(); } static getFile(fileName) { console.log(readFileSync(`./${fileName}`).toString()); const fileData = readFileSync(`./${fileName}`).toString().split("\n"); const tableName = getTableName(fileData[0]); if (!existsSync(`./${tableName}.csv`) || !existsSync(`./${tableName}.json`)) throw new Error("404 CSV file Not Found"); const data = readFileSync(`./${tableName}.csv`).toString().split("\n"); const metaData = JSON.parse(readFileSync(`./${tableName}.json`).toString()); let attributes = []; if (data.length &gt; 1) { attributes = data.slice(1, data.length - 1).map((attr) =&gt; { let attrArr = attr.split(","); attrArr = attrArr.map((attr) =&gt; { if (!attr.includes('"')) return parseInt(attr); return attr; }); return attrArr; }); } console.log("&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); return new Table(tableName, metaData.types, data[0].split(","), attributes); } #getIndex() { let index = {}; this.attributes.forEach((attr, idx) =&gt; { index[attr] = idx; }); return index; } saveToFile() { let fileData = this.attributes.join(",") + "\n"; this.records.forEach((record) =&gt; { fileData += record.join(",") + "\n"; }); writeFileSync(`./${this.tableName}.csv`, fileData); console.log("200 OK"); console.log("Content-Type: Text/JSON"); console.log(`Content-Length: ${fileData.length}`); } insert(values) { if (values.length !== this.attributesLen - 1) throw new Error("400 values have different length"); const types = Object.values(this.types); const newRecord = { id: this.currIdx }; values.forEach((val, index) =&gt; { if (types[index + 1] !== typeof val) { throw new Error("400 type not matched"); } newRecord[this.attributes[index + 1]] = val; }); this.records.push([this.currIdx, ...values]); this.currIdx++; console.log(newRecord); this.saveToFile(); } delete(targetIndex, targetVal) { this.records = this.records.filter((record) =&gt; { record[targetIndex] !== targetVal; }); this.saveToFile(); } update(col, val, con_col, con_val) { if (!this.index.hasOwnProperty(col)) throw new Error("404 column not Found"); if (!this.index.hasOwnProperty(con_col)) throw new Error("404 condition column not Found"); const targetCol = this.index[con_col]; const updateCol = this.index[col]; this.records.forEach((record, idx) =&gt; { if (record[targetCol] == con_val) { record[updateCol] = val; } }); this.saveToFile(); } } module.exports = { Table }; 기존에 설계하던 프로퍼티들과 메서드간에는 차이가 다소 있다.\계속해서 쓰이는 파일을 읽어 처리하는 기능을 정적 메서드로 구현하여 새로운 Table 객체를 반환하게 함으로써 해당 테이블의 메서드를 사용할 수 있게 해두었다. 각 명령어의 메서드는 그에 따른 함수가 있지만, 최종적으로는 대부분 이 메서드들을 통해서 정보가 갱신된다.프로퍼티같은 경우는 어트리뷰트와 그 길이, 레코드와 현재의 끝 id값, index는 각 어트리뷰트마다 가지는 인덱스를 객체 형태로 기록해놓았다.타입같은 경우는 따로 만든 json 파일을 가지고 해당 메타데이터를 타입 프로퍼티에 넣어주는 방식으로 구현했다.
const { writeFileSync, existsSync, readFileSync, mkdir } = require("fs"); function create(fileName) { let attributes = [`id`]; let metaData = { fileName: fileName, types: { id: "number" } }; let tableName; const data = readFileSync(`./${fileName}`).toString(); data.split("\n").forEach((attr, idx) =&gt; { console.log(attr); if (idx === 0) tableName = getTableName(attr); else { if (!attr) return; const { attribute, type } = getColumn(attr); attributes.push(`${attribute}`); if (type === "Numeric") metaData.types[attribute] = "number"; else metaData.types[attribute] = "string"; } }); if (existsSync(`./${tableName}.csv`)) throw new Error("409 File Already Exists"); writeFileSync(`./${tableName}.csv`, attributes.join(",") + "\n"); writeFileSync(`./${tableName}.json`, JSON.stringify(metaData)); console.log("\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); console.log("201 Created"); } const getTableName = (line) =&gt; { const [_, tableName, bttp] = line.split(" "); if (bttp !== "BTTP") throw new Error("400 Invalid Bttp request"); return tableName; }; const getColumn = (line) =&gt; { const regex = /^Column:\s(\w+)\=(String|Numeric)/; if (!regex.test(line)) throw new Error("400 Invalid Column Syntax"); const attribute = line.match(regex)[1]; const type = line.match(regex)[2]; return { attribute, type }; }; module.exports = { create, getTableName }; create는 처음 bttp 파일에 대해서 처리를 해줘야 하므로 다소 긴 경향이 있다.주요 로직은 파일을 읽어 줄마다 처리 + 유효성 검증 numeric타입이 자바스크립트에서 typeof를 사용할 때 유용하지 않으므로 number로 치환 새로운 JSON 파일에 타입 정보를 보관 및 저장 의 로직을 가진다.<img src="https://i.imgur.com/M1clZ1W.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">야호~<br><img src="https://i.imgur.com/R5X2R7U.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
const { readFileSync, existsSync } = require("fs"); const { getTableName } = require("./create"); const { Table } = require("./table"); function insert(fileName) { const insertData = readFileSync(`./${fileName}`) .toString() .split("\n") .slice(1); const table = Table.getFile(fileName); const { attrs, values } = getAttrAndVal(insertData); table.insert(values); } const getAttrAndVal = (insertData) =&gt; { const attrs = []; const values = []; insertData.forEach((data) =&gt; { let [colOrVal, val] = data.split(" "); if (colOrVal === "Column:") { if (!val.includes('"')) val = parseInt(val); attrs.push(val); } else if (colOrVal === "Value:") { if (!val.includes('"')) val = parseInt(val); values.push(val); } else { throw new Error("400 Bad Request"); } }); if (attrs.length !== values.length) throw new Error("400 Column not matched to Value"); return { attrs, values }; }; module.exports = { insert }; insert는 생각보다 많이 까다로웠다. 처음에는 들어오는 모든 값들이 무작위로 주어져서 해당 인덱스값을 계속 대조하여 알맞은 형태로 레코드를 만들어 넣어야 하는 것이 아닐까? 생각했는데 찾아봤더니 sql 쿼리문에서는 따로 순서를 지정해야 한다.
INSERT INTO Temp_Table(field1, field2, field4, field3, field5, field6, field7, field8, field9, field10) VALUES('data4','data4-2','data4-4','data4-3','data4-5','data4-6','data4-7','data4-8','data4-9','data4-10'); 따라서 나는 그냥 어트리뷰트 순서대로 레코드가 들어올 것이고, 나는 그냥 타입 체크만 하면 되겠다 생각하고 구현했다.<br><img src="https://i.imgur.com/0Wt0IpB.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/mm9TOF7.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
const { readFileSync } = require("fs"); const { Table } = require("./table"); function update(fileName) { const table = Table.getFile(fileName); const updateData = readFileSync(`./${fileName}`) .toString() .split("\n") .slice(1); const [col, colData] = updateData[0].split(" "); const [val, valData] = updateData[1].split(" "); let [con, conData] = updateData[2].split(" "); if (col !== "Column:" || val !== "Value:" || con !== "Condition:") throw new Error("400 Bad Request(command)"); const [conData_col, conData_val] = conData.split("="); table.update(colData, valData, conData_col, conData_val); } module.exports = { update }; update는 조건에 해당하는 레코드를 찾아서 설정한 column값의 인덱스에 지정한 value값을 넣어주도록 했다.조건이 까다롭지는 않지만 각종 파라미터들의 파싱이 많다보니 복잡해진 경향이 있다.<br><img src="https://i.imgur.com/8nWEOv7.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/Dk7JzYk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
const { readFileSync } = require("fs"); const { Table } = require("./table"); function deleteRecord(filename) { const file = Table.getFile(filename); if (!file.records.length) throw new Error("404 record not exist"); const [text, condition] = readFileSync(`./${filename}`) .toString() .split("\n")[1] .split(" "); if (text !== "Condition:") throw new Error("400 Bad Request"); const [col, con] = condition.split("="); if (!col || !con) throw new Error("400 Bad Request(Condition)"); console.log(col, con); const targetIndex = file.index[col]; file.delete(targetIndex, con); } module.exports = { deleteRecord }; ... //클래스 메서드 delete(targetIndex, targetVal) { this.records = this.records.filter((record) =&gt; { record[targetIndex] !== targetVal; }); this.saveToFile(); } Delete의 경우에는 조건을 검색하는 방식이 update와 비슷하게 작동하기 때문에 일부분을 재활용했다.특이한 점(?)으로는 기존의 레코드 배열들을 고차함수 filter를 통해 걸러주어 코드가 보다 깨끗해졌다.<br><img src="https://i.imgur.com/76GF5Pm.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/97Hio6u.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">해커톤땜에 준비하느라 시간부족이슈로 내일 시간이 된다면 구현할듯 싶다..가도 빌드하면서 기다리면서 조금씩 했다.자고싶다..
const { readFileSync } = require("fs"); const { Table } = require("./table"); function select(fileName) { const table = Table.getFile(fileName); const [con, condition] = readFileSync(`./${fileName}`) .toString() .split("\n")[1] .split(" "); if (con !== "Condition:") throw new Error("400 Bad Request(condition)"); console.log(condition); const regex = /(\w+)([=&gt;&lt;])([\w"]+)/; const matched = condition.match(regex); const col = matched[1]; const logic = matched[2]; const val = matched[3]; table.select_equal(col, val); } module.exports = { select }; ... //테이블 클래스 메서드 select_equal(col, val) { const idx = this.index[col]; const result = []; this.records.forEach((record) =&gt; { if (record[idx] === val) { result.push(record); } }); this.recordToObject(result); } recordToObject(arr) { const result = []; arr.forEach((record) =&gt; { let converted = {}; record.forEach((attr, idx) =&gt; { converted[this.attributes[idx]] = attr; }); result.push(converted); }); console.log(result); } Select의 경우 현재는 equal = 만 따로 처리를 하는 로직을 만들어놨다.생각해보니 일치와 같은 경우는 어차피 index값을 통해 각 어트리뷰트에 대한 값을 잘 뽑아낼 수 있으므로 맨 처음에 정규표현식을 통해 그룹캡처를 해서 필요한 조건(어트리뷰트, 값, 논리연산자)를 뽑아내고 각각 논리연산자에 따라 로직을 switch/case문을 통해 처리할 예정이다.현재 등호만 해놨는데, 등호의 경우에는 레코드를 전부 돌면서 해당 값과 같은 레코드들만 찾아내서 뽑아내면 된다.<br><img src="https://i.imgur.com/ZynVeWW.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/JJqW0yG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
const { existsSync, readFileSync, unlinkSync } = require("fs"); const { Table } = require("./table"); function drop(fileName) { if (!existsSync(`./${fileName}`)) throw new Error("404 file not found"); const table = Table.getFile(fileName); const length = readFileSync(`./${fileName}`).toString().length; if (!existsSync(`./${fileName}`)) throw new Error(`404 file not found(csv)`); unlinkSync(`./${table.tableName}.csv`); unlinkSync(`./${table.tableName}.json`); console.log("&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); console.log("200 OK"); console.log(`Row-Count: ${length}`); } module.exports = { drop }; DROP은 unlinksync를 사용해주기만 하면 됐으므로 일단은 처음에 테이블 객체를 받아오는 정적 메서드를 통해서 테이블 객체를 받아온 뒤, 해당 파일 이름의 프로퍼티를 가져와 이를 지워주는 방식으로 사용했다.<br><img src="https://i.imgur.com/uNwC6Co.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/dtAEJ2Q.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/JJqW0yG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://medium.com/@queenskisivuli/how-sql-writes-data-insert-create-and-delete-3b5536d9370b" target="_self">https://medium.com/@queenskisivuli/how-sql-writes-data-insert-create-and-delete-3b5536d9370b</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://rachel0115.tistory.com/entry/SQL-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC-SELECT-%EC%A0%88" target="_self">https://rachel0115.tistory.com/entry/SQL-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC-SELECT-%EC%A0%88</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC" target="_self">https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@hsshin0602/CS-%EC%A7%80%EC%8B%9D-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-VS-%ED%8C%8C%EC%9D%BC-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C" target="_self">https://velog.io/@hsshin0602/CS-%EC%A7%80%EC%8B%9D-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-VS-%ED%8C%8C%EC%9D%BC-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/" target="_self">https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://mommoo.tistory.com/62" target="_self">https://mommoo.tistory.com/62</a>
함수분리
function create(fileName) { const data = readFileSync(`./${fileName}`).toString(); const { attributes, metaData, tableName } = parsingCreate(data, fileName); if (existsSync(`./${tableName}.csv`)) throw new Error("409 File Already Exists"); writeFileSync(`./${tableName}.csv`, attributes.join(",") + "\n"); writeFileSync(`./${tableName}.json`, JSON.stringify(metaData)); console.log("\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); console.log(STATUS_CODE[201]);
}
...
const parsingCreate = (data) =&gt; { let attributes = [`id`]; let metaData = { fileName: "", types: { id: "number" } }; let tableName; data.split("\n").forEach((attr, idx) =&gt; { console.log(attr); if (idx === 0) { tableName = Table.getTableName(attr); metaData.fileName = tableName; } else { if (!attr) return; const { attribute, type } = getColumn(attr); attributes.push(attribute); if (type === "Numeric") metaData.types[attribute] = "number"; else metaData.types[attribute] = "string"; } }); return { tableName, attributes, metaData };
};
대표적인 create 메서드의 경우, 이전까지는 parsingCreate이라는 함수를 따로 두지 않고 이러한 메타데이터, 어트리뷰트, 테이블 이름 등을 추출해 내는데 해당 함수 안에서 모두 처리하다보니 함수의 가독성 자체가 매우 떨어졌다. 그러다보니 이러한 부분을 개선해야 할 필요성을 자연스럽게 구현하는 과정에서 느끼게 되었고, 이를 개선하기에서 고쳐야겠다고 생각했다.
사실 조금 더 좋은 방식은 어트리뷰트와 메타데이터, 테이블 이름을 다 함수로 분리한다면 보다 해당 함수의 길이가 짧아질 수는 있겠지만, 사실한 하나의 파일에 대해 여러번 반복문을 돌며 처리하는 꼴이 되기 때문에 성능면에서 손해라고 생각하여 하나의 함수에 처리하는 것으로 생각했다.
상태 코드 상수화
const STATUS_CODE = { 200: "200 OK", 201: "201 CREATED", 400: "400 BAD REQUEST", 404: "404 FILE NOT FOUND", 500: "500 INVALID BTTP REQUEST",
}; module.exports = { STATUS_CODE }; 상태 코드 상수화의 경우 다양한 상태코드가 있지만 주로 응답 코드에 맞는 메세지가 있는데, 이를 매치하기 위해 여러 코드를 구별하서 쓰다 보니 항상 나오는 에러코드들은 정해져 있었다.
이에 이러한 에러에 대해 매번 에러를 throw하는 과정에서 굳이 메세지를 하드코딩하기보단, 상수화시켜서 이를 import해와서 사용하는 방식으로 사용하면 나중에도 예외처리를 할 때 편해질 것 같아서 개선을 진행했다.
json 구조 바꾸기
{ "fileName": "billboard", "types": { "id": "number", "singer": "string", "year": "number", "song": "string" }
} 나는 기존 파일에 타입을 다른 구분자를 붙여 구분하는 것은 원래의 형식에 벗어나기도 하고, 원래도 메타데이터를 두고 관리한다는 이야기를 들어 타입과 같은 메타데이터를 따로 두려고 했었다. 그러나 이러한 타입만을 따로 두기에는 json파일에 대해 오히려 낭비같다는 생각이 들어, 내가 나중에 처리해서 쓸만한 데이터들을 따로 보관하기로 했었다.
따라서 나는 fileName과 type을 두었으며, fileName의 경우 후에 json 파일을 읽어들어와 filename을 쉽게 뽑아내어 파일에 대한 처리가 보다 쉬워질 수 있다고 생각하여 json구조를 기존 파일명을 보관하는 것보다는 테이블의 이름을 기억하여 활용할 수 있도록 하였다.
'']]></description><link>부스트캠프/챌린지/챌린지-day_16.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_16.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/M1clZ1W.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/M1clZ1W.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지 Day_18]]></title><description><![CDATA[
서버
checkin
clap
checkout
summary
direct
채팅(chat, finish, broadcast)
클라이언트
!history
checkin
clap
checkout
summary
direct
채팅(chat, finish, broadcast)
<img src="https://i.imgur.com/1EXkbPf.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="max-width: 100%;"><br><img src="https://i.imgur.com/ZSMP3U0.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="max-width: 100%;"> 서버가 받은 모든 요청에는 적절한 응답을 보내준다. (아무런 반응이 없으면 안된다.) 서버는 여러 클라이언트가 동시에 연결할 수 있어야 한다. checkin 요청을 받은 후에도 연결을 유지해야 한다. 비동기 입력화면 checkin 성공한 시각을 변수에 기록 chekout할 때 checkout시각 - chekin 시각 -&gt; Core Time 실행 후 입력한 명령을 모두 기록(서버x 클라이언트 자체에서) 요청, 응답, 브로드캐스트를 모두 클라이언트가 받아 출력 const net = require("net"); const { handleCommand } = require("./handleCommand"); const server = net.createServer((socket) =&gt; { console.log("Client Connected"); const userSessionId = crypto.randomUUID(); socket.on("data", (data) =&gt; { console.log(`${userSessionId} Received from client: ${data}`); data = JSON.parse(data); const response = handleCommand(userSessionId, data, socket); socket.write(response); }); socket.on("end", () =&gt; { console.log("Client disconnected"); }); }); const port = 2024; server.listen(port, () =&gt; { console.log(`Server listening on port ${port}`); }); 서버는 net.Socket을 활용하여 2024포트에 대해서 서버를 키고, JSON 형식의 커맨드, 데이터로 이루어진 객체를 받아 이에 대해서 각각 처리한다. 이러한 데이터 처리 방식은 기존 프론트와 백의 데이터 통신에 대한 방식과 거의 흡사하다.
function checkin(campId, host, port) { let client = new net.Socket(); client.connect(port, host, () =&gt; {}); client.on("data", (data) =&gt; { ResponseHandler.handle(data); }); client.on("close", () =&gt; { process.exit(); }); client.write(RequestJson.makeCheckinRequest(campId)); historyList.push("checkin"); return client; } 클라이언트는 net.Socket을 이용하여 전달된 host와 port에 대해 연결이후 write로 서버에 요청이 간후 응답이 돌아오게 될경우 ResponseHandler를 이용하여 응답 결과 출력
// 클라이언트 &gt; checkin J004 &lt; checkin success to group#1 // 서버 &gt;&gt; checkin J004 (success) from 127.0.0.1:12334 =&gt; session#1, group#1 const { Repository } = require("./repository"); const User = require("./user"); function checkin(userSessionId, data, socket) { const campId = data.data; const repository = new Repository(); numberValidCheck(campId); const user = repository.addUser(campId, userSessionId, socket); const groupNum = repository.joinGroup(user); console.log( `checkin ${user.campId} (Success) from ${socket.remoteAddress} =&gt; session#${user.indexId}, group#${user.group.groupNum}` ); return JSON.stringify({ command: data.command, data: groupNum }); } const numberValidCheck = (campId) =&gt; { const idNumber = parseInt(campId.slice(1)); if (typeof idNumber !== "number" || idNumber &gt; 256 || idNumber &lt; 1) { throw new Error("Invalid Id number"); } }; module.exports = { checkin }; campId (J001~J256) checkin -&gt; 그룹 할당 4명까지 그룹 할당 그룹에서 빠져나간 경우 재할당 가능(할당하는 방식에 대해선 의논) checkin 응답 -&gt; 그룹 번호를 정수형으로 알려줌 체크인의 경우 각 유저마다 오는 달라지는 UUID 값에 대해 Database 객체에 Repository라는 중간 객체를 통해 갱신하는 방식으로 구현했다.또한 그룹도 객체로 만들어주어 각 각 그룹에서 남은 공간을 찾아 해당하는 캠퍼를 넣어주도록 했고, 이 또한 repository의 메서드를 통해 갱신한다. 마지막에는 JSON값을 리턴해주어 클라이언트에서도 처리가 용이하도록 구현했다. campId 범위 초과 에러 재입력 checkin 상태에서 다시 checkin 불가능 <br><img src="https://i.imgur.com/1xTeOsG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
// 클라이언트 &gt; checkout &lt; checkout (disconnected) &gt; Core time = 11min 32sec // 서버 &gt;&gt; checkout from session#2(J005) - disconnected const { Repository } = require("./repository"); function checkout(user, userSessionId) { const repository = new Repository(); console.log( `checkout from session#${user.indexId}(${user.campId}) - disconnected` ); repository.deleteUser(userSessionId); return JSON.stringify({ command: "checkout", data: true }); } module.exports = { checkout }; 이전에 checkin 했던 그룹에서 퇴장 그룹에 다른 캠퍼가 남아있다면, 해당 그룹 캠퍼들에게 퇴장 메시지 전달 chekout 요청 후 응답을 받으면 연결을 끊기 chekout 없이 TCP 연결이 끊겨도 checkout 처리 체크아웃에서 신경써야 할 점은 기존의 접속 중인 캠퍼를 보관하는 database의 user객체에 대해 삭제를 함과 동시에 그룹에서 또한 제거해야 한다는 점이었다. 이를 유의하여 repository를 통해 정보를 갱신하고, error가 던져지지 않는 이상 true값만 데이터로 리턴하여 성공 여부를 알리도록 했다.<br><img src="https://i.imgur.com/yF2jcmY.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
// 클라이언트 &gt; summary day4 &lt; keywords are "Heap, Stack" // 서버 &gt;&gt; summary from session#2(J005) : day19 =&gt; 'Network, Server' function summary(user, data) { if (!day.hasOwnProperty(data.data) || !data.data) throw new Error("404 Day Not Found"); console.log(`summary from session#${user.indexId}(${user.campId})`); return JSON.stringify({ command: "summary", data: `\"${day[data.data]}\"` }); } const day = Object.freeze({ day1: "IDE,node", day2: "Linux,System", day3: "XML,JSON", day4: "Heap,Stack", day6: "Object,Class", day7: "File Path, UnitTest", day8: "Immutable, Closure", day9: "Event, Publisher", day11: "Async,EventLoop", day13: "Git, Object", day16: "HTTP, SQL", day18: "Network, Server", }); module.exports = { summary }; summary 요청을 보내서 키워드 받기 데이터 -&gt; day 몇 번째 미션인지 정수형으로 받기 서버 -&gt; 정수형을 확인해서 응답 summary같은 경우 이미 주어지는 값들이 고정되어 있으므로, 이를 상수처리 해주고 가져다가 쓸 수 있게끔 해 주었다. 해당하지 않은 대상이 나오게 된다면 에러를 던져주었다.<br><img src="https://i.imgur.com/M4Wx24P.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="max-width: 100%;"><br><img src="https://i.imgur.com/NHxvPjL.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
// 클라이언트 &gt; chat maxCount=2 &lt; broadcast from server, "채팅이 시작되었습니다" //클라이언트 - 다른 클라이언트에게 chat을 통해 채팅방을 만들고 브로드캐스트 받았을 때 &lt; broadcast from J005, "반갑습니다" // 서버 &gt;&gt; chat from session#1(J004) function chat(user) { if (!user.group) throw new Error("404 Group not found"); user.group.chatStart(); return JSON.stringify({ command: "chat", data: true }); } module.exports = { chat }; 같은 그룹에 있는 사람들과 브로드캐스트 요청 데이터 -&gt; maxCount(int) 메시지 개수 &lt; maxCount 메시지 개수가 MaxCount를 넘으면 서로에게 전달되지 않음 //클라이언트 -&gt; 알아서 넣기 //서버 &gt;&gt; finish from session#1(J004) function finish() { if (!user.group) throw new Error("404 Group not found"); user.group.chatFinish(); return JSON.stringify({ command: "finish", data: true }); } module.exports = { finish }; 채팅 요청을 보낸 캠퍼가 finish를 보내면 채팅 멈추기 다시 브로드캐스트 불가능 보낼 때
//클라이언트 &gt; broadcast "반갑습니다" //서버 &gt;&gt; broadcast from session#2(J005) =&gt; "반갑습니다" class Database { _instance = null; constructor() { if (this._instance === null) { this._instance = this; this.user = {}; this.groups = []; this.clap = 0; this.currsessionId = 0; } return this._instance; } getNewSessionId() { this.currsessionId++; return this.currsessionId; } } const getInstance = () =&gt; { if (this.database == undefined) { this.database = new Database(); } return this.database; }; module.exports = { getInstance }; 받을 때
//클라이언트 &lt; broadcast from J004, "오늘힘드네요" //서버 &gt;&gt; broadcast to group#1 =&gt; text="반갑습니다", from="J005" 브로드캐스트 요청을 보내면 chat 진행중인 그룹 모두에게 브로드캐스트 요청 데이터 -&gt; text(string) 보낼 때
//클라이언트 &gt; direct to J004 "마지막이니 힘내요" &lt; direct (success) //서버 &gt;&gt; direct from session#2(J005) =&gt; to="J004", text="마지막이니 힘내요" 받을 때
//클라이언트 &lt; direct from J005, "마지막이니 힘내요" //서버 broadcast to session#1(J004) =&gt; text="마지막이니 힘내요" 직접 특정한 캠퍼에게 메시지를 보낼 수 있는 기능 요청 데이터 -&gt; campId(string), text(string) 수신할 대상 캠퍼가 체크인 안했으면 보내지 않기 체크인을 한 상태라면 text 메시지 전달 //클라이언트 &gt; clap &lt; clap count is 1 //서버 &gt;&gt; clap from session#1(J004) =&gt; 1 const { Repository } = require("./repository"); function clap() { const repository = new Repository(); repository.addClap(); console.log("clap!"); return JSON.stringify({ command: "clap", data: repository.getClap() }); } module.exports = { clap }; 모든 클라이언트가 보내는 요청 횟수를 누적하기 위한 기능 요청할 때마다 하나씩 값을 누적해서 숫자 응답 한 클라이언트에서 반복해서 요청 가능 <br><img src="https://i.imgur.com/27cgnmt.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
모든 기능 완성 ✅ 2024-08-08
클라이언트의 readline 구조 개선 ✅ 2024-08-08
http Request &amp;&amp; response 구조로 데이터 보내기 ✅ 2024-08-08
Error 핸들링 -&gt; 클라이언트에 에러 전송 개선 ✅ 2024-08-08
const RequestHandler = require("./requestHandler");
const readline = require("readline");
const rl = readline.createInterface({ input: process.stdin, output: process.stdout,
}); let client = null;
const port = 2024;
const host = "localhost";
let startTime = 0;
rl.on("line", (line) =&gt; { const order = line.trim().split(" "); if (order[0] == "!history") { RequestHandler.history(); } else if (!client) { if (order[0] == "checkin") { startTime = Date.now(); client = RequestHandler.checkin(order[1], host, port); } else { console.log("잘못된 명령입니다"); } } else { if (order[0] == "clap") { RequestHandler.clap(client); } else if (order[0] == "checkout") { RequestHandler.checkout(client); printTime(startTime, Date.now()); } else if (order[0] == "summary") { RequestHandler.summary(client, order[1]); } else if (order[0] == "direct") { //RequestHandler.direct(client); } else if (order[0] == "chat") { } else if (order[0] == "finish") { } else if (order[0] == "broadcast") { } else { console.log("잘못된 명령입니다"); } }
}); function printTime(startTime, endTime) { let time = parseInt((endTime - startTime) / 1000); console.log(`Core time = ${parseInt(time / 60)}min ${time % 60}sec`);
} 기존 코드의 경우 readline 내에서 어떻게 처리할 지에 대해 보다 구조를 잘 파악하기 위해 readline 내에서 명령어를 처리하다보니 아무래도 if else 문을 보다 남발하는 경우가 있었다. 또한 클라이언트가 없는 경우에 대해서도 따로 서버의 명령어를 처리하면 안되기 때문에 이를 막다보니 다양한 예외 상황에 대해 처리하기 위해 if else문을 썼지만 이를 switch/case문을 통해 보다 구조적으로 정리할 수 있을 것 같았디.const RequestHandler = require("./requestHandler"); //클라이언트 객체
let client;
//접속 시간을 구하기 위한 startTime
let startTime;
const PORT = 2024;
const HOST = "localhost"; function commandHandler(line) { const [command, ...data] = line.trim().split(" "); console.log(command, data); if (!client &amp;&amp; command !== "checkin") { console.log("체크인을 진행해야 명령어가 가능합니다."); } else { switch (command) { case "!history": RequestHandler.history(); break; case "checkin": startTime = Date.now(); client = RequestHandler.checkin(data[0], HOST, PORT); break; case "checkout": RequestHandler.checkout(client); printTime(startTime, Date.now()); break; case "summary": RequestHandler.summary(client, data[0]); break; case "clap": RequestHandler.clap(client); break; case "direct": RequestHandler.direct(client, data[0], data[1]); break; case "broadcast": RequestHandler.broadcast(client, data[0]); break; case "finish": RequestHandler.finish(client); break; default: console.log("잘못된 명령어입니다."); break; } }
} function printTime(startTime, endTime) { let time = parseInt((endTime - startTime) / 1000); console.log(`Core time = ${parseInt(time / 60)}min ${time % 60}sec`);
} module.exports = { commandHandler };
따라서 client의 commandHandler를 따로 만들고, 이에 대해서 readline의 클로저로 넘겨주었다.
이 클로저에서는 각 클라이언트에 대해 객체를 관리하고, 명령어에 대해 처리하는 기존에 있던 콜백함수를 따로 모듈화시켜놓고 기존의 문법을 살짝 변형한 정도이다.
이를 통해 나중에 보다 구조적으로 확인이 편하고, 명령어 추가가 보다 용이하다.const { commandHandler } = require("./commandHandler");
const readline = require("readline");
const rl = readline.createInterface({ input: process.stdin, output: process.stdout,
}); rl.on("line", commandHandler); 또한 기존에 있던 client의 readline부분이 매우 간소화되어 명령어와 데이터의 흐름 별로 보다 파악이 용이하게 개선되었다고 생각한다.function makeCheckinRequest(campId) { return JSON.stringify({ command: "checkin", data: campId, });
} function makeClapRequest() { return JSON.stringify({ command: "clap", });
} function makeCheckoutRequest() { return JSON.stringify({ command: "checkout", });
} function makeSummaryRequest(day) { return JSON.stringify({ command: "summary", data: day, });
} function makeChatRequest(cnt) { return JSON.stringify({ command: "chat", data: cnt, });
}
이전에는 그냥 json형식으로 command &amp; data의 형식으로 보냈는데, 이럴 떄마다 command의 역할 자체가 하나의 http 요청을 보내는 것이 아닌, 데이터만 받아서 이를 처리해서 실행하는 느낌이 들었다.
우리의 미션에서는 학습해야 할 부분이 http request &amp; response에 대한 부분도 있었기 때문에 이러한 데이터를 서버에 보내는 것이 형식에 맞지 않는 것 같았다. 따라서 이를 기본적인 http 요청의 구조를 만들어 서버에 보내는 로직을 따로 설정하여 요청 및 응답하는 것이 조금 더 적합한 방식이라고 생각했다.const httpRequest = (path, data = {}, method = "POST") =&gt; { const request = { method: method, path: path, version: "HTTP/1.1", headers: { "Content-Type": "application/json", "Content-Length": JSON.stringify(data).length, }, body: { data: data, }, }; return JSON.stringify(request);
}; module.exports = { httpRequest,
};
따라서 기존 HTTP 요청의 일부분을 따라하여 비슷한 식의 템플릿에 데이터를 담아 보내도록 했다. 여기서 path의 경우 기존에 요청하던 명령어들을 의미하며, 데이터의 경우 requestHandler에서 readline을 통해 받은 데이터를 처리하여 넘겨주어 JSON 형식의 표준화된 데이터를 얻게 되고, 이를 서버에 보낸다.const httpSuccessResponse = (path, data = {}, method = "POST") =&gt; { const request = { result: "SUCCESS", method: method, path: path, version: "HTTP/1.1", headers: { "Content-Type": "application/json", "Content-Length": JSON.stringify(data).length, }, body: { data: data, }, }; return JSON.stringify(request);
}; const httpFailResponse = (path, error = "", method = "POST") =&gt; { const request = { result: "ERROR", method: method, path: path, version: "HTTP/1.1", headers: { "Content-Type": "application/json", "Content-Length": JSON.stringify(error).length, }, body: { error: error, }, }; return JSON.stringify(request);
}; module.exports = { httpFailResponse, httpFailResponse,
};
서버에서도 받은 응답에대해 처리를 하고 응답 결과에 따라 두 가지의 응답을 보낼 수 있도록 하였다. FAIL의 경우 왜 FAIL이 이루어졌는지에 대한 이유를 담아 보낼 수 있도록 하였다.function throwServerError(errorCode, path, message) { throw Object.assign(new Error(message), { code: errorCode, path: path, });
} module.exports = { throwServerError };
기존의 서버 에러들은 그저 에러를 던져주기만 하고 이에 대해 따로 처리해주지 않아 서버에서만 제대로 에러가 뜨고 , 클라이언트에서는 에러에 대해 핸들링을 따로 해주지 않았다.따라서 이러한 에러를 던져주는 과정에서 서버에서 이 에러를 받아 적절한 http Response로 바꿔준 후 error 관련 정보를 담은 응답을 보내줘 클라이언트에서 이를 처리할 수 있도록 해줬다.
에러와 같은 경우 코드와 어떤 명령어를 실행했을 때, 어떤 에러가 떴는지를 알아야 하기 때문에 위와 같이 기존 Error에 새로운 property를 추가하여 에러를 받아 처리해주도록 했다. socket.on("data", (request) =&gt; { console.log(`Received from client: ${request}`); request = JSON.parse(request); const data = request.body.data; const path = request.path; try { handleCommand(userSessionId, path, data, socket); } catch (error) { socket.write(httpFailResponse(error.path, error.code, error.message)); } });
서버가 에러를 핸들링하는 로직또한 바꿔주었다.
서버가 데이터를 받으면 handleCommand를 통해 데이터가 가게 되고, 이렇게 간 데이터가 유효성 검증 중에 에러가 발생한다면 위의 에러를 던져주어 서버의 최상위인 해당 코드에서 받아 socket.write로 받아 이를 http response 형식으로 처리하여 클라이언트로 보낼 수 있도록 하였다.]]></description><link>부스트캠프/챌린지/챌린지-day_18.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day_18.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/1EXkbPf.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/1EXkbPf.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지 1주차 회고]]></title><description><![CDATA[3학년 2학기가 끝나고 고민이 많았다.
2학년 2학기부터 시작한 개발은 처음에는 정말 계단처럼 척척 올라가는 단계였다면, 지금은 또 정체기에 들어선 듯 싶었다.
항상 나에게 재밌고 새롭게만 다가왔던 개발은 1년이 지난 시점에서 이미 내 흥미에서 벗어나고 있었다.
나도 모르는 새에 프로젝트를 해도 똑같은 리액트로 코드를 짠다라는 느낌이 아니라 코드를 '싼다'라는 배설적인 의미의 코딩을 하고 있었다. 어느순간 계속해서 새로운 기술을 쓰지 않고, 로직을 개선해나가지 않고 안주해버린 듯한 느낌이었다.<img src="https://i.imgur.com/Hdxqj6l.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">CS를 공부해도 전보다 못한 열정에 하루에 공부하는 시간이 10시간을 넘은 적이 거의 없었던 것 같다. 이런저런 핑계를 대면서 열심히 하고 있다고 말은 하지만, 어딘가 마음이 불편했다.이대로만 간다면 나는 나중에 정말 흔하디 흔한, 누구보다도 대체당하기 쉬운 개발자가 될 것만 같았다.
이러한 불안한 마음에 보다 열정을 되찾고자 부트캠프를 찾기 시작했다. 적어도 부트캠프는 9시부터 6시까지 코어타임을 가지고 있으니까 그 시간동안 하면 뭐라도 좀 더 하겠지 하는 마음이었다.그렇게 나는 카카오테크, 네이버 부스트캠프, 프로그래머스 데브코스를 신청했고
카카오테크는 떨어졌지만 부스트캠프는 베이직에 붙어 입과했다.베이직은 문제를 받는 사람 따라 난이도가 천차만별로 달라질 것 같다.
나같이 코드를 배설하는 사람들은 난이도가 어렵지만, 설계부터 착실히 검증까지 해내는 사람들에게는 나름 쉬운 과제들이었다고 생각한다.
나 또한 문제는 다 풀었지만, 설계를 하고 이를 구현하는 일련의 과정을 하나로 연결시키는 과정에서 어딘가 뒤틀리며 항상 난항을 겪었다. 그러면서 '나름 나정도면 괜찮지 않을까' 병이 치료되었다.
이제까지 나름 스스로 합리화하면서 살아왔던 과거의 나를 반성할 수 있었다.<br><img src="https://i.imgur.com/WhSfX43.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 네이버는 반성할 기회도 준다!<br><img src="https://i.imgur.com/UF5S8lJ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/zwilcF4.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">운이 좋게도 개망했다고 생각한 2차 테스트를 통과했다.
싱글벙글 멤버십 갈 나를 생각하며 웃었다.그리고 챌린지 시작 1주일이 지난 지금의 나:<br>
<img src="https://i.imgur.com/YY1v8u8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
지금도 아직 학습 정리할 것들이 태산인데 코딩하면서 밤 새서 공부하면 그대로 줄줄 샐 것 같아 이거 쓰는중내 체감상으로는 그렇다. 매우매우 어렵다.
나같이 설계와 CS를 못하는 사람들에게는 아마 알보칠같은 존재인 것 같다.
효과는 확실한데 약을 바르는 순간 죽을맛이다.
아직 일주일밖에 안 지났는데 지난 3일동안 총 잔 시간이 합쳐서 9시간이다(4시간 + 4시간 + 1시간).코드를 짜면서도 현타의 연속이었다.
내가 이렇게 코드를 못 짜는 사람이었나? 싶기도 하고 내 약했던 부분이 수두룩 발견되기 시작한다.<br><img src="https://i.imgur.com/rcf6jwo.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">프로그래머가 공부할 때는 크게 두 가지 유형이 있다고 한다.
일단 머리로 들이받고 보는 '야생형'과
내가 필요한 것들을 모두 학습하고 천천히 단계별로 진전해가는 '학습형'이다.나는 100% 야생형으로, 일단 들이받고 보는 스타일이었는데 이번 문제들을 보고 좀 치료가 됐다.
아예 모르면 그냥 아무것도 못 할 수준이기 때문에 학습형과 야생형의 중간정도까지 와서 지금은 최소한의 사전 지식 습득 후에 코드로 진입한다.
하지만 여기서도 제대로 개념들을 이해하지 못하면 뭘 설계할 때도 삑사리가 나기 마련이기에 처음엔 엄청 많은 오류들을 맞닥뜨리면서 자연스럽게 학습할 수밖에 없는 환경이 주어진다.또 뭘 완성하더라도 내가 몰랐던 것들을 다시금 정리하면서 복습하는 느낌도 있어 원래 했던 학습효과보다 효과가 훨 좋은 것 같다.부스트캠프는 매일 문제를 해결하고, 피어들과 리뷰하는 시간을 가진다.
내 코드가 아닌 다른 사람들의 코드를 읽으면서 코드 문해력을 높이고, 내가 아닌 다른 사람들의 설계 방식 등을 보면서 조금이나마 다른 사람들의 코드를 이해하려는 생각을 한 것 같다.이전까지만 해도 남들의 코드는 귀찮다고 안 보던 내가 리드미를 꼼꼼히 읽어보니 생각보다 다른 사람들의 코드를 보는 것도 재밌고 가독성과 로직이 본받을만하면 그걸 나중에 써보면서 나의 코드를 개선할 여지도 주어져 내가 하는 것에 따라 효과가 천차만별로 달라질 수 있다고 생각한다.그리고 이제까지 나는 개발자 인맥이 그렇게 많지 않았는데, 네이버 부스트캠프에 들어오는 사람들 중에서도 주니어개발자 이상의 실력을 가진 사람이 많다. 그러다보니 그런 분들에게 내 코드를 보여주고 각자 코드에 대해 이야기를 나누다보면 예상치 못하게 꿀팁들을 계속 주워먹게 된다. 이 점도 피어리뷰의 장점인듯 싶다.<br><img src="https://i.imgur.com/ub15h51.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">근데 아직까지는 피어리뷰를 이제까지 거의 해본 적이 없어서 어떻게 해야할 지 잘 몰라서 살짝 어영부영 넘어간 날도 있는 것 같기도 한데, 다음 주는 이를 보다 잘 활용해볼 생각이다.<br><img src="https://i.imgur.com/pBOoTGV.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
오랜만에 챌린지한 문제들을 매일마다 하다보니 나도 모르게 불이 붙었다
피곤한데도 코드가 손에서 떼지질 않는다.
그러다보니 매일 4시에 자는건 기본이고, 심지어 오늘은 전날 23~24시 쪽잠 후에 00시부터 지금까지 깨어있다.
내 마음대로 되지 않는 코드를 보면서 화가 나기도 했다
하지만 문득 새벽에 코딩을 하면서 생각했다
내가 언제 이렇게 열심히 했었지?
사실 코딩을 밤 새가면서 열심히 했을 때는 웹프로그래밍을 처음 배웠을 때였다.
그때는 개발을 해도 시간 가는줄 모르고 해가 뜰 때까지 코딩을 하면서도 웃던 나였는데, 어느샌가 흥미를 잃어가고 있었던 것을 인지하고 있었음에도 어떻게 할 지 몰랐다.
그런데 또 여기서 내 앞에 보이는 한계의 벽이 뚫릴락말락하다보니까 열심히 하게 됐다(이게 진짜 사람 미치게함)그래서 밤을 샜는데도 막 기분이 엄청 안좋지는 않다. 아니 오히려 좋다고 말해야 될 것 같다.<br>
<img src="https://i.imgur.com/rWzV4fT.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
매일매일 내가 성장한다는 느낌을 뚜렷하게 받고 있기 때문에 기분이 안 좋을래야 안 좋을 수가 없다. 약간 메이플 성장의 비약 먹고 1부터 200까지 빠르게 찍는 느낌이랄까.암튼 1주차는 여차여차 잘(?) 마무리 했다.
아니 사실 마무리 못했다
학습정리 하러 가야지]]></description><link>부스트캠프/챌린지/챌린지-1주차-회고.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 1주차 회고.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/Hdxqj6l.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/Hdxqj6l.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[챌린지 Day1_문제]]></title><description><![CDATA[
웹 개발자는 VS Code에서 JavaScript 프로그램 구현을 할 수 있고, Node.js로 JavaScript 코드를 실행할 수 있다. 기본 개발 환경을 구성하고 git과 GitHub 서비스를 활용해서 소스 코드를 관리할 수 있다. 없음부스트캠프 회의실을 관리하는 콘솔 프로그램을 작성하려고 합니다. 문자열 배열로 "시간대와 인원"을 묶어서 제공하면 회의실 시간표를 저장해서 출력하는 프로그램을 작성하세요.
프로그램에서는 표준 입력으로&nbsp;"시간대-참석인원-회의시간"&nbsp;형태로 반복해서 입력받으며 회의실별로 시간표를 출력하고, 다시 입력받는 것을 반복한다. 예약 요청은 문자열 배열로 시간대, 회의시간, 참석 인원이 쌍으로 제공된다. 시간대는 오전&nbsp;AM&nbsp;/ 오후&nbsp;PM&nbsp;중에 하나 회의 시간은 1시간부터 4시간까지 참석 인원은 2명부터 20명까지 예시)&nbsp;AM-02-1&nbsp;: 오전 시간대 2명 1시간 /&nbsp;PM-15-2&nbsp;: 오후 시간대 15명 2시간 출력은 콘솔에 회의실별로 시간표를 채워서 출력한다. (아래 동작 예시 참고) 회의실별로 오전 4칸 / 오후 4칸을 채워진 것으로 표시한다. 채워진 상태와 비워진 상태를 표시한다. 회의실은 A, B, C 3곳이고 각각 최대 인원이 정해져 있다.참석 가능한 인원 5명까지참석 가능한 인원 10명까지참석 가능한 인원 20명까지
예약할 때는 인원이 더 적은 회의실부터 우선하여, A &gt; B &gt; C 순으로 예약을 허용한다. 참석 인원이 회의실 인원을 초과하면 예약할 수 없다. 오전이나 오후 4칸이 원하는 시간만큼 남지 않으면 더 이상 회의를 넣을 수 없으며 예약은 실패한다. AM/PM 값이 아니거나 시간 범위, 참석인원 입력 범위가 벗어난 항목은 시간표에 반영하지 않는 예외처리가 필요하다. 그 외에 예약이 불가능한 경우는 하단에 예약 대기를 출력한다. 함수를 사용하며, 별도 타입을 선언하지 않아도 된다. 함수 하나가 10줄 이상 넘어가면 하위 함수로 분리하고, 상위 함수는 하위 함수를 호출한다. 함수 선언 이후에 들여쓰기 단계가 3단계를 초과하는 경우는 함수로 분리한다. 입력값을 받기 위해서 표준 입력 방식을 사용해도 되고, 소스코드 파일 안에서 함수를 호출하면서 입력값을 넣어도 된다. 결과는 VS Code 콘솔에 출력되어야 한다. 최종적으로 콘솔에 출력한 결과를 이미지로 캡처한다. 요구사항을 분석해서 스스로 할 일 체크리스트를 README.md에 작성한다. 체크리스트를 하나씩 완료할 때마다 소스와 실행 결과는 gist에 commit 한다. (Push는 한 번만 해도 무방하다.) 최대한 아래 표 형식을 유지하면서 각자 특색있는 출력 형식으로 꾸며도 된다.
출력값은 다음과 같은 형식으로 고정폭 글꼴을 사용해서 출력하는 게 좋다. 입력값이&nbsp;["AM-03-2"]&nbsp;이면 3명이니까 5명 회의실 A에 오전에 우선 할당한다. |오|전|시|간||오|후|시|간|
----------------------------------
회의실 A|🁢🁢|🁢🁢| | || | | | |
----------------------------------
회의실 B| | | | || | | | |
----------------------------------
회의실 C| | | | || | | | |
입력값이&nbsp;["AM-02-3", "PM-06-2", "AM-11-2", "PM-15-1", "PM-05-1"]&nbsp;라면 다음과 같이 시간표를 출력한다. |오|전|시|간||오|후|시|간|
----------------------------------
회의실 A|🁢🁢|🁢🁢|🁢🁢| ||🁢🁢| | | |
----------------------------------
회의실 B|🁢🁢|🁢🁢| | ||🁢🁢|🁢🁢| | |
----------------------------------
회의실 C| | | | ||🁢🁢| | | |
입력값이&nbsp;["AM-02-3", "PM-06-2", "AM-04-2", "AM-11-2", "PM-15-1", "PM-05-1", "PM-08-3"]&nbsp;라면 다음과 같이 시간표를 출력한다. |오|전|시|간||오|후|시|간|
----------------------------------
회의실 A|🁢🁢|🁢🁢|🁢🁢| ||🁢🁢| | | |
예약대기|🁢🁢|🁢🁢| | || | | | |
----------------------------------
회의실 B|🁢🁢|🁢🁢| | ||🁢🁢|🁢🁢| | |
예약대기| | | | ||🁢🁢|🁢🁢|🁢🁢| |
----------------------------------
회의실 C| | | | ||🁢🁢| | | |
예약대기| | | | || | | | |
----------------------------------
]]></description><link>부스트캠프/챌린지/챌린지-day1_문제.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day1_문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day1_학습저장소용]]></title><description><![CDATA[아무래도 챌린지 첫 날인만큼 너무 긴장하지 말라는 식으로 순수 JS만을 이용한 문제를 내준 것이 아닐까 싶다. 하지만 베이직때보다는 보다 복잡한 로직이 예상되어 각 기능별로 함수를 만들어 코드의 가독성을 높여야 할 것 같았다.
프로그램에서는 표준 입력으로&nbsp;"시간대-참석인원-회의시간"&nbsp;형태로 반복해서 입력받으며 회의실별로 시간표를 출력하고, 다시 입력받는 것을 반복한다. 이 부분은 반복해서 입력받는 과정에서의 예외처리가 중요하다고 생각한다. 무조건 배열은 다 돌아야 하기 때문에 예약이 안되는 상황같은 예외들이 많아질 수 있기 때문이다. 예약 요청은 문자열 배열로 시간대, 회의시간, 참석 인원이 쌍으로 제공된다. 시간대는 오전&nbsp;AM&nbsp;/ 오후&nbsp;PM&nbsp;중에 하나만 가능하다.
회의 시간은 1시간부터 4시간까지 가능하다.
참석 인원은 2명부터 20명까지만 가능하도록 해야한다.
예시)&nbsp;AM-02-1&nbsp;: 오전 시간대 2명 1시간 /&nbsp;PM-15-2&nbsp;: 오후 시간대 15명 2시간 A -&gt; B -&gt; C 순으로 예약
참석 인원이 회의실 인원을 초과하면 예약할 수 없다.
오전이나 오후 4칸이 원하는 시간만큼 남지 않으면 더 이상 회의를 넣을 수 없으며 예약은 실패처리 참석가능인원 : 5 참석가능인원 : 10 참석가능인원 : 20 함수를 사용하며, 별도 타입을 선언하지 않아도 된다. 함수 하나가 10줄 이상 넘어가면 하위 함수로 분리하고, 상위 함수는 하위 함수를 호출한다. 함수 선언 이후에 들여쓰기 단계가 3단계를 초과하는 경우는 함수로 분리한다. 입력값을 받기 위해서 표준 입력 방식을 사용해도 되고, 소스코드 파일 안에서 함수를 호출하면서 입력값을 넣어도 된다. 결과는 VS Code 콘솔에 출력되어야 한다. 최종적으로 콘솔에 출력한 결과를 이미지로 캡처한다. 요구사항을 분석해서 스스로 할 일 체크리스트를 README.md에 작성한다. 체크리스트를 하나씩 완료할 때마다 소스와 실행 결과는 gist에 commit 한다. (Push는 한 번만 해도 무방하다.) 회의실 데이터 구조 설계
회의실 현황 출력 구조 설계
함수 분리해서 설계 분리한 함수가 10줄 이상 넘어가면 하위 함수로 바꾸기
들여쓰기 단계가 3단계를 초과하는 경우 함수로 분리 코드 합쳐 구현하기
회의실 데이터의 구조는 Object로 설정하면 어떨까 싶었다. 어차피 한 시간이 검정색 사각형 두 칸을 똑같이 차지하고, 만약 예약 대기가 생길 경우 이러한 예약들도 기록해놓은 다음 대기중인 예약을 보여줘야 할 기능이 있어야 하기 때문에 이러한 요소들을 console.log할 때는 보다 구조화된 데이터야 출력하기 쉬워질 수 있을 것 같았다. function meetingRoom() { let reservation = { nowAmReservation: [], nowPmReservation: [], otherReservation: { am: [], pm: [] }, }; let A = { person: 5, ...reservation }; let B = { person: 10, ...reservation }; let C = { person: 20, ...reservation };
}
spread연산자를 사용한 이유는 함수 내에 10줄 이상 되지 않아야 한다는 조건이 붙었기 때문에 최대한 코드 수를 줄이고자 이렇게 설계했다.
...
라고 생각하고 나서 회의실 현황 출력 구조를 설계하는데 있어서 이름 속성이 따로 있다면 출력하기 더 편하겠다는 생각이 생겨 이름 속성을 각 미팅룸에 추가하였다.
추가적으로 어차피 출력 구조에서는 예약 현황만 보여주면 되기 때문에 시간만 필요하므로 굳이 오전과 오후 시간을 각각 배열에 넣고 배열을 돌기보다는 시간만 기록하는 것이 더 효율적이겠다 생각했다.function meetingRoom() { let reservation = { nowAmReservation: 0, nowPmReservation: 0, otherReservation: { am: 0, pm: 0 }, }; let A = { name: "A", person: 5, ...reservation }; let B = { name: "B", person: 10, ...reservation }; let C = { name: "C", person: 20, ...reservation };
}
구상한 데이터 구조를 통해 회의실 현황 구조를 함수 내부의 함수 실행을 통해 출력하려고 한다. |오|전|시|간||오|후|시|간|
----------------------------------
회의실 A|🁢🁢|🁢🁢|🁢🁢| ||🁢🁢| | | |
예약대기|🁢🁢|🁢🁢| | || | | | |
----------------------------------
회의실 B|🁢🁢|🁢🁢| | ||🁢🁢|🁢🁢| | |
예약대기| | | | ||🁢🁢|🁢🁢|🁢🁢| |
----------------------------------
회의실 C| | | | ||🁢🁢| | | |
예약대기| | | | || | | | |
---------------------------------- 보면 가장 위의 오전시간과 오후시간 앞 공간은 공백 8칸으로, \t 을 통해 따로 공백을 들이지 않아도 간격을 똑같이 벌릴 수 있다.
오전시간과 오후시간의 경우 |오|전|시|간|과 |오|후|시|간이 각각 붙어있는 것과 같은 형태로 보인다. 그렇기에 나중에 회의실 현황을 입력할 때도 오전시간과 오후 시간을 따로 처리하여 문자열로 붙이는 것이 괜찮을 것이라 판단된다.
각 예약 현황을 보여주는 박스의 경우 배열에 시간의 수 만큼 블록을 만들었다.join하여 사이에 벽을 세워준 후 양쪽에도 |를 붙여 하나의 문자열로 만들고 출력하는 것이 보다 편해보였다.
예약대기의 경우도 똑같이 설계하여 보여주되, 예약 대기의 경우 여러개가 있으면 무슨 웨이팅 대기줄마냥 너무 많아질 수 있기 때문에 예약 대기는 바로 다음에 이용 가능한 시간정도만 받고 이후의 예약 건에 대해서는 예외처리를 해주는 것이 낫다고 판단했다.
const print = () =&gt; { console.log("\t|오|전|시|간||오|후|시|간|"); console.log("----------------------------------"); printReservation(A); console.log("----------------------------------"); printReservation(B); console.log("----------------------------------"); printReservation(C); }; print();
print 함수 자체는 meetingRoom()함수 내에서 출력해야 해당 객체를 안에서 넘길 수 있으므로 내부함수로 구현하였다. 오전시간과 오후시간 구분같은 경우 위에서 말한 대로 \t만큼의 공백만 앞에 가져가고 구분을 직접 넣어주었다.const printReservation = (room) =&gt; { console.log( printPresentReservation( room.name, room.nowAmReservation, room.nowPmReservation ) ); printOtherReservation(room.otherReservation.am || room.otherReservation.pm) &amp;&amp;
console.log(printOtherReservation(room.otherReservation));
};
printReservation은 각 회의실의 객체를 받아 오전시간, 오후시간에 대한 예약 현황을 예약 대기와 현재 현황 모두 출력시켜주는 함수이다.
예약대기의 경우에는 예약이 없을 경우 출력시킬 필요가 없으므로 논리연산자를 통해 조건부로 출렧킬 수 있도록 하였다.const printPresentReservation = (name, am, pm) =&gt; { return `회의실${name} ${makeBlockString(am)}${makeBlockString(pm)}`;
};
금일 예약된 회의실을 출력하는 함수의 경우 name,am,pm의 parameter를 받아 문자열을 받도록 하여 상위함수에서 출력하도록 하였다.
여기서 makeBlockString()은 각 시간대의 블록만큼 채워서 문자열로 리턴해주는 함수이다.const makeBlockString = (rooms) =&gt; { const blank = "| | | | |"; const filledRoom = "🁢🁢"; const blankRoom = " "; if (!rooms || rooms &lt; 0 || rooms &gt; 4) return blank; // Added bounds checking for `rooms` let result = "|"; for (let i = 0; i &lt; 4; i++) { result += (i &lt; rooms ? filledRoom : blankRoom) + "|"; } return result;
};
각 4시간의 블록들을 각각 시간에 따라 블록을 채운 문자열을 반환하는 함수이다.
처음에 해당 함수를 만들 때 여러가지 방법을 생각했다.
배열의 활용 블록으로 배열을 채운 후 join하는 방식을 생각했었지만 공백의 처리가 보다 길어질 것 같아 다른 방식을 물색했다. 문자열의 슬라이싱 blank와 filled변수에 각각 모두 빈, 찬 타임테이블을 할당하고 각각의 변수를 일정 인덱스만큼 슬라이싱 하여 붙이는 방법을 생각했다. 하지만 여기서 인덱스로 접근을 했을 때 다중 바이트 문자열인 블록때문에 인덱스에 맞는 문자열이 나오지 않았다. 직접 하나씩 문자열을 더하는 방법 사실 가장 정석적으로 무난한 방법이라고 생각된다^^,,, 다른 방법을 사용했을 때보다 직접 하나씩 문자열을 더하는 방법이 가장 안전하고 출력 결과를 직관적으로 예상할 수 있어 문자열을 더하는 방식을 선택하였다. const printOtherReservation = (reservation) =&gt; { if (reservation.am || reservation.pm) { return `예약대기${makeBlockString(reservation.am)}${makeBlockString( reservation.pm )}`; }
};
예약 대기 현황 출력해주는 함수의 경우도 똑같이 시간만큼 찬 블록을 문자열로 리턴해주는 함수를 사용하여 전체 문자열을 합친 문자열을 리턴시켰다.
특별한 점이라고 한다면 예약 대기가 오전, 오후 둘 다 없을 경우 따로 출력시켜야 하지 않아야 하기에 조건에 맞는 경우만 리턴시켜 리턴값이 undefined인 경우엔 출력시키지 않도록 하였다.const checkException = (item) =&gt; { let [timeZone, person, time] = item.split("-"); person = parseInt(person); time = parseInt(time); if (timeZone.toLowerCase() !== "am" &amp;&amp; timeZone.toLowerCase() !== "pm") return false; if (person &lt; 2 || person &gt; 20) return false; if (time &lt; 1 || time &gt; 4) return false; return true;
};
checkException 함수는 각 예외 케이스에 대해 검출하는 로직을 가지고 있다. 생길 수 있는 예외는
시간대(am&amp;pm)을 잘못 썼을 때
인원 수가 어떤 회의실에서도 받아줄 수 없을 때
시간이 1 미만 또는 5 이상으로 넣을 수 없는 시간일 때
가 있다. const distributeRoom = (people) =&gt; { if (people &lt;= 5) { return 0; } else if (people &lt;= 10) { return 1; } else if (people &lt;= 20) { return 2; }
};
사람 수가 들어갈 수 있는 조건만 맞다면 A-&gt;B-&gt;C 순으로 들어가라고 나와있었기 때문에 A,B,C 회의실을 배열에 넣고 돌려 처음으로 조건에 맞는 곳에 넣으려고 했지만 마스터 JK님이 A: 0~5, B: 5~ 10, C: 11~20 명으로 생각하라고 하셨다. 사실 현실적으로 보면 대부분 공간이 너무 많이 남는 곳은 빌려주지 않으니 보다 현실주의적인 로직이라고 생각한다.
아무튼 그래서 각 회의실이 어떤 인덱스를 가지는지 알기 때문에 배열로 들어간 회의실 안에 접근할 수 있도록 인덱스 번호를 리턴하였다.
이 외의 경우는 어차피 범위를 넘어가므로 그 전에 예외처리에서 걸러졌기 때문에 상관이 없다.const putPeopleInRoom = (roomArr, timeZone, time, people) =&gt; { let roomName = distributeRoom(people); if (roomArr[roomName][timeZone] + time &lt; 5) { roomArr[roomName][timeZone] += time; } else if (roomArr[roomName].otherReservation[timeZone] + time &lt; 5) { roomArr[roomName].otherReservation[timeZone] += time; }
};
지금 보았는데 변수명이 오해의 소지가 있다. 사람의 수는 조건만 검증하는데 쓰이고 그냥 예약 시간을 추가하는 함수이다.function meetingRoom() { let reservation = { nowAmReservation: 0, nowPmReservation: 0, otherReservation: { am: 0, pm: 0 }, }; let A = { name: "A", person: 5, ...reservation }; let B = { name: "B", person: 10, ...reservation }; let C = { name: "C", person: 20, ...reservation };
}
이전에 스프레드 연산자를 사용하여 다른 예약대기 객체를 함께 복사했었는데, 여기서 문제는 복사가 얇은 복사가 되어 참조값이 공유된다는 점이었다. 이 때문에 예약대기가 모두 같게 나오는 오류가 있었다.
이 때문에 서로 참조값을 공유하지 않은 객체들을 가질 수 있도록 만들어야 했는데, 나같은 경우는 따로 복사를 하기보단 새롭게 객체를 만드는 함수를 썼다.function makeRoom(name) { return { name: name, am: 0, pm: 0, otherReservation: { am: 0, pm: 0 }, };
} function meetingRoom() { let A = makeRoom("A"); let B = makeRoom("B"); let C = makeRoom("C"); let roomArr = [A, B, C]; ...이하생략 }
이를 통해 함수의 라인을 조금 줄일 수 있었고, 보다 가독성이 좋아졌다고 생각한다. function inputInterface() { const regex = /^([AP]M)-(0[1-9]|1[0-9]|2[0-9])-([1-5])$/; const inputs = []; const question = () =&gt; { rl.question( "[AM/PM]-00(인원)-0(시간, 5시간 미만)의 순서대로 시간대-참석인원-회의시간을 적어주세요. \n끝내시려면 q를 입력하세요.", (line) =&gt; { if (line === "q") input(inputs); else if (regex.test(line)) { inputs.push(line); question(); } else { console.log( "입력 형식에 맞지 않습니다.다시 입력해주세요. \n 끝내시려면 q를 입력하세요." ); question(); } } ); }; question(); }
원래는 일반 배열을 함수의 parameter에 넣는 방식으로만 구현했었는데, 후에 체크포인트를 확인하고 입력을 따로 받을 인터페이스가 체크포인트에 들어있어 추가해야 할 필요성을 느꼈다.
이에 inputInterface()함수를 만들어 readline 모듈을 사용한 질문 입력 로직을 구상했다.
질문 입력의 경우
질문을 출력하면서 입력 받기
정규표현식을 통해 받은 입력을 테스트 테스트 통과 시 나중에 함수에 파라미터로 넣을 배열에 push
테스트를 통과하지 못했을 시 다시금 입력 형식에 맞게 입력하도록 출력 이러한 입력은 q버튼을 누를 때까지 q를 입력한 경우를 제외하고 다시금 qustion 함수를 실행시켜 무한반복되도록 설계하였다.
const readline = require("readline"); const rl = readline.createInterface({ input: process.stdin, output: process.stdout,
}); function makeRoom(name) { return { name: name, am: 0, pm: 0, otherReservation: { am: 0, pm: 0 }, };
} function meetingRoom() { let A = makeRoom("A"); let B = makeRoom("B"); let C = makeRoom("C"); let roomArr = [A, B, C]; const print = () =&gt; { let waitingReservation; console.log("\t|오|전|시|간||오|후|시|간|"); console.log("----------------------------------"); waitingReservation = printReservation(A, waitingReservation); console.log("----------------------------------"); waitingReservation = printReservation(B, waitingReservation); console.log("----------------------------------"); waitingReservation = printReservation(C, waitingReservation); }; const input = (item) =&gt; { if (checkException(item)) { let [timeZone, person, time] = item.split("-"); person = parseInt(person); time = parseInt(time); putPeopleInRoom(roomArr, timeZone.toLowerCase(), time, person); } print(); }; function inputInterface() { const regex = /^([AP]M)-(0[1-9]|1[0-9]|2[0-9])-([1-5])$/; const inputs = []; const question = () =&gt; { rl.question( "[AM/PM]-00(인원)-0(시간, 5시간 미만)의 순서대로 시간대-참석인원-회의시간을 적어주세요. \n끝내시려면 q를 입력하세요.", (line) =&gt; { if (line === "q") { print(); process.exit(); } else if (regex.test(line)) { input(line); question(); } else { console.log( "입력 형식에 맞지 않습니다.다시 입력해주세요. \n 끝내시려면 q를 입력하세요." ); print(); question(); } } ); }; question(); } inputInterface();
} const printReservation = (room, waitingReservation) =&gt; { console.log(printPresentReservation(room.name, room.am, room.pm)); if ( room.otherReservation.am || room.otherReservation.pm || waitingReservation ) { console.log(printOtherReservation(room.otherReservation)); return true; }
}; const printPresentReservation = (name, am, pm) =&gt; { return `회의실${name} ${makeBlockString(am)}${makeBlockString(pm)}`;
}; const printOtherReservation = (reservation) =&gt; { return `예약대기${makeBlockString(reservation.am)}${makeBlockString( reservation.pm )}`;
}; const makeBlockString = (rooms) =&gt; { const blank = "| | | | |"; const filledRoom = "🁢🁢"; const blankRoom = " "; if (!rooms || rooms &lt; 0 || rooms &gt; 4) return blank; let result = "|"; for (let i = 0; i &lt; 4; i++) { result += (i &lt; rooms ? filledRoom : blankRoom) + "|"; } return result;
}; const checkException = (item) =&gt; { let [timeZone, person, time] = item.split("-"); person = parseInt(person); time = parseInt(time); if (timeZone.toLowerCase() !== "am" &amp;&amp; timeZone.toLowerCase() !== "pm") return false; if (person &lt; 2 || person &gt; 20) return false; if (time &lt; 1 || time &gt; 4) return false; return true;
}; const putPeopleInRoom = (roomArr, timeZone, time, people) =&gt; { let roomName = distributeRoom(people); if (roomArr[roomName][timeZone] + time &lt; 5) { roomArr[roomName][timeZone] += time; } else if (roomArr[roomName].otherReservation[timeZone] + time &lt; 5) { roomArr[roomName].otherReservation[timeZone] += time; }
}; const distributeRoom = (people) =&gt; { if (people &lt;= 5) { return 0; } else if (people &lt;= 10) { return 1; } else if (people &lt;= 20) { return 2; }
}; meetingRoom(); 구현된 함수들을 조합하여 완성된 형태가 되었다. 이전에는 하나의 함수에 우겨넣는 코드를 짰었는데, 각 함수가 10줄 미만이라는 제한을 가지고 코드를 짜다보니 훨씬 오랜시간이 걸렸지만, 그만큼 설계를 하면서 설계에 대한 감각이 보다 늘은 것 같아 의미 있는 경험이었다.]]></description><link>부스트캠프/챌린지/챌린지-day1_학습저장소용.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day1_학습저장소용.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[챌린지 Day1_학습정리용]]></title><description><![CDATA[
gist 설명에는&nbsp;J041 - Day01&nbsp;처럼&nbsp;캠퍼 ID - Day 숫자&nbsp;형식으로 표기하고 README.md 파일을 생성
gist 화면에서 다음과 같이 Embed 버튼을 눌러서 Clone 주소로 변경한다. Clone via HTTPS로 변경하고 옆에 복사하기 버튼을 누르면 gist의 git 주소를 확인할 수 있다. 다음과 같은&nbsp;git clone {클론할 gist의 git 주소} {클론할 폴더명}&nbsp;형태 명령으로 gist를 클론한다.
git clone https://github.com/e7d4f69b0e0af82xxxxxxx.git day1 이 때 맨 마지막 day1 폴더명을 생략하면 gist id&nbsp;e7d4f69b0e0af82xxxxx&nbsp;값으로 폴더가 생성된다. 폴더명을 안 써도 무방하지만 헷갈릴 수 있으니 폴더명을 지정하는 게 좋다.
로컬에 생긴 폴더에서 새로운 파일을 작성하고 add, commit 해야 한다. 로컬에서 README 파일을 열어서 내용을 수정해 보고 git 명령으로 add, commit 한다. 작업한 파일명과 작업 내용을 기록해야 한다.git status // 확인 //파일 변경하기 git add 파일명 // 추가/변경 파일 git commit -m "커밋 기록용 메시지" // 커밋 아래 push는 한꺼번에 해도 되지만 add와 commit은 작업을 할 때 마다 반복적으로 해야 한다. 파일을 추가하거나 새로운 작업을 할 때 마다 add, commit 을 하는 습관을 만들자.
git push Username for 'https://gist.github.com': {아이디입력}
Password for 'https://{아이디}@gist.github.com': {토큰입력} 이 때 push를 하려면 GitHub 아이디와 권한이 있는 토큰이 필요하다.
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/settings/tokens" target="_self">https://github.com/settings/tokens</a>&nbsp;주소로 이동해서 토큰을 생성하거나 기존의 토큰에서&nbsp;gist&nbsp;관련 권한을 추가해야 한다.
토큰값을 복사하고 push 명령에서 아이디를 입력하고, 패스워드 대신에 복사한 토큰값을 입력한다. 주의 사항: gist 저장소에는 git 저장소와 달리 하위 폴더를 생성하지 못한다. 모든 파일을 하나의 폴더에 올릴 수밖에 없다.
로그인이 되어 있는 경우 그냥 git push 명령어만으로 푸시가 되어 편하다.
원래는 문제를 해결함에 있어서 Class를 선언한 뒤 this키워드를 활용할 계획이었다. 하지만 문제를 읽어보며 함수형으로 해야 한다고 하길래 this라는 키워드가 현재 가르키는 객체를 가리킨다고 하던데, function이 객체로 인식될까 싶었다.function meetingRoom() { data: { } console.log(this);
}
결론부터 말하자면 function은 객체가 아니기 때문에 function 안에 this를 호출하게 되면 html 내의 태그에서는 window객체를 가리킨다.
그냥 터미널에서 실행하게 되는 경우에는 js의 내장메소드를 가지는 객체들을 호출하는 것이 아닌가 싶다.&lt;ref *1&gt; Object [global] { global: [Circular *1], clearImmediate: [Function: clearImmediate], setImmediate: [Function: setImmediate] { [Symbol(nodejs.util.promisify.custom)]: [Getter] }, clearInterval: [Function: clearInterval], clearTimeout: [Function: clearTimeout], setInterval: [Function: setInterval], setTimeout: [Function: setTimeout] { [Symbol(nodejs.util.promisify.custom)]: [Getter] }, queueMicrotask: [Function: queueMicrotask], structuredClone: [Function: structuredClone], atob: [Getter/Setter], btoa: [Getter/Setter], performance: [Getter/Setter], navigator: [Getter], fetch: [Function: fetch], crypto: [Getter]
}
아무튼 function과 this를 사용하여 적절한 객체를 가리키고 싶다면, 객체 안에 함수를 넣고, 그 함수 안에서 this를 통해 객체의 값에 접근하는 것이 바람직하다.
결국 구현에 활용하진 않았지만, 꼭 알아둘 상식이지만 몰라서 다시금 되새기려 정리했다.금일 문제에서 나온 🁢 블록은 다중 바이트 문자이다. 다중 바이트 문자는 문자(또는 다중 바이트 문자는) 한 문자당 1바이트 이상의 바이트를 사용하는 문자들이다. 한국어, 중국어, 일본어 등 많은 언어들이 다중 바이트 문자를 사용한다.다중 바이트 문자인 유니코드는 기존에 영어와 특수문자만 가능했던 과거와는 다르게 모든 나라의 사람들이 이용할 수 있도록 문자의 폭을 넓혔어야 했는데 이를 8비트(0~255)가지로밖에 표현하지 못한다면 한계가 있기 때문에 유니코드를 사용함으로써 가변적으로 바이트를 사용하는 것이다. 하지만 이러한 유니코드는 가변 길이 인코딩 방식인 UTF-8을 통해 인코딩하지 않는 이상 문자를 인코딩하는 과정에서 오류가 발생할 가능성이 높으며, 특히 슬라이싱에서 많이 나타난다.나의 경우도 블록을 채우는 문자열을 만드는 과정에서 |🁢🁢|🁢🁢|🁢🁢|🁢🁢|로 된 문자열을 슬라이싱하는 과정에서 물음표가 뜨는 오류를 맞았다. 분명 내가 설계한 인덱스가 맞았는데도 하나하나 인덱스를 검사해보니 인덱스 자체를 유니코드가 포함되어있어 잘못 해석되었다. 앞으로도 유니코드를 사용함에 있어서 꼭 UTF-8로 인코딩한 후에 사용하자.readline 모듈은 데이터를 한 줄씩 읽으면서 읽을 수 있는 스트림의 인터페이스를 제공하는 모듈이다.
해당 API는 동기/비동기 기반 모두 따로 사용가능하다.// 비동기 promise 기반
const readline = require('node:readline/promises');
// 콜백과 동기처리 기반
const readline = require('node:readline');
const readline = require('node:readline');
const { stdin: input, stdout: output } = require('node:process'); // 인터페이스 생성자
const rl = readline.createInterface({ input, output }); rl.question('What do you think of Node.js? ', (answer) =&gt; { // TODO: Log the answer in a database console.log(`Thank you for your valuable feedback: ${answer}`); rl.close();
});
동기 기반 readline 사용은 콜백함수를 두번째 파라미터로 넣어 해당 데이터 스트림이 콜백함수 안으로 들어가는 구조를 지닌다.const readline = require('node:readline/promises')
const { stdin: input, stdout: output } = require('node:process'); const rl = readline.createInterface({ input, output }); const signal = AbortSignal.timeout(10_000); signal.addEventListener('abort', () =&gt; { console.log('The food question timed out');
}, { once: true }); const answer = await rl.question('What is your favorite food? ', { signal });
console.log(`Oh, so your favorite food is ${answer}`);
반면 비동기 기반 readline의 사용은 Promise를 사용하기 때문에 await키워드를 사용하여 비동기적으로 들어오는 질문에 대해 동기적으로 처리할 수 있다.]]></description><link>부스트캠프/챌린지/챌린지-day1_학습정리용.html</link><guid isPermaLink="false">부스트캠프/챌린지/챌린지 Day1_학습정리용.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[스크린샷 2024-07-23 오전 1.18.51]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-23-오전-1.18.51.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-23-오전-1.18.51.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-23 오전 1.18.51.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-23-오전-1.18.51.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-23-오전-1.18.51.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 4.11.30]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.11.30.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.11.30.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 4.11.30.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.11.30.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.11.30.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 4.13.14]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.13.14.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.13.14.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 4.13.14.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.13.14.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.13.14.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.54.32]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.54.32.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.54.32.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.54.32.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.54.32.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.54.32.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.52.17]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.52.17.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.52.17.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.52.17.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.52.17.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.52.17.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.44.03]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.44.03.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.44.03.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.44.03.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.44.03.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.44.03.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.48.39]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.48.39.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.48.39.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.48.39.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.48.39.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.48.39.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.50.34]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.50.34.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.50.34.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.50.34.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.50.34.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.50.34.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.36.40]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.36.40.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.36.40.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.36.40.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.36.40.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.36.40.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.39.37]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.39.37.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.39.37.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.39.37.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.39.37.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.39.37.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.40.46]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.40.46.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.40.46.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.40.46.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.40.46.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.40.46.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.29.30]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.29.30.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.29.30.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.29.30.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.29.30.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.29.30.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2024-07-21 오후 3.35.33]]></title><description><![CDATA[<img src="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.35.33.png" target="_self">]]></description><link>부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.35.33.html</link><guid isPermaLink="false">부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.35.33.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.35.33.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.35.33.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[가상 메모리]]></title><description><![CDATA[컴퓨터 시스템에 실제로 이용 가능한 기억 자원을 이상적으로 추상화하여 사용자들에게 큰 메모리로 보이게 하는 것으로 적은 메모리로 여러 프로세스를 실행시키기 위한 시스템ㅈㅈㅈ
<img src="https://i.imgur.com/NLOpua6.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
가상적으로 주어진 주소 -&gt; 가상주소
가상 주소에 매핑된 실제 주소 -&gt; 물리주소<br>
<img src="https://i.imgur.com/yuKB1C2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
가상 주소가 메모리 관리 유닛(MMU)를 통해서 물리 주소로 매핑됨크기가 동일한 페이지로 가상 주소 공간과 매칭하는 물리 주소 공간 관리]]></description><link>부스트캠프/챌린지/가상-메모리.html</link><guid isPermaLink="false">부스트캠프/챌린지/가상 메모리.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/NLOpua6.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/NLOpua6.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[릴레이노트]]></title><description><![CDATA[✔️&nbsp; 퀘스트 :&nbsp;과제를 진행하기 전에 과제를 세분화 하여 시간계획을 세운 뒤 과제 진행하기✔️&nbsp;의도 : 계획을 짜는 것 또한 개발자의 중요한 능력이다. 계획을 짜며 본인의 능력치를 파악해보자
✔️&nbsp;수행 기준
계획 하기 : 체크리스트 작성, 사전 지식 학습 , 구현, readme작성 등 세부 Task를 정하여 Task 당 할당 시간을 정한다.
수행 하기 : 각 Task들에 얼마나 시간이 소요되었는지 측정한다. (최대한 계획한것과 비슷하게 수행한다.
분석하기 : 계획과 수행 사이에서 발생한 시간 차이가 왜 났는지 분석한다.
]]></description><link>부스트캠프/챌린지/릴레이노트.html</link><guid isPermaLink="false">부스트캠프/챌린지/릴레이노트.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[릴레이프로젝트]]></title><description><![CDATA[
- 모든 상황에서 완벽한 단 한가지 방법은 과학자들이 찾는 수식에만 있다.
- 그 수식을 현실에서 구현할 때 주어진 환경에 따라 다양한 해결 방법이 있고 우리는 이를 다양하게 시도해 보면서 답을 찾아나가야 하는데, 자신의 익숙한 환경에서 문제를 해결하려고 하면 사고의 폭이 줄어들어 결국 제대로 된 해결을 하지 못한다.
- 나 또한 이번 짝프로그래밍에서 내가 생각한 설계방식 하에서만 생각하다가 계속 막혔었는데, 짝과 함께 서로의 의견을 공유하고 수용하면서 보다 내 기준에서 벗어나 다양한 해결방법에도 접근한 결과 해결이 될 수 있어 공감된 경험이었다. 의도한 실수를 반복하면서 작은 부분 개선
결과를 향하면서 과정을 기록
남을 향한 자존심을 버리고, 나를 향한 자존감 채우기
개구리를 해부하지 말고 직접 만들기
낯선 방식으로 해결하기
두리번거리면서 속력과 방향을 자주 확인하기 어떤 구절이 가장 인상깊었고, 이유가 무엇인가요?
부스트캠프에서 책 내용과 비슷한 경험을 해본적이 있나요?
토론하고 싶은 내용이 있다면 토론도 좋습니다.
이해가 안된 부분이 있다면 이야기 나눠보세요.
그 외 내가 해석한 내용을 나눕니다.
]]></description><link>부스트캠프/챌린지/릴레이프로젝트.html</link><guid isPermaLink="false">부스트캠프/챌린지/릴레이프로젝트.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[무제 파일]]></title><link>부스트캠프/챌린지/무제-파일.html</link><guid isPermaLink="false">부스트캠프/챌린지/무제 파일.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[aws ssa]]></title><description><![CDATA[<a data-href="MFA" href="부스트캠프/챌린지/mfa.html#_0" class="internal-link" target="_self" rel="noopener nofollow">MFA</a>]]></description><link>부스트캠프/챌린지/aws-ssa.html</link><guid isPermaLink="false">부스트캠프/챌린지/aws ssa.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[sql 기본문법]]></title><description><![CDATA[SQL(Structured Query Language) 는 관계형 데이터베이스에 정보 저장 및 처리에 용이한 프로그래밍 언어이다.
관계형 데이터베이스는 정보를 표 형태로 저장하며, 행과 열을 통해 데이터 속성과 데이터 값 간의 다양한 관계를 나타낸다.데이터베이스를 데이터의 집합이라고 한다면, DBMS(데이터베이스 관리 시스템)은 이러한 데이터베이스를 관리하고 운영할 수 있는 소프트웨어이다. 정보에 대해서
다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합
사용자 또는 다른 프로그램의 요구를 처리하고 적절히 응답하여 데이터를 사용할 수 있도록 해준다.
자료의 통합성 증진
데이터의 접근성 용이
데이터 통제 강화
애플리케이션 프로그램 개발 및 관리 용이
보안 강화 계층형(Hierarchical)<img src="https://i.imgur.com/F0m6agz.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 트리 형태를 갖는 계층형 구조
현재는 사용 X <br>망형(Network)<img src="https://i.imgur.com/tZMMoSx.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 하위에 있는 구성원끼리도 연결된 구조
현재는 사용 X <br>관계형(Relational) <img src="https://i.imgur.com/3ETG6Gc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 테이블(table)이라는 최소 단위로 구성
테이블은 하나 이상의 열과 행으로 이루어짐 객체지향형(Object-Oriented)
객체관계형(Object-Relational) MYSQL Oracle에서 제공하는 오픈 소스 관계형 데이터베이스 관리 시스템 NOSQL 테이블을 사용하여 데이터를 저장하지 않는 비관계형 데이터베이스
수평 확장(NOSQL 소프트웨어를 실행하는 컴퓨터의 추가)이 가능하여 최신 애플리케이션에 많이 사용됨 Microsoft SQL Server SQL로 데이터를 조작하는 마이크로소프트의 관계형 데이터베이스 관리 시스템 PostgreSQL
DB2
ACCESS
SQLite
-- USE '스키마명'
USE mh_db
-- SELECT '컬럼명' FROM '테이블명'
SELECT member_id, name FROM member; -- SELECT 와 FROM 사이에 *를 적으면 테이블의 모든 컬럼을 조회한다.
SELECT * FROM member; -- 두 SQL은 동일한 기능
SELECT * FROM market_db.member;
SELECT * FROM member;; -- 논리연산자 사용 가능
SELECT TRUE OR FALSE AND FALSE; // 1 SELECT (TRUE OR FALSE) AND FALSE; // 0
-- between을 통한 범위 표현
SELECT * FROM member WHERE height between 160 and 165
-- mem_name 컬럼 값이 '블'로 시작하는 4글자 글자 데이터 조회
SELECT * FROM member WHERE mem_name LIKE '블___'; -- mem_name 컬럼 값이 '블'로 시작하는 모든 데이터 조회
SELECT * FROM member WHERE mem_name LIKE '블%'; -- mem_name 컬럼 값에 '블'이 들어가는 모든 데이터 조회
SELECT * FROM member WHERE mem_name LIKE '%블%'; 글자_ -&gt; 글자로 시작, 언더바의 수에 따라 글자 지정
글자% -&gt; 해당 글자로 시작하는 모든 데이터 조회
%글자% -&gt; 값에 해당 글자가 들어가는 모든 데이터 조회
-- member 테이블에서 mem_number 컬럼 값이 5이상인 데이터 조회
SELECT * FROM member WHERE mem_number &gt;= 5;
-- addr 컬럼값이 경기, 전남, 경남인 데이터 조회
SELECT * FROM member WHERE addr IN('경기', '전남', '경남'); SELECT * FROM member WHERE addr = '경기' OR addr = '전남' OR addr = '경남';
SELECT mem_name, height FROM member WHERE height &gt; (select height from member where mem_name LIKE '에이핑크');
2개의 SQL문을 하나로 만들기-- debut_date 값을 기준으로 정렬 (기본 ASC)
SELECT * FROM member ORDER BY debut_date; ASC -&gt; 오름차순(기본값)
DESC -&gt; 내립차순
-- height 컬럼 값이 164 이상인 데이터를 조회하여 -- height 값 기준 내림차순 정렬하고 동일한 값이라면 debut_date 값 기준 오름차순 정렬
SELECT * FROM member WHERE height &gt;= 164 ORDER BY height DESC, debut_date;
SELECT * FROM member LIMIT 3; -- 상위 3건만 조회 SELECT * FROM member LIMIT 3, 2; -- 3번째 데이터부터 2건만 조회 LIMIT 2 OFFSET 3; -- 위와 동일 LIMIT 시작, 개수
처음부터 N까지의 데이터만 가져옴
LIMIT와 OFFSET 조합으로도 출력 개수 제한 가능
-- addr 의 모든 컬럼 값을 중복을 제거하여 조회
SELECT DISTINCT addr FROM member;
DISTINCT를 열 이름 앞에 붙이면 중복된 값은 1개만 출력-- mem_id가 같은 데이터를 그룹으로 묶음
-- 그룹핑된 데이터에서 mem_id와 amount의 합계를 구함
SELECT mem_id, SUM(amount) AS "합계" FROM buy GROUP BY mem_id ORDER BY mem_id; SUM() 컬럼의 합계
AVG() 컬럼의 평균
MIN() 컬럼의 최소값 반환
MAX() 컬럼의 최대값을 반환
COUNT() 행의 개수(NULL 값 포함)
COUNT(DISTINCT) : 행의 개수 (NULL값 비포함)
-- 집계 함수 안에서 연산도 가능
SELECT mem_id, SUM(amount*price) AS "총 금액" FROM buy GROUP BY mem_id ORDER BY mem_id;
-- mem_id 를 기준으로 그룹화
-- 그룹화된 데이터를 기준으로 amount*price 합계가 1000 이상인 그룹만 남김
-- 조건에 걸러진 그룹에서 amount*price 의 합계를 조회
SELECT SUM(amount*price) AS "총 금액" FROM buy GROUP BY mem_id HAVING SUM(amount*price) &gt;= 1000;
]]></description><link>부스트캠프/챌린지/sql-기본문법.html</link><guid isPermaLink="false">부스트캠프/챌린지/sql 기본문법.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/F0m6agz.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/F0m6agz.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[TCP-IP]]></title><description><![CDATA[전송프로토콜 TCP(Tansmission Control Protocol)와 인터넷 프로토콜(Internet Protocol)을 합친 말. 인터넷 &amp; 이와 유사한 컴퓨터 네트워크 사이에서 정보를 주고받는데 이용되는 통신 프로토콜의 모음으로, 온라인상의 안전하고 효율적인 데이터 전송의 표준화된 요건이다.TCP는 한 기기에서 다른 기기로 데이터를 전송할 때 필요한 표준 요건이라면, IP는 데이터들을 최대한 빨리 대상 IP 주소로 보내는 역할을 위한 표준 요건이다. 이러한 TCP/IP는 공통적으로 온라인상의 안전하고 효율적인 데이터를 전송한다는 공통적 결과를 목표로 하기 때문에 합쳐져 사용된다. 이러한 TCP/IP가 규칙이나 프로토콜이 적용되는 조건 하에서 세워진 통신과 데이터 전송의 방식이 4가지의 계층으로 나누어진다.<img src="https://i.imgur.com/U7Ok7UJ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
사용자가 상호작용하기 가장 쉬운 계층
사용자가 네트워크에 접근할 수 있는 인터페이스 제공
종류 메일 -&gt; SMPT(Simple Mail Transfter Protocol)
인터넷 브라우저 -&gt; HTTP(Hypertext Transfer Protocol)
파일 전송 -&gt; FTP(File Transfer Protocol)
동적 호스트 설정 통신 -&gt; DHCP(Dynamic host Configuration protocol)
간이 망 관리 -&gt; SNMP(Simple Network Management Protocol)
도메인 -&gt; DNS(Domain Name System) 데이터의 전송을 담당하는 계층으로,TCP 뿐만 아니라 사용자 데이터그램 통신 규약(User Datagram Protocol: UDP)도 있음
TCP는 두 네트워크 사이에 연결을 형성하고 효율적 작업을 위해 데이터를 작은 패킷으로 나눠서 데이터를 전송
데이터의 전달을 보증하고 보낸 순서대로 받게해줌
- 순서가 맞지 않거나 중간에 뭐가 빠졌으면 점검 요청
\ IP뿐만 아니라 주소 변환 규약(Address Resolution Protocol: ARP) 인터넷 그룹 관리 프로토콜(Internet Group Management Protocol: IGMP)\
인터넷 제어 메세지 프로토콜(Internet Control Message Protocol: ICMP)도 있음 데이터의 원천지(origin)와 목적지에 관한 정보 첨부
패킷 전달 여부를 보증하지 않고, 어떻게든 빨리 보내야 함 데이터 전송의 최하위 계층
데이터가 원하는 IP 주소에 도달할 뿐만 아니라 해당 네트워크 내의 연결된 기기에 연결되어 있는지 확인
원하는 기기의 MAC 주소를 확인하고 이더넷 케이블 및 와이파이를 통한 데이터 전송 관리 등의 작업 담당
<br><img src="https://i.imgur.com/YHmZe4I.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
송신측 클라이언트의 애플리케이션 계층에서 어느 웹 페이지를 보고 싶다라는 HTTP 요청을 지시
그 다음에 있는 트랜스포트 계층에서는 애플리케이션 계층에서 받은 데이터(HTTP 메시지)를 통신하기 쉽게 조각내어 안내 번호와 포트 번호(TCP 패킷)를 붙여 네트워크 계층에 전달
네트워크 계층에서 데이터에 IP 패킷을 추가해서 링크 계층에 전달
링크 계층에서는 수신지 MAC 주소와 이더넷 프레임을 추가
이로써 네트워크를 통해 송신할 준비가 됨
수신측 서버는 링크 계층에서 데이터를 받아들여 순서대로 위의 계층에 전달하여 애플리케이션 계층까지 도달
수신측 애플리케이션 계층에 도달하게 되면 클라이언트가 발신했던 HTTP 리퀘스트를 수신할 수 있다. 시스템 사이에서 파일 전송
원격 시스템에 로그인
원격 시스템에서 명령 실행
원격 시스템에 파일 인쇄
원격 사용자에 이메일 전송
원격 사용자와 대화식 통신
네트워크 관리 패킷 데이터의 전달을 보증하고 보낸 순서대로 받게 해준다
도착한 조각을 점검하여 줄을 세우고 망가졌거나 빠진 조각을 다시 요청하는 식으로 순서를 보증.
TCP는 데이터를 상대방에게 확실하게 보내기 위해서&nbsp;3 way 핸드쉐이킹이라는 방법을 사용하고 있다. 이 방법은 패킷을 보내고 잘 보내졌는지 여부를 상대에게 확인하러 간다.
여기에서 고유의 'SYN'와 'ACK'라는 TCP 플래그를 사용한다. (일종의 확인 마크 정도로 이해하면 된다)
한마디로 TCP는 IP의 문제를 보완해주는 녀석이라고 보면 된다.
상대 클라이언트와 연결되기 전에 가상 연결을 하여 패킷으로 보내 확인하는 동작<br>
<img src="https://i.imgur.com/JftQwrz.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
클라이언트 -&gt; 서버 SYN : 연결을 생성할 때 클라이엍느가 서버에 시퀀스 번호를 보냄 서버 -&gt; 클라이언트 SYN-ACK : 시퀀스 번호를 받은 서버가 ACK 값을 생성하여 클라이언트에게 응답 다시 클라인언트 -&gt; 서버 ACK : ACK 값을 사용하여 응답하는 패킷
데이터 패킷 이후: 클라이언트 -&gt; 서버 데이터 패킷 전송 <br><img src="https://i.imgur.com/yNrYr50.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">3 way shake에서 통신을 마칠 때 거치는 과정이 추가된 버전이다.<br><img src="https://i.imgur.com/Ir6TBSH.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Segment에 있는&nbsp;첫 번째 바이트의 바이트 스트림 번호 TCP는 데이터를 단지 순서대로 정렬되어 있는 바이트 스트림으로 본다.
ex) 0~999, 1000~1999의 Segment를 보낼 때 seq# = 각각 0, 1000 TCP 연결, 종료 시에는&nbsp;Sequence Number를 임의의 랜덤 값으로 설정한다. Sequence Number가 노출되면 공격자가 위조 패킷을 보낼 수 있어 보안을 위해 랜덤 값으로 설정한다. 받고 싶은 다음 바이트 번호 ex) 0~999, 1000~1999의 Segment를 받았을 때 ack# = 각각 1000, 2000 ACK(Acknowledgement) 패킷을 받았다는 응답을 할 때 사용
Acknowledgement Number의 유효성
최초 연결의 첫 번째 세그먼트를 제외한 모든 Segment의 ACK 비트는 1로 설정 FIN(Finish) TCP 연결을 종료할 때 사용
더 이상 전송할 데이터가 없음을 의미 RST(Reset) TCP 연결을 강제로 종료할 때 사용
비 정상적인 세션 연결 끊기에 해당
연결을 즉시 끊고자 할 때 사용 ]]></description><link>부스트캠프/챌린지/tcp-ip.html</link><guid isPermaLink="false">부스트캠프/챌린지/TCP-IP.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/U7Ok7UJ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/U7Ok7UJ.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[TELNET과 SSH]]></title><description><![CDATA[로컬 영역이나 인터넷에 있는 원격 시스템의 가상 터미널을 제공하는 클라이언트와 서버간 응용 프로토콜
Telnet(텔넷)을 이용하면 네트워크에 있는 컴퓨터를 자신의&nbsp;컴퓨터처럼 파일 전송, 파일 생성, 디렉토리 생성 등을 자유롭게 할 수 있다.Telnet 클라이언트는 사용자의 컴퓨터에 실행되며, 원격 서버에 접속하여 커맨드를 전송하고 결과를 받아옵니다. 이를 통해 원격 컴퓨터에서 마치 로컬 컴퓨터에서 작업하는 것처럼 명령어를 실행할 수 있습니다.
TCP/IP 기반의 프로토콜
원격 터미널 접속 서비스
TCP 23번 포트(Default)
보안성을 위해 사용자가 포트 변경 가능 보안에 취약 Telnet은 데이터를 암호화하지 않고&nbsp;평문(바이트 스트림) 으로 전송하기 때문에 네트워크 상에서&nbsp;데이터가 노출되거나 가로채질 위험이 있음
또한 사용자 인증 정보(예: 비밀번호)도 평문으로 전송되어 보안 위험이 있음 기능적 부족 원격 작업을 위한&nbsp;기본적인 기능만 제공하며, 고급 기능이나 파일 전송 등의 다양한 기능을 제공하지 않습니다. 이러한 이유로, 현재는 대부분의 경우 SSH(Secure Shell)와 같은 보안이 강화된 프로토콜을 사용한다.SSH(Secure Shell)은 다른 사용자가 세션을 엿듣지 못하도록 세션을 감싸주는 Telnet 응용프로그램으로 보안버전의 프로그램이다. TCP 상에 보안 채널(터널링)을 형성하여 안전한 데이터 교환이 이루어질 수 있도록 만든 버전이다.패스워드와 같은 민감정보들이 암호화된 채로 전송되기 때문에 보안에 적합하며, 기본포트번호는 22번을 사용한다. 보안 과정에서 SSH는 기존 telnet과는 다르게 KEY를 사용하여 연결 상대를 인증하고 안전하게 데이터를 주고받을 수 있도록 한다. 이 KEY를 생성하는 방식은 두 가지가 있는데, '대칭키'와 '비대칭키(공개키)' 를 사용한다.맨 처음 접속을 하는 과정에서 사용자와 서버는 서로의 정체를 증명해야 한다. 여기서 사용되는 것이 비대칭키 방식이다.
비대칭키에서는 서버나 사용자가 Key pair 를 생성한다. 이 키 페어는 공개 키(public key)와 개인 키(Private Key)로 이루어져 있으며, 공개키는 .pub / 개인 키는 .pem 의 파일 형식을 가진다.여기서 중요한 점은 공개 키가는 누구나 가질 수 있지만, 개인 키는 공개 키 하나에 1:1 매핑되어있는 관계이기 때문에 함께 생성된 개인 키와 공개 키만 서로 해석이 가능하다.따라서 서버는 사용자로부터 전송받은 공개 키를 자신이 가지는 개인 키와 비교하고, 두 값이 같게 되면 서버는 자신이 기억하고 있는 사용자가 맞음을 판단하고 접속을 허용해주게 되는 것이다. 이러한 방식으로 최초 접속 시에 인증 절차가 완료된다.대칭키의 경우는 비대칭키를 통해 사용자와 서버 간의 인증이 완료된 후, 데이터를 주고받을 때 사용되는 키 방식이다.
대칭키 방식에서는 비대칭키 방식과 달리 하나의 대칭 키만을 사용하는데, 이 대칭 키는 사용자와 서버가 각자 만들어 공유한다.
이 공유하는 대칭 키로 사용자가 데이터를 암호화해서 전송하면, 서버에선 이 대칭키를 똑같이 사용해서 암호를 푼 다음 데이터를 얻을 수 있다.
이러한 대칭 키는 정보 교환때마다 계속해서 갱신된다.두 프로토콜의 차이점은 로그인, 프로그램 실행, 하드디스크 체크, 로그아웃 등의 작업에서 이루어지는 사용자와 서버간의 통신 방법이다.
사용자는 어떤 작업을 서버에 알려주기 위해 네트워크를 통해 TCP/IP 패킷정보를 전달하고 결과값을 다시 서버에서 받게 되는데, 이 과정에서 telnet은 정보를 byteStream으로 받지만, SSH의 경우는 DES, RSA 등 고급 암호화를 통해 통신을 하여 보안에 가장 큰 차이점이 있다.
하지만 이 과정에서 SSH가 조금 더 많은 오버헤드가 발생한다는 점이 있지만, 보안을 보완해준다는 점에서 이러한 단점을 상쇄한다.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@jeongbeom4693/SSH%EC%99%80-Telnet" target="_self">https://velog.io/@jeongbeom4693/SSH%EC%99%80-Telnet</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://dev-kwon.tistory.com/88" target="_self">https://dev-kwon.tistory.com/88</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@froajnzd/%EC%9B%90%EA%B2%A9-%EC%A0%91%EC%86%8D%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95-2%EA%B0%80%EC%A7%80-SSH-TELNET" target="_self">https://velog.io/@froajnzd/%EC%9B%90%EA%B2%A9-%EC%A0%91%EC%86%8D%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95-2%EA%B0%80%EC%A7%80-SSH-TELNET</a>]]></description><link>부스트캠프/챌린지/telnet과-ssh.html</link><guid isPermaLink="false">부스트캠프/챌린지/TELNET과 SSH.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Pasted image 20240723210202]]></title><description><![CDATA[<img src="부스트캠프/챌린지/pasted-image-20240723210202.png" target="_self">]]></description><link>부스트캠프/챌린지/pasted-image-20240723210202.html</link><guid isPermaLink="false">부스트캠프/챌린지/Pasted image 20240723210202.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/pasted-image-20240723210202.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/pasted-image-20240723210202.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20240726011348]]></title><description><![CDATA[<img src="부스트캠프/챌린지/pasted-image-20240726011348.png" target="_self">]]></description><link>부스트캠프/챌린지/pasted-image-20240726011348.html</link><guid isPermaLink="false">부스트캠프/챌린지/Pasted image 20240726011348.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/pasted-image-20240726011348.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/pasted-image-20240726011348.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pub-Sub 패턴]]></title><description><![CDATA[<img src="https://i.imgur.com/pwO2e66.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
발행-구독 패턴은 옵저버 패턴과 비슷하지만 조금 다른 점이 특징인 디자인패턴이다.
옵저버 패턴이 한 객체의 상태가 바뀔 때 그 객체에 의존하는 다른 객체들에게 알림이 가고 자동으로 정보가 갱신되는 1:N의 강한 관계를 가졌다면, Pub-sub패턴은 이보다는 느슨한 관계를 가지는 디자인 패턴이다.이 디자인 패턴은 비동기 메세징 패러다임으로 ,발행자인 Publisher가 있고, 이벤트에 대해서 구독중인 Subscriber가 있으며 그 둘 사이에는 Message Broker가 존재한다.Message Broker는 Publisher가 발행하는 이벤트에 대해서 관리하고, 만약 이벤트를 호출하게 된다면 Message Broker를 통해 정해진 범주에 따라 구독을 신청한 수신자에게 전달을 하는 역할이다. 이 과정에서 메시지 큐가 브로커의 역할을 수행하며, 구독과 발행 이후의 메시지를 처리해준다.따라서 발행자가 어떠한 이벤트를 발생시키거나 구독자가 어떤 이벤트에 대해서 구독한 뒤의 일은 모두 메시지 브로커가 일임하여 던져져 있는 구독과 발행을 보고 알아서 메시지를 처리하기 때문에 옵저버 패턴과 가장 큰 차이점으로 발행자와 구독자가 서로를 몰라도 소통이 가능하다는 점이기도 하다.이 외에도 차이점은
옵저버 패턴보다 더 낮은 결합도
옵저버 패턴은 동기적으로 동작하지만 발행구독 패턴은 비동기적으로 동작
옵저버 패턴 단일 도메인에서 동작하며 발행구독 크로스 도메인 상황에서도 동작이 가능
옵저버 패턴보다 코드 관리, 재사용성, 안정성이 높음
등이 있다.
이러한 메시지 브로커에 있는 메시지 큐의 경우 메시지 지향 미들웨어 (MOM : Message Oriented Middleware, 비동기 메시지를 사용하는 응용 프로그램 간 데이터 송수신)로 구현한 시스템으로, 대용량 데이터 처리를 위한 배치 작업이나 채팅 서비스, 비동기 데이터 처리 등에 이용된다. 비동기(Asynchronous) : 큐에 넣어서 나중에 처리 가능
비동조(Decoupling) : 앱과 분리 가능
탄력성(Resilience) : 일부 실패가 전체에 영향을 끼치지 않음
과잉(Redunadancy) : 실패할 경우 재실행 가능
보증(Guarantees) : 작업 처리 확인 가능
확장성(Scalable) : 다수 프로세스들이 큐에 메시지 보내기 가능
하지만 이러한 메시지 큐의 단점으로는 큐이기 때문에 결국 뒤에 있는 메시지의 경우 구독자에게 가기 까지 과도한 트래픽에 따라 지연이 많이 발생할 수도 있다는 점이 있다.]]></description><link>부스트캠프/챌린지/pub-sub-패턴.html</link><guid isPermaLink="false">부스트캠프/챌린지/Pub-Sub 패턴.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/pwO2e66.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/pwO2e66.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ReactiveX]]></title><description><![CDATA[<img src="https://i.imgur.com/KIy6A9K.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
A→B를 호출하고 리턴받는 타입이 T타입이라고 할 때, getData() → T라고 말할 수 있음 이러한 방식을 sync방식으로 리턴 타입이 하나인 경우 표시 가능 동기 방식으로 A→B를 호출했는데 넘겨주는 값이 여러개라면, 이를 탐색할 수 있는 타입이라면 getDate() → Iterable[T] 처럼 리턴받는 타입을 선언해줄 수 있음
비동기 방식으로 처리하게 되면, A→ B를 호출했는데, 비동기적으로 언젠가 나중에 T라는 타입을 받을 수 있다고 하면, getData() → Future[T] 처럼 언젠가 받을 수 있음을 Future, Promise 등으로 선언해놓을 수 있음
ReactiveX는 비동기로 호출하는데 여러번 비동기로 호출되는 구조도 가능하다는 컨셉으로, 동기 처리의 여러 항목들에 대해 비동기 방식으로 확장한 개념 이를 getData() → Obeserable[T] 처럼 표현함 <br><img alt="스크린샷 2024-07-31 오전 1.13.48.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/bdbbb5cf-6e96-44bd-8fb9-def0a4efd9d7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-31_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.13.48.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">한번만 호출하기 때문에 Push single로 볼 수 있음<br><img alt="스크린샷 2024-07-31 오전 1.14.20.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/677dbf30-447b-4dc6-b7bc-aa0f63ce223b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-31_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.14.20.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
context1이 context2에 비동기함수를 실행하여 바로 리턴됨
이 과정에서 바인딩(binding) 을 해놓으면, 해당 비동기 호출에 대해 n번, 즉 여러번 호출이 가능함
네트워크를 요청하거나, 이벤트가 여러번 발생하거나, 다운로드 등의 행위
이러한 부분에 대해 앞으로는 이러한 API들이 생길 수 있다고 상정하는 것이 ReactiveX의 사상
<br><img alt="스크린샷 2024-07-31 오전 1.16.44.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/062ac52e-f8ed-458b-ab43-0973597cc528/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-31_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.16.44.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Observable[T]는T라는 타입을 가지고 여러번 호출할 때마다 Observable하는 애들이 subscribe해서 호출하도록 만듦
RX는 바인딩을 통해서 계속해서 다음 이벤트가 올 때마다 subscribe를 통해서 클로저를 전달받는 형태
즉 클로저를 여러번 호출하는 형태
]]></description><link>부스트캠프/챌린지/reactivex.html</link><guid isPermaLink="false">부스트캠프/챌린지/ReactiveX.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/KIy6A9K.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/KIy6A9K.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day13_학습정리]]></title><description><![CDATA[
작업 디렉토리 실제 파일이 이루어진 곳 Staging area 영구적으로 저장하기 위해 Staging area에 저장하고 싶은 파일들의 정보를 등록
git add 를 통해 작업 디렉토리의 파일들을 staging area에 올려놓을 수 있음 이 때 작업 디렉토리의 파일을 옮기는 것이 아닌, 복사하는 것.
작업 디렉토리의 파일을 수정해도 Staging area의 파일에는 반영되지 않음 Head(Git Directory) Staging Area에 있는 파일들을 가지고 최종 확정본(commit)을 만들어 커밋을 완료 staged staging area에 있는 파일들
staging area에 있는 파일들을 커밋하게 되면 해당 파일들은 하나의 커밋으로 저장된 후 파일의 상태는 unmodified로 내려오게 됨
staging area에서 staged된 상태의 파일 tracking 파일을 추적하여 파일의 변경을 사용자에게 알려줌 untracked 추적되지 않는 상태 modified unmodified 상태의 파일들을 수정하게 되면 변하는 상태
파일의 변경이 이루어짐 안전한 해시 알고리즘의 표준
'SHA-256'은 Secure Hash Algorithm 256-bit의 줄임말로, 암호학적 해시&nbsp;함수 중 하나
해시 함수 → 임의의 크기를 가진 데이터를 고정된 크기의 해시 값으로 변환하는 함수
SHA-256은 256비트(32바이트) 길이의 해시 값을 생성하며, 주로 데이터 무결성 검증, 메시디 인증 코드(MAC) 생성, 비밀번호 저장 등 다양한 보안 관련 작업에 사용된다.SHA-256은 입력 데이터의 작은 변화에도 큰 차이를 만들어내기 때문에 데이터의 무결성을 확인하는 데 유용하다.
SHA-256은&nbsp;일방향 해시 함수이므로, 해시 값을 통해&nbsp;원래 데이터를 복원할 수는 없음.따라서 주로 비밀번호의 안전한 저장과 비교, 파일의 무결성 검사 등에 활용된다.
우리가 깃은 협업관리 툴로 많이 쓰지만 정작 이러한 깃의 작동 원리나 내부 구조에 대해서 알아본 적은 거의 없고 앞으로도 없을 사람이 많을 것이다. 하지만 무엇인가를 잘 알기 위해서 구조를 아는 것은 필수적이고, 공부하다보면 계속해서 현업에서도 쓰일 깃의 활용성을 보다 높일 것이다.깃은 우리가 맨날 init하고 add하고 이것저것 하는데 정작 이 명령어를 통해서 뭐가 어떻게 바뀌는지 모른다. 한번 제대로 알아보자.UNIX 운영체제를 기준으로 폴더 이름이나 파일 이름 앞에 .을 붙이면 숨김처리가 된다. 그렇기 때문에 우리가 이러한 init을 통해 뭐가 만들어지는지 모르는 사람도 많았을 것이다.(나도 그랬다)
참고로 맥은 Shift + cmd + . 을 누르면 숨김파일을 볼 수 있다.
<img src="https://i.imgur.com/cmsa185.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
git init을 하면 .git이라는 디렉토리가 내가 init을 실행한 경로에서 만들어진다.<br><img src="https://i.imgur.com/clfwwGq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
뭐가 되게 많다.
여기에서 우리가 주목해야 할 것들은 따로 있다..git/objects .git/objects/info .git/objects/pack 이러한 Objects 디렉토리의 내용들이 가장 중요하다.처음에 이 디렉토리에는 아무것도 없지만, 우리가 데이터를 add하게 되면 해당 디렉토리로 2가지 글자로 된 디렉토리를 만들고, 그 아래로 38글자의 파일명을 가지는 파일이 각각 들어가 있다.이 Objects의 구성은 실제 파일에 담긴 값들을 zlib으로 압축한 뒤, SHA1 해시한 값을 2/38글자로 자른 것이다.
해시값은 내용이 똑같지 않은 이상 조금이라도 변동이 생기면 달라지므로 파일 식별이 좋아진다. 따라서 기존 파일에 대한 수정이 이루어졌을 경우 이전 버전과 현재의 버전 두 가지가 함께 저장되어 있다. 그래서 우리는 git revert와 같은 방식으로 이전 커밋 기록 파일을 그대로 가져올 수 있는 것이다.이 Objects 안에 들어가는 개체는 크게 3가지로 나뉠 수 있다.
Blob
Tree
Commit
tag(dlc)
Blob은 대형 이진 객체(Binary Large Object)라는 이름의 약자이다. 닉값 한 듯이 이미지, 사운드, 비디오와 같은 멀티미디어 데이터를 다룰 때 사용하기 좋은 객체이며 JSON과 같은 데이터도 다룰 수 있다.
하지만 이는 바이너리 형태로 큰 객체를 저장하기 때문에 자바스크립트와 같은 데에서도 Blob 객체를 다룰 수도 있지만 ArrayBuffer, ArrayBufferView, File, DOMString 객체와 같은 한정적인 자료구조만 담을 수 있다.const blob = new Blob([new ArrayBuffer(data),{ type: "application/json"
})
자바스크립트에선 이러한 식으로 만들 수 있다.이 객체는 해당 파일의 바이트 크기 size와 MIME 타입을 나타내는 type Property를 가진다.트리는 커밋당 하나 이상의 트리를 포함하는 개체이다.
Tree의 특이점이라고 한다면, 유닉스 그러니까 우리가 쓰는 리눅스나 맥에서의 파일 시스템과 유사한 구조를 가진다. (하긴 리누스 토르발즈가 만들었으니)
트리는 서브 트리 또는 BLOB객체를 가지며, 이러한 서브 트리의 경우 디렉토리의 구조를 표현하기 위해 사용한다. $ git cat-file -p master^{tree} //&lt;-- master브랜치가 가리키는 Tree 개체
100644 blob a906cb2a4a904a152e80877d4088654daad0c859 README
100644 blob 8f94139338f9404f26296befa88755fc2598c289 Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 lib &lt;-- 다른 Tree 개체
해당 깃의 Tree객체를 보면 파일 식별자 / 개체 / 해시값 / 파일명으로 되어 있음을 알 수 있다.
여기서 파일 식별자는
100644(읽기파일(blob))
100755(실행파일(blob))
040000 디렉터리(Tree)
를 의미한다. 뒤의 숫자는 파일 시스템모드(권한)을 의미하낟.
커밋은 부모 커밋에 대한 참조를 공유한다.이 커밋은 만들어질 때 부모 커밋에 대한 참조를 가져오면서 commit tree를 만들어 커밋 개체에 대한 설명과 Tree 개체의 SHA-1값을 넘긴다.이 때 이 Tree객체는 최상단 Tree를 하나 가리키는데. username과 user.email 설정에서 가져온 정보, 시간정도, 커밋 메시지가 들어감깃의 대부분의 객체가 불변 객체인 만큼, commit 객체 또한 불변성(immutable)을 가지고 있으며, 이는 곧 업데이트되지 않는다는 의미기도 하다.이러한 commit 객체에는 작성자
커밋 실행자
커밋 날짜
로그 메시지
tree 객체
등의 정보를 지닌다.
태그는 꼬리표와 같은 의미를 가진다.
이러한 tag는 우리가 git tag할 때 생성되며, commit 객체명, tag 이름, tagger, 메시지 등이 기록된다.
우리가 자주 쓰지는 않지만 태그를 통해 버전 명 등을 달아서 관리하고 싶을 때 사용하는 옵션이다.그렇다면 이러한 객체들은 어느 시점에서 생기고, 어떤 시점에서 원격 저장소로 가는 등의 흐름을 알아보자.기본적으로 깃에서 담겨 있는 데이터들은 파일 시스템 상에서의 스냅샷이다. 즉, 우리가 저장하는 커맨드(커밋)하여 적용할 때의 순간을 중요시한다.깃 프로젝트는
Working Directory : 작업할 파일이 있는 디렉토리로 untracked/tracked 상태의 파일들로 나뉘어짐
Staging Area: 커밋을 수행할 파일들이 올라와있는 영역
repository : 커밋들이 모여있는 영역
등의 구성요소를 가진다.
<br><img src="https://i.imgur.com/IUPjl7A.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
해당 사진은 Pro Git에 나오는 파일의 상태 변화도이다. 해당 상태를 따라가보자.우리가 맨 처음에 git init을 통해 프로젝트를 만들고, 파일을 git add 하게 되면 커밋할 파일들은 Staging area에 추가된다. 하지만 이 파일들은 바로 repository로 가는 것이 아닌, 해당 staging Area에 올라와 있다가 우리가 git commit을 하게 되면 비로소 repository로 가게 된다.그리고 또 이 commit을 해서 repository로 가기 전까지의 과정에서 맨 처음에는 unmodified 상태로, 신규로 파일이 추가되었을 때를 의미한다. 해당 사진에서는 바로 staged 상태로 직행하는 것처럼 나와있다. 왜냐하면 statged 상태가 Staging Area에 반영된 상태임을 나타내는 상태이기 때문이다. git add 를 한 뒤로 unmodified 상태였던 파일들은 만약에 수정이 이루어지면 Modified 상태가 되고, 이를 다시 add를 통해서 Staging Area로 다시금 올릴 수 있다.이러한 Staging Area는 디렉토리 뿐만이 아니라 파일 단위로도 Staging Area에 올려놓을 수 있기 때문에 일부분만 커밋할 때나 일부에서 일어난 충돌을 해제할 때 유용하다.이렇게 Staging Area에 올린 것들은 git commit을 통해서 해당 커밋에 대해서 Tree Object를 만들고, 이러한 Tree Object를 가리키는 Commit Object를 만들며, 이러한 커밋들을 index라는 파일을 통해 커밋들의 해시값을 관리한다. 이렇게 가는 과정에서
개체의 타입을 blob으로 만들면서 헤더를 먼저 만듦
공백 문자 하나, 내용의 크기, 마지막에 널 문자를 추가
헤더와 원래 내용을 합쳐서 SHA-1 체크섬 계산
zlib을 통해 내용 압축(zlib-deflate.delfate())
압축한 내용을 개체로 저장
- SHA-1값 중에서 맨 앞에 있는 두 자를 가져다 하위 디렉토리 이름으로 사용
- 나머지 38자를 그 디렉토리 안에 있는 파일 이름으로 사용
- fileUtils.mkdir로 디렉토리를 만들고 연 다음에 압축한 내용을 저장
와 같은 파일들의 저장이 이루어지게 된다.
]]></description><link>부스트캠프/챌린지/day13_학습정리.html</link><guid isPermaLink="false">부스트캠프/챌린지/Day13_학습정리.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/cmsa185.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/cmsa185.jpeg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[MFA]]></title><description><![CDATA[user = password + MFA(Multi Factor Authe)]]></description><link>부스트캠프/챌린지/mfa.html</link><guid isPermaLink="false">부스트캠프/챌린지/MFA.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Observer 패턴]]></title><description><![CDATA[<img src="https://i.imgur.com/QtK5Ay8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/7MVzWmk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">옵저버 패턴은 객체의 상태 변화를 관찰하는 관찰자(옵저버)의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 드등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인패턴이다.옵저버는 계속해서 객체의 상태를 관찰하고 있는 상태이고, 이러한 상태 변화를 감지하여 연관된 객체들에게 알림을 보낸다고 하는데, 한낮 다른 객체에 불과한 옵저버가 어떻게 알고있는걸까?답은 이벤트 처리에 있다.객체가 생성되는 시점에 해당 객체에 옵저버를 구독(attach)시키고, 해당 객체에 의존하고 있는 다른 객체들에게도 옵저버를 통해 업데이트 상황을 알 수 있도록 한다.class Observer { constructor() { this.students = []; } add(student){ this.students.push(student); } getStateUpdate(student,action){ console.log(`학생 ${student.name}이 ${action}을 했네요 건강하게만 커야한다~`) }
}
학생 옵저버를 만들었다. class Student{ observer constructor(name){ this.name = name; } attach(observer){ this.observer = observer; } eat(){ console.log(`${this.name}이 밥을 먹는다`) this.#notify(this,"밥먹기") } #notify(who,action) { this.observer.getStateUpdate(who,action); } } const obeserver = new Observer(); const minsu = new Student("minsu"); minsu.attach(obeserver) minsu.eat()
그리고 학생 객체를 만든 뒤에 민수에게 옵저버를 구독시키고, 민수의 메서드에서는 해당 옵저버에게 자신의 상태가 업데이트되었음을 함께 알리는 메서드를 실행시킨다.<br><img src="https://i.imgur.com/X3DlW4K.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
그럼 옵저버는 이러한 상태 업데이트의 이벤트를 받아 처리하는 것이다.
해당 옵저버는 배열을 통해 자신이 바라보고 있는 객체들을 관리할 수 있으며, 이러한 객체들에 관해서도 각각 상태가 갱신되었을 때 forEach를 통해 객체들을 돌면서 동일하게 상태 업데이트에 대해서 처리하는 메서드를 실행시킨다면 각 객체들이 이러한 한 객체의 이벤트를 받아 자신들도 동일하게 객체를 동기화시키는 작업을 시킬 수 있다.이러한 관계는 객체간의 느슨한 결합성이 포인트이다.
두 객체가 느슨하게 결합되어 있다는 것은 디자인패턴 중 Pub-Sub 패턴처럼, 서로가 상호작용을 하지만서도 서로에 대해 모르는 상태이기 떄문에 이에 대해서 유연하게 처리가 가능하다.
옵저버를 언제든 새로 추가 및 제거
새로운 형식의 옵저버라도 주제를 변경할 필요가 없음
주제와 옵저버는 서로 독립적으로 사용 가능
주제나 옵저버가 바뀌더라도 서로에게 영향을 미치지 않음
]]></description><link>부스트캠프/챌린지/observer-패턴.html</link><guid isPermaLink="false">부스트캠프/챌린지/Observer 패턴.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/QtK5Ay8.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/QtK5Ay8.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OSI 7 Layer]]></title><description><![CDATA[OSI(Open Systems Interconnection) 모델은 한국어로 번역하면 오픈 시스템 상호 연결 모델로, 네트워크 통신 기능을 7개의 계층으로 가누는 개념적인 프레임워크이다.
이 데이터 모델은 컴퓨터간 네트워킹을 위한 범용 언어를 제공하기 때문에 다양한 기술이 표준 프로토콜/통신 규칙을 사용하여 통신할 수 있다.
각 계층별로 모든 유형의 네트워크 통신 기술이 캡슐화되어 특정 기능을 제공하고 이를 네트워킹에 유용하게 사용할 수 있으며, 흐름을 한 눈에 알아보고 이해하기 쉽다.<img src="https://i.imgur.com/YD36UjY.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
각 계층은 독립적으로 작용하며, 해당 계층에 맞는 프로토콜이 각각 존재한다.<br>
<img src="https://i.imgur.com/yzjxdAQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이 프로토콜에 의해서 하위 계층으로 갈 수록 헤더가 붙으면서 데이터의 크기는 점점 커진다.비트 단위로 데이터가 이루어져 있으며, 네트워크 케이블과 신호에 관한 규칙을 다루고 있다.
통신 케이블의 종류와 신호의 규격 및 무선통신 주파수 설정, 커넥터 형태 등을 정한다.
관련된 장비로는 동축 케이블의 아날로그 신호를 디지털 데이터로 변환하는 모뎀, 다수의 컴퓨터를 연결하여 하나의 네트워크로 보내는 허브, 디지털 신호를 증폭해주는 리피터 등이 있다.
이 계층에서는 통신 케이블을 통해 데이터를 전송만 하는 기능만 하므로, 어떤 데이터인지나 에러에 대해서는 신경쓰지 않는다.물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할로, 통신에서의 에러 검출, 재전송, 흐름 제어(충돌 점검)의 기능을 가지고 있다.
이 계층에서는 MAC 주소를 가지고 통신하게 되며, 이 계층에서 전송되는 단위를 프레임이라고 한다.대표적인 장비로는 브리지, 스위치 등이 있어 이러한 장비를 통해 MAC 주소를 가지고 물리계층에서 받은 정보를 전달한다.
MAC 주소(Media Access Control Address)
네트워크 인터페이스에 할당된 물리적 고유 식별 주소
데이터를 목적지까지 가장 안전하고 빠르게 전달하는 라우팅의 기능을 가진 계층이다.
해당 계층의 데이터 단위는 패킷(packet)으로, 경로와 주소를 정하고 경로에 따라 패킷을 전달해 주는 것이 이 계층의 역할이다. 이를 통해 데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능해진다.대표적인 장비는 라우터이며, 최상위 계층으로 데이터를 전송하는 최적의 경로를 찾아 설정하고, 청구 정보를 관리한다.
해당 계층에서는 논리적 주소인 IP 주소를 사용하면서 전송 계층에서 요구하는 서비스 품질(Qos)을 위한 수단을 제공한다.전송 계층은 서비스를 구분하고 사용자 사이의 신뢰성있는 데이터 전달은 담당하는 계층이다.
해당 계층의 프로토콜에는 신뢰성있는 데이터 전송이 목적인 TCP(Transmission Control Protocol)와 빠른 데이터 전송이 목적인 UDP(User Datagram Protocol)가 있다.TCP의 경우 세그먼트(Segment)라는 데이터 단위를 사용하며 UDP는 데이터그램(Datagram) 이라는 데이터 단위를 사용한다.TCP는 세그먼트를 작은 패킷으로 나눠 여러 경로를 통해 데이터를 전송하고 목적지에서 순서대로 패킷을 조립하여 데이터를 전달하는 반면, 데이터그램은 순서에 상관없이 데이터를 전달하기 때문에 신뢰성이 없다.세션 계층은 데이터가 통신하기 위한 논리적인 연결을 의미하며, 일종의 통신수단, 대화통로 등으로 볼 수 있다.
데이터의 송수신 타이밍과 방법이 해당 계층에서 규정되며, 세션 설정, 유지, 종료, 전송 중단시 복구 등의 기능을 한다.
해당 계층을 통해 TCP/IP 세션을 만들고 없애는 책임을 진다.표현 계층은 전송되는 정보의 구문(Syntax) 및 의미(Semantics)에 관여하는 계층으로, 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고 암호화한다.
따라서 인코딩(Encoding), 데이터 압축(Compression), 암호화(Cryptography) 등 주요한 동작을 수행한다.
파일의 확장자(txt, jpeg, mp4, html 등)는 이 계층과 관련된 프로토콜이다.응용 서비스를 수행하고 사용자 인터페이스를 제공하는 계층으로, HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다.
해당 통신 패킷들은 방금 나열한 프로토콜에 의해 모두 처리되며 우리가 사용하는 브라우저나, 메일 프로그램은 프로토콜을&nbsp;보다 쉽게 사용하게 해주는 응용프로그램이다. 한마디로 모든 통신의 양 끝단은 HTTP와 같은 프로토콜이지 응용프로그램이 아니다.
복잡한 시스템에 대한 이해 공유 복잡한 네트워크 시스템 아키텍쳐를 구성하고 모델링이 가능
주요 기능에 따라 각 시스템 구성 요소의 운영 계층 분리
추상화를 통해 시스템을 분해하여 사람들이 시스템을 전체적으로 개념화하는 것을 쉽게 만듦 더 빠른 연구 및 개발 엔지니어가 새로운 시스템을 만들 때 OSI 모델의 어떤 계층을 대상으로 개발하는지 알고 개발하기 때문에 이에 대한 이해도를 기반으로 더 빠른 연구 및 개발이 가능 유연한 표준화 네트워크 통신 개발을 표준화하여 시스템에 대한 사전 지식 없이도 복잡한 시스템을 이해, 구축 및 분해 가능 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://shlee0882.tistory.com/110" target="_self">https://shlee0882.tistory.com/110</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://huimang2.github.io/etc/iso-standard-7498" target="_self">https://huimang2.github.io/etc/iso-standard-7498</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://aws.amazon.com/ko/what-is/osi-model/" target="_self">https://aws.amazon.com/ko/what-is/osi-model/</a>]]></description><link>부스트캠프/챌린지/osi-7-layer.html</link><guid isPermaLink="false">부스트캠프/챌린지/OSI 7 Layer.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/YD36UjY.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/YD36UjY.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20240721133934]]></title><description><![CDATA[<img src="부스트캠프/챌린지/pasted-image-20240721133934.png" target="_self">]]></description><link>부스트캠프/챌린지/pasted-image-20240721133934.html</link><guid isPermaLink="false">부스트캠프/챌린지/Pasted image 20240721133934.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/pasted-image-20240721133934.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/pasted-image-20240721133934.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20240723210155]]></title><description><![CDATA[<img src="부스트캠프/챌린지/pasted-image-20240723210155.png" target="_self">]]></description><link>부스트캠프/챌린지/pasted-image-20240723210155.html</link><guid isPermaLink="false">부스트캠프/챌린지/Pasted image 20240723210155.png</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="부스트캠프/챌린지/pasted-image-20240723210155.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;부스트캠프/챌린지/pasted-image-20240723210155.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[실수 축제]]></title><description><![CDATA[ // rest =&gt; 지역번호를 뺀 나머지 뒷번호 const rest = tel.substring(3); if (top === "001" || top === "002") { if (rest.length &gt; 12 || rest.length &lt; 8) return failure; return ["국제전화", "O"]; }
console.log(solution("002--22344--12344121123")); 의도했던 출력 : [ "국제전화", "X" ] 실제 출력: [ "전국", "X" ] 국제전화일 경우 001 또는 002 이후 뒷 번호가 8~12자까지 허용하여 조건을 만족할 경우에는 [ "국제전화", "O" ]를 출력시키고, 그렇지 않을 경우 [ "국제전화", "X" ]를 출력시키려 했으나, 실수로 failure 변수에 할당된 배열 자체에는 [ "전국", "X" ]밖에 담겨있지 않아 예상했던 출력과는 달랐던 실수였다.국제 전화와 국내 전화를 구분하기 위해 failure를 Object로 만들어 각 상황에 맞는 전화번호 오류를 출력하도록 만들었다const failure = { domestic: ["전국", "X"], global: ["국제전화", "X"] };
... if (top === "001" || top === "002") { if (rest.length &gt; 12 || rest.length &lt; 8) return failure.global; return ["국제전화", "O"]; } }
// output: [ '국제전화', 'O' ]
console.log(solution("002-2234-1234"));
// output: [ '국제전화', 'X' ]
console.log(solution("002-22344-12344121123"));
]]></description><link>부스트캠프/베이직/실수-축제.html</link><guid isPermaLink="false">부스트캠프/베이직/실수 축제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[웹프로그래밍]]></title><description><![CDATA[Array.prototype.every()
Array 인스턴스의&nbsp;every()&nbsp;메서드는 배열의 모든 요소가 제공된 함수로 구현된 테스트를 통과하는지 테스트합니다. 이 메서드는 불리언 값을 반환합니다.const isBelowThreshold = (currentValue) =&gt; currentValue &lt; 40; const array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold));
// Expected output: true
Array.prototype.some()
some()&nbsp;메서드는 배열 안의 어떤 요소라도 주어진 판별 함수를 적어도 하나라도 통과하는지 테스트합니다. 만약 배열에서 주어진 함수가 true을 반환하면 true를 반환합니다. 그렇지 않으면 false를 반환합니다. 이 메서드는 배열을 변경하지 않습니다.const array = [1, 2, 3, 4, 5]; // Checks whether an element is even
const even = (element) =&gt; element % 2 === 0; console.log(array.some(even));
// Expected output: true Array.prototype.filter()
<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_self"><code></code></a>Array&nbsp;인스턴스의&nbsp;filter()&nbsp;메서드는 주어진 배열의 일부에 대한&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Glossary/Shallow_copy" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Glossary/Shallow_copy" target="_self">얕은 복사본</a>을 생성하고, 주어진 배열에서 제공된 함수에 의해 구현된 테스트를 통과한 요소로만 필터링 합니다.const words = ['spray', 'elite', 'exuberant', 'destruction', 'present']; const result = words.filter((word) =&gt; word.length &gt; 6); console.log(result);
// Expected output: Array ["exuberant", "destruction", "present"]
Array.prototype.find() (인덱스는 findIndex)<br>
<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_self"><code></code></a>Array&nbsp;인스턴스의&nbsp;find()&nbsp;메서드는 제공된 배열에서 제공된 테스트 함수를 만족하는 첫 번째 요소를 반환합니다. 테스트 함수를 만족하는 값이 없으면&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_self"><code></code></a>undefined가 반환됩니다.
<br>배열에서 찾은 요소의&nbsp;인덱스가 필요한 경우,&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" target="_self"><code></code></a>findIndex()를 사용하세요.
<br>값의 인덱스를 찾아야 하는 경우,&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_self"><code></code></a>indexOf()를 사용하세요. (<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" target="_self"><code></code></a>findIndex()와 유사하지만, 테스트 함수를 사용하는 것 대신 각 요소가 값과 동일한지 확인합니다.)
<br>배열에 값이&nbsp;존재하는지 찾아야 하는 경우,&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_self"><code></code></a>includes()를 사용하세요. 이 역시 테스트 함수를 사용하는 것 대신 각 요소가 값과 동일한지 확인합니다.
<br>제공된 테스트 함수를 만족하는 요소가 있는지 찾아야 하는 경우,&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_self"><code></code></a>some()을 사용하세요.
const array1 = [5, 12, 8, 130, 44]; const found = array1.find((element) =&gt; element &gt; 10); console.log(found);
// Expected output: 12
Array.prototype.map()
map()&nbsp;메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환합니다.const array1 = [1, 4, 9, 16]; // Pass a function to map
const map1 = array1.map((x) =&gt; x * 2); console.log(map1);
// Expected output: Array [2, 8, 18, 32]
setTimeout()
전역&nbsp;setTimeout()&nbsp;메서드는 만료된 후 함수나 지정한 코드 조각을 한 번 실행하는 타이머를 설정합니다.setTimeout(() =&gt; console.log("2초 후에 실행됨"), 2000);
function add(x, y) { console.log(x + y);
}
setTimeout(add, 2000, 3, 4);
setInterval()let id = setInterval(() =&gt; {
console.log('1초 마다 호출합니다.');
}, 1000);
setTimeout(() =&gt; {
clearInterval(id);
console.log('*** 타이머를 제거합니다.');
}, 5000)
<br><img src="https://i.imgur.com/Sy2SZid.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/HYKvyRe.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">let d1 = new Date(); let weekName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thr', 'Fri', 'Sat']; console.log(d1.getFullYear() + "/" + (d1.getMonth() + 1) + "/" + d1.getDate());
// 2023/11/6 console.log(d1.getHours() + ":" + d1.getMinutes() + ":" + d1.getSeconds());
// 21:51:32 console.log(weekName[d1.getDay()]);
//MON console.log(d1.getTime());
// 1960부터 초로 센 시간
<br><img src="https://i.imgur.com/zg2BT7e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/qszzBhs.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/uzW5RKm.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/o9Sj4US.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/8g1lJjK.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/qGYUbwA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/wtIc5Zs.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/mafnyQu.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/v2X3OtG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/zlizind.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/nszavn2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/VsRQogI.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/Qap34cC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/STnbAyE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/YC70aCM.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/rx5xwHN.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/RVsqMEa.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/MCgVKjD.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/PICeyGj.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/C5i2GIw.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/ssVycjX.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/uEaGOVU.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/fQHX3Cz.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/rTxAK7G.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/qna39DW.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/hstrGnm.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/xpu3dw5.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/3Dq7TgH.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/cONdLut.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/opocaAd.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/Zn7fVoC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/gE9Lhn3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/8eGdWP1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/nvrAUl0.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/3c1Jpkm.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/6tvjtXP.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/r4Kz7WG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/3yYYJJv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/H0AJ7F6.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/mBbGaZo.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
\]]></description><link>부스트캠프/베이직/웹프로그래밍.html</link><guid isPermaLink="false">부스트캠프/베이직/웹프로그래밍.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/Sy2SZid.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/Sy2SZid.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[페이지 라우팅]]></title><description><![CDATA[클라이언트 요청에 적절한 페이지를 제공하는 기술
라우팅 경로로 데이터를 전달하는ㄴ 방법
path 문자열에 ':토큰_이름' 형태로 설정
토큰에 해당하는 문자열은 request 객체의 parmas.토큰_이름 속설으로 전달함
const express = require('express');
const app = express(); app.get('/main/:s1/sub/:s2', (request, response) =&gt; {
const str1 = request.params.s1;
const str2 = request.params.s2;
response.send(`&lt;h1&gt;main = ${str1}&lt;br&gt;sub = ${str2}&lt;/h1&gt;`);
}); app.listen(52273, () =&gt; {
console.log('Server running at http://localhost:52273');
}); 클라이언트에게 응답하는 정보를 담은 객체
send() 메서드는 클라이언트에게 body를 전달하므로 가장 마지막에 한 번만 실행 가능
HTTP 상태 코드: 서버가 클라이언트에 알려주는 해당 경로의 상태const express = require("express");
const app = express();
app.get("*", (request, response) =&gt; { response.status(404); response.set("methodA", "ABCDE"); response.set({ methodB1: "FGHIJ", methodB2: "KLMNO", }); response.send("이것은 본문");
});
app.listen(52273, () =&gt; { console.log("Server running at http://127.0.0.1:52273");
}); 서버가 Content-Type 제공 웹 브라우저는 헤더를 확인, 제공된 데이터의 형태 확인(MIME라는 문자열로 제공) type() 메서드로 MIME 형식 지정
const express = require("express");
const fs = require("fs");
const app = express();
app.get("/image", (request, response) =&gt; { fs.readFile("myimage.png", (error, data) =&gt; { response.type("image/png"); response.send(data); });
});
app.get("/audio", (request, response) =&gt; { fs.readFile("myaudio.mp3", (error, data) =&gt; { response.type("audio/mpeg"); response.send(data); });
});
app.listen(52273, () =&gt; { console.log("Check http://127.0.0.1:52273/image"); console.log("Check http://127.0.0.1:52273/audio");
}); 웹 브라우저가 리다이렉트를 확인하면 화면을 출력하지 않고, 응답 헤더에 있는 Location 속성을 확인해서 해당 위치로 이동
특정 경로로 웹 브라우저를 인도할 때 사용
redirect() 메서드를 통해 이동
const express = require("express");
const app = express(); app.get("*", (request, response) =&gt; { response.redirect("https://www.hufs.ac.kr");
}); app.listen(52273, () =&gt; { console.log("Server running at http://127.0.0.1:52273");
}); 클라이언트에서 form 방식을 통해 다른 url로 넘어갔을 때 요청 매개 변수를 추출하는 방법
GET 방식 요청 매개 변수
<a data-tooltip-position="top" aria-label="https://search.naver.com/search.naver?where=nexearch&amp;query=%EC%B4%88%EC%BD%9C%EB%A6%BF&amp;sm=top_hty&amp;fbm=0&amp;ie=utf8" rel="noopener nofollow" class="external-link is-unresolved" href="https://search.naver.com/search.naver?where=nexearch&amp;query=%EC%B4%88%EC%BD%9C%EB%A6%BF&amp;sm=top_hty&amp;fbm=0&amp;ie=utf8" target="_self">https://search.naver.com/search.naver?where=nexearch&amp;query=초콜릿&amp;sm=top_hty&amp;fbm=0&amp;ie=utf8</a>const express = require("express");
const app = express();
app.get("*", (request, response) =&gt; { console.log("request.query:", request.query); // request.query: { name: '홍길동', age: '32', skill: [ '변신', '공중부양' ] }, name = 홍길동, age = 32, skill = [ '변신', '공중부양' ] console.log(" name =", request.query.name); console.log(" age =", request.query.age); console.log("skill =", request.query.skill); response.send(request.query);
}); app.listen(52273, () =&gt; { console.log( "Check http://127.0.0.1:52273?name=홍길동&amp;age=32&amp;skill=변신&amp;skill=공중부양" );
}); Express는 자체적인 최소한의 기능을 갖춘 라우팅 웹 프레임워크
Express 애플리케이션은 일련의 미들웨어 함수 호출로 구성
미들웨어 함수? 클라이언트의 Request를 Response로 반환하기까지 중간에 거치는 모든 함수 미들웨어: 요청과 응답 사이에서 중간처리를 하는 모든 함수들
모듈: 이러한 함수들의 묶음
내장 모듈: Node.js에서 기본적으로 지원하는 모듈들
확장 모듈: Node.js 사용자들이 필요에 의해 만들어낸 오픈소스 기반의 모듈들 웹 페이지에서 변경되지 않는 요소(이미지, JS 파일, CSS 파일 등)를 제공하는 기능
자주 사용되므로 express에서 직접 제공
정적 파일을 제공할 폴더를 지정: app.use(express.static('폴더명')); public 폴더를 만들고
public 폴더에 hello.html, audio.mp3 파일 넣음
public/image 폴더에 image.png 파일 넣음
const express = require("express");
const app = express(); //기본 url 뒤에 public 폴더의 위치에 바로 접근 가능
//public 폴더에 hello.html이 있으면 localhost:52273/hello.html 로 접근하면 바로 띄워줌
app.use(express.static("public"));
app.get("*", (request, response) =&gt; { response.status(404); //경로가 없기 때문에 static한 요소가 지정되지 않아 출력 response.send("해당 경로에는 아무것도 없습니다.");
});
app.listen(52273, () =&gt; { console.log("Server running at http://localhost:52273");
}); GET 방식 URL을 통해 데이터를 전달하는 방식
URL 토큰과 URL 요청 매개 변수로 전달
주소에 데이터가 공개된느 문제가 있음 POST 방식 요청 본문으로 데이터를 전달 클라이언트가 서버로 본문을 전달할 때 요청 본문의 종류를 MIME 형식으로 전달 서버에서 클라이언트로 응답 본문을 보내면 웹 브라우저가 알아서 Content-Type을 분석하여 처리
클라이언트에서 서버로 요청 본문을 보내면 서버 개발자가 직접 Content-Type에 따른 대응을 해야 함 요청한 본문의 Content-Type에 따라 본문을 분석해주는 미들웨어 단, multipart 형태는 분석하지 못함
body-parser 미들웨어는 express에 기본 설치됨 application/x-www-form-urlencoded 형식의 본문을 처리하는 방법 app.use(express.urlencoded({extended: false}));
extended: false는 node.js에 포함된 queryString 라이브러리를 사용한다는 의미 const express = require("express");
const app = express(); app.use(express.static("public"));
app.use(express.urlencoded({ extended: false }));
app.get("/", (request, response) =&gt; { let output = ""; // form 형식의 html을 넘겨줌 output += '&lt;form method="post"&gt;'; output += ' &lt;input type="text" name="a" /&gt;'; output += ' &lt;input type="text" name="b" /&gt;'; output += ' &lt;input type="submit" /&gt;'; output += "&lt;/form&gt;"; response.send(output);
}); app.post("/", (request, response) =&gt; { // form을 통해서 넘겨 받은 데이터를 출력 console.log("a =", request.body.a); console.log("b =", request.body.b); response.send(request.body);
}); app.listen(52273, () =&gt; { console.log("Server running at http://localhost:52273");
}); ]]></description><link>부스트캠프/베이직/페이지-라우팅.html</link><guid isPermaLink="false">부스트캠프/베이직/페이지 라우팅.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[학습 저장소 제출용]]></title><link>부스트캠프/베이직/학습-저장소-제출용.html</link><guid isPermaLink="false">부스트캠프/베이직/학습 저장소 제출용.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[2주차 릴레이노트]]></title><description><![CDATA[
S.M.A.R.T 하게 목표 세우기 개발자의 원칙, p176 S.M.A.R.T 원칙을 따라 목표를 정해야한덕 Specific 구체적이덕 Measurable 측정 가능하덕 Achievable 달성 가능하덕 Realistic 현실적이덕 Time-bound 기한을 정해덕 0726 2주차 릴레이노트에서 수정됐덕.
내가 인상깊게 읽었던 132p. 남을 향한 자존심을 버리고, 나를 향한 자존감 채우기의 내용을 해석해서 수행기준에 조금 더 녹여냈덕! 일주일(주말 제외) 동안 할 수 있는 목표를 정하고 목표를 위해 무언가를 했다는 증거를 보여주는 거덕. 해당 목표는 너무 큰 목표가 아닌, 쉽고 작은 목표여야 한덕! 매일 아침 일어나서 꽃에 물 주기와 같은 작은 목표들을 보다 상세하게 작성하고, 이를 성취함으로써 성취한 나에 대해 뿌듯함을 느끼는 것이덕. ]]></description><link>부스트캠프/챌린지/2주차-릴레이노트.html</link><guid isPermaLink="false">부스트캠프/챌린지/2주차 릴레이노트.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[3주차 개인회고]]></title><description><![CDATA[3주차 부스트캠프 회고어느덧 부스트캠프를 벌써 3/4나 와버렸다
하루하루 코딩만 하면서 살다보니 생각보다 너무 시간이 빨리 가버린 것 같다.
벌써 개강이 한 달도 안 남았다니...(멤버십 가고싶긴 해)
여러모로 이번 부스트캠프를 통해 많이 발전한 것 같은 느낌이 들고, 내가 진짜 '개발자'가 되기 위해서는 어떤 자세를 가지고 어떻게 해나가야 하는지에 대해서 많이 배웠다.
암튼 이번주 회고는 KPT 회고를 이용하여 일주일에 대한 분석을 해보려고 한다.이번 일주일동안 만족한 부분은 아무래도 하나의 미션이 2일을 차지한다는 점이다.
하루는 구현, 하루는 리팩토링의 시간을 가지면서 아무래도 이제까지 다음 미션을 하느라 제대로 시간이 나지 않았던 탓에 이번주는 리팩토링을 하는 시간이 주어져 매우 만족스럽다.당장 한달 전 나의 모습만 하더라도, 나는 리팩토링을 잘 안하던 사람이었다.
내가 쓴 코드를 다시 보고 고쳐야 하는 과정 자체가 하나의 하기 귀찮은 일로 여겨졌다.
하지만 이번 미션들을 진행하면서 당장 구현할 시간만 하더라도 매일 새벽 4시까지 구현을 하다가 지쳐 쓰러져 잠에 들고, 다시 하루를 준비했다. 그랬기 때문에 구현에만 온 집중을 쏟고 있어 내가 코드를 쓰면서 가지고 있던 온갖 안좋은 습관들을 코드에서 볼 수 있었다.
예를 들면, let을 남발한다던가, 고차함수의 활용보다는 for문으로 반복을 돈다던지 하는 자바스크립트의 활용을 제대로 하고 있지 않는 안좋은 습관이었다.이러한 습관들이 모두 들어가 있는 코드를 보면서 마음이 좋지 않았다. 마치 항공모함의 구멍들을 글루건으로 메우려는 듯한 어리석은 코드를 쓰는 사람같아서 약간의 자괴감도 있었다.
하지만 이번주는 첫번째 날에서 미션을 해결하고 이틀차에 이를 개선할 수 있는 시간을 가지면서 다시금 내 코드를 볼 수 있는 시간이 생기게 되었다. 이를 통해 내가 개인적으로 미션을 해결하는 과정에서도 마음이 급해 제대로 하지 않은 부분들의 코드를 다시금 볼 수 있는 시간이 되었고, 이러한 부분들을 수정하고 내 코드가 어떻게 하면 더 예뻐질 수 있을까? 를 많이 고민하면서 코드 자체를 보는 시각 자체를 발전할 수 있는 시간이었다. 앞으로도 이러한 코드에 대해 리뷰를 활발히 하면서 보다 코드를 개선해가는 시야를 키우려고 노력하면 좋을 것 같다.하지만 그 중에도 불편하게 느끼는 부분은 있기 마련이다. 하지만 이 부분은 정말 개인적인 일이라 변명 거리도 없다.
해커톤이 바로 다음주에 있기 때문에 현재도 한창 개발을 진행중이다. 그래서 하루에 조금이라도 하려고 노력중인데, 그러다보니 프로젝트에 대한 생각이 머리에서 떠나지 않고 계속 머물고 있어 미션을 해결하는데 방해가 되었다.
물론 4시까지는 부스트캠프에 집중하고 잘 시간을 조금 쪼개고 주말을 할애하여 많이 하고 있기는 하지만 아무래도 선택과 집중이 필요하지 않았나 생각된다. 학습 정리도 조금 더 보충하고 싶은 마음이 있음에도 불구하고 이를 나중에서야 보충할 수 있다는 사실이 조금은 불편하게 느껴졌다. 이에 딸려오는 피로도 또한 무시할 수 없었기에 참..애매한 문제이다.자바스크립트는 콜백, 즉 클로저를 활용하여 고차함수들을 사용하는 방법이 정말 많다. 하지만 아직까지는 기본적인 각 객체의 프로토타입 메서드의 기본적인 활용도정도만큼으로만 사용하고 있다는 사실이 살짝은 불편하게 느껴졌다. 아무래도 자바스크립트는 사용자의 실력에 따라서 스마트하게 활용할 수 있는 방법이 무궁무진한데, 이를 제대로 활용 못하는 내가 덜 된 개발자같은 느낌을 받았다.
특히 reduce는 코딩하는 사람의 고차함수 활용 실력을 볼 수 있는 고차함 수 중 하나라고 생각하는데, 이를 제대로 활용할 수도 있는 부분에서 활용하지 않고 원시적인 방법을 택한 나를 보고 이러한 부분이 문제라고 생각했다.아무래도 후딱 이번 주 주말을 활용하여 빠르게 마치고 다시금 부스트캠프에 집중하도록 하는 것이 가장 베스트일 것 같다고 생각했다. 이 이상 계속 지나면 아무래도 부스트캠프의 미션을 전부 구현할 수 있는 시간이 나지 않을 것 같기 때문에 최대한 빨리 끝내는 것이 목표이다. 그래서 이 회고를 쓰고 난 시점부터 계속해서 꾸준히 프로젝트를 주말 내로 완성시킬 계획이다.전부터 하고 있었지만, 자바스크립트 Deep Dive 라는 책을 공부하고 있었다. 이 책은 자바스크립트의 작동 방식부터 시작하여 세세한 부분까지 다루고 있는 책인데, 여기서 내가 학습이 필요하다고 생각하는 부분을 정리하여 꾸준히 기술블로그에 올릴 예정이다. 현재도 클로저에 대해서 보다 공부하고 싶다는 생각이 들어 정리중에 있다.암튼 이렇게 또 일주일이 지나갔다. 정말 빠르게 지나간 일주일이었지만, 그 시간만큼은 어느 때와도 비교하기 힘든 만큼 내가 성장할 수 있었던 소중한 시간들이었기에 참 좋았다고 생각한다.
마지막 다음주를 향해서 화이팅!]]></description><link>부스트캠프/챌린지/3주차-개인회고.html</link><guid isPermaLink="false">부스트캠프/챌린지/3주차 개인회고.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Broadcast, Unicast, Multicast]]></title><description><![CDATA[1:1 통신 방식으로 받는 인터넷 대부분의 통신 방식이다.
하나의 호스트가 다른 하나의 호스트와 통신을 하기 위한 목적으로 설계되었다.
데이터는 프레임에 자신의 MAC 주소와 상대방의 호스트의 목적지 MAC 또는 목적지 IP 정보를 활용하여 데이터를 전송한다.
같은 네트워크에 있는 모든 시스템들은 IP/MAC 주소를 받아 자신의 IP/MAC 주소와 비교 후에 자신의 IP/MAC 주소와 같지 않다면 프레임을 버리고, 같으면 프레임을 받아서 처리한다.
MAC주소 (Media Access Control Address)
네트워크 인터페이스에 할당된 물리적 고유 식별 주소
네트워크 통신을 계층화하여 설명하는 OSI 모델에서 데이터 링크 계층의 일부
1:N의 통신 방식으로, N은 네트워크 내 전체 호스트를 의미한다.
보내는 대상의 IP/MAC 주소를 모르더라도 통신이 가능하다.
하나의 호스트가 같은 네트워크 대역의 모든 호스트들에게 통신을 하기 위한 목적으로 설계되어 있다.브로드캐스트 방식의 경우 브로드캐스트용 주소가 미리 정해져있고, 수신받는 시스템은 해당 주소가 오면 패킷을 자신의 CPU로 전송하고 CPU가 패킷을 처리한다.
모든 시스템에게 패킷이 전송되는 만큼, 이에 따른 트래픽은 증가하며 CPU 또한 패킷을 처리하면서 성능저하 이슈가 생길 수 있다.
통신하고자 하는 시스템의 MAC 주소를 알지 못하는 경우
네트워크에 있는 모든 시스템에게 알리는 경우
라우터끼리 정보를 교환하거나 새로운 라우터를 찾는 경우
등에 이용이 된다.
멀티캐스트는 네트워크에 연결되어 있는 시스템 중 일부들에게만 정보를 전송하는 것으로, 라우터가 멀티캐스트를 지원해야만 사용이 가능하다.멀티캐스트를 사용하는 이유는 그룹간 통신을 위하여 다중 사용자에게 동일한 데이터를 보낼 때 유니캐스트 전송 방식을이용하면 데이터 패킷을 여러번 전송해야 하고, 이에 따른 네트워크의 효율이 낮아지게 된다. 하지만 멀티캐스트는 여러 수신자에게 한 번에 메시지가 전송되므로 네트워크의 자원 낭비를 최소화한다. 멀티캐스트 전송의 경우 일반적으로 TCP/IP의 헤더에 수신자의 인터넷 주소를 표시하여 전송하는 것과는 달리 수신자들을 그룹으로 묶어 그룹 주소를 표시하여 패킷을 전송한다.이러한 멀티캐스트 그룹으로 묶는 작업은 애플리케이션이 실행될 때 수행되는데, 멀티캐스트 IP/MAC 주소를 라우터에 등록되면서 멀티캐스트 그룹에 속하게 된다. 하나의 클라이언트에서 여러 멀티캐스트 주소를 수용할 수 있다.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://jwprogramming.tistory.com/29" target="_self">https://jwprogramming.tistory.com/29</a>]]></description><link>부스트캠프/챌린지/broadcast,-unicast,-multicast.html</link><guid isPermaLink="false">부스트캠프/챌린지/Broadcast, Unicast, Multicast.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[DBMS와 RDBMS]]></title><description><![CDATA[DBMS는 DataBase Management System의 약자로 데이터베이스를 관리하는 시스템이다.
DBMS는 사용자와 DB 사이에서 사용자의 요구에 따라 데이터를 생성해주고 ,DB를 관리한다.
페이지 단위 I/O 수행 - 부분 업데이트 가능
Clustering Index 방식으로 데이터를 효과적으로 읽고 쓸 수 있음
B+ tree 인덱스를 사용한 효율적인 레코드 검색
Soft delete, outspcae-update에 가까운 복잡한 방식의 업데이트 및 삭제 지원
동시성을 높이고 트랜잭션을 지원하기 위해 MVCC(Multiversion concurruncy control) 메커니즘 사용
]]></description><link>부스트캠프/챌린지/dbms와-rdbms.html</link><guid isPermaLink="false">부스트캠프/챌린지/DBMS와 RDBMS.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[돌아보기]]></title><description><![CDATA[스스로 해결한 내용들
코드 분석(주석 작성)
버그 수정
리팩토링할 것들 분석하기
테스트 케이스 세분화
위 내용을 해결하며 배운 점들처음에 코드를 분석하면서 의아했던 점은 문제에 대한 정보가 너무 부족해서 X를 리턴하는 케이스에 대해서 '왜 그런거지?'라는 생각이 들었다. 아직까지도 이러한 케이스가 왜 X를 리턴하도록 해야만 했는지에 대한 의문이 남아있어 문제를 풀면서도 찝찝한 마음이 들었다.
하지만 계속해서 문제에 대해 보완해가면서 이러한 사실들에 집중하기보다는 현재 내가 해결해야 하는 문제와 추가해야할 기능에 대해 집중해야 함을 깨달았다. 문제상황에 대한 지문은 명확하게 주어져있으며, 나에게는 이를 해결할 것을 요구했기 때문이다. 문제를 다 풀고 이를 생각하면서 내가 문제를 해결함에 있어서 어떤 부분에 집중해야 하는지를 다시금 깨닫게 되었다.또한 문제를 해결하고 나서도 세분화되어있는 코드를 보고 자연스럽게 '이를 통일하면 보다 가독성이 좋지 않을까?'라는 생각이 들었다. 이에 개별적으로 리팩토링을 진행했고 훨씬 가독성이 높아진 코드를 보면서 이제까지 내가 썼던 코드들 또한 이렇게 거리를 두고 다시금 바라보면서 통일할 수 있는 부분을 최대한 통일하면서 관리하는 것이 리팩토링의 첫 걸음임을 깨달았다. 앞으로도 이를 계속해서 적용해가면서 문제를 해결해나갈 예정이다.수료생의 접근법을 보면서 가장 기억에 남는 내용은 현재 수료생분들이 많은 경험을 가지고 있음에도 불구하고 나와 문제에 대해 접근법이 비슷하다는 점이었다. 정규표현식을 쓸 수도 있는 '-'제거의 문제에 대해 replaceAll 메서드를 사용하셨고, 나 또한 이를 사용하여 -를 제거하였다. 하지만 여기에서도 차이점은 나는 그저 해당 메서드를 사용해야겠다는 생각만 있었지, 막상 이를 사용하려는 명확한 이유가 없었지만 수료생분은 나와는 달리 코드의 라인 하나하나에 집중해서 문제에 접근하시는 것을 보고 이러한 자세를 보고 배워야 겠다는 생각이 들었다.]]></description><link>부스트캠프/베이직/돌아보기.html</link><guid isPermaLink="false">부스트캠프/베이직/돌아보기.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[문제]]></title><description><![CDATA[
로컬에 통합 개발 환경을 설정한다. 주어진 코드를 개발 환경에서 빌드해서 동작하는 것을 확인한다. 디버거로 브레이크 포인트를 지정하고 스텝-오버, 스텝-인, 넥스트 명령을 실습한다. 주어진 요구사항에 맞게 수정하거나 개선한다. 없음. OOO 회사에 입사 첫날, 예전 개발자가 만들다 멈춘&nbsp;전국 전화번호 규칙을 판단해 주는 코드를 공유해 주었다. 우선 이 코드를 분석하고 개선하는 과정을 나름대로 잘 기록해두자. 학습 결과를 제출할 때 기록한 내용을 제출해야 한다.
서울&nbsp;지역 판단 조건을 정리해서 기록한다. 휴대폰&nbsp;번호 판단 조건을 정리해서 기록한다. -&nbsp;문자가 포함되어 있어도 동작해야 한다. 이 부분 코드를 찾아서 개선한다. 기존 코드 ⇒ 개선한 코드 모두 기록한다. 개선한 이후 동작을 확인하기 위한 입력/출력 조건을 추가한다. 001과&nbsp;002&nbsp;로 시작하는 번호는 국제전화로 판단해서 앞 3자리를 제외하고 8자리~12자리까지만 허용하는 로직을 추가한다. 구현한 이후 동작을 확인하기 위한 입력/출력 조건을 추가한다.
]]></description><link>부스트캠프/베이직/문제.html</link><guid isPermaLink="false">부스트캠프/베이직/문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[문제 분석]]></title><description><![CDATA[function solution(telno) { // 전화번호 변수에 할당 const tel = telno; // 실패했을 경우 const failure = ["전국", "X"]; // 전화번호 앞자리 const map = { "010": "휴대폰", "011": "휴대폰", "016": "휴대폰", "017": "휴대폰", "018": "휴대폰", "019": "휴대폰", "031": "경기", "032": "인천", "033": "강원", "041": "충청", "042": "대전", "044": "세종", "051": "부산", "052": "울산", "053": "대구", "054": "경북", "055": "경남", "061": "전남", "062": "광주", "063": "전북", "064": "제주", }; // 전화번호 오류 1.전화번호의 길이가 맞지 않는 경우 if (tel.length &gt; 11 || tel.length &lt; 9) return failure; // 전화번호 오류 2.전화번호의 첫 자리가 0으로 시작하지 않을 경우 else if (tel[0] !== "0") return failure; // top =&gt; 전화번호 가장 앞 3자리 const top = tel.substring(0, 3); // ext =&gt; 전화번호 앞 3자리를 제외한 나머지 번호 const ext = tel.substring(tel.length - 4); // 전화번호 앞에서 두 번째 자리가 2일 때 =&gt; 02가 서울이므로 서울에 대한 예외처리 if (tel[1] === "2") { // 서울 전화번호의 경우 02-xxxx-xxxx의 전화번호이므로 총 글자수가 10개 이상이면 오류 if (tel.length !== 10) return ["서울", "X"]; // 서울 전화번호지만 가운데 4자리 숫자가 모두 같을 때는 비정상적인 전화번호로 처리 if (ext[0] === ext[1] &amp;&amp; ext[1] === ext[2] &amp;&amp; ext[2] === ext[3]) return ["서울", "X"]; // 이 외에는 서울 전화번호가 맞으므로 O return ["서울", "O"]; } else if (tel[1] === "1") { // 전화번호 앞에서 두 번째 자리가 1일 때 =&gt; 휴대폰일 경우밖에 없음 // 해당하는 세자리 수가 map에서 없을 때는 오류 발생 if (!map[top]) return failure; // 해당하는 세자리 수가 map에는 있지만 010은 아닐 때 =&gt; 휴대폰이지만 X if (tel[2] !== "0") return ["휴대폰", "X"]; // 010-XXXX-XXXX의 전화번호(11자리)이고, 전화번호 뒷부분(8자리)의 가장 첫 번째 수가 짝수일 때 =&gt; 휴대폰이면서 O if (tel.length === 11 &amp;&amp; parseInt(tel[3]) % 2 === 0) return ["휴대폰", "O"]; //이외의 경우 휴대폰이지만 X return ["휴대폰", "X"]; } else if (map[top]) { // 02, 01X 이외의 경우에 앞 세자리가 전화번호에 있을 경우 // 0XX-0XX-XXXX의 경우 맞는 지역을 찾고 X와 함께 리턴 if (tel.length === 10 &amp;&amp; tel[3] === "0") return [map[top], "X"]; // 0XX-0XXX-XXXX(앞 두번째 자리가 3 이상, 4번째 자리가 1 이상)의 경우 -&gt; 지역명과 함께 O 리턴 return [map[top], "O"]; } // 나머지의 예외 케이스는 모두 실패처리 return failure;
} console.log(solution("010-123-1234"));
console.log(solution("010-2234-1234"));
console.log(solution("02-1234-1234"));
console.log(solution("0212341111"));
console.log(solution("0311237890"));
console.log(solution("061-012-7890"));
console.log(solution("015-0157899"));
console.log(solution("042-2123-7890")); 전화번호의 길이는 9~11자
전화번호의 첫 자리가 0이어야 함 전화번호 앞에서 두 번째 자리가 2(02)
10자리(02-XXXX-XXXX)
서울 전화번호지만 가운데 4자리 숫자가 모두 같지 않아야 함 전화번호 앞에서 두 번째 자리가 1
세번째 자리가 0이 아닐 경우에는 휴대폰이지만 조건에 맞지 않음
010-XXXX-XXXX의 전화번호(11자리)이고, 전화번호 뒷부분(8자리)의 가장 첫 번째 수가 짝수일 때 조건에 맞음
그 외의 경우에는 휴대폰이지만 모두 조건이 맞지 않은 것으로
🚨 위 조건에 맞지 않은 경우는 모두 실패처리 🚨const tel = telno.replaceAll("-", "");
맨 처음에 번호를 parameter로 받은 다음에 replaceAll 메서드를 사용하여 -를 모두 제거// output : [ '휴대폰', O ]
console.log(solution("010-------2234----1234"));
// output : [ '서울', O ]
console.log(solution("0-2-1-2-3--41-1-1-2"));
// top과 ext 할당을 위로 끌어올려 국제번호 판단하는데 활용 // top =&gt; 전화번호 가장 앞 3자리 const top = tel.substring(0, 3); // ext =&gt; 전화번호 뒤 4자리 const ext = tel.substring(tel.length - 4); // rest =&gt; 지역번호를 뺀 나머지 뒷번호 const rest = tel.substring(3); if (top === "001" || top === "002") { if (rest.length &gt; 12 || rest.length &lt; 8) return failure.global; return ["국제전화", "O"]; }
001과 002로 시작하는 번호의 경우에는 전 코드에서 top 변수가 앞의 지역번호를 판별하는 용도로 사용한 것을 활용하여 top이 재할당되는 위치를 위로 끌어올린 다음 top 변수에 조건문을 걸어 통채로 001과 002를 검사하였다.검사에 통과하였을 경우 더 검사해야 할 조건은 앞3자리를 제외한 뒷자리의 글자수밖에 없기 때문에 length 조건만 추가해주어 해당 조건을 통과하지 못했을 때, failure.global 을 리턴하도록 하였다. 여기서 global은 기존 failure을 객체로 만들어 지역번호/국제전화/휴대폰 번호 검사 실패를 세분화하여 만듦으로써 변수를 통해 접근하여 리턴하도록 만들었다.console.log("국제전화 테스트케이스");
// output: [ '국제전화', 'O' ]
console.log(solution("002-2234-1234"));
// output: [ '국제전화', 'X' ]
console.log(solution("002-22344-12344121123"));
// output: [ '국제전화', 'O' ]
console.log(solution("001-2234----12342"));
// output: [ '국제전화', 'X' ]
console.log(solution("001-2234-122"));
function solution(telno) { // 전화번호 변수에 할당 const tel = telno.replaceAll("-", ""); //성공했을 경우 const success = { seoul: ["서울", "O"], global: ["국제전화", "O"], phone: ["휴대폰", "O"], }; // 실패했을 경우 const failure = { domestic: ["전국", "X"], seoul: ["서울", "X"], global: ["국제전화", "X"], phone: ["휴대폰", "X"], }; // 전화번호 앞자리 const map = { "010": "휴대폰", "011": "휴대폰", "016": "휴대폰", "017": "휴대폰", "018": "휴대폰", "019": "휴대폰", "031": "경기", "032": "인천", "033": "강원", "041": "충청", "042": "대전", "044": "세종", "051": "부산", "052": "울산", "053": "대구", "054": "경북", "055": "경남", "061": "전남", "062": "광주", "063": "전북", "064": "제주", }; // top과 ext 할당을 위로 끌어올려 국제번호 판단하는데 활용 // top =&gt; 전화번호 가장 앞 3자리 const top = tel.substring(0, 3); // ext =&gt; 전화번호 뒤 4자리 const ext = tel.substring(tel.length - 4); // rest =&gt; 지역번호를 뺀 나머지 뒷번호 const rest = tel.substring(3); if (top === "001" || top === "002") { if (rest.length &gt; 12 || rest.length &lt; 8) return failure.global; return success.global; } // 전화번호 오류 1.전화번호의 길이가 맞지 않는 경우 if (tel.length &gt; 11 || tel.length &lt; 9) return failure.domestic; // 전화번호 오류 2.전화번호의 첫 자리가 0으로 시작하지 않을 경우 else if (tel[0] !== "0") return failure.domestic; // 전화번호 앞에서 두 번째 자리가 2일 때 =&gt; 02가 서울이므로 서울에 대한 예외처리 if (tel[1] === "2") { // 서울 전화번호의 경우 02-xxxx-xxxx의 전화번호이므로 총 글자수가 10개 이상이면 오류 if (tel.length !== 10) return failure.seoul; // 서울 전화번호지만 가운데 4자리 숫자가 모두 같을 때는 비정상적인 전화번호로 처리 if (ext[0] === ext[1] &amp;&amp; ext[1] === ext[2] &amp;&amp; ext[2] === ext[3]) return failure.seoul; return success.seoul; } else if (tel[1] === "1") { // 전화번호 앞에서 두 번째 자리가 1일 때 =&gt; 휴대폰일 경우밖에 없음 // 해당하는 세자리 수가 map에서 없을 때는 오류 발생 if (!map[top]) return failure.domestic; // 해당하는 세자리 수가 map에는 있지만 010은 아닐 때 =&gt; 휴대폰이지만 X if (tel[2] !== "0") return failure.phone; // 010-XXXX-XXXX의 전화번호(11자리)이고, 전화번호 뒷부분(8자리)의 가장 첫 번째 수가 짝수일 때 =&gt; 휴대폰이면서 O if (tel.length === 11 &amp;&amp; parseInt(tel[3]) % 2 === 0) return success.phone; //이외의 경우 휴대폰이지만 X return failure.phone; } else if (map[top]) { // 02, 01X 이외의 경우에 앞 세자리가 전화번호에 있을 경우 // 0XX-0XX-XXXX의 경우 맞는 지역을 찾고 X와 함께 리턴 if (tel.length === 10 &amp;&amp; tel[3] === "0") return [map[top], "X"]; // 0XX-XXXX-XXXX(앞 두번째 자리가 3 이상)의 경우 -&gt; 지역명과 함께 O 리턴 return [map[top], "O"]; } // 나머지의 예외 케이스는 모두 실패처리 return failure.domestic;
} console.log("국제전화 테스트케이스");
// output: [ '국제전화', 'O' ]
console.log(solution("002-2234-1234"));
// output: [ '국제전화', 'X' ]
console.log(solution("002-22344-12344121123"));
// output: [ '국제전화', 'O' ]
console.log(solution("001-2234----12342"));
// output: [ '국제전화', 'X' ]
console.log(solution("001-2234-122")); console.log("- 포함 동작 테스트케이스");
// output: [ '휴대폰', 'O' ]
console.log(solution("010-------2234----1234"));
// output: [ '서울', 'O' ]
console.log(solution("0-2-1-2-3--41-1-1-2")); console.log("일반 케이스");
// output: [ '휴대폰', 'X' ]
console.log(solution("010-123-1234"));
// output: [ '휴대폰', 'O' ]
console.log(solution("010-2234-1234"));
// output: [ '서울', 'O' ]
console.log(solution("02-1234-1234"));
// output: [ '전국', 'X' ]
console.log(solution("12-1234-1234"));
// output: [ '서울', 'X' ]
console.log(solution("0212341111"));
// output: [ '경기', 'O' ]
console.log(solution("0311237890"));
// output: [ '전남', 'X' ]
console.log(solution("061-012-7890"));
// output: [ '전국', 'X' ]
console.log(solution("015-0157899"));
// output: [ '대전', 'O' ]
console.log(solution("042-2123-7890")); ]]></description><link>부스트캠프/베이직/문제-분석.html</link><guid isPermaLink="false">부스트캠프/베이직/문제 분석.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_8]]></title><description><![CDATA[<a data-href="Day_8 문제" href="부스트캠프/베이직/day_8-문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_8 문제</a><br>
<a data-href="Day_8 학습저장소" href="부스트캠프/베이직/day_8-학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_8 학습저장소</a>]]></description><link>부스트캠프/베이직/day_8.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_8.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_8 학습저장소]]></title><description><![CDATA[처음세 소수점 나오는 시간들을 보고 흠칫했다. 이러한 복잡한 시간들을 기반으로 긴 요구사항을 논리적인 수식으로 계산하고 원하는 형식으로 출력할 수 있도록 설계 및 구현하는 능력을 기르기 위해 내준 문제인 것 같다고 생각했다.지구의 그레고리안 달력을 기준으로 특정 날짜를 입력
-&gt; 그 날짜에 해당하는 화성일을 포함하는 화성월을 표시&gt; 지구날짜는? 2024-01-01
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 화성까지 여행 100% 지구날은 738,901 =&gt; 1105 화성년 8월 11일 1105년 8월
Su Lu Ma Me Jo Ve Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28 지구날짜 : 2024-01-01
지구날 계산 2023을 4로 나누기 -&gt; 505개의 윤년 + 1518개의 일반년
505 * 366 + 1518 * 365 일
184,830 + 554,070 = 738900일
1월 1일의 1일을 더해서 738901일 화성일 계산
- 738901(지구일) / (668+669)(화성년 + 화성윤년) = 552
- 552 * 2 = 1104년 - 1년(0년부터 시작한다고 생각) = 1103년
- 738901(지구일) % (668+669) = 877일
- 887일은 1년보다 기니까 887-668(1103년은 윤년x) = 207일
- 207 / 28 = 7, 207 % 28 = 11
=&gt; 1105(1104+1)년 8월 11일
예시 분석부터 복잡하다.. 처음에는 0년부터 시작하지 않는다는 가정 하에 계산했더니 8월13일이 나와서 0년부터 시작한다고 가정했더니 8월 11일이 나왔기 때문에 0년까지 세야하는 것 같다. 1 화성년 = 686.98 지구일 = 668.5907 화성일
1 화성일 : 1 솔(sol) = 24.65979 지구시간 (지구 하루와 화성 하루가 같다고 가정합니다.) 1화성년 = 668 화성일, 2년마다 669 화성일
1주일 = 7화성일
1화성월 = 28화성일(=4주일)
1화성년 =24화성월
6화성월마다 하루씩 빠짐 1년 = 24*28 - 4 = 668 화성일
윤년마다 하루 추가(669 화성일) 6화성월마다 하루 빠진 마지막 요일은 당겨서 계산 X 다음 달의 솔 솔리스(일요일)부터 다시 시작 솔 솔리스 (Sol Solis: 태양의 날) - 일
솔 루나에 (Sol Lunae: 달의 날) - 월
솔 마르티우스 (Sol Martius: 화성의 날) - 화
솔 메르쿠리 (Sol Mercurii: 수성의 날) - 수
솔 요비스 (Sol Jovis: 목성의 날) - 목
솔 베네리스 (Sol Veneris: 금성의 날) - 금
솔 사투르니 (Sol Saturni: 토성의 날) - 토 1년 = 365일
4년(윤년)마다 2월 말에 29일을 붙여 366일
기능은 화성과 지구를 클래스나 개별함수로 구현하면 좋을 것 같다고 생각했다. 아무래도 여러 기능들을 세분화해서 구현하려고 하다보니 여러개의 함수가 분리되어 있는 것도 가독성이 떨어질 것 같아 클래스가 더 낫다고 판단이 되었다.지구날을 달력대로 받는게 아니라 지구날을 일자로 바꾸고 그 일자를 다시 계산하여 화성 날짜로 바꾸는게 용이할 것 같았다.
해당 메소드는 정적 메소드로 구현하여 생성자에서도 사용할 수 있게끔 하였다.static convertYear(fullDate) { let year = Math.floor(fullDate / (668 + 669)) * 2; let restDays = (fullDate % (668 + 669)) - 1; if (year % 2 === 0 &amp;&amp; restDays &gt; 669) { year++; restDays -= 669; } else if (restDays &gt; 668) { year++; restDays -= 668; } return [year, restDays]; }
restDays에서 하루를 뺀 이유는 1년 1월 1일부터 시작하기 때문에 이미 하루가 넘어가 있는 상태로 볼 수 있어 하루를 뺐다.
또한 이를 계산하는 과정에서 년도를 일반년 + 윤년의 경우를 합쳐 계산한 뒤에 1년 이상의 일수가 남으면 다시금 빼는 방식으로 설계했는데, 로직 자체가 남은 일수를 계산할 때도 쓰이는 변수와 로직이 같기 때문에 굳이 분리하기보단 통일한 다음에 리턴값에 배열로 넣어주었다.이 달력은 윤년을 판단해서 출력해야 한다. static convertMonthAndDays(restDays) { let month; for (month = 1; month &lt; 24; month++) { if (month % 6 === 0) { if (restDays &gt; 27) restDays -= 27; else break; } else { if (restDays &gt; 28) { restDays -= 28; } else break; } } return [month, restDays - 1]; }
for문을 통해 조건을 거는게 보다 코드 로직이 편할 것 같아 for문으로 구성해 보았다.
윤년을 신경쓰지 않은 이유는 어차피 마지막 월이기 때문에 마지막 월은 그대로 남겨두어야 다음 년도전까지의 날짜까지 되어 있는 날들이 마지막 월까지 갔을 때 남은 일수를 그대로 넣을 수 있다.
마지막에 resDays에 -1을 한 이유는 1월 1일부터 시작한다는 것을 가정으로 하고 계산했기 때문에 1일이 추가되었으므로 빼주어야 한다.달력을 출력하는 메소드는 그냥 각 row마다 배열로 구성한 뒤 마지막 28일만 관건이기 때문에 조건문을 넣어주었다. printCalendar() { let calendar = [ ["So", "Lu", "Ma", "Me", "Jo", "Ve", "Sa"], [" 1", " 2", " 3", " 4", " 5", " 6", " 7"], [" 8", " 9", "10", "11", "12", "13", "14"], ["15", "16", "17", "18", "19", "20", "21"], [ "22", "23", "24", "25", "26", "27", this.mon % 6 === 0 ? (this.year % 2 === 0 ? "28" : "") : "28", ], ]; let stdOut = ` ${this.year}년 ${this.mon}월\n\n`; calendar.forEach((row) =&gt; { stdOut += row.join(" ") + "\n\n"; }); return stdOut; }
일부러 문자공백수를 맞추기 위해 문자열로 바꾸었고, 이렇게 모든 row를 담은 배열을 forEach문을 통해서 출력 문자열에 넣어주었다.지구일로 변환하는 함수 또한 따로 구현하여 화성의 날짜 계산할 때 필요한 부분을 세분화했다.
나의 경우에는 년월일-&gt; 일의 큰 메소드 안에 년-&gt;일, 달-&gt;일의 두 가지 메소드를 따로 제작하여 분리했다.// 총 일수로 바꿔주는 메소드 getFullDate() { return this.getFullYearDate() + this.getFullMonthDate() + this.day; } getFullYearDate() { return ( this.countLeapYear() * 366 + (this.year - 1 - this.countLeapYear()) * 365 ); } // 달 -&gt; 날짜로 바꿔주는 메소드 getFullMonthDate() { const daysInMonths = [ 31, // 1월 this.year % 4 === 0 ? 29 : 28, // 2월(윤년 계산) 31, // 3월 30, // 4월 31, // 5월 30, // 6월 31, // 7월 31, // 8월 30, // 9월 31, // 10월 30, // 11월 31, // 12월 ]; if (this.mon === 1) return 0; return daysInMonths .slice(0, this.mon) .reduce((total, days) =&gt; total + days, 0); }
윤년은 총 일수를 알 때 366일인 경우를 알아야 하기 때문에 입력한 연도 전까지 윤년이 몇 개가 있는지 확인하기 위해 메소드를 제작했다. // 윤년 세는 메소드 countLeapYear() { return Math.floor((this.year - 1) / 4); }
const readline = require("readline");
const rl = readline.createInterface({ input: process.stdin, output: process.stdout,
}); const clearLastLine = () =&gt; { process.stdout.moveCursor(0, -1); // up one line process.stdout.clearLine(1); // from cursor to end
}; let earth, mars;
rl.question("지구날짜는? ", (date) =&gt; { earth = new Earth(date.trim()); mars = new Mars(earth.getFullDate()); let load = "____________________"; let ready = "████████████████████"; let i = 0; const loading = setInterval(() =&gt; { if (i !== 0) clearLastLine(); console.log(`${ready.slice(0, i)}${load.slice(i)} 화성까지 여행 ${i * 5}%`); if (i &lt; 20) i++; }, 200); setTimeout(() =&gt; { clearInterval(loading); console.log( `\n지구날은 ${earth.getFullDate().toLocaleString()} =&gt; ${ mars.year } 화성년 ${mars.mon}월 ${mars.days}일\n\n` ); console.log(mars.printCalendar()); rl.close(); }, 5000);
});
rl.on("close", () =&gt; { process.exit();
}); 입력과 출력은 readline 모듈을 통해 구현했다.
진행 바 같은 경우에는 진행정도와 미진행 정도를 바 문자열에서 슬라이싱하고, setInterval을 통해 계속해서 앞 줄을 지우는 clearLastLine()을 통해서 계속해서 상태정도가 올라가는 듯한 효과를 줄 수 있다.
문제에서 학습목표로 주어졌던 비동기 API인 setTimeOut을 사용하여 5초 후에 진행바가 종료되도록 해주었고, 종료된 이후에는 화성의 달력을 출력하도록 하였다.]]></description><link>부스트캠프/베이직/day_8-학습저장소.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_8 학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_9]]></title><description><![CDATA[<a data-href="Day_9 문제" href="부스트캠프/베이직/day_9-문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_9 문제</a><br>
<a data-href="Day_9 학습저장소" href="부스트캠프/베이직/day_9-학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_9 학습저장소</a><br>
<a data-href="Day_9 실수파티" href="부스트캠프/베이직/day_9-실수파티.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_9 실수파티</a>네이버 부스트캠프를 2주일동안 하면서 설계에 대한 감각이 많이 늘은 것 같다. 로그 데이터 자료구조 선택부터 기능별로 함수 분리까지 하는 작업 또한 전에는 하지 못해서 항상 하나의 함수에 모든 코드를 몰아넣기 마련이었는데 많이 발전한 느낌이 든다.]]></description><link>부스트캠프/베이직/day_9.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_9.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_9 문제]]></title><description><![CDATA[
시스템 로그 파일을 분석해서 원하는 데이터 구조를 설계하고 구현할 수 있다. 데이터 구조 내용을 탐색하고 분석해서 결과를 생성할 수 있다. 문자열 분석을 원하는 수준으로 처리할 수 있다. 없음. <a data-tooltip-position="top" aria-label="https://lucas-image.codesquad.kr/1701410305471system.log" rel="noopener nofollow" class="external-link is-unresolved" href="https://lucas-image.codesquad.kr/1701410305471system.log" target="_self">system.log 파일 다운로드</a>
프로그램에서 시스템 로그 파일을 열어서 데이터별로 분류하여 데이터 구조로 구현해야 한다.error	14:22:30.608355+0900	airportd	[corewifi] END REQ [GET BSSID] (pid=5617 proc=iStat Menus Status service=com.apple.corewlan-xpc intf=en1 uuid=92833 err=1)
default	14:22:33.784903+0900	Airmail	[C264.1 Hostname#9e7acbfe:993 initial path ((null))] event: path:start @0.000s
info	14:23:16.765320+0900	bluetoothd	canScanNow session:&lt;private&gt;(Unspecified) allowed:1 deviceLocked:0 deviceFirstUnlocked:1 allowedInBKG:1 sessionState:daemon &lt;private&gt; 로그는 문자열 한 줄마다 하나의 데이터로 구분한다. 한 줄의 마지막은 줄바꿈(\n) 문자를 포함한다. 로그는 다음과 같은 요소를 포함하면 각 요소는 탭문자(\t)로 구분한다. 로그 레벨 default, Info, error 등 고정된 값이 아니라 새로운 항목이 추가될 수 있다. 기록 시각 14:22:30.579612+0900&nbsp;시간 형식 프로세스 WindowServer, kernel, mDNSResponder 등 문자열 기록 나머지 문자열 로그 파일을 분석한 데이터를 바탕으로 다음과 같은 기능을 구현할 수 있는 만큼 구현하세요. 대신 각각 다른 함수로 구현하세요.
각 로그 데이터 값을 포함할 객체 또는 타입을 선언해야 합니다. 로그 레벨 유형별로 필터링할 수 있어야 합니다. 로그 시각으로 정렬할 수 있어야 합니다. 프로세스 이름으로 필터링할 수 있어야 합니다. 프로세스 이름으로 정렬할 수 있어야 합니다. 로그레벨, 프로세스 별로 카운트값을 가져올 수 있어야 합니다. 위의 시스템 로그 이외에 규칙에 맞는 데이터 파일을 직접 만들어서 테스트해 보고 학습 결과에 첨부하세요.]]></description><link>부스트캠프/베이직/day_9-문제.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_9 문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_9 실수파티]]></title><description><![CDATA[[logs, logsInfo] = inspectFile(filePath);
TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))
const main = (filePath) =&gt; { [logs, logsInfo] = inspectFile(filePath); filtering("processName", "bluetoothd"); count("processName"); sort("processName");
};
처음엔 파일을 검사할 때 그저 함수로 readline 모듈을 사용해서 받고, 알아서 자연스럽게 다음 코드로 옮겨갈 것이라 생각했지만 에러가 떴다. 이유를 살펴보니 readline 모듈이 비동기적으로 작동하기 때문에 내가 만든 다른 함수들이 먼저 실행되고, 이 때문에 없는 배열을 참조하려 하면서 나온 에러였다.function inspectFile(filename) { return new Promise((resolve, reject) =&gt; { ... reader.on("line", (line) =&gt; { inspect(line, logs, logsInfo); }); reader.on("close", () =&gt; { resolve([logs, logsInfo]); }); });
}
readline 모듈을 사용한 함수를 Promise 객체화시켜 데이터 분석 작업이 모두 끝날 때까지 await을 걸어주어 동기적으로 실행되게끔 설계했다.const main = async (filePath) =&gt; { [logs, logsInfo] = await inspectFile(filePath);
]]></description><link>부스트캠프/베이직/day_9-실수파티.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_9 실수파티.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_9 학습저장소]]></title><description><![CDATA[시스템 로그 파일을 분석해서 원하는 데이터 구조를 설계하고 구현하는 프로그램을 작성해야 하는 이번 문제의 핵심은 데이터 구조 내용을 어떻게 탐색하고 분석하는 방법을 선택하는지일 것이다. 해당 데이터 구조에 따라서 성능이 달라질 가능성이 있기 때문에 최적의 구조로 필터링이나 정렬 등을 할 수 있어야 할 것 같다. error 14:22:30.608355+0900 airportd [corewifi] END REQ [GET BSSID] (pid=5617 proc=iStat Menus Status service=com.apple.corewlan-xpc intf=en1 uuid=92833 err=1) default 14:22:33.784903+0900 Airmail [C264.1 Hostname#9e7acbfe:993 initial path ((null))] event: path:start @0.000s info 14:23:16.765320+0900 bluetoothd canScanNow session:&lt;private&gt;(Unspecified) allowed:1 deviceLocked:0 deviceFirstUnlocked:1 allowedInBKG:1 sessionState:daemon &lt;private&gt;
로그은 \n으로 나뉘어지고, 각 요소는 \t로 구분된다.로그 레벨\t기록 시각\t프로세스\t기록
아래와 같은 형식으로 기록된다. 그렇다면 이 로그파일을 readline 모듈을 통해서 한줄한줄 읽어가는 방식도 가능하고, fs 모듈을 사용해서 파일 자체를 통으로 읽는 것도 가능하다.하지만 아래 프로그래밍 요구사항에서 나와있는 다른 요구사항중에 필터링, 정렬 등의 키워드가 있는 것을 보아 한 배열에 모든 정보들을 객체에 넣은 후에, 정렬이라 필터링 등의 고차함수를 이용하여 결과를 출력하면 되겠다고 생각했다. 이러한 객체들을 만들기 위해서는 한 줄로 읽든, \n으로 split한 다음에 forEach를 돌려 처리하는 방법 중에 골라야 할 것 같다.function inspectFile(filename) { return new Promise((resolve, reject) =&gt; { var instream = fs.createReadStream(filename); var reader = readline.createInterface({ input: instream }); var logs = []; var logsInfo = { processName: {}, logLevel: {}, }; reader.on("line", (line) =&gt; { inspect(line, logs, logsInfo); }); reader.on("close", () =&gt; { resolve([logs, logsInfo]); }); reader.on("error", (error) =&gt; { reject(error); }); });
} let logs, logsInfo;
const main = async (filePath) =&gt; { try { [logs, logsInfo] = await inspectFile(filePath); filtering("processName", "bluetoothd"); count("processName"); sort("processName"); } catch (error) { console.error("Error:", error); }
}; main("./1701410305471system.log");
텍스트 파일을 먼저 읽은 후에 이후의 데이터를 가지고 처리해야해서 Promise를 사용해서 해당 파일을 읽으면서 모두 데이터들에 대한 처리를 완성한 후에 기능들을 실행할 수 있도록 async/await문을 사용했다.function inspect(line, logs, logsInfo) { [logLevel, recordTime, processName, record] = line.split("\t"); if ((processName &amp;&amp; processName.length &gt; 30) || logLevel.length &gt; 15) return; logs.push({ logLevel: logLevel, recordTime: recordTime, processName: processName, record: record, }); logsInfo.processName[processName] ? logsInfo.processName[processName]++ : (logsInfo.processName[processName] = 1); logsInfo.logLevel[logLevel] ? logsInfo.logLevel[logLevel]++ : (logsInfo.logLevel[logLevel] = 1);
}
reader.on("line")에 두번째로 들어가는 parameter의 콜백함수는 각 line은 tab으로 split하여 객체로 만들어 준 다음에 배열에 푸시하였다. 여기서 한번 모든 로그를 push했을 때 \t으로 개행되지 않은 예외 케이스가 존재했기 때문에 비정상적으로 긴 프로세스 이름과 로그의 이름이 있을 경우 통과하도록 만들었다.// 필터링
function filtering(div, filterName) { let filteredLogs; if (div === "logLevel") { filteredLogs = logs.filter((item) =&gt; item.logLevel !== filterName); } else if (div === "processName") { filteredLogs = logs.filter((item) =&gt; item.processName !== filterName); } else { console.log("잘못된 구분입니다."); return; } filteredLogs.forEach((item) =&gt; { console.log(Object.values(item).join("\t")); });
}
필터링의 경우 필터링할 구분(로그 레벨, 프로세스 이름)과 걸러낼 이름을 받아 배열에 filter 처리를 해주고, 다시 이를 원래의 로그 형태로 출력될 수 있도록 문자열로 console.log해 주었다.function sort(div, reverse = false) { if (div === "recordTime") { if (reverse === true) { logs.reverse().forEach((log) =&gt; { console.log(Object.values(log).join("\t")); }); } else { logs.forEach((log) =&gt; { console.log(Object.values(log).join("\t")); }); } } else if (div === "processName") { if ((reverse = true)) { console.log( logs.sort((a, b) =&gt; { b.processName - a.processName; }) ); } else { console.log( logs.sort((a, b) =&gt; { a.processName - b.processName; }) ); } } else { console.log("잘못된 구분입니다."); }
}
sort의 경우도 어떤 구분(기록 시간, 프로세스 이름)을 기준으로 정렬해야하는지를 받고, 오름차순 혹은 내림차순으로 받을지 말하는 reverse파라미터를 추가해주었다.
근데 생각해보니 로그의 의미 자체가 '이제까지 활동한 것들을 기록'해주는 것이다.
그러므로 오름차순의 경우에는 따로 시간별로 정렬을 해줄 필요가 없다.
<img src="https://i.imgur.com/kc59lfZ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
그게.. 로그니까
아무튼 역순으로 할 때는 배열을 뒤집어주고 출력해주기만 하면 된다.
프로세스 이름의 경우에는 sort 고차함수를 이용해서 정렳시켜주었다.function count(div) { if (div === "logLevel" || div === "processName") { console.log(logsInfo[div]); } else { console.log("올바른 구분명이 아닙니다."); }
}
아까 입력을 받으면서 로그들을 모두 객체화시키고 배열에 넣는 과정에서 logsInfo라는 별도의 객체를 두었다.function inspect(line, logs, logsInfo) { [logLevel, recordTime, processName, record] = line.split("\t"); if ((processName &amp;&amp; processName.length &gt; 30) || logLevel.length &gt; 15) return; logs.push({ logLevel: logLevel, recordTime: recordTime, processName: processName, record: record, }); logsInfo.processName[processName] ? logsInfo.processName[processName]++ : (logsInfo.processName[processName] = 1); logsInfo.logLevel[logLevel] ? logsInfo.logLevel[logLevel]++ : (logsInfo.logLevel[logLevel] = 1);
}
한 줄씩 로그를 받아가면서 카운트를 동시에 세 주어 나중에 따로 구할 필요가 없도록 설계했다.
따라서 올바른 구분명(로그레벨이나 프로세스 이름)만 입력하면 해당 구분의 카운터를 출력할 수 있도록 설계했다.]]></description><link>부스트캠프/베이직/day_9-학습저장소.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_9 학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/kc59lfZ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/kc59lfZ.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day_5]]></title><description><![CDATA[<a data-href="Day_5 문제" href="부스트캠프/베이직/day_5-문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_5 문제</a><br>
<a data-href="Day_5 학습제출용" href="부스트캠프/베이직/day_5-학습제출용.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_5 학습제출용</a>]]></description><link>부스트캠프/베이직/day_5.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_5.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_6]]></title><description><![CDATA[<a data-href="Day_6 문제" href="부스트캠프/베이직/day_6-문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_6 문제</a><br>
<a data-href="Day_6 학습저장소" href="부스트캠프/베이직/day_6-학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_6 학습저장소</a><br>
<a data-href="Day_6 셀프 체크리스트" href="부스트캠프/베이직/day_6-셀프-체크리스트.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_6 셀프 체크리스트</a>]]></description><link>부스트캠프/베이직/day_6.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_6.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_6 문제]]></title><description><![CDATA[다음과 같이 가상으로 부스트캠프 컨퍼런스 참가자를 모집하려고 합니다.
아래 모집 절차를 고려해서 웹 또는 앱 시스템이 동작하는 방식을 설계해보세요.다음과 같은 내용이 포함되어야 한다.
모집 절차와 매칭되는 상태 관리 다이어그램 상태 변화와 데이터 흐름을 알 수 있는 다이어그램 이메일 전송은 외부 시스템에 요청한다고 가정한다. 당첨차 안내도 외부 문자 시스템을 요청한다고 가정한다. 결제 시스템도 간편한 외부 시스템을 사용한다고 가정한다. 다이어그램은 글씨와 도형으로 표현하면 어떤 형식이어도 무방하다. 데이터와 동작은 서로 다른 형태로 표시한다. 서브시스템 혹은 구성 요소 이름은 명사 형태로 작성하고, 동작이나 행동은 동사 형태로 작성한다. 다른 사람에게 설명한다고 가정하고 혹은 이 설계 문서를 보고 다른 사람이 개발한다고 생각하고 README.md 파일에 보기 좋게 정리해야 한다. 티켓 안내 보기 ⇒ 티켓 폼 제출 (이메일 포함) ⇒ 접수 결과 안내 이메일 발송 ⇒ 카드 또는 가상계좌로 티켓비용 결제 ⇒ 결제 완료 확인 이메일 발송 ⇒ 랜덤 선택 ⇒ 당첨자 안내 ⇒ 미당첨자는 환불 처리 후 안내
전체 티켓 개수 설정 접수 현황 보기 결제 현황 보기 당첨자 명단 보고 당첨자 안내하기 환불 처리 안내 자동화 시스템이 아니고 사람이 직접한다고 상상해본다. 참가자와 관리자 입장에서 생각해본다. 특정한 화면이나 구현할 내용을 먼저 생각하면 생각이 갇힐 수도 있다. 모든 세밀한 예외상황까지는 고려하지 않아도 무방하다. 예를 들어 카드 번호 오류로 재결제를 해야한다거나 이메일이 발송되지 않아서 재전송하는 경우 등은 고려하지 않아도 된다.
]]></description><link>부스트캠프/베이직/day_6-문제.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_6 문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_6 셀프 체크리스트]]></title><description><![CDATA[수료생의 접근법을 보면서 공통적으로 찾아볼 수 있었던 부분은 외부 업체로부터 가져온 시스템을 사용하는 이메일, 결제, 문자 등의 시스템들을 경외시하지 않고 이러한 시스템들과 컨퍼런스 예약 시스템이 긴밀하게 연결되어 있는 구조였다. 각 시스템을 거쳐 돌아오는 response에 대해서 반응하여 다음 플로우로 넘어가는 구조를 잘 볼 수 있었는데, 이러한 구조를 보고 내가 짠 유저플로우 차트를 보니 그런 부분이 부족하다는 점을 깨달았다. 외부 시스템을 사용하는 경우도 네이버 로그인이나 결제 등 다양한 부분에서 사용되기도 하는데 프로젝트에서도 이러한 부분이 가장 해결하기 어려운 부분이었다. 하지만 막상 이렇게 플로우차트를 보고 만들려고 하다 보니 나도 모르게 외부에서 사용하는 시스템이니까 간단하게 하고 넘겨도 되겠다 하는 생각에 이러한 부분을 신경쓰지 못한게 보여 보완의 필요성을 느끼게 되었다.]]></description><link>부스트캠프/베이직/day_6-셀프-체크리스트.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_6 셀프 체크리스트.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_6 학습저장소]]></title><description><![CDATA[부스트캠프 1주차에는 주로 자바스크립트를 이용한 코딩 구현문제로 이루어져 있었는데, 2주차로 들어오니 문제의 방향이 조금 바뀐 것 같다는 생각을 했다.이렇게 한 이유는 JK님의 랩업세션에서 조금이나마 파악할 수 있었는데, 그저 '코더'가 아닌 '개발자'를 양성하겠다는 부스트캠프의 이념에 따라 기획된 것 같다고 생각했다.개발자에게 필요한 것은 단순 코드를 구현하는 역량 뿐만이 아닌 주어진 문제를 해결하기 위한 방법을 설계하고 이를 검증하는 단계까지 할 수 있는 역량이다. 그런 의미에서 설계가 중심이 된 이번 문제는 보다 의미가 있다고 생각한다.컨퍼런스 등록 시스템은 웹 또는 앱 시스템이다.이 시스템을 통해 사람들은 티켓을 구매하여 폼을 제출하고, 이메일 링크를 통해 구매한 뒤 추첨하여 일부를 당첨시키는 로직이다.이 시스템은 사람들이 컨퍼런스 티켓을 구매하는 시스템이기도 하지만, 뒤에서 관리자가 이를 조작할 수 있는 시스템 UI 또한 구성되어야 한다.티켓 안내 보기 ⇒ 티켓 폼 제출 (이메일 포함) ⇒ 접수 결과 안내 이메일 발송 ⇒ 카드 또는 가상계좌로 티켓비용 결제 ⇒ 결제 완료 확인 이메일 발송 ⇒ 랜덤 선택 ⇒ 당첨자 안내 ⇒ 미당첨자는 환불 처리 후 안내문제에서 제시된 일련의 절차들은 모두 유저가 티켓 웹사이트에 접속하여 당첨안내를 받을 때까지의 과정의 나열이다. 관리자 또한 이러한 정보들에 접근하여 갱신 및 조회하는 기능을 설계하는 것이 조건으로 되어 있었으므로 플로우 차트를 통해 구현하면 되겠다고 생각했다.
티켓 안내 보기 티켓 안내문, 컨퍼런스 홍보문 티켓 폼 제출 (이메일 포함) 양식 설계 접수 결과 안내 이메일 발송 양식에서 받은 이메일로 접수 결과 발송 이메일 전송 -&gt; 외부 시스템 요청 접수와 함께 결제 링크 생성 카드 또는 가상계좌로 티켓비용 결제 티켓 비용이 결제되면 완료페이지로 이동
결제 시스템도 간편한 외부 시스템 사용 결제 완료 확인 이메일 발송 결제가 완료되면서 완료 페이지로 이동과 함께 이메일 발송 랜덤 선택 받은 폼들에서 랜덤 추첨 당첨자 안내 추첨해서 나온 당첨자들에게 문자로 개별 안내 당첨자 이메일 안내도 외부 문자 시스템 요청 미당첨자는 환불 처리 후 안내
폼 데이터 구조의 경우 미리 설계할 경우 당첨이나 결제 여부 등에 따른 추첨 등에 대한 처리가 좀 더 용이할 것 같아 설계해 보았다.
접수번호 접수자 식별에 필요 이름 접수자 기본 정보 나이 나중에 티켓 예매 유저 정보 통계를 낼 때 쓸만한 정보라서 추가해봤다. 이메일 결제 및 접수 완료 메일을 보내기 위한 주소 핸드폰 번호 컨퍼런스 당첨 안내를 위한 문자에 쓰이는 번호 결제여부 결제여부를 보고 결제한 사람들만 추첨을 돌려 당첨시켜야 하므로 결제여부를 따로 추가했다. 당첨 여부 결제한 사람들만 추첨을 돌린 뒤 관리자가 설정한 유저의 수만큼만 당첨 여부를 설정해주어 후에 관리자가 이를 보고 당첨자 연락을 돌릴 수 있도록 하였다. 환불받을 계좌 만약 당첨되지 않은 사람의 경우 환불을 해줘야 하지만 미당첨 후에 따로 받으면 그만큼의 절차가 소요되므로 처음에 폼에서부터 환불받을 계좌를 받았다.
계좌는 배열로 앞에는 은행, 뒤에는 계좌번호의 형식으로 하여 환불하는데 필요한 계좌 정보를 모두 담으려한다. 전체 티켓 개수 설정 처음에 전체 티켓 개수를 갱신함으로써 추첨인원에 맞게 추첨할 수 있도록 하였다 접수 현황 보기
결제 현황 보기
당첨자 명단 보고 당첨자 안내하기 당첨자 명단 조회 환불 처리 안내
- 관리자가 추첨 이후 미당첨자 인원에게 환불 처리 안내를 보내기 위한 조회
- 당첨자 명단과는 반대로 미당첨자 명단 조회로 볼 수 있다.
기타 조회관련 사항들은 데이터베이스에 있는 값들을 조회만 하면 되므로 UI를 통해 접근하여 조회하는 간단한 방식으로 설계하였다.
<img src="https://i.imgur.com/0iWUGbl.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/AnaMZnh.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Flow Chart는 온보딩 스크린 또는 홈페이지와 같이 소비자가 제품을 진입하는 시점을 시작으로 제품 구매 또는 회원가입과 같은 최종 조치 또는 결과로 끝나는 것을 말한다. 즉 프로세스 수행에 필요한 일련의 단계와 결과를 시각적으로 표현한 것이다.또한 사용자의 전체 경험을 한눈에 확인할 수 있고, 이를 통하여 세부항목들을 구축해나가는데 유용하다.사용자 여정의 각 터치 포인트는 Flow Chart에서 노드로 표시된다. 노드의 모양은 다양하지만 정해진 의미를 담고 있기 때문에 쉽게 식별할 수 있다. 예를 들어 타원은 프로세스의 시작과 끝을 나타내며 다이아몬드는 결 정을 의미하므로 "예" 및 "아니오" 화살표가 표시된다. 사각형은 "로그인" 또는 "구매"를 의미한다.]]></description><link>부스트캠프/베이직/day_6-학습저장소.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_6 학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/0iWUGbl.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/0iWUGbl.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day_7]]></title><description><![CDATA[<a data-href="Day_7 스택 계산기" href="부스트캠프/베이직/day_7-스택-계산기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_7 스택 계산기</a><br>
<a data-href="Day_7 학습저장소" href="부스트캠프/베이직/day_7-학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_7 학습저장소</a><br>
<a data-href="Day_7 실수축제" href="부스트캠프/베이직/day_7-실수축제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_7 실수축제</a><br>
<a data-href="Day_7 셀프 체크리스트" href="부스트캠프/베이직/day_7-셀프-체크리스트.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_7 셀프 체크리스트</a>]]></description><link>부스트캠프/베이직/day_7.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_7.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_7 셀프 체크리스트]]></title><description><![CDATA[수료생의 접근법에서 눈에 띄었던 점은 Stack 클래스를 따로 선언하여 이를 다시금 스택 계산기 클래스에서 사용했다는 점이었다. 이렇게 될 경우 맨 처음에는 '굳이 이렇게 하게 되면 나중에 로직을 살펴볼 때 오히려 계속해서 올라가면서 알아봐야 하기 때문에 힘들지 않을까?'하는 생각이 있었는데, overflow와 같은 기능은 스택 메모리에서 발생하는 문제이지, 계산기에서 발생하는 문제가 아니라는 말에 큰 깨달음을 얻었다. 내가 생각하기에는 그저 계산기에 모든 기능이 들어가있으면 되겠다고 생각했지만, 수료생분은 그 계산기 안에서도 관리하는 스택과 레지스터 등의 역할을 확실히 잡아놓고 코드를 썼기 때문에 해당 기능에서 제공하는 에러인지, 자료구조의 기능인지를 명확하게 볼 수 있어 이러한 부분은 내가 간과했다고 생각하여 다시금 깨달음을 얻을 수 있었다.깨달은 점을 바탕으로 내 코드 또한 어떤 것이 '스택'에서 제공해야 하는 오류이고, 어떤 것이 '스택 계산기'에서 제공해야 하는 에러인지 다시금 생각해보았다. 이미 정해진 스택의 사이즈를 벗어나지 않도록 뜨게 하는 empty 에러나 overflow 에러가 내가 설계한 스택 계산기에서 제공해야 하는 에러가 아닌 스택에서 제공해야 하는 에러임을 깨달았다. 이에 나 또한 기존에 배열로만 만들었었던 스택을 클래스로 따로 선언하여 해당 클래스에서 제공하는 에러가 될 수 있도록 설계를 재구성하였다.]]></description><link>부스트캠프/베이직/day_7-셀프-체크리스트.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_7 셀프 체크리스트.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_7 스택 계산기]]></title><description><![CDATA[
배열로 스택 구조를 직접 구현할 수 있다. 스택 동작을 이해하고 원하는 동작을 처리할 수 있다. 레지스터 역할을 이해할 수 있다. 동작 구현을 위해서 함수를 작게 분리할 수 있다. 스택 Stack 동작 방식에 대해 학습해야 합니다. 다음과 같은 명령어를 지원하는 간단한 스택메모리 계산기를 만들려고 합니다.<img alt="stack-register" src="https://lucas-image.codesquad.kr/1700731986654stack-register.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
스택 내부 공간은 총 8칸만 존재합니다. 레지스터는 A, B 두 개만 존재하며, ADD나 SUB 명령으로 계산하는 용도로 사용합니다. 레지스터나 스택 값은 모두 정수형을 기준으로 계산합니다. 계산기가 지원하는 명령은 다음과 같습니다.
POPA&nbsp;명령은 스택 메모리에서 값 하나를 꺼내서 A 레지스터로 복사합니다. 만약 스택에 꺼낼 값이 없으면 "EMPTY"를 출력합니다. POPB&nbsp;명령은 스택 메모리에서 값 하나를 꺼내서 B 레지스터로 복사합니다. 만약 스택에 꺼낼 값이 없으면 "EMPTY"를 출력합니다. ADD&nbsp;명령은 A와 B 레지스터 값을 더해서 스택에 PUSH합니다. SUB&nbsp;명령은 A 레지스터 값에서 B 레지스터 값을 빼서 스택에 PUSH합니다. PUSH0&nbsp;명령은 스택에 0 값을 PUSH합니다. PUSH1&nbsp;명령은 스택에 1 값을 PUSH합니다. PUSH2&nbsp;명령은 스택에 2 값을 PUSH합니다. SWAP&nbsp;명령은 A 레지스터 값과 B 레지스터 값을 맞교환합니다. PRINT&nbsp;명령은 스택 마지막 값을 꺼내서 출력합니다. 이 때 스택은 하나 줄어듭니다. 만약 스택이 비어있으면 "EMPTY"를 출력에 추가합니다. 입력값은 명령만 포함하고 있습니다. 입력값 배열은 최대 100까지만 포함합니다. 입력값 배열에 모든 명령을 처리하고 하면 계산을 멈추고 return 합니다. 레지스터 A와 B는 POP 명령으로 스택에서 값을 가져올 수 있습니다. 실행하고 처음에는 값이 없습니다. 만약 레지스터 A나 B가 초기 상태로 값이 없으면, ADD, SUB, SWAP 연산을 수행할 수 없어서 "ERROR"를 출력합니다. 스택에서 꺼내는 POPA, POPB, PRINT 명령을 수행할 때 값이 없으면 "EMPTY"를 출력합니다. 스택에 값을 추가하는 ADD, SUB, PUSH0, PUSH1, PUSH2 명령을 수행할 때, 8칸을 모두 채운 이후에는 "OVERFLOW"를 출력에 추가합니다. 입력한 명령 중에 처리할 수 없는 명령의 경우는 "UNKNOWN"을 출력하고 다음 명령을 수행합니다. 8개 높이(또는 길이)를 가지는 Stack 동작 PUSH, POP 구현은 각 언어에서 제공하는 배열Array, 리스트List, 벡터Vector 등 자료구조만 이용해서 별도 타입을 구현하세요. 긴 함수 하나로 구현하지 말고, 각 명령어 처리는 개별 함수나 메소드로 분리해서 작성해야 합니다. 특히 하나의 명령어는 개별 함수로 분리해서 작성하세요. 입력값 ["PRINT", "PUSH0", "PRINT", "POPA"]
==&gt; return ["EMPTY", "0", "EMPTY"]처음 PRINT는 스택이 비어있으니 "EMPTY", 그 다음 PUSH0을 하고 PRINT하면 0을 출력합니다.
그 다음 POPA는 스택이 비어있으니 "EMPTY"를 출력합니다.입력값 ["PUSH1", "PUSH1", "PUSH2", "POPA", "POPB", "SWAP", "ADD", "PRINT", "PRINT"]
==&gt; return ["3", "1"]스택에 1, 1, 2 순서로 값을 넣고 POPA로 2를 꺼내서 A에 보관, 1을 꺼내서 B에 보관합니다.
SWAP으로 A에 1, B에 2로 바뀌고 ADD로 1+2 = 3 값을 다시 스택에 넣고, PRINT로 꺼내서 3을 출력하고, 한 번 더 PRINT로 1을 꺼내서 출력합니다.입력값 ["PUSH2", "PUSH2", "PUSH1", "POPA", "POPB", "SWAP", "SUB", "POPA", "POPB", "ADD", "PRINT"]
==&gt; return ["3"]스택에 2, 2, 1 순서로 값을 넣고, POPA로 1을 꺼내서 A에 보관, POPB로 2를 꺼내서 B에 보관합니다.
SWAP으로 A에 2로, B에 1로 바뀌고, SUB로 2-1 = 1 값을 다시 스택에 넣고, POPA로 1을 꺼내서 A에 보관, 2을 꺼내서 B에 보관합니다.
ADD로 1+2 = 4 값을 스택에 넣고 PRINT로 꺼내서 3를 출력합니다.입력값 ["ADD", "PUSH2", "PUSH1", "PUSH0", "PUSH2", "PUSH1", "PUSH2", "PUSH2", "PUSH0", "PUSH2", "PUSH3"]
==&gt; return ["ERROR", "OVERFLOW", "UNKNOWN"]레지스터에 값이 없는 데 ADD는 실패해서 ERROR를 출력합니다.
PUSH 명령을 9개 수행하면서 9번째 명령은 실패해서 OVERFLOW를 출력합니다.
마지막 PUSH3 명령은 수행하지 못하기 때문에 UNKNOWN을 출력합니다.]]></description><link>부스트캠프/베이직/day_7-스택-계산기.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_7 스택 계산기.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://lucas-image.codesquad.kr/1700731986654stack-register.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://lucas-image.codesquad.kr/1700731986654stack-register.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day_7 실수축제]]></title><description><![CDATA[ switch (command) { ... case "PRINT": result = calculator.print(); if (result) stdOut.push(result); stdOut.push(result); break; }
입력값: ["PRINT", "PUSH0", "PRINT", "POPA"]
예상했던 결과값: ["EMPTY", "0", "EMPTY"]
실제 결과값: ["EMPTY", "EMPTY"]나는 각 메소드들의 리턴값에 대해서 에러나 구현 조건에 의해 특정 값을 리턴하지 않는 이상 따로 return값을 넣어주지 않았다. 그렇게 만든 메소드를 바탕으로 Switch case문을 통해 메소드를 실행시키고 여기에서 리턴값이 있는 경우에만 나중에 출력할 배열에 넣어주도록 만들었다. 하지만 이 경우 만약에 0이란 값이 오류가 아닌데도 의도해서 PUSH0 -&gt; PRINT와 같이 동작시킬 경우 PRINT가 리턴하는 수는 0이기 때문에 falsy한 값으로 취급하여 if(result)에서 true 조건으로 가지 못해 0이 결과값 배열에 추가되지 않는 현상이 발생했다.이러한 오류가 나는 부분을 보완하기 위해 메소드를 실행하고 에러나 구현조건에 의해 특정 값을 리턴하지 않는 경우 undefined가 리턴되는 점을 고려하여 typeof를 통해 필요없는 리턴값들만 필터링하도록 로직을 변경하였다....
case "PRINT": result = calculator.print(); if (typeof result !== "undefined") stdOut.push(result); break; ]]></description><link>부스트캠프/베이직/day_7-실수축제.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_7 실수축제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_7 학습저장소]]></title><description><![CDATA[기본적인 스택 구조를 배열로 구현하는 문제이다. 하지만 그저 배열에서 PUSH, POP 등을 구현하는 것이 아닌 계산기의 형태로 계산기에는 레지스터 또한 들어가 있다. 이러한 점을 고려하면서 설계를 하고 구현해보라는 식의 문제인데, 설계와 코딩을 둘 다 신경쓸 수 있도록 만든 문제같다.<img src="https://i.imgur.com/D6AsLK3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
8개 높이(또는 길이)를 가지는 Stack 동작 PUSH, POP 구현은 각 언어에서 제공하는 배열Array, 리스트List, 벡터Vector 등 자료구조만 이용해서 별도 타입을 구현하라라고 되어있다. 자바스크립트의 경우는 배열을 사용하면 된다.
긴 함수 하나로 구현하지 말고, 각 명령어 처리는 개별 함수나 메소드로 분리해서 작성해야 함. 특히 하나의 명령어는 개별 함수로 분리해서 작성하라는 안내가 되어 있으므로 자바스크립트에서는 클래스를 이용하여 각 기능들을 메소드로 구현하면 될 것 같다.
배열 말고도 스택 계산기에는 값을 일시적으로 저장할 수 있는 레지스터 A, B 두 개가 있다. 입력한 명령 중에 처리할 수 없는 명령의 경우는 "UNKNOWN"을 출력하고 다음 명령을 수행
입력값 배열에 모든 명령을 처리하면 계산을 멈추고 return
입력값은 명령만 포함
입력값 배열은 최대 100까지만 포함 POPA - 스택 메모리에서 값 하나를 꺼내 A 레지스터로 복사. 꺼낼 값이 없으면 "EMPTY"출력 명령을 수행할 때 값이 없으면 "EMPTY"를 출력
레지스터 A와 B는 POP 명령으로 스택에서 값을 가져올 수 있음. 실행하고 처음에는 값이 없음 POPB - 스택 메모리에서 값 하나를 꺼내 B 레지스터로 복사. 꺼낼 값이 없으면 "EMPTY"출력 명령을 수행할 때 값이 없으면 "EMPTY"를 출력
레지스터 A와 B는 POP 명령으로 스택에서 값을 가져올 수 있음. 실행하고 처음에는 값이 없음 ADD - A와 B 레지스터 값을 더해서 스택에 PUSH 8칸을 모두 채운 이후에는 "OVERFLOW"를 출력
만약 레지스터 A나 B가 초기 상태로 값이 없으면, ADD 연산을 수행할 수 없어서 "ERROR"를 출력 SUB - A 레지스터 값에서 B 레지스터 값을 빼서 스택에 PUSH 8칸을 모두 채운 이후에는 "OVERFLOW"를 출력
만약 레지스터 A나 B가 초기 상태로 값이 없으면, SUB 연산을 수행할 수 없어서 "ERROR"를 출력 PUSH0 - 스택에 0 값을 PUSH 8칸을 모두 채운 이후에는 "OVERFLOW"를 출력 PUSH1 - 스택에 1 값을 PUSH 8칸을 모두 채운 이후에는 "OVERFLOW"를 출력 PUSH2 - 스택에 2 값을 PUSH 8칸을 모두 채운 이후에는 "OVERFLOW"를 출력 SWAP - A레지스터 값과 B 레지스터 값을 맞교환 만약 레지스터 A나 B가 초기 상태로 값이 없으면, SWAP 연산을 수행할 수 없어서 "ERROR"를 출력 PRINT - 스택 마지막 값을 꺼내서 출력. 이 때 스택은 하나 줄어듦. 만약 스택이 비어있으면 "EMPTY"를 출력에 추가. 명령을 수행할 때 값이 없으면 "EMPTY"를 출력 class Stack_Cal { constructor() { this.registerA = ""; this.registerB = ""; this.stack = new Array(8).fill(""); }
}
스택 계산기에서는 정수 값을 받기 때문에 0으로 초기값을 설정하게 되면 이 또한 값으로 받아들인다. 그렇기 때문에 일부러 빈 문자열을 초기값으로 만들었다. popA() { if (this.stack.length === 0) return "EMPTY"; this.registerA = this.stack.pop(); } popB() { if (this.stack.length === 0) return "EMPTY"; this.registerB = this.stack.pop(); }
add() { if (!this.registerA || !this.registerB) return "ERROR"; if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(this.registerA + this.registerB); } sub() { if (!this.registerA || !this.registerB) return "ERROR"; if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(this.registerA - this.registerB); } push0() { if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(0); } push1() { if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(1); } push2() { if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(2); } swap() { if (!this.registerA || !this.registerB) return "ERROR"; let temp = this.registerA; this.registerA = this.registerB; this.registerB = temp; } print() { if (this.stack.length === 0) return "EMPTY"; return this.stack.pop(); }
class Stack_Cal { constructor() { this.registerA = ""; this.registerB = ""; this.stack = new Array(); } popA() { if (this.stack.length === 0) return "EMPTY"; this.registerA = this.stack.pop(); } popB() { if (this.stack.length === 0) return "EMPTY"; this.registerB = this.stack.pop(); } add() { if (!this.registerA || !this.registerB) return "ERROR"; if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(this.registerA + this.registerB); } sub() { if (!this.registerA || !this.registerB) return "ERROR"; if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(this.registerA - this.registerB); } push0() { if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(0); } push1() { if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(1); } push2() { if (this.stack.length === 8) return "OVERFLOW"; this.stack.push(2); } swap() { if (!this.registerA || !this.registerB) return "ERROR"; let temp = this.registerA; this.registerA = this.registerB; this.registerB = temp; } print() { if (this.stack.length === 0) return "EMPTY"; return this.stack.pop(); }
} function command(commandList) { let calculator = new Stack_Cal(); let stdOut = []; commandList.forEach((command) =&gt; { let result; switch (command) { case "POPA": result = calculator.popA(); if (typeof result !== "undefined") stdOut.push(result); break; case "POPB": result = calculator.popB(); if (typeof result !== "undefined") stdOut.push(result); break; case "ADD": result = calculator.add(); if (typeof result !== "undefined") stdOut.push(result); break; case "SUB": result = calculator.sub(); if (typeof result !== "undefined") stdOut.push(result); break; case "PUSH0": result = calculator.push0(); if (typeof result !== "undefined") stdOut.push(result); break; case "PUSH1": result = calculator.push1(); if (typeof result !== "undefined") stdOut.push(result); break; case "PUSH2": result = calculator.push2(); if (typeof result !== "undefined") stdOut.push(result); break; case "SWAP": result = calculator.swap(); if (typeof result !== "undefined") stdOut.push(result); break; case "PRINT": result = calculator.print(); if (typeof result !== "undefined") stdOut.push(result); break; default: stdOut.push("UNKNOWN"); break; } }); return stdOut;
}
명령어 입력기는 switch case문을 사용해서 해당 메소드를 실행하고, 실행 결과가 따로 있는 경우 실행 결과 배열에 넣어주도록 설계했다. ]]></description><link>부스트캠프/베이직/day_7-학습저장소.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_7 학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/D6AsLK3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/D6AsLK3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day_8 문제]]></title><description><![CDATA[
조금 긴 요구사항을 논리적인 수식으로 계산하고 원하는 형식으로 출력할 수 있다. 비동기 API를 사용해서 콘솔에 출력을 업데이트할 수 있다. 각 언어별로 콘솔 출력을 위한 함수를 학습해야 합니다.
Javascript :&nbsp;console.log() Swift :&nbsp;print() Kotlin :&nbsp;println() 화성에 거주하는 사람을 위한 화성 달력을 만들려고 합니다. 실제 화성 년월일 계산 단위는 다음과 같습니다.
1 화성년 = 686.98 지구일 = 668.5907 화성일 1 화성일 : 1 솔(sol) = 24.65979 지구시간 (지구 하루와 화성 하루가 같다고 가정합니다.) 계산 정확성과 편의성을 위해 다음과 같이 정합니다.
1화성년을 668화성일로 정하고, 2년마다 669화성일로 정합니다. 1주일(화성주일)을 7화성일로 정합니다. 1화성월을 28화성일(=4주일)로 정합니다. 1화성년 달력을 24화성월로 정합니다.
단, 24×28=672이라서 668보다, 6화성월마다 하루씩, 총 4일을 빼서 672-4=668로 맞춥니다.
윤년의 경우 마지막 한 달에서 하루를 빼지 않고 669일로 맞춥니다. 6화성월마다 하루 빠진 마지막 요일은 다음달에 당겨서 계산하지 않고, 모든 화성월은 솔 솔리스부터 시작합니다. 지구 요일과 동일한 기준으로 일월화수목금토 7개 요일에 이름을 붙입니다.
솔 솔리스 (Sol Solis: 태양의 날)
솔 루나에 (Sol Lunae: 달의 날)
솔 마르티우스 (Sol Martius: 화성의 날)
솔 메르쿠리 (Sol Mercurii: 수성의 날)
솔 요비스 (Sol Jovis: 목성의 날)
솔 베네리스 (Sol Veneris: 금성의 날)
솔 사투르니 (Sol Saturni: 토성의 날)
지구에서 사용하는 그레고리안 달력을 기준으로 특정 날짜를 입력하면
그 날짜에 해당하는 화성일을 포함하는 화성월을 표시하는 프로그램을 작성해야 합니다.계산 편의상 지구 달력 그레고리력은 1년 1월 1일부터 시작이고, 1년은 365일이며 4년마다 2월말에 29일을 붙여서 366일로 계산합니다.지구 날짜를 입력받고 나면, 5초 동안 진행 현황을 콘솔 화면에 업데이트하는 Progress Bar를 직접 구현해서 표시해야 합니다. 적어도 10% 마다 업데이트해서 100%까지 진행 상황을 보여줘야 합니다.예시1
▓▓▓▓▓▓▓▓▓▓░░░░░░░░░░ 50%
예시2
██████████▁▁▁▁▁▁▁▁▁▁ 50%
예시3
⚫⚫⚫⚫⚫⚪⚪⚪⚪⚪ 50% 터미널 설정을 ANSI로 해놓고 ANSICode 코드를 출력하면 폰트색이나 배경색을 지정할 수도 있습니다. ANSI 샘플 코드&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://gist.github.com/godrm/95c9ac19cacd8b8d29127ce908182ae3" target="_self">https://gist.github.com/godrm/95c9ac19cacd8b8d29127ce908182ae3</a> &gt; 지구날짜는? 2024-01-01
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 화성까지 여행 100% 지구날은 738,901 =&gt; 1105 화성년 8월 11일 1105년 8월
Su Lu Ma Me Jo Ve Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
]]></description><link>부스트캠프/베이직/day_8-문제.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_8 문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_3]]></title><link>부스트캠프/베이직/day_3.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_3.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_3 문제]]></title><description><![CDATA[
시각적인 표를 프로그램에서 필요한 데이터 구조로 선언할 수 있다. 직접 만든 데이터 구조를 탐색할 수 있다. 없음. 다음과 같이 특정 게임에 대한 검색 프로그램을 작성하려고 합니다.
검색 동작을 하는 find() 함수를 구현하세요.각 게임을 판매한 기간은 다음과 같습니다.<img alt="Game-Timelinev2" src="https://lucas-image.codesquad.kr/1717382106318Game-Timelinev2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
위의 기간에만 해당 게임을 할 수 있다고 가정하세요. 파일 이름은 다음과 같이 작성하세요.
자바스크립트&nbsp;find.js&nbsp;, 스위프트&nbsp;find.swift&nbsp;, 코틀린&nbsp;find.kt 각 함수 시그니처는 다음과 같이 구현하세요.function find(param0, param1)
func find(param0 : String, param1: Int) -&gt; String
fun find(param0: String, param1: Int) : String 첫 번째 매개변수 param0는 문자열로 특정 시점을 전달하고, 두 번째 매개변수 param1는 정수형으로 참가 인원수를 전달해야 합니다. find() 함수 리턴값은 문자열로 리턴해야 합니다. find() 함수의 시그니처를 변경하지 마세요. 게임에 대한 데이터 구조에서 판매 시작 시점과 판매 종료 시점을 param0와 비교해서 판매 중인 시점의 게임을 출력해야 합니다. 판매 중인 동안만 참가할 수 있다고 가정합니다. 그리고 param1 참가자 인원수와 비교해서 참가 가능한 게임만 출력해야 합니다. 단종된 모델의 경우는 이름 뒤에 * 문자를 붙여서 출력합니다. 최종 출력값은 게임 별점(내림차순)으로 정렬해야 합니다. "198402", 1 -&gt; "Prince(RPG) 4.8, Brave(RPG) 4.2" 1984년 2월에 가능한 게임은 Brave, Prince로 모두 단종이라 *가 붙음
Prince는 별점 4.8, Brave는 별점 4.2라서 Prince &gt; Brave 순으로 출력 "200008", 8 -&gt; "Football(Sports)" 2000년 8월에 가능한 게임 중에 8명이 참여 가능한 게임은 Football 하나 뿐임 "199004", 5 -&gt; "" 1990년 4월에 가능한 게임은 Ace와 Prince 뿐인데 5명 이상 불가능하니까 결과는 빈 문자열 ]]></description><link>부스트캠프/베이직/day_3-문제.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_3 문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://lucas-image.codesquad.kr/1717382106318Game-Timelinev2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://lucas-image.codesquad.kr/1717382106318Game-Timelinev2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day_3 피드백]]></title><description><![CDATA[박미림 수료생분의 학습 저장소에서 구현 과정을 서술함에 있어서 find()함수를 단계별로 나누어 구현한 것을 보았다. 세세한 부분까지 나누어 이러한 단계를 메소드 체이닝을 통해 각 단계를 따로 나누는 것이 아닌, 통합적으로 만들어 바로 리턴한 것이 눈에 띄었다. 이전까지는 각 라인이 하나의 메소드를 사용해야만 가독성이 좋다고 생각했지만, 최소 네 줄 이상이 될 수 있었던 filter, sort, map, join 메서드를 한 줄로 압축한 것이 오히려 가독성이 좋고 어떤 결과가 나올지 예측이 쉬워 내 코드에서도 이러한 부분을 보완해야함을 깨달았다.박미림 수료생분의 학습 저장소를 보고 ]]></description><link>부스트캠프/베이직/day_3-피드백.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_3 피드백.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_3 학습내용]]></title><description><![CDATA[적절한 데이터 구조를 선택하여 시각적인 표를 구현하고 탐색할 수 있게 만들 수 있도록 연습하는 과정이다.
find()함수에서 게임을 플레이 하는 시점과 참가인원수를 받은 후 이를 filter를 통해서 조건에 맞는 게임만 뽑아내면 되겠다고 생각했다.게임 테이블을 구현하는 것 자체는 어렵지 않지만 해당 게임을 검색하는 과정에서 string 형식으로 들어오는 특정 시점과 참여자를 적절히 파싱하고 조건을 검색하는 과정에서 고민을 해보라고 내준 미션같은 느낌이 들었다.// game.js
const games = { Kong: { discontinued: true, genre: "Adventure", star: 4.1, maxUser: 1, open: "1970.1", close: "1981.4", }, Ace: { discontinued: false, genre: "Board", star: 3.8, maxUser: 4, open: "1987.7", close: "2024.7", }, Mario: { discontinued: true, genre: "RPG", star: 3.3, maxUser: 2, open: "2001.9", close: "2007.11", }, Prince: { discontinued: true, genre: "RPG", star: 4.8, maxUser: 1, open: "1983.3", close: "2002.5", }, Dragons: { discontinued: true, genre: "Fight", star: 3.4, maxUser: 4, open: "1990.5", close: "1995.12", }, Civil: { discontinued: false, genre: "Simulation", star: 4.2, maxUser: 1, open: "2002.6", close: "2024.7", }, Teken: { discontinued: true, genre: "Fight", star: 4.0, maxUser: 2, open: "1998.7", close: "2009.12", }, GoCart: { discontinued: false, genre: "Sports", star: 4.6, maxUser: 8, open: "2006.12", close: "2024.07", }, Football: { discontinued: false, genre: "Sports", star: 2.9, maxUser: 8, open: "1994.6", close: "2024.7", }, Brave: { discontinued: true, genre: "RPG", star: 4.2, maxUser: 1, open: "1980.6", close: "1985.1", },
}; export default games; 처음에는 find.js에 모든 게임도 넣은 다음에 바로바로 사용할 수 있도록 하려고 했으나 정보를 기입하는 과정에서 라인이 너무 길어져 보기 힘들었다. 그래서 게임들의 정보를 game.js를 만든 뒤에 import 해와서 사용하는 방식으로 설계했다.문자열을 YYYY / MM 으로 잘라 따로 비교function find(date, users) { const year = parseInt(date.slice(0, 4)); const month = parseInt(date.slice(4)); ...
검색 결과를 sort()메서드를 통해 한번 정렬을 시켜주었다.판매중인 동안만 참여 가능한 검색 결과의 조건을 거르기 위해 filter메서드를 사용했다. filter의 콜백함수 안에서 각각의 게임들의 판매시작일, 판매종료일을 .으로 구분하여 기록해 놓았기 때문에 split하여 연도와 월을 구분했다
내가 설정한 조건은
먼저 maxUser를 통해 플레이할 수 있는 유저의 수보다 참가자 수가 많을 경우 거름
오픈년도보다 뒤의 연도를 입력했을 경우 판매종료년도와 같을 경우 월은 작거나 같아야 함
판매종료년도보다 이전일 경우 통과 오픈년도와 참가년도가 같을 경우 오픈월이거나 그 후의 월에 참여해야 함
오픈년도가 판매종료년도와 같을 경우 참가월이 판매종료월보다 같거나 작아야 함 let search = games.filter((item) =&gt; { const open = item.open.split(".").map(Number); const close = item.close.split(".").map(Number); if (item.maxUser &lt; users) { return false; } if (open[0] &lt; year) { if (close[0] === year &amp;&amp; close[1] &gt;= month) return true; else if (close[0] &gt; year) return true; return false; } else if (open[0] === year) { if (open[1] &lt;= month) return true; else if (open[0] === close[0] &amp;&amp; close[1] &gt;= month) return true; return false; } return false; }); search.sort((a, b) =&gt; { b.star - a.star; });
삼항연산자를 사용하면 될 것 같아서 넣는 문자열 안에 삼항연산자를 넣어서 시도해 보았다. 정상적으로 작동함을 확인했다.let result = []; search.forEach((game) =&gt; { result.push( `${game.name}${game.discontinued ? "*" : ""}(${game.genre}) ${ result.length &gt; 1 ? game.star : "" }` ); });
만약 find()함수에 제대로 된 값이 들어가지 않았을 경우를 대비하여 이러한 에러조건에 대해 대응하도록 조건을 설정했다.function find(date, users) { if (!date || !users || date.length !== 6 || isNaN(users)) return ""; ... }
조건은
date나 users가 falsy한 값일 경우
날짜 형식이 정상이아닐 경우
users에 숫자가 들어오지 않을 경우
를 생각하여 명시하였다.
function find(date, users) { if (!date || !users || date.length !== 6 || isNaN(users)) return ""; const year = parseInt(date.slice(0, 4)); const month = parseInt(date.slice(4)); let search = games.filter((item) =&gt; { const open = item.open.split(".").map(Number); const close = item.close.split(".").map(Number); if (item.maxUser &lt; users) { return false; } if (open[0] &lt; year) { if (close[0] === year &amp;&amp; close[1] &gt;= month) return true; else if (close[0] &gt; year) return true; return false; } else if (open[0] === year) { if (open[1] &lt;= month) return true; else if (open[0] === close[0] &amp;&amp; close[1] &gt;= month) return true; return false; } return false; }); search.sort((a, b) =&gt; { b.star - a.star; }); let result = []; search.forEach((game) =&gt; { result.push( `${game.name}${game.discontinued ? "*" : ""}(${game.genre}) ${ search.length &gt; 1 ? game.star : "" }` ); }); return result.join(", ");
}
import games from "./gameList";
^^^^^^
SyntaxError: Cannot use import statement outside a module
객체를 import 해오는 과정에서 위와 같은 에러를 보았다. import 문은 ES6 모듈을 사용하는 환경에서만 지원되지만 Node.js에서는 ES6 모듈을 사용하려면 추가적인 과정이 필요했다. 찾아보기로는 두 가지 방법이 있었다. 파일 확장자를 .mjs로 설정 game.js를 game.mjs로 변경한 뒤 다시 실행했지만 같은 오류가 지속되었다. package.json 파일에 "type": "module"추가 미션3 폴더를 따로 만들고, 거기에 package.json파일을 만든 뒤에 해당 속성을 추가해줬더니 해결되었다. 이제까지는 항상 리액트만 사용하면서 모듈들을 항상 가져오면서 package.json에 이미 모듈이 디폴트로 명시되어있었기 때문에 알지 못했지만 이번에 새롭게 에러를 발견하면서 package.json의 기능과 모듈에 대한 이해를 보다 높일 수 있었다.]]></description><link>부스트캠프/베이직/day_3-학습내용.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_3 학습내용.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/cwjV6tf.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/cwjV6tf.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day_4]]></title><description><![CDATA[<a data-href="Day_4 문제" href="부스트캠프/베이직/day_4-문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_4 문제</a><br>
<a data-href="Day_4 학습저장소" href="부스트캠프/베이직/day_4-학습저장소.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_4 학습저장소</a><br>
<a data-href="Day_4 제출용" href="부스트캠프/베이직/day_4-제출용.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_4 제출용</a>]]></description><link>부스트캠프/베이직/day_4.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_4.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_4 문제]]></title><description><![CDATA[컬렉션 타입을 선언하고 원하는 값으로 채우고, 다른 값으로 출력할 수 있다.
없음. 3가지 발판 유형을 가지는 사다리 게임을 구현하려고 한다.
다음 요구사항을 만족하도록 사다리 데이터 구조를 결정한다. 사다리 데이터를 모두 빈상태로 초기화 함수를 구현한다.&nbsp;reset() 사다리 데이터 구조에 발판을 랜덤하게 생성하는 함수를 구현한다.&nbsp;randomFill() 사다리 데이터에 발판 출력용 문자열을 직접 넣지 않는다. 사다리 데이터 구조를 분석하는 함수를 구현한다.&nbsp;analyze() 사다리 데이터 구조를 문자열로 출력하는 함수를 구현한다.&nbsp;display() 사다리 발판 종류 ---&nbsp;1자 발판 : 좌→우, 우→좌 양쪽에서 모두 이동 가능하다. \-\&nbsp;우하향 발판 : 좌→우에서만 이동 가능하다. /-/&nbsp;좌하향 발판 : 우→좌에서만 이동 가능하다. 참가자는 5명으로, 사다리 높이는 5칸으로 고정한다. 클래스나 객체로 구현하지 않고 아래 함수들만 구현해도 무방하다. 모든 함수를 main 하나의 파일에 작성한다. 자바스크립트 main.js , 스위프트 main.swift, 코틀린 main.kt 사다리 데이터 구조를 초기화한다. 모두 비어있는 상태로 만들어야 한다. 랜덤하게 3가지 발판 종류를 선택해서 사다리 데이터 구조를 채운다. 총 발판 몇 개를 채울지도 랜덤하게 결정한다. 사다리 데이터 구조를 분석한 결과를 리턴한다. 좌우에 1자 발판이 연속으로 나오면 false 좌측에 우하향 발판 + 우측에 좌하향 발판이 연속으로 나오면 false 좌측에 좌하향 발판 + 우측에 우하향 발판이 연속으로 나오면 false 위에 해당하는 경우가 없으면 true를 return 사다리 데이터 구조를 분석해서 문자열로 리턴한다. 사다리 세로는&nbsp;|&nbsp;파이프 문자로 출력한다. 발판 종류별로 출력하는 형식은 다음과 같다. ---&nbsp;1자 발판 \-\&nbsp;우하향 발판 /-/&nbsp;좌하향 발판 빈 발판 한 줄 마지막 끝에는 줄바꿈 문자&nbsp;\n을 붙여서 출력한다. 출력은 analyze() 동작과 상관없이 동작한다. | | | | |\n
| | | | |\n
| | | | |\n
| | | | |\n
| | | | |\n
| | |---| |\n
|\-\|---| |/-/|\n
| |/-/|---| |\n
|---| |\-\|---|\n
| |\-\|---| |\n
| | |---| |\n
|\-\|---|---| |\n
| |/-/|---| |\n
|---| |\-\|---|\n
| |\-\|---| |\n
또는| | |---| |\n
|/-/|---| | |\n
| |/-/|\-\| |\n
|---| |\-\|---|\n
| |\-\|---| |\n
]]></description><link>부스트캠프/베이직/day_4-문제.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_4 문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_4 제출용]]></title><description><![CDATA[나름 자바스크립트 공부를 좀 했다고 생각했지만 막상 미션에서 설명하는 학습 목표의 컬렉션이 무엇인지 자문했을 때는 말문이 막힐 수밖에 없었다. 이는 곧 내 학습이 충분치 않았다는 방증이기도 하다. 이번 기회를 통해 보다 개념들에 충실해야 다른 문제를 해결함에 있어서도 활용할 수 있다는 것을 깨달았다.
또한 Weakset, Weakmap의 존재 자체를 모르고 있었는데 가비지 콜렉터의 역할과 연결되어 있는 자료구조는 처음 알게 되었다. 이러한 최적화에 효율적인 자료구조 자체를 모르고 있었다는 사실에 학습이 더 필요하다고 생각하면서도 현재 하고 있는 프로젝트에서 이러한 자료구조를 사용할 수 있을지에 대해서 생각해보는 것도 좋은 방식일 것 같다.박미림 수료생분의 클래스로 구현한 점이 눈에 띄었다. 나의 경우 함수를 세분화한다는 생각에만 사로잡혀 따로 클래스를 구현할 생각은 하지 못했는데 클래스를 구현함으로써 다양한 사다리 게임 객체를 만들 수 있고, 각 메소드가 독립적으로 작용하기 때문에 항상 의도한 대로 움직이는 예측가능성과 코드의 응집도를 높일 수 있어 훨씬 보기 좋은 구조라고 생각한다.
또한 클래스 내에 있는 #의 역할을 알지 못했는데, private 필드를 의미한다는 것을 알게 되었다. 이를 통해 클래스 내부에서만 읽고 쓰면서 외부에서 보이지 않도록 만들 수 있다는 사실을 처음 알게 되었다.수료생의 접근법을 보고 가장 처음으로 reset() 함수를 개선해보았다. 내가 쓴 코드에서 처음 reset에서 이중루프문을 통해 2차원 배열을 만들기 대문에 다소 가독성이 비교적 떨어지는 부분이 있어보였다. 이에 Array.from 정적 메서드를 통해 2차원 배열을 생성하는 문을 보다 간결하게 작성하였다.
다음으로 에러 조건을 설정하여 reset() 전에 randomFill() 함수를 호출 할 경우를 대비하여 이러한 경우에 자바스크립트의 에러 전에 사전적으로 차단하였다.
마지막에는 전체적인 사다리의 기능들이 하나의 클래스 안으로 모두 들어가 사용될 수 있도록 리팩토링하였다.]]></description><link>부스트캠프/베이직/day_4-제출용.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_4 제출용.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_4 학습저장소]]></title><description><![CDATA[학습 목표를 보고 처음에 컬렉션 타입이 정확히 무엇인가를 머릿속으로 설명하지 못했다. 그렇다는 것은 즉 내가 이 용어에 대한 개념을 정확하게 이해하지 못하다는 방증이기도 해서 가장 먼저 Collection에 대해 알아보고 문제를 해결해야겠다고 생각했다.해당 문제의 핵심은 사다리게임을 구현함에 있어서 각자 사다리 게임의 기능을 세분화해서 함수로 구현하는데 초점이 맞춰져 있는 문제같다. 게임의 기능을 독립적인 함수로 구현해내어 어느 경우에서 사용해도 독립적이기 때문에 게임에 영향을 미치지 않도록 하는 것이 중요할 것 같다고 생각했다.
---&nbsp;1자 발판 : 좌→우, 우→좌 양쪽에서 모두 이동 가능하다.
\\-\&nbsp;우하향 발판 : 좌→우에서만 이동 가능하다.
/-/&nbsp;좌하향 발판 : 우→좌에서만 이동 가능하다.
사다리 데이터를 모두 빈 상태로 초기화 함수를 구현한다
모두 비어있는 상태로 만들어야 한다
사다리의 참가자는 5명 * 사다리 높이는 5칸 = 25개의 | 파이프 문자를 순서대로 배치하면 될 것 같다.reset() + display() 한 경우를 보자| | | | |\n
| | | | |\n
| | | | |\n
| | | | |\n
| | | | |\n 각 줄마다 \\n 으로 구분되어 있고, 각 칸 사이에는 발판이 들어갈 3개의 공백이 있다.
각 줄마다 배열로 사다리, 공백을 만들면 될 것 같다. 줄바꿈의 경우에는 display() 할 경우에 join메서드에 줄바꿈 문자를 넣으면 될 것 같다.let ladder;
const reset = () =&gt; { let row = []; for (let i = 1; i &lt; 10; i++) { row.push(i % 2 === 0 ? " " : "|"); } ladder = new Array(5).fill(row);
};
ladder을 전역적으로 관리하는 이유는 해당 함수 뿐만이 아니라 randomFill() 함수 등을 파라미터 없이 실행하는 테스트케이스를 보여줬기 때문에 전역적으로 관리해야겠다고 생각했다.
하지만 여기선 오류가 있었는데, 랜덤으로 만들어 주는 사다리의 모든 열에 있는 사다리의 모양이 똑같이 나왔다.
왜인지 디버깅을 하면서 분석해보니 Array.fill()을 하는 과정에서 같은 배열로 fill해서 같은 참조를 공유하고 있었다. 그래서 fill 방법은 어쩔 수 없이 사용하지 않기로 결정했다.let ladder = new Array(5);
const reset = () =&gt; { let row; for (let i = 0; i &lt; 5; i++) { row = []; for (let j = 1; j &lt; 10; j++) { row.push(j % 2 === 0 ? " " : "|"); } ladder[i] = row; }
};
아예 ladder에 5칸을 미리 만들어놓고 거기에 재할당하는 방식으로 변경했다.사다리 데이터 구조에 발판을 랜덤하게 생성한다
3가지 발판 종류를 랜덤 선택해야 하고 총 발판 몇 개를 채울지도 랜덤하게 결정한다.
빈칸의 개수는 4개이고 각 빈칸마다 3가지 발판 종류중에 하나를 랜덤으로 선택해야 한다.
이를 좀 더 세분화하여 함수화시킬 수 있지 않을까? 생각해서 기능을 함수별로 나누어 보았다.3가지 발판 종류 중에 하나를 랜덤으로 뽑아서 리턴한다.const ladderType = { 0: "---", 1: "/-/", 2: "\\-\\", 3: " ",
};
const getRandomLadderType = () =&gt; { return ladderType[Math.floor(Math.random() * 4)];
};
0~3까지의 순서에 각각 사다리를 값으로 주었으며 이 사이 값만 랜덤하게 뽑아서 해당하는 사다리 타입을 리턴하도록 했다.
빈칸까지 랜덤하게 넣으면 알아서 랜덤한 수로 빈칸까지 만들어지니 총 발판을 몇 개를 채울지 랜덤 선택하는 것까지 일석이조!각 열의 빈 칸에 랜덤한 사다리 타입을 넣어준다.
randomFill하게 되면 이중 루프문을 사용해줘야 할 것 같은데 그게 보기 싫어서 함수로 따로 나누어보았다!const rowRandomFill = (row) =&gt; { for (let i = 0; i &lt; row.length; i++) { if (i % 2 === 1) row[i] = getRandomLadderType(); }
};
최종적으로 나온 randomFill() 함수 안에 들어가는 코드는 아래와 같다.const randomFill = () =&gt; { for (let i = 0; i &lt; ladder.length; i++) { rowRandomFill(ladder[i]); }
};
randomFill 함수 전체가 가독성이 좋아져서 기분이 좋다 우하하
수료생분 접근법을 조금 차용해서 활용해봤는데 훨씬 코드가 깨끗해진 느낌..?사다리 데이터 구조를 분석한다
좌우에 1자 발판이 연속으로 나오면 false
좌측에 우하향 발판 + 우측에 좌하향 발판이 연속으로 나오면 false
좌측에 좌하향 발판 + 우측에 우하향 발판이 연속으로 나오면 false
위에 해당하는 경우가 없으면 true를 return
const rowAnalyze = (row) =&gt; { for (let i = 1; i &lt; row.length; i += 2) { if (row[i] === row[i + 2] &amp;&amp; row[i] == "---") return false; if (row[i] === "\\-\\" &amp;&amp; row[i + 2] == "/-/") return false; if (row[i] === "/-/" &amp;&amp; row[i + 2] == "\\-\\") return false; } return true;
};
analyze()는 간단하게 열마다 루프문을 돌면서 좌우를 확인하는 함수를 분리해서 만들고, 이걸 전체 배열에서 돌면서 모두 검사하도록 했다.const analyze = () =&gt; { for (let i = 0; i &lt; ladder.length; i++) { if (!rowAnalyze(ladder[i])) return false; } return true;
};
사다리 데이터 구조를 문자열로 출력하는 함수를 구현한다
사다리 세로는&nbsp;|&nbsp;파이프 문자로 출력한다.
발판 종류별로 출력하는 형식은 다음과 같다. ---&nbsp;1자 발판
\-\&nbsp;우하향 발판
/-/&nbsp;좌하향 발판
빈 발판 한 줄 마지막 끝에는 줄바꿈 문자&nbsp;\n을 붙여서 출력한다.
출력은 analyze() 동작과 상관없이 동작한다.
const display = () =&gt; { let output = ""; for (let i = 0; i &lt; ladder.length; i++) { output = output + ladder[i].join("") + "\n"; } return output;
};
display는 따로 어려운 거 없이 만들어놓은 배열의 열을 하나씩 돌면서 합쳐주었다.const ladderType = { 0: "---", 1: "/-/", 2: "\\-\\", 3: " ",
};
const getRandomLadderType = () =&gt; { return ladderType[Math.floor(Math.random() * 4)];
}; let ladder = new Array(5);
const reset = () =&gt; { let row; for (let i = 0; i &lt; 5; i++) { row = []; for (let j = 1; j &lt; 10; j++) { row.push(j % 2 === 0 ? " " : "|"); } ladder[i] = row; }
}; const randomFill = () =&gt; { for (let i = 0; i &lt; ladder.length; i++) { rowRandomFill(ladder[i]); }
};
const rowRandomFill = (row) =&gt; { for (let i = 0; i &lt; row.length; i++) { if (i % 2 === 1) row[i] = getRandomLadderType(); }
}; const analyze = () =&gt; { for (let i = 0; i &lt; ladder.length; i++) { if (!rowAnalyze(ladder[i])) return false; } return true;
}; const rowAnalyze = (row) =&gt; { for (let i = 1; i &lt; row.length; i += 2) { if (row[i] === row[i + 2] &amp;&amp; row[i] == "---") return false; if (row[i] === "\\-\\" &amp;&amp; row[i + 2] == "/-/") return false; if (row[i] === "/-/" &amp;&amp; row[i + 2] == "\\-\\") return false; } return true;
}; const display = () =&gt; { let output = ""; for (let i = 0; i &lt; ladder.length; i++) { output = output + ladder[i].join("") + "\n"; } return output;
}; reset();
randomFill();
console.log(analyze());
console.log(display()); 구조 또는 비구조화된 형태로 프로그래밍 언어가 제공하는 값을 담을 수 있는 공간
Collection은 아래와 같은 기능을 사용할 수 있다.
for - of 루프
스프레드 연산자(...)
분해 할당(destructuring assignment)
기타 iterable을 인수로 받는 함수
Collection에는 인덱스 기반 컬렉션(Indexed Collection) 과 키 기반 컬렉션(Keyed Collection) 이 있다.인덱스 값에 의해 정렬이 되는 데이터 컬렉션으로 Array와 TypedArray 객체가 이에 해당한다.
배열은 이름과 인덱스를 사용하여 참조하는 값들의 순서가 있는 목록이다.// new 연산자를 이용해서 생성한다.
let arr = new Array(); // 위 코드는 아래와 동일하다.
let arr = [];
TypedArray는 이진 데이터 버퍼에 기초해 배열과 같은 보기를 만들어낸다.
이 객체는 직접 인스턴스화할 수 없고 특정 유형의 배열 인스턴스를 지정하여 만들 수 있다.// 불가능
new TypedArray()
// 가능
const typedArray1 = new Int8Array(8);
typedArray1[0] = 32; const typedArray2 = new Int8Array(typedArray1);
typedArray2[1] = 42; console.log(typedArray1);
// Int8Array [32, 0, 0, 0, 0, 0, 0, 0] console.log(typedArray2);
// Int8Array [32, 42, 0, 0, 0, 0, 0, 0] TypedArray 객체은 아래와 같은 것들이 있다.Key 기반 컬렉션은 입려개된 키값을 기준으로 정렬되는 데이터의 집합으로, Map, Set, WeakMap, WeakSet이 있다.간단한 키와 값을 서로 매핑시켜 저장하며 저장된 순서대로 각 요소들을 반복적으로 접근할 수 있다. // 생성자
var sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog"); for (var [key, value] of sayings) { console.log(key + " goes " + value);
}
// "cat goes meow"
// "elephant goes toot"
전통적으로 Object 또한 키-값 쌍으로 이루어져 있어 문자열을 값에 매핑하는데 사용되었다. 하지만 ES6에 들어서 새로 생긴 Map은 몇 가지 Object보다 유용한 장점을 가지고 있다.
Map의 키는 모든 값이 가능 Object는 크기를 수동 추적하지만 Map은 size 속성이 있음
Map은 삽입된 순서대로 반복
Object에는 prototype이 있어 Map에 기본 키들이 있다.
이러한 차이들을 가지고 어떤 자료구조를 사용할지에 대해서는 아래와 같은 점을 참고하자
실행 시까지 키를 알수 없고, 모든 키가 동일한 type이며 모든 값들이 동일한 type일 경우에는 objects를 대신해서 map을 사용
각 개별 요소에 대해 적용해야 하는 로직이 있을 경우에는 objects를 사용
Set 객체는 값들의 집합으로 입력된 순서에 따라 저장된 요소를 반복처리할 수 있다.
Set은 중복된 값을 허용하지 않는다는 특징을 가지고 있다.var mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo"); mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2 for (let item of mySet) console.log(item);
// 1
// "some text" Map, Set이 참조하는 객체들은 강하게 연결되어있어 자바스크립트의 가비지 컬렉터가 메모리 수거를 하지 못한다.
Map, Set도 크기가 크기 때문에 더이상 쓰지 않을 경우(객체에 대한 참조가 더이상 존재하지 않을 경우)에는 메모리에서 삭제하기 쉽도록 나온 것이&nbsp;WeakMap, WeakSet이다.]]></description><link>부스트캠프/베이직/day_4-학습저장소.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_4 학습저장소.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_5 문제]]></title><description><![CDATA[
graphviz 문법을 이해하고, dot 형식을 지원하는 그래프 생성 도구를 짝으로 함께 설계하는 것이 목표다. 코드를 구현하기 전에 무엇을 구현해야 하는가 이해도를 높이고 해결하려는 것에 집중한다. 없음. 다 같이 graphviz 오픈소스와 지원하는 문법 형식에 대해 조사한다.<a data-tooltip-position="top" aria-label="https://dreampuf.github.io/GraphvizOnline/?compressed=MQZQggsgCgMgogAgGYHsBOCBCKUGcAuAxgIYC2ADlsbgJaEBQAJjQOZrHkAWCA4ggN716CEbgCuAIzYduhADZiCAUzQB9AAwDhIhAQCecpQgC8CfMQkBubSMIo56YxIVLrOhHItK5JhACIQFQA3OiMoYkIAa2IWJT83dx1xKXYuBHlFfBVVAEYtRIKEKDQURjFCfAQAbVxODiUnFAAPXXwDBqQaOUNGdPtHQj1iADsAXRtC0UixBMmRcjRQ2bn8GnxDZcnPCW9fP2LS8vwAOk7DeInJuwc0YzlWTnw2JT1NnQBfS4Qv0UlpNIyyjUACZ8nMRAB5NCMFTVWr1RotfSGYxnHp9G7GQYjcbgkToGFoACSjDeBQWhwqZMS212pj8UMJpy6cWp7mujnuLEez1ePwQn3cgu%2B7mS-1kCiBqgAnGCCsijKZzFZ%2BbSfPSQHplKQihForELld%2BrdnGJXBN%2BWLUhLMtkcppBHiECB8Ithiw4XVyA0JM1Wu1UV10Rzbtixvz3EThpUal6fX6FYHukpeiGsUNw061XsQCgxGhCEpmec2To01yeWgXm9hSJayKktMEABaAB8ztdNHdywWoRb7aj%2BGWq3WRjbHbdLGWBJUJP7E67U4mFLKFXnB1XQ-o7yAA&amp;compressed=MQZQggsgCgMgogAgGYHsBOCBCKUGcAuAxgIYC2ADlsbgJaEBQAJjQOZrHkAWCAYmTQBsAngBU0AU3EIA3vQTyEAekUJAHo2AdloSBUCcAa43IUApFJwB2CANoDiAI3ECAvACIjpxwBoEuTh3H3CNNEIBcQ9CFAF0e2sBAFdxAF0Abn15A2ITKUsbOyc0jPdPb3Jff0Dg0PDI6LiklIQIYjQhCytbB0cGpoKvHz8AoJCEMIi0e3IaEwBrWoUsQQEW7PbMee6ikv7yocrRtkkTWrrlBEAF0cABye09WZczAFoAPnrG5qy2p1IUfE5xNEcZw3SUgeTyaizejg%2BXx%2Bf2S12Md0eKwEC1eOUcSGIUN%2B-1SgIQwKRKNaaIxWJh9AAvvQgA" rel="noopener nofollow" class="external-link is-unresolved" href="https://dreampuf.github.io/GraphvizOnline/?compressed=MQZQggsgCgMgogAgGYHsBOCBCKUGcAuAxgIYC2ADlsbgJaEBQAJjQOZrHkAWCA4ggN716CEbgCuAIzYduhADZiCAUzQB9AAwDhIhAQCecpQgC8CfMQkBubSMIo56YxIVLrOhHItK5JhACIQFQA3OiMoYkIAa2IWJT83dx1xKXYuBHlFfBVVAEYtRIKEKDQURjFCfAQAbVxODiUnFAAPXXwDBqQaOUNGdPtHQj1iADsAXRtC0UixBMmRcjRQ2bn8GnxDZcnPCW9fP2LS8vwAOk7DeInJuwc0YzlWTnw2JT1NnQBfS4Qv0UlpNIyyjUACZ8nMRAB5NCMFTVWr1RotfSGYxnHp9G7GQYjcbgkToGFoACSjDeBQWhwqZMS212pj8UMJpy6cWp7mujnuLEez1ePwQn3cgu%2B7mS-1kCiBqgAnGCCsijKZzFZ%2BbSfPSQHplKQihForELld%2BrdnGJXBN%2BWLUhLMtkcppBHiECB8Ithiw4XVyA0JM1Wu1UV10Rzbtixvz3EThpUal6fX6FYHukpeiGsUNw061XsQCgxGhCEpmec2To01yeWgXm9hSJayKktMEABaAB8ztdNHdywWoRb7aj%2BGWq3WRjbHbdLGWBJUJP7E67U4mFLKFXnB1XQ-o7yAA&amp;compressed=MQZQggsgCgMgogAgGYHsBOCBCKUGcAuAxgIYC2ADlsbgJaEBQAJjQOZrHkAWCAYmTQBsAngBU0AU3EIA3vQTyEAekUJAHo2AdloSBUCcAa43IUApFJwB2CANoDiAI3ECAvACIjpxwBoEuTh3H3CNNEIBcQ9CFAF0e2sBAFdxAF0Abn15A2ITKUsbOyc0jPdPb3Jff0Dg0PDI6LiklIQIYjQhCytbB0cGpoKvHz8AoJCEMIi0e3IaEwBrWoUsQQEW7PbMee6ikv7yocrRtkkTWrrlBEAF0cABye09WZczAFoAPnrG5qy2p1IUfE5xNEcZw3SUgeTyaizejg%2BXx%2Bf2S12Md0eKwEC1eOUcSGIUN%2B-1SgIQwKRKNaaIxWJh9AAvvQgA" target="_self">graphviz 예시</a>#SAMPLE for Boostcamp Basic
digraph FamilyTree { // 노드 정의 John [label="John", shape=circle, color=blue]; Jane [label="Jane", shape=circle, color=blue]; Mary [label="Mary", shape=circle, color=pink]; Bill [label="Bill", shape=circle, color=green]; // 에지 정의 John -&gt; Mary [label="mother"]; Jane -&gt; Mary [label="mother"]; John -&gt; Bill [label="father"]; Jane -&gt; Bill [label="father"];
} 최소 2명 이상이 하나의 형식에 대해 도전하고 같이 학습하고 설계한다.
어떤 형식을 기준으로 할 것인지 2명 이상이 함께 결정한다.
프로그래밍 요구사항을 만족하는 그래프 생성 도구를 설계한다.
예시에 있는 구조와 속성, 이름 등이 바뀌어도 동작하도록 설계한다.
전달할 데이터 구조를 어떻게 표현할 것인가 결정한다.
설계 후에 구현을 해도 무방하지만 구현만 해서는 안된다.
구현하는 경우에 설계 결과물이 프로그래밍 결과물만큼 상세하거나 많아야 한다. 해결하려는 문제와 동작 방식에 대해 이해한 내용을 요약한다.
설계는 데이터 구조와 데이터 흐름을 명시한 그림을 손으로 그린다.
손으로 그린 그림을 캡처해서 gist에 첨부한다.
gist에 README.md 파일을 추가하고 설계 의도와 방향에 대해 간략하게 설명을 붙인다. 다음과 같이 패키지 &gt; 파일 &gt; 타입 &gt; 속성 단계별로 구성된 구조를 그래프로 데이터 구조를 넘기면&nbsp;graphviz&nbsp;출력 형식 문자열로 변환하는 프로그램을 작성한다.
패키지는 여러 파일을 포함한다.
파일 하나에는 타입 하나를 포함한다.
타입은 고유 이름과 여러 속성을 가진다.
속성마다 특정 타입을 참조한다.
System 아래에는 Integer, String 타입이 이미 존재한다. <br><img src="https://i.imgur.com/mCFsCk9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img alt="스크린샷 2024-06-28 오후 11.42.25.png" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e38e7aad-5ec6-442f-8c61-c603fe2723ee/843f5b88-9cd6-42ff-8909-94324c4dfb90/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.42.25.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">package Service Type Product { sku : String price : Int title : String
}
package Service Type Order { orderId : String product : Product
}
완벽하게 동일할 필요는 없고, 스타일이나 색상을 제외하고 필수 항목만 비슷하게 채우면 된다. 패키지 &gt; 파일 &gt; 타입 포함 관계를 볼 수 있으면 어떤 형식으로도 가능하다.digraph G { subgraph cluster_0 { style = tab; color=blue; label = "Service Package"; subgraph cluster_1 { Product [shape=box style=filled color=cyan] sku; price; title; label = "Product.file"; color=lightgrey; } subgraph cluster_2 { Order [shape=box style=filled color=cyan] orderId; product; label = "Order.file"; color=lightgrey; } } subgraph cluster_9 { style = tab; label = "System Package"; color=blue; subgraph cluster_10 { String [shape=box style=filled color=cyan] Int [shape=box style=filled color=cyan] label = "Source.file"; color=lightgrey; } } sku -&gt; String; price -&gt; Int; title -&gt; String; orderId -&gt; String; product -&gt; Product;
}
<br><img alt="graphviz-service" src="https://lucas-image.codesquad.kr/1715669344967graphviz-service.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><a data-tooltip-position="top" aria-label="https://dreampuf.github.io/GraphvizOnline/?compressed=MQZQggsgCgMgogAgGYHsBOCBCKUGcAuAxgIYC2ADlsbgJaEBQAJjQOZrHkAWCA4ggN716CEbgCuAIzYduhADZiCAUzQB9AAwDhIhAQCecpQgC8CfMQkBubSMIo56YxIVLrOhHItK5JhACIQFQA3OiMoYkIAa2IWJT83dx1xKXYuBHlFfBVVAEYtRIKEKDQURjFCfAQAbVxODiUnFAAPXXwDBqQaOUNGdPtHQj1iADsAXRtC0UixBMmRcjRQ2bn8GnxDZcnPCW9fP2LS8vwAOk7DeInJuwc0YzlWTnw2JT1NnQBfS4Qv0UlpNIyyjUACZ8nMRAB5NCMFTVWr1RotfSGYxnHp9G7GQYjcbgkToGFoACSjDeBQWhwqZMS212pj8UMJpy6cWp7mujnuLEez1ePwQn3cgu%2B7mS-1kCiBqgAnGCCsijKZzFZ%2BbSfPSQHplKQihForELld%2BrdnGJXBN%2BWLUhLMtkcppBHiECB8Ithiw4XVyA0JM1Wu1UV10Rzbtixvz3EThpUal6fX6FYHukpeiGsUNw061XsQCgxGhCEpmec2To01yeWgXm9hSJayKktMEABaAB8ztdNHdywWoRb7aj%2BGWq3WRjbHbdLGWBJUJP7E67U4mFLKFXnB1XQ-o7yAA" rel="noopener nofollow" class="external-link is-unresolved" href="https://dreampuf.github.io/GraphvizOnline/?compressed=MQZQggsgCgMgogAgGYHsBOCBCKUGcAuAxgIYC2ADlsbgJaEBQAJjQOZrHkAWCA4ggN716CEbgCuAIzYduhADZiCAUzQB9AAwDhIhAQCecpQgC8CfMQkBubSMIo56YxIVLrOhHItK5JhACIQFQA3OiMoYkIAa2IWJT83dx1xKXYuBHlFfBVVAEYtRIKEKDQURjFCfAQAbVxODiUnFAAPXXwDBqQaOUNGdPtHQj1iADsAXRtC0UixBMmRcjRQ2bn8GnxDZcnPCW9fP2LS8vwAOk7DeInJuwc0YzlWTnw2JT1NnQBfS4Qv0UlpNIyyjUACZ8nMRAB5NCMFTVWr1RotfSGYxnHp9G7GQYjcbgkToGFoACSjDeBQWhwqZMS212pj8UMJpy6cWp7mujnuLEez1ePwQn3cgu%2B7mS-1kCiBqgAnGCCsijKZzFZ%2BbSfPSQHplKQihForELld%2BrdnGJXBN%2BWLUhLMtkcppBHiECB8Ithiw4XVyA0JM1Wu1UV10Rzbtixvz3EThpUal6fX6FYHukpeiGsUNw061XsQCgxGhCEpmec2To01yeWgXm9hSJayKktMEABaAB8ztdNHdywWoRb7aj%2BGWq3WRjbHbdLGWBJUJP7E67U4mFLKFXnB1XQ-o7yAA" target="_self">샘플 바로가기</a>]]></description><link>부스트캠프/베이직/day_5-문제.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_5 문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/mCFsCk9.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/mCFsCk9.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day_5 학습제출용]]></title><link>부스트캠프/베이직/day_5-학습제출용.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_5 학습제출용.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[피어세션]]></title><description><![CDATA[
HTML는 용도에 맞는 tag를 찾아서 사용
HTML5 Layout 태그를 활용
모든 엘리먼트들은 가지런히 배치해야하고, 일정한 간격을 유지.
배치를 할때 flex 속성 또는 Position 속성을 사용
HTML,CSS 브라우저 개발자도구를 활용한 문제 분석 방법 DOM 에 대한 정의와 DOM APIs 에 대한 다양한 이해
DOM 노드를 탐색하는 querySelector 와 같은 API 사용
addEventListener 함수를 활용한 이벤트 등록
breakpoint를 활용한 프로그래밍 실행 중단과 디버깅 CSS 코드의 중복을 해결하는 방법을 설명해보세요.
주소창에 URL을 입력 후, 브라우저 렌더링이 될때까지의 과정을 설명해보세요. Node.js 설치
Node.js 의 내부 구조 및 동작원리 학습
Node.js 공식문서에서 API 살펴보기 Express 설치
Express 에서 사용하는 모듈과 패키지들의 역할 살펴보기
Middleware의 동작방식 이해
템플릿 엔진 문법 학습 및 활용 주소창에서&nbsp;http://localhost:3000/blog/230801.html을 입력해서 응답하기까지의 일어나는 일들을 Express -&gt; Node.js -&gt; EventLoop -&gt; LibUV -&gt; OS(Linux) 의 관점에서 설명해 보세요.
템플릿 엔진을 사용하는 이유는 무엇일까요? 템플릿 엔진을 사용하지 않는다면 어떤 대안이 있을 수 있을까요?
공통적인 요소들에 대해서 똑같은 html 구조를 가진 부분들을 재사용성을 높여 다른 곳에서도 유용하게 사용할 뿐만 아니라 개별적인 서버의 templating 작업에서도 유용하게 쓰일 수 있는 방식을 사용하게 되면 전체적인 코드의 길이를 줄일 수 있을 뿐만 아니라 다른 페이지에서도 사용할 수 있어 활용도가 높다.pug 템플릿 엔진의 경우, 이를 mixin 기능을 통해 구현할 수 있었는데, 이 mixin은 argument를 받고 이에 해당하는 html 요소들을 동적으로 생성할 수 있다는 점에서 우리가 알던 리액트와 같은 컴포넌트의 구조와 비슷하여 알아보거나 처리하기 쉽다는 장점을 가졌다.mixin card(title,detail,author,date,id) style | @import url('/shared/card/css/card.css') include /shared/deleteConfirm/component/deleteConfirm.pug div.cardContainer(id=`${id}` draggable="true" data-date=`${date}`) form(action="post").editform(hidden) .form__div--cardForm input.form__input--title(type="text" placeholder="제목을 입력하세요" value=`${title}`) textarea.form__textarea--cardDetail(type="text" placeholder="내용을 입력하세요" rows=1 maxlength=500)#cardDetail #{detail} .form__div--buttonWrapper input.form__input__cancel-button(type="button", value="취소") input.form__input__submit-button(type="button", value="등록") li.generalCard(data-drag=id) .articleWrapper article p.title #{title} p.detail #{detail} p.author author by #{author} aside img.deleteTodo(src="../asset/close.svg", alt="delete", data-close=id) img.activeEditmode(src="../asset/pen.svg", alt="edit", data-edit=id) +deleteConfirm("todo")
해당하는 컴포넌트는 각각의 todolist 안의 카드들이며, 이를 +card(title,detail,author,date,id)를 통해 계속해서 재사용할 수 있는 형태로 바꿔주었다.하지만 개별 카드에 해당하는 이벤트를 등록하기 위해 해당 컴포넌트 안에서 스크립트를 제작하고 붙여주었는데, 문제는 해당하는 이벤트가 3번이 실행되었다.문제를 파악해보니 section이 3개로 나뉘어져 이 또한 컴포넌트로 구현했었는데, 재사용하는 컴포넌트의 문제점은 id가 모두 같아 이를 판별하기 어렵다는 점이다. 모든 컴포넌트들에서 등록했던 이벤트가 각각 실행되어 3번이 실행되는 문제가 생긴 것이다.기존의 문제를 해결하기 위해서는 상위 컴포넌트에서 각 컴포넌트에 해당하는 이벤트를 개별적으로 등록해주는 방법이 있었는데,
querySelectorAll를 통해 모든 컴포넌트들을 가져와 forEach문을 통해 각각의 요소에 이벤트 등록
상위 컴포넌트에서 이벤트를 위임하여 처리
가 있었다. 하지만 1번의 경우 개별적인 컴포넌트들이 많아지게 되면 각각에 대해서도 모든 이벤트 핸들러를 등록해줘야 하기 때문에 성능상에 이슈가 생길 수 있다. 따라서 상위에서 모두 공통적으로 작용할 수 있는 이벤트를 하나 등록하고, 위임하여 해당하는 컴포넌트를 구분 한 후에 처리할 수 있도록 하는 이벤트위임을 선택하였다.
document.getElementById("sections").addEventListener("click", (event) =&gt; { // 각 섹션별 이벤트들 let addTodo = event.target.dataset.addform; if (addTodo) { // 각 폼에 이벤트 위임 let form = document.getElementById(addTodo); // 보이게 하는 속성 form.hidden = false; // 할일 추가 폼 입력란 크기 조절 let detailInput = form.getElementsByClassName( "form__textarea--cardDetail" )[0]; detailInput.addEventListener("input", adjustTextInput); // 창 닫기 폼 let cancelButton = form.getElementsByClassName( "form__input__cancel-button" )[0]; cancelButton.addEventListener("click", () =&gt; closeForm(form)); let submitButton = form.getElementsByClassName( "form__input__submit-button" )[0]; submitButton.addEventListener("click", () =&gt; { console.log("submit event"); }); } // 각 카드 관련 이벤트들 // 카드 파트(편집 모드 열기) let editId = event.target.dataset.edit; if (editId) { const editComponent = document.getElementById(editId); // Edit mode 활성화 editComponent.getElementsByClassName("editform")[0].hidden = false; // 할일 추가 폼 입력란 크기 조절 let detailInput = editComponent.getElementsByClassName( "form__textarea--cardDetail" )[0]; detailInput.addEventListener("input", adjustTextInput); // 카드 수정 -&gt; 취소 눌렀을 때 let cancelButton = editComponent.getElementsByClassName( "form__input__cancel-button" )[0]; cancelButton.addEventListener("click", () =&gt; closeEditForm(editComponent)); // 일반 카드 숨기기 const generalCard = editComponent.getElementsByClassName("generalCard")[0]; if (generalCard) { generalCard.style.display = "none"; } } // 카드 삭제하기 let closeId = event.target.dataset.close; if (closeId) { const closeComponent = document.getElementById(closeId); closeComponent.getElementsByClassName("modalBackground")[0].style.display = "flex"; closeComponent .getElementsByClassName("cancelButton")[0] .addEventListener("click", () =&gt; { closeComponent.getElementsByClassName( "modalBackground" )[0].style.display = "none"; }); closeComponent .getElementsByClassName("conFirmButton")[0] .addEventListener("click", () =&gt; { closeComponent.getElementsByClassName( "modalBackground" )[0].style.display = "none"; closeComponent.remove(); }); }
});
Feature-sliced Design은 모듈 간의 느슨한 결합과 높은 응집력을 제공할 수 있으며, 쉽게 확장할 수 있는 아키텍처이다.
<img src="https://i.imgur.com/tO9yswk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이러한 패턴은 세 가지 구분 개념이 있다.<br>
<img src="https://i.imgur.com/iJJFpxc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
app 애플리케이션 로직이 초기화되는 곳
프로바이더, 라우터, 전역 스타일, 전역 타입 선언 등
애플리케이션의 진입점 역할 processes(depricated) 이 레이어는 여러 단계로 이루어진 등록과 같이 여러 페이지에 걸쳐 있는 프로세스를 처리
이 레이어는 더 이상 사용되지 않는 것으로 간주되지만 여전히 가끔씩 마주할 수 있습니다. 선택적 레이어입니다. pages 이 레이어에는 애플리케이션의 페이지가 포함됩니다. widgets 페이지에 사용되는 독립적인 UI 컴포넌트 features 이 레이어는 비즈니스 가치를 전달하는 사용자 시나리오와 기능
좋아요, 리뷰 작성, 제품 평가 등이 있습니다. 선택적 레이어 entities 비즈니스 엔티티
사용자, 리뷰, 댓글 등이 포함될 수 있습니다. 선택적 레이어 shared 이 레이어에는 특정 비즈니스 로직에 종속되지 않은 재사용 가능한 컴포넌트와 유틸리티
여기에는 UI 키트, axios 설정, 애플리케이션 설정, 비즈니스 로직에 묶이지 않은 헬퍼 등 슬라이스는 특정 엔티티에 대해서 코드를 그룹화 한다.<br>
<img src="https://i.imgur.com/yVam9En.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이와 같이 필요한 값에 대해서 독립적으로 다룰 수 있는 디렉토리를 생성한다.각 슬라이스는 세그먼트로 구성되며 목적에 따라 슬라이스 내의 코드를 나누는데 도움이 될 수 있다.
api - 필요한 서버 요청.
UI - 슬라이스의 UI 컴포넌트.
model - 비즈니스 로직, 즉 상태와의 상호 작용. actions 및 selectors가 이에 해당
lib - 슬라이스 내에서 사용되는 보조 기능.
config - 슬라이스에 필요한 구성값이지만 구성 세그먼트는 거의 필요하지 않음.
consants - 필요한 상수.
나는 이러한 FSD를 일부 참고하여 나만의 디렉토리 구조를 만드는데 활용하였다.
하지만 중요한 점인 슬라이스와 세그먼트의 본질에 어긋나지 않도록 조율하였다.<br><img src="https://i.imgur.com/BZgt0IG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/7jaWaf4.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>부스트캠프/멤버십/1주차/피어세션.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/피어세션.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/tO9yswk.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/tO9yswk.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_2주차_마스터클래스]]></title><description><![CDATA[이번주 할일
동적인 부분 ? 계획에 맞게 진행em, rem 최상위에 설정한 값을 가지고 설정(상대적 단위)함수를 활용한 개발
FP는 아님
순수함수로 만들기
단일책임원칙
DOM//복수로 받는 것들
document.getElements~(복수) // 단수로 받는 것들
document.getElement~(단수) HTMLCollections //전개 연산자로 각 노드들을 조작
[...Nodelist]
개발자 도구로 선택한 요소 가져오기
$0, 1, 2....
함수를 활용한 개발?Event onClick이벤트 -&gt; pc, 모바일에서 정상 작동 모바일 디바이스의 브라우저 엔진이 이벤트를 모바일에 맞게 최적화
<img src="https://i.imgur.com/mE0exW2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">e.target과 e.currentTarget의 차이
e.target -&gt; 이벤트가 이루어진 요소
e.currentTarget -&gt; body 상위 컴포넌트 단위로 이벤트 위임module pattern
클로저를 활용해서 함수를 리턴하는 방식으로 private하게 데이터를 관리<br>
<img src="https://i.imgur.com/fqm2USX.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">commonjs 스펙
브라우저에서 모듈을 가져와서 사용하는 방식browserify 도구
spa -&gt; 여러 js 파일이 많아 복잡함
esm이 지원되지 않아도 번들링해서 주는 webpack(모듈 번들러)
여러 개의 트리 구조처럼 된 스크립트가 번들화되어 하나의 js만 script로 넣을 수 있게끔현대는 esm 방식으로 개발
아직은 브라우저 호환성이 완벽하지 않아 모듈 번들러를 사용스토어 - 뷰를 연결시켜주는 controller -&gt; MVC와 유사한 패턴
view를 기준으로 잘 나누기
store 상태작업
view 돔작업vsync에 대해 알기자동 이동 -&gt; transition으로 애니메이션 되는 것처럼패널을 세개로 나눠서 메모리 효율성을 높이기<br><img src="https://i.imgur.com/Fhbd2qq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
DIKW 피라미드
data 실제적인 값을 디스크에 저장(반영구적 보관을 위해)
기록을 하기 위해서는 디스크의 바이너리 형태로 저장할 수 있어야 함
electronical하게 저장
전기적으로 저장할 수 있는 값을 데이터라고 함 Information 의미가 있는 값
데이터를 Information으로 만들기 위해서는 데이터들이 모여있는걸보고 저장 knowledge information을 이용하여 information을 얻음
가지고 있는 information을 바탕으로 도출해낼 수 있는 유용한(유용성) 지식 wisdom 가지고 있는 knowledge를 바탕으로 문제풀이에 사용하는 자료구조
리스트-&gt; 애플리케이션에 종속적
바이너리 트리
맵
그래프
=&gt; 메모리에서 저장되고 돌아감
DDBMS d이전의 DBMS
List - &gt; Lfat Records
Binary Tree -&gt; 계층형 디비
Graph -&gt; 네트워크 DVBRDBMS
E.F.Codd "A relational Model of data for Large SHared Data banks"
IBM System R
bkerkeley Postgress
1970년대 이후로 데이터 저장을 위해 가장 널리 사용됨
오라클, MySQL, MS-SQL, PostgreSQL
트랜잭션 지원
ACID
Atomicity
Consistency
Isolation
Durability
CAP 이론수평 확장 vs 수직 확장
수평 확장 : 컴퓨터를 여러개로 늘리는 것(dbms를 늘림)
수직 확장: 디스크, cpu등 돈을 써서 스펙을 늘림
NOSQL
Not Only SQL
관계형 데이터베이스를 보완하기 위한 데이터 저장소
도큐먼트 디비, KV Store, 그래프 DB 등 json기반 레코드 저장
빠르고 사용이 간단함
비정형 대용량 데이터에 대한 빠른 접근 제공
orm(object relational mapping) -&gt; 객체와 db 사이에는 차이가 큰데 이를 억지로 맞추려는
조금 더 객체에 가까움 (ogm) KV 저장 지원
RAM에서 돌아감
매우 빠름(마이크로세컨드 단위)
단순 데이터 처리 용도로 사용되었으나 기능이 점차로 증가되는 추세
캐시, 세션 클러스터링(세션db), Pub-Sub, 이벤트 처리 등의 다양한 용도로 사용 가능
Redis: NOSQL 인메모리 디비지만 맥가이버 칼 같은 존재 Apache Lucene 기반 검색엔진
전문 검색에 널리 사용 대규모 실시간 데이터 스트리밍을 처리하기 위해 개발된 오픈 소스 분산형 이벤트 스트리밍 플랫폼
Likedin에서 처음 개발, 이후 Apache Software Foundation에서 관리
실시간 데이터 피드
데이터 스트리밍
로그 수집
트랜잭션 로그 처리
RabbitMQ가 더 가벼운 프로젝트에 적합
서버의 3계층
사용자의 요청 처리(웹 서버 - 정적인 콘텐츠)
WAS(web application server)
database
+Message queue(RabbitMQ) KV Store + Document Store
설치가 필요없음
고성능 고가용성 내구도
비쌈 대규모 데이터를 분산처리하기위해 만들어진 오픈 소스 플랫폼
HadooFS
MapReduce
YARN, HADDOP Common
최소 3카피의 데이터 분산저장 Zookeeper: 관리 도구 Hive: SQL 쿼리를 사용해 HDFS에 저장된 데이터를 분석할 수 있는 데이터 웨어하우스 시스템. HBase: HDFS 위에 구축된 분산형 NoSQL 데이터베이스, 빠른 데이터 조회가 필요한 경우 사 용. Spark: 대규모 데이터 처리 및 분석을 위한 고속 처리 엔진, 특히 반복 작업에 효율적. Flume: 로그 데이터를 수집하고, HDFS로 전송하는 분산형 데이터 수집 시스템. Pig: 대규모 데이터 세트의 분석을 단순화하는 스크립팅 플랫폼. Oozie: Hadoop 작업의 워크플로우를 관리하는 스케줄러.
<br><img src="https://i.imgur.com/FAv5RRk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
3306 포트로 로컬에서만 열기<br><img src="https://i.imgur.com/ZtcL0QF.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
bind address
mysqlx
주석처리
이후 sudo systemctl restart mysqlerd 공부하기<br><img src="https://i.imgur.com/TKBPSGH.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">connection pool 만들기!<br><img src="https://i.imgur.com/dfi6YEb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/5Q8ZzU1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
query plan을 통해 성능 체크]]></description><link>부스트캠프/멤버십/2주차/멤버십_2주차_마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/멤버십_2주차_마스터클래스.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/mE0exW2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/mE0exW2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멤버십_2주차_주간계획]]></title><description><![CDATA[
가상머신 설치 + 우분투
리눅스 서버에 MySQL 설치
css rem 활용해서 리팩토링하기
모듈을 활용할 수 있도록 리팩토링
css 애니메이션 처리 코딩 컨벤션 처리
api 설계 및 구현 scope chain
Closure
클라이언트 렌더링과 서버 렌더링
esm 방식
SQL문 fsd 정리
esm 정리 가상머신에 우분투 설치 후 Linux에 mySQL 설치
각 데이터에 대한 get api 제작 디렉토리 구조 다시 짜기
DOM api들을 모듈라 프로그래밍을 활용하여 재구조화하기
클라이언트 사이드 렌더링으로 구조 변경 animation 정리 애니메이션 적용하기
post(카드 추가), delete(카드 삭제), patch(카드 수정) 서버 구현 및 연결 bem 방법론 정리 칼럼 추가, 수정 및 삭제
FAB 버튼 기존 코드 리팩토링 animation 정리 히스토리 컴포넌트에 애니메이션 추가
카드 정렬 애니메이션 추가 기존 코드 리팩토링
]]></description><link>부스트캠프/멤버십/2주차/멤버십_2주차_주간계획.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/멤버십_2주차_주간계획.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[멤버십_2주차_학습정리]]></title><description><![CDATA[$ npm install --save-dev @babel/core @babel/cli
# env preset 설치 $ npm install --save-dev @babel/preset-env
의존성 설치 후 프로젝트 루트에 .babelrc 파일 생성 후 작성{ "presets": ["@babel/preset-env"] }
위 npm script는 src/js 폴더(타깃 폴더)에 있는 모든 ES6+ 파일들을 트랜스파일링한 후, 그 결과물을 dist/js 폴더에 저장한다. 사용한 옵션의 의미는 아래와 같다.-w
타깃 폴더에 있는 모든 파일들의 변경을 감지하여 자동으로 트랜스파일한다. (--watch 옵션의 축약형)-d
트랜스파일링된 결과물이 저장될 폴더를 지정한다. (--out-dir 옵션의 축약형)# Webpack V4는 webpack-cli를 요구한다
$ npm install --save-dev webpack webpack-cli
웹팩이 모듈을 번들링할 때 babel을 사용하여 es6+ 코드를 es5 코드로 트랜스파일링할 수 있도록 babel-loader 설치오래된 브라우저에서도 ES6+에서 새롭게 추가된 객체나 메소드를 사용하기 위해서는&nbsp;<a data-tooltip-position="top" aria-label="https://babeljs.io/docs/en/babel-polyfill" rel="noopener nofollow" class="external-link is-unresolved" href="https://babeljs.io/docs/en/babel-polyfill" target="_self">@babel/polyfill</a>을 설치해야 한다.$ npm install @babel/polyfill
전 세계 나라들은 각각 다른 언어, 날짜, 시간, 화폐 등을 가지고 있기 때문에 내가 실행하는 환경이 우리나라로 설정되어 있는지 환경을 확인할 필요가 있다.
그래서 국제화를 통해 사용자가 어떻게 표시할지 환경을 선택하는 기능을 로케일(Locale)이라고 한다.localectl 커맨드는 내 로케일 설정을 확인 및 설정이 가능하다<br>
<img src="https://i.imgur.com/P7aacCU.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
system Locale : 현재 설정되어 있는 로케일 표시
VC Keymap : 가상 콘솔에서 사용하는 키맵
X11 Layout : Xwindows에서 사용되는 키보드 레이아웃
X11 Model : 키보드 모델
localectl list-locales 커맨드를 통해 설정이 가능한 locale을 확인한다.<br>
<img src="https://i.imgur.com/Ta5dDYq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Ubuntu를 설치한 후 최초 접속 후에는 우분투 패키지를 업그레이드하고 한글 설정을 해줌으로써 Locale을 우리나라 기준으로 설정할 수 있다.$ sudo apt update
$ sudo apt upgrade
$ sudo apt install language-pack-ko
$ sudo locale-gen ko_KR.UTF-8
$ sudo update-locale LANG=ko_KR.UTF-8 LC_MESSAGES=POSIX
<br><img src="https://i.imgur.com/ZYAyXRj.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">설정 이후에는 재부팅을 해주어야 한다.
재부팅 이후 다시 locale을 확인하자<br><img src="https://i.imgur.com/VYB61wy.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">잘 변경되었다.설치 전 패키지들을 업데이트 해준다sudo apt update
sudo apt upgrade
패키지 업데이트 이후에는 MySQL을 설치한다
22.04 기준으로 auth socket을 이용해서 root 접속을 하게 되었다.
sudo apt install mysql-server
mysql 서버를 실행시키기 위해서는 아래와 같은 커맨드를 입력한다.
mysql root 사용자로 로컬 로그인시 패스워드가 필요하지 않다.
mysql root 사용자의 외부 접속은 허용하지 않는다
# root 접속하기
sudo mysql
서버가 정상적으로 실행되었는지 확인하기 위해서는 sudo systemctl status mysql
를 입력한다<br><img src="https://i.imgur.com/vA1RBU0.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"># db 만들기
create database db이름;
# 유저 생성
create user '유저이름'@'%' identified by db비밀번호;
# 생성한 유저에게 권한 부여
grant all on db이름.* to '유저이름'@'%' with grant option flush privileges
db를 만들고 권한을 부여했다면 이제는 유저를 통해서 접속할 수 있다.sudo mysql -u 유저이름 -p
비밀번호 입력
~
mysql&gt;
$ sudo reboot
$ mysql -u root -p $ sudo systemctl status mysql
$ sudo systemctl enable mysql
# 자동 실행 취소 명령 (참고용, 타이핑하지 마세요)
# sudo systemctl disable mysql
$ sudo reboot
$ mysql -u root -p MYSQL은 우분투에서 사용하는 경우 Localhost에서만 접속이 가능하도록 설정되어 있다.
따라서 외부 접속에 대해 가능하게 하려면 기존의 환경 파일을 수정해주어야 한다.sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
...
# 주석처리
# bind-address = 127.0.0.1 # 저장 후 재시작
sudo systemctl restart mysql
workbench를 설치하기 위해서는 이전에 ubuntu의 desktop을 보아야 하는데, 나와 같은 경우 multipass ubuntu 가상머신에서 GUI 데스크탑 환경을 사용하기 때문에 따로 desktop 버전을 설치해주어야 한다.sudo apt update
sudo apt upgrade
sudo apt install ubuntu-desktop xrdp
$ sudo apt update
$ sudo apt -y install wget
$ wget https://dev.mysql.com/get/mysql-apt-config_0.8.15-1_all.deb
다운로드 확인$ ls -lh mysql-apt-config_0.8.15-1_all.deb 설치 스크립트 실행# apt $ sudo apt install ./mysql-apt-config_0.8.15-1_all.deb # dpkg
$ sudo dpkg -i mysql-apt-config_0.8.15-1_all.deb ssh는 원격 호스트로의 접속과 더불어 'SSH Tunneling' 또는 'ssh port forwarding'이라는 기능을 제공한다.<br><img src="https://i.imgur.com/QtK4Z3y.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
서버에 접근할 필요성이 생기게 된다면, ssh를 통해서 서버에 접근하게 될 것이다.
하지만 서버에서는 보안상의 문제로 서버에서 리슨하고 있는 포트가 방화벽에 의해 막혀있다. 이 경우, 호스트는 서버에 직접적으로 접근할 수 없다. 위 사진처럼 22포트를 통해서는 접속이 되지만, 6667 서버에 의해서는 방화벽에 의해 접근이 제한된다.이럴 때 쓰는 것이 ssh 터널링으로, ssh 연결을 통해서 방화벽을 우회하고 업 서버에 접근하여 정보를 안전하게 전달하고 데이터를 받을 수 있다.
Local Port Forwarding
Remote Port Forwarding
Dynamic Port Forwarding ssh 서버에서는 보안상에서 허용되어 있지 않기 때문에 ssh 서버의 구성을 바꿔줘야 할 필요성이 있는데, 루트 권한을 통해 기존의 ssh 설절증 바꾸어준다.# 설정 편집창 열기
$ sudo vi /etc/ssh/sshd_config # ssh 설정 변경하기
...
#AllowTcpForwarding yes
#GatewayPorts no -&gt; yes
... # 설정을 적용하기 위해 sshd 서비스 재시작
$ sudo systemctl restart sshd
# 또는
$ sudo service sshd restart
AllowTcpForwarding과 GatewayPorts 주석을 해제하고 yes로 값을 바꾼다.로컬 터널링은 앱 클라이언트가 있는 호스트에서 서버가 구동되어 있는 호스트로 ssh 연결을 맺는다.$ ssh -L PORT1:HOSTNAME:PORT2 user@hostB
ssh 클라이언트는 port1에 리슨하고, port1로 들어오는 요청에 대해 ssh 클라이언트가 ssh 서버쪽으로 요청을 보내고, 서버로 전송된 요청은 HOSTNAME:PORT2로 전해진다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://hbase.tistory.com/328" target="_self">https://hbase.tistory.com/328</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://elsainmac.tistory.com/870" target="_self">https://elsainmac.tistory.com/870</a>ERD는 E-R 다이어그램의 약자이다.
E는 Entity 즉, 개체 속성이고 R은 Relation으로 풀어 말하자면 개체 속성과 개체 간 관계를 다이어그램으로 표현한 것이다.데이터베이스 테이블 내의 모든 레코드에서 고유한 아이디
모든 레코드가 서로 다른 값을 가지고 있어 각 레코드 식별 가능
NULL값이 존재할 수 없음
레코드의 값은 중복 불가능
테이블에는 하나의 기본 키만 가질 수 있지만 경우에 따라 1개 이상의 기본 키를 정의할 수도 있음(다수열 기본 키, 복합 기본 키)
%% 테이블 생성할 때 %%
CREATE TABLE user { id int PRIMARY KEY } %% 이미 있는 테이블에 추가 %%
`ALTER TABLE users ADD PRIMARY KEY (name);` %% 다중 Primary Key %%
CREATE TABLE users ( id INT NOT NULL , name VARCHAR(50), email VARCHAR(100), password VARCHAR(50), PRIMARY KEY (id, name)
); PK 사용할 컬럼에 PRIMARY KEY 붙여주기
중복값과 NULL값이 없어야 한다는 점을 기억하자
중복값을 INSERT할 때 작동하지 않는다.
ALTER TABLE users DROP PRIMARY KEY; 삭제 쿼리를 실행하기 전에 반드시 기본키가 다른 테이블에서 참조되지 않는지 확인해야 함 참조 무결성 제약조건 위배로 데이터베이스가 손상될 수 있음 기본 키를 삭제하려ㅑ면 먼저 해당 키가 참조하는 외래 키를 삭제해야 함 PRIMARY KEY의 속성 중 하나
삽입되는 레코드에 유니크한 값을 자동적으로 부여한다.
일반적으로 1부터 증가하며 값을 부여하지만, 별도의 다른 값을 부여할 수도 있다.
CREATE TABLE user { id int PRIMARY KEY AUTO_INCREMENT }
다른 테이블의 기본 키를 참조하는 컬럼으로, 데이터가 일관(데이터 무결성)될 수 있도록&nbsp;돕는 역할을 한다.
보통은 두 개의 데이터베이스 테이블을 잇고자 기본 키와 함께 사용된다. 일종의 테이블을&nbsp;연결하는 가상의 다리 역할을 한다.
외부 키는 한 테이블의 필드로, 다른 테이블의 기본 키를 나타낸다.
외래 키를 가지고 있는 테이블을 하위 테이블, 기본 키를 가지고 있는 테이블을 참조 이블 또는 상위 테이블이라고 한다.
각 외부 키와 기본 키는 1:1관계로 매칭되어야 하며, 기본 키에 존재하지 않는 값이 외부키에 존재할 수 없다. -&gt; 외래 키 제한 표현으로 데이터베이스에게 두 테이블 간의 관계를 알려주어야 한다. 두 테이블 간의 관계를 정의한다.
기본 키의 존재하지 않는 값을 외래 키에 존재하게 되는 일을 막아준다.
CREATE TABLE country ( country_id integer, name varchar(50), population integer); CREATE TABLE city ( city_id integer, name varchar(50), country_id integer);
💡제한 표현이 없는 상태에서 데이터베이스는 두 테이블간의 관계를 파악하지 못한다. 따라서 우리가 외래키로 설정한&nbsp;city&nbsp;테이블의&nbsp;country_id는 기본 키인&nbsp;country&nbsp;테이블의&nbsp;country_id에 존재하지 않는 값을 입력해도 아무런 문제가 없이 실행된다.
이를 방지하고 데이터베이스에게 두 테이블간의 관계를 알려주기 위해 제한 표현을 사용한다.
💡 외래 키를 생성하기 전, 기본 키를 먼저 정의해야 한다.
# 부모 테이블을 참조하는 외래 키 생성
CREATE TABLE child_table ( #child_table 자식 테이블 child_column INT NOT NULL, #자식 테이블에서 외래키로 사용될 필드 ... FOREIGN KEY (child_column) REFERENCES parent_table(parent_column) # parent_table 부모 테이블
); # 기본 키와 외래 키를 정의한 새로운 테이블 생성
DROP TABLE IF EXISTS customers;
CREATE TABLE customers ( id INT NOT NULL PRIMARY KEY, name VARCHAR(50) NOT NULL, email VARCHAR(50) UNIQUE
); DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT NOT NULL PRIMARY KEY, customer_id INT, order_date DATE, total DECIMAL(10,2), FOREIGN KEY (customer_id) REFERENCES customers(id)
); # 외래키 삭제
`ALTER TABLE orders DROP FOREIGN KEY fk_customer_id;` # 제약조건 이름 확인
`SHOW CREATE TABLE orders`
외래 키 제약 조건에 의해 참조되는 테이블에서 데이터의 수정이나 삭제가 발생하면, 참조하고 있는 테이블의 데이터도 같이 영향을 받기 때문에 참조하고 있는 테이블의 동작은 키워드를 사용해서 FOREIGN KEY 제약 조건에서 설정할 수 있다.외래 키가 참조하는 테이블 행이 삭제될 때 실행되는 동작
CASCADE: 외래키가 참조하는 모든 행도 함께 삭제
SET NULL: 외래키 값을 NULL로 설정(자식 외래키가 NOT NULL일 때는 안됨)
SET DEFAULT : 외래키 값을 기본값으로 설정
RESTRICT: 외래키가 참조하는 행이 있으면 삭제를 거부
외래키가 참조하는 테이블의 행이 업데이트될 때 실행되는 동작
CASCADE: 외래키가 참조하는 모든 행도 함께 업데이트
SET NULL: 외래키 값을 NULL로 설정(자식 외래키가 NOT NULL일 때는 안됨)
SET DEFAULT : 외래키 값을 기본값으로 설정
RESTRICT: 외래키가 참조하는 행이 있으면 삭제를 거부
CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(50)
); CREATE TABLE orders ( id INT PRIMARY KEY, customer_id INT, amount DECIMAL(10,2), FOREIGN KEY (customer_id) REFERENCES customer(id) ON DELETE CASCADE ON UPDATE CASCADE
);
고유 키는 테이블에서 특정 필드의 값을 고유하게 만들기 위해 사용하는 값이다.
고유 키는 Primary Key와 마찬가지로, 각 레코드를 식별하는데 사용된다.
하지만 기본 키와는 다른 점은 NULL값을 포함할 수 있다는 점이다.# 일반적인 생성방법
CREATE TABLE users( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50) UNIQUE , email VARCHAR(100), password VARCHAR(50)
); CREATE TABLE users( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50) , email VARCHAR(100), password VARCHAR(50), UNIQUE(name)
); # 기존 테이블에 고유키 추가
`ALTER TABLE users ADD CONSTRAINT unique_password UNIQUE (password);` `ALTER TABLE users DROP INDEX unique_password;`
MVC 패턴이란 Model-View-Controller의 앞글자만 따온 약자로, 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴이다.
디자인 패턴이란?
프로그램이나 어떤 특정한 것을 개발하는 중에 발생했던 문제점들을 정리해서 상황에 따라 간편하게 적용하여 쓸 수 있는 것을 정리한 규약
해당 패턴은 소프트웨어의 비즈니스 로직과 화면을 구분하는데 중점을 두고 있다. 즉, 하나의 애플리케이션을 설계함에 있어서 구성 요소를 세 가지 역할로 나누어 구분한 것이다.
세 가지 역할은
모델(Model) : 데이터와 비즈니스 로직 관리
뷰(View) : 레이아웃과 화면 처리
컨트롤러(Controller) : 모델과 뷰로 명령을 전달
로 구분된다
<br><img src="https://i.imgur.com/ZqqejMn.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
위의 그림처럼 서로의 관계가 정의되어 있다.
각각의 요소에 대해서 자세히 알아보자애플리케이션의 정보, 데이터를 나타낸다.
데이터베이스, 상수, 초기화값, 변수 등을 뜻하며, 이러한 정보들을 가공하는 역할을 한다.
사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 함
뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 함 뷰를 참조하는 내부 속성값을 지니면 안됨 변경이 일어나면, 변경 통지에 대한 처리방법을 구현 정보 변경이 일어나면, 이벤트를 발생시켜 전달하고, 이를 뷰에서 수신하여 처리하거나 하는 처리 방법이 따로 있어야 함
모델은 재사용가능해야 하며 다른 인터페이스에서도 변하지 않아야 함 사용자 ui를 담당하는 요소이다. 데이터 및 객체의 입력, 출력을 담당한다.
데이터를 기반으로 사용자들이 볼 수 있는 화면이다. 즉, 표시할 데이터를 모델로부터 받아 출력한다.
모델이 가지고 있는 정보를 따로 저장해서는 안됨 임의의 뷰 내부에 저장 금지 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 함 모델과 같은 자기 자신을 제외하고 다른 요소들의 참조나 동작을 모름
데이터를 받으면 단순히 화면에 표시만 함 변경이 일어나면 변경 통지에 대한 처리 방법 구현 모델과 같이 변경이 일어났을 때 변경을 알려줘야 하는 방법 구현
재사용가능하게끔 설계 컨트롤러는 데이터와 ui(사용자 인터페이스) 요소들을 잇는 다리 역할이다.
사용자가 데이터를 클릭하면 수정하는 것에 대한 이벤트들을 처리한다
모델이나 뷰에 대해서 알고 있어야 함 모델이나 뷰는 서로 모르즈만 컨트롤러는 그 사이에 둘을 모두 알고 있는 상태에서 변경을 외부로 알리거나 수신할 수 있어야 함 모델이나 뷰의 변경을 모니터링 해야함
이러한 3개의 구성 요소로 나누어 동작하는 웹 서버의 구조를 활용하면 가지는 장점들이 뚜렷하다.
유지보수성 향상 모델, 뷰, 컨트롤러가 명확하게 나누어져 있어 코드의 수정이나 확장이 용이하다
유지보수가 필요한 부분을 집어 해당 부분만 수정하면 됨 개발의 병렬성 증가 따로따로 개발이 가능해서 협업을 할 경우 개발의 분업화가 잘 이루어질 수 있음 유연성과 확장성 애플리케이션의 기능을 쉽게 추가 및 확장 가능하다
각각의 요소에 맞추어 추가하기만 하면 된다 테스트 용이성 mvc 패턴은 각 컴포넌트가 독립적으로 동작하도록 설계되었기 때문에 단위 테스트를 수행하기 쉬움 코드의 명확한 구조 코드의 구조가 명확해짐
코드의 가독성을 높임 중복 코드 감소 중복 코드를 하나로 묶음으로써 재사용이 용이하고 코드의 중복이 사라짐 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Glossary/MVC" target="_self">https://developer.mozilla.org/ko/docs/Glossary/MVC</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://m.blog.naver.com/jhc9639/220967034588" target="_self">https://m.blog.naver.com/jhc9639/220967034588</a>]]></description><link>부스트캠프/멤버십/2주차/멤버십_2주차_학습정리.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/멤버십_2주차_학습정리.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/P7aacCU.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/P7aacCU.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day 1]]></title><link>부스트캠프/베이직/day-1.html</link><guid isPermaLink="false">부스트캠프/베이직/Day 1.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day 2]]></title><link>부스트캠프/베이직/day-2.html</link><guid isPermaLink="false">부스트캠프/베이직/Day 2.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_10]]></title><description><![CDATA[<a data-href="Day_10 문제" href="부스트캠프/베이직/day_10-문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_10 문제</a><br>
<a data-href="Day_10 풀이" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Day_10 풀이</a>]]></description><link>부스트캠프/베이직/day_10.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_10.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[Day_10 문제]]></title><description><![CDATA[K-MEAN 알고리즘 동작 방식을 이해하고 구현할 수 있다.
없음. 데이터 목록을 보고 요구사항에 맞게 분류하고 구현할 수 있어야 한다.
최소 2명 이상이 하나의 형식에 대해 도전한다.
어떤 함수를 구현할 것인가 2명 이상이 함께 결정한다.
프로그래밍 요구사항을 만족하는 공통 함수를 설계한다.
전달할 데이터 구조를 어떻게 표현할 것인가 결정한다.
설계 후에 구현을 해도 무방하지만 구현만 해서는 안된다. 설계는 데이터 구조와 데이터 흐름을 명시한 그림을 손으로 그린다.
손으로 그린 그림을 캡처해서 gist에 첨부한다.
gist에 README.md 파일을 추가하고 설계 의도와 방향에 대해 간략하게 설명을 붙인다.
우리나라 40개 시를 편입년도, 위도, 경도, 인구수를 함께 기록하면 다음 표와 같다. 이 표의 데이터 항목을 분석해서 분류하는 것을 구현하려고 한다.[["0","서울" ,"1946","37.5665","126.9780","9720846"],
["1","부산" ,"1963","35.1796","129.0756","3413841"],
["2","인천" ,"1981","37.4563","126.7052","2938420"],
["3","대구" ,"1981","35.8714","128.6014","2414220"],
["4","대전" ,"1995","36.3504","127.3845","1475221"],
["5","광주" ,"1986","35.1595","126.8526","1454677"],
["6","울산" ,"1997","35.5384","129.3114","1159673"],
["7","세종" ,"2012","36.4875","127.2816","362259"],
["8","수원" ,"1949","37.2636","127.0286","1240374"],
["9","창원" ,"2010","35.2286","128.6811","1046188"],
["10","포항" ,"1949","36.0190","129.3435","511807"],
["11","전주" ,"1949","35.8242","127.1480","658346"],
["12","청주" ,"1949","36.6424","127.4890","847110"],
["13","제주" ,"1955","33.4996","126.5312","486306"],
["14","고양" ,"1992","37.6564","126.8350","1075500"],
["15","용인" ,"1996","37.2411","127.1776","1081914"],
["16","천안" ,"1995","36.8151","127.1139","666417"],
["17","김해" ,"1995","35.2342","128.8811","559648"],
["18","평택" ,"1986","36.9921","127.1122","519075"],
["19","마산" ,"1949","35.2138","128.5833","424192"],
["20","군산" ,"1949","35.9672","126.7364","266569"],
["21","원주" ,"1955","37.3422","127.9202","364738"],
["22","의정부","1963","37.7389","127.0455","442782"],
["23","김포" ,"1998","37.6236","126.7145","442453"],
["24","광명" ,"1981","37.4772","126.8664","345262"],
["25","춘천" ,"1995","37.8813","127.7298","285584"],
["26","안산" ,"1995","36.7898","127.0049","321355"],
["27","성남" ,"1973","37.4200","127.1265","944626"],
["28","구미" ,"1978","36.1195","128.3446","402607"],
["29","시흥" ,"1989","37.3803","126.8031","446420"],
["30","목포" ,"1949","34.8118","126.3922","238718"],
["31","익산" ,"1947","35.9483","126.9577","292524"],
["32","경주" ,"1955","35.8562","129.2247","257041"],
["33","의왕" ,"1986","37.3446","126.9688","157346"],
["34","부천" ,"1973","37.4989","126.7831","843794"],
["35","남양주","1995","37.6367","127.2143","736287"],
["36","파주" ,"1997","37.7598","126.7805","453589"],
["37","거제" ,"1989","34.8806","128.6216","241253"],
["38","화성" ,"2001","37.1997","126.8310","791057"],
["39","강릉" ,"1995","37.7519","128.8761","213658"]]
위의 데이터를 분석해서 K개 그룹으로 분류해서 나눠주는 kmeans_pop(), kmeans_long() 함수를 구현해야 합니다. 다음과 같은 방식으로 동작하도록 구현해야 합니다. 단, K값은 2부터 10까지 가능합니다.
kmeans_pop() : x축은 년도, y축은 인구수(population)를 기준으로 합니다. kmeans_long() : x축은 년도, y축은 경도(logitude)를 기준으로 합니다. 입력받은 변수 개수에 따라 무작위로 K개를 임시 중심값으로 선택한다.
모든 도시들을 순회하면서 중심값과 각각 거리를 계산한다.
임시 중심값과 가까운 순으로 K개 그룹을 묶는다.
각 그룹별로 포함된 도시들 무게 중심을 구한다.
새로 계산한 무게 중심과 이전 중심값을 비교한다.
중심값이 변경되었으면 2번부터 다시 반복해서 계산한다.
중심값이 동일하면 멈추고 그룹별 중심값과 그룹에 포함된 도시를 출력한다.
알고리즘 구현에 따라 결과가 달라질 수 있으며, 거리를 계산할 때 년도는 숫자의 크기에 영향을 받기 때문에 어느정도 조정을 해야할 수도 있다.그룹#1 중심값 : (1946, 9720847)
그룹#1 도시들 : ["서울"]
그룹#2 중심값 : (1986, 511807)
그룹#2 도시들 : ["부산", "인천"..."화성", "강릉"]그룹#1 중심값 (1996.67, 127.07)
그룹#1 도시들 : [대전, 세종, 고양, 용인, 천안, 김포, 춘천, 안산, 시흥, 남양주, 파주, 화성]
그룹#2 중심값 (1951.93, 127.60)
그룹#2 도시들 : [서울, 부산, 수원, 포항, 전주, 청주, 제주, 마산, 군산, 원주, 의정부, 성남, 고양, 안양, 서귀포]
그룹#3 중심값 (1994.50, 128.83)
그룹#3 도시들 : [대구, 울산, 창원, 김해, 거제, 강릉]
그룹#4 중심값 (1980.50, 127.09)
그룹#4 도시들 : [인천, 광주, 평택, 광명, 성남, 구미, 의왕, 부천]<img alt="0b23f050-1b01-40d0-bfa9-737e7b9a1d9e" src="https://lucas-image.codesquad.kr/17161990571640b23f050-1b01-40d0-bfa9-737e7b9a1d9e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>부스트캠프/베이직/day_10-문제.html</link><guid isPermaLink="false">부스트캠프/베이직/Day_10 문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://lucas-image.codesquad.kr/17161990571640b23f050-1b01-40d0-bfa9-737e7b9a1d9e.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://lucas-image.codesquad.kr/17161990571640b23f050-1b01-40d0-bfa9-737e7b9a1d9e.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day2_문제]]></title><description><![CDATA[
주어진 조건을 분석하고 어떤 데이터 구조를 왜 사용해야 하는지 스스로 판단할 수 있다. 주어진 조건에 맞는 데이터 구조를 배열로 표현하고 탐색하면서 채울 수 있다. 없음. <img alt="boostmarble" src="https://lucas-image.codesquad.kr/1715659579646boostmarble.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그림처럼 시작 지점부터 15칸이 그려진 부스트마블 보드게임을 구현하려고 합니다. 아래 요구사항을 만족하는 play() 함수를 작성하세요.
A, B, C, D 4명의 참가자가 있다고 가정하고 매 턴마다 주사위 대신에 1-4 사이의 값이 입력으로 제공됩니다. 모든 참가자는 시작 지점에서 출발하고, 주어진 1-4 값만큼 이동합니다. 한 번도 방문하지 않은 곳에 누군가 도착하면 그 곳을 소유합니다. 다른 사람이 이미 소유한 곳에 도착하면 뺏을 수 없습니다. 여러 사람들이 모든 장소를 소유할 때까지 계속 입력으로 이동할 수 있습니다. 더 이상 이동할 입력값이 없거나, 더 이상 소유할 장소가 없으면 게임을 종료합니다. 종료 시점에는 각 참가자별로 소유한 장소 개수를 리턴하세요. 매개변수 param0는 참가자 A, B, C, D 순서로 이동할 칸을 의미하는 숫자를 4개씩 포함하는 배열입니다. 예시)&nbsp;"1,2,3,4"&nbsp;는 A 1칸, B 2칸, C 3칸, D 4칸 이동한다는 의미입니다. 리턴값은 맵(또는 사전) 형태로 참가자별 소유한 장소 개수를 포함합니다. 예시)&nbsp;[ "A" : 4 , "B" : 3 , "C" : 5, "D" : 3 ] ]]></description><link>부스트캠프/베이직/day2_문제.html</link><guid isPermaLink="false">부스트캠프/베이직/Day2_문제.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://lucas-image.codesquad.kr/1715659579646boostmarble.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://lucas-image.codesquad.kr/1715659579646boostmarble.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Day2_학습내용]]></title><description><![CDATA[
매개변수 param0는 참가자 A, B, C, D 순서로 이동할 칸을 의미하는 숫자를 4개씩 포함하는 배열입니다. 예시)&nbsp;"1,2,3,4"&nbsp;는 A 1칸, B 2칸, C 3칸, D 4칸 이동한다는 의미입니다.
=&gt; 즉, play함수는 parameter로 들어오는 A, B, C, D의 이동한 칸 만큼 움직이게 만들고, 게임 종료 조건을 확인할 수 있도록 만드는 함수여야 함 A, B, C, D 4명의 참가자가 있다고 가정하고 매 턴마다 주사위 대신에 1-4 사이의 값이 입력으로 제공됩니다.
=&gt; parameter로 들어가는 A, B, C, D의 입력은 1-4의 값을 랜덤으로 뽑게 해 주는 dice() 함수 제작 모든 참가자는 시작 지점에서 출발하고, 주어진 1-4 값만큼 이동합니다.
=&gt; play()함수를 제작하여 모든 참가자를 이동하게 만듦. 이동한 후에는 이동한 뒤의 참가자 위치를 리턴해야 위치를 기록할 수 있음 한 번도 방문하지 않은 곳에 누군가 도착하면 그 곳을 소유합니다.
=&gt; 만약 play()함수에서 유저가 움직였을 때 참가자 위치에 소유 표시가 따로 되어 있지 않으면 소유 표시
=&gt; 소유 표시를 어떻게 할 것인가?
=&gt; 배열로 만들면 인덱스 번호를 통해 편하게 접근가능 다른 사람이 이미 소유한 곳에 도착하면 뺏을 수 없습니다.
=&gt; 소유표시가 되어 있으면 그냥 따로 아무것도 없이 지나감 여러 사람들이 모든 장소를 소유할 때까지 계속 입력으로 이동할 수 있습니다.
=&gt; 모든 장소에 소유 표시가 될 때까지 이동
=&gt; 소유 표시를 계속해서 확인해야 함
=&gt; 소유 표시는 계속해서 루프를 돌면서 확인하기보다는 따로 소유한 곳의 수를 세서 15개가 되면 종료하도록 만든다면 시간 복잡도가 줄어들 것 더 이상 이동할 입력값이 없거나, 더 이상 소유할 장소가 없으면 게임을 종료합니다.
=&gt; 게임종료 조건은 이동할 입력값이 없거나 소유할 장소가 없을 경우
=&gt; 처음엔 A, B, C, D 4명의 참가자가 있다고 가정하고 매 턴마다 주사위 대신에 1-4 사이의 값이 입력으로 제공됩니다.라는 말을 보고 내가 직접 함수를 만드는 것으로 생각했지만 해당 조건을 보니 아마 입력으로 제공되는 것으로 생각됨.
=&gt; 하지만 테스트케이스를 하나하나 제작하기에는 게임당 설계 소요의 시간이 커 따로 dice() 함수를 만들기로 결정 종료 시점에는 각 참가자별로 소유한 장소 개수를 리턴하세요.
=&gt; play() 함수의 리턴값
예시)&nbsp;[ "A" : 4 , "B" : 3 , "C" : 5, "D" : 3 ] // Map(4) { 'A' =&gt; 0, 'B' =&gt; 0, 'C' =&gt; 0, 'D' =&gt; 0 }
let userInfo = new Map([ ["A", 0], ["B", 0], ["C", 0], ["D", 0],
]); play 함수에 이동할 칸들의 배열이 parameter로 들어간다면 play 함수에는 a,b,c,d를 움직이게 만들도록 하고 여기서 소유 표시를 해야 함
참가자별로 소유한 장소 개수는 맵으로 만들면 되지만, 주사위 놀이 판 같은 경우는 어디에 기록?
=&gt; 그냥 배열에 해당 칸 수만큼 0으로 채워 넣고 소유표시의 경우 1표시하면 될듯?
let diceMap = new Array(16).fill(0);
칸은 5칸이지만 16개로 한 이유는 출발지를 더미로 만들어 놓아 따로 dice에서 -1을 하지 않도록 만듦// 각 참가자가 소유한 땅
let userOwn = new Map([ ["A", 0], ["B", 0], ["C", 0], ["D", 0],
]);
// 참가자 위치
let userLoc = { A: 0, B: 0, C: 0, D: 0,
};
// 총 소유 땅
let owned = 0; 참가자가 소유한 땅은 Map 사용
참가자 위치의 땅은 Object 사용 잦은 업데이트가 발생하는데, 여기서 해당 값에 접근하고 업데이트하는 코드는 Object가 직관적이라 사용해 보았음 바닥조건을 위한 총 소유 땅은 숫자를 할당하여 모든 칸(15칸)에 도달하면 더 게임을 진행하게 하지 않기 위해 따로 사용 매번 배열을 돌면서 소유하지 않은 땅을 검사할 필요가 없음 const dice = () =&gt; { let diceList = []; for (let person = 0; person &lt; 4; person++) { const random = Math.floor(Math.random() * 100); let moveCnt; if (random &gt;= 0 &amp;&amp; random &lt; 25) { moveCnt = 1; } else if (random &gt;= 25 &amp;&amp; random &lt; 50) { moveCnt = 2; } else if (random &gt;= 50 &amp;&amp; random &lt; 75) { moveCnt = 3; } else if (random &gt;= 75 &amp;&amp; random &lt; 100) { moveCnt = 4; } diceList.push(moveCnt); } return diceList;
}; 4명의 참가자가 있다고 가정되어 있으므로 명시
4번동안 루프문을 돌면서 랜덤한 수를 뽑고 각자 같은 확률로 1, 2, 3, 4를 나눠 moveCnt변수에 할당
할당한 수를 배열에 4번 넣어 리스트를 완성한 후 리턴
const play = (dice) =&gt; { console.log(dice); for (let i = 0; i &lt; dice.length; i++) { let user; switch (i) { case 0: user = "A"; break; case 1: user = "B"; break; case 2: user = "C"; break; case 3: user = "D"; break; } let move = (userLoc[user] + dice[i]) % 16; userLoc[user] = move; if (diceMap[move] === 0 &amp;&amp; move !== 0) { diceMap[move] = 1; userOwn.set(user, userOwn.get(user) + 1); owned++; } if (owned === 15) { return userOwn; } } return userOwn;
}; 매개변수 param0는 참가자 A, B, C, D 순서로 이동할 칸을 의미하는 숫자를 4개씩 포함하는 배열입니다. 예시)&nbsp;"1,2,3,4"&nbsp;는 A 1칸, B 2칸, C 3칸, D 4칸 이동한다는 의미입니다.
=&gt; 즉, play함수는 parameter로 들어오는 A, B, C, D의 이동한 칸 만큼 움직이게 만들고, 게임 종료 조건을 확인할 수 있도록 만드는 함수여야 함 이동은 항상 해야 하므로 주사위 값과 현재 유저의 위치를 더한 다음 16으로 나눈 나머지로 위치 업데이트
소유할 수 있는 조건(해당 조건에 땅에 건물이 없고 시작점(더미)가 아닌 경우) 해당 유저의 건물 수 추가
해당 주사위판의 땅을 소유했다는 것을 1로 표시
총 세운 건물 수를 추가
소유할 수 없는 경우 그냥 지나감 play()함수에서 만약 최대 소유 개수를 넘으면 바로 빠져나오도록 바닥조건 명시
function game(diceCnt) { let diceData = dice(diceCnt); while (true) { let dice = diceData.pop().split(",").map(Number); let result = play(dice); if (owned === 15 || diceData.length === 0) { return result; } }
} console.log(game(1)); 내가 턴수를 입력하면 해당 턴수만큼 진행하도록 만듦
while(true)가 무한루프에 갇힐 위험성이 있지만 바닥조건을 꼼꼼히 명시하여 탈출 바닥조건 주사위가 더 없을 때
더 이상 소유할 땅이 없을 때 let diceMap = new Array(16).fill(0);
let userOwn = new Map([ ["A", 0], ["B", 0], ["C", 0], ["D", 0],
]);
let userLoc = { A: 0, B: 0, C: 0, D: 0,
};
let owned = 0; const play = (dice) =&gt; { for (let i = 0; i &lt; dice.length; i++) { let user; switch (i) { case 0: user = "A"; break; case 1: user = "B"; break; case 2: user = "C"; break; case 3: user = "D"; break; } let move = (userLoc[user] + dice[i]) % 16; userLoc[user] = move; if (diceMap[move] === 0 &amp;&amp; move !== 0) { diceMap[move] = 1; userOwn.set(user, userOwn.get(user) + 1); owned++; } if (owned === 15) { return userOwn; } } return userOwn;
}; const dice = (cnt) =&gt; { let diceData = []; for (let i = 0; i &lt; cnt; i++) { let diceList = []; for (let person = 0; person &lt; 4; person++) { const random = Math.floor(Math.random() * 100); let moveCnt; if (random &gt;= 0 &amp;&amp; random &lt; 25) { moveCnt = 1; } else if (random &gt;= 25 &amp;&amp; random &lt; 50) { moveCnt = 2; } else if (random &gt;= 50 &amp;&amp; random &lt; 75) { moveCnt = 3; } else if (random &gt;= 75 &amp;&amp; random &lt; 100) { moveCnt = 4; } diceList.push(moveCnt); } diceData.push(diceList.join(",")); } return diceData;
}; function game(turns) { let diceData = dice(turns); while (true) { let dice = diceData.pop().split(",").map(Number); let result = play(dice); if (owned === 15 || diceData.length === 0) { return result; } }
} console.log(game(1)); ]]></description><link>부스트캠프/베이직/day2_학습내용.html</link><guid isPermaLink="false">부스트캠프/베이직/Day2_학습내용.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[마스터클래스_1주차]]></title><description><![CDATA[서버 렌더링
express -&gt; 웹애플리케이션 서버
-&gt; data(db에서 나온) + template(html 구조형태) &lt;pug, ejx&gt;
-&gt; templating , rendering(렌더링)
-&gt; response(todolist가 포함된 html을 클라이언트에 전달)
-&gt; 그대로 브라우저는 렌더링해서 보여짐html을 직접 .html로 만들고
데이터는 서버에서 데이터를 받아 넣기운영체제의 커널에 IO 요청 -&gt; 처리
큐에 쌓인 대로 처리가 안됨libuv =&gt; 싱글스레드
비동기 작업을 수행할 때 쓰레드 풀에서 작업하는데, 이 쓰레드 풀이 멀티쓰레드
쓰레드 풀이 있기 떄문에 블로킹 작업을 수행할 떄 쓰레드 풀에서 쓰레드를 가져와 작업을 수행함자바스크립트가 빠른 이유
바이트코드라서 장점이 있음
바이트코드는 기본적으로 두 가지 방식으로 실행됨
interpreter가 해석해서 실행
자주 사용하는 코드는 compiler에 의해 기계어가 되어 실행(JIT Compiler)
속도가 빨라짐에 따라 범용적으로 사용하기 위해 외부에서도 자바스크립트를 사용할 수 있는 런타임인 node.js를 만듦
초기에는 IO를 비동기(non blocking i/o)로 처리하기 위해 만들어짐
tomcat -&gt; 동기 Io 방식이라 io가 끝날 때까지 계속해서 기다리는 유휴 상태 nodejs는 바로 리턴하기 때문에 메모리 측면에서 이득이 있음
디스크는 병렬 작업이 안되기 때문에 사실상 io의 성능은 같은데 작업의 효율성 자체가 올라가는 것
단위시간당 사용자 처리량 -&gt; 싱글스레드가 멀티스레드보다 더 높음c10k문제
아파치 -&gt; 프로세스가 1만개 생김
커널 내부에서는 프로세스가 거기서 거기
이를 해결하려 나온 것이 ngnix, node.jstwobytwo
동기블로킹
비동기 논블로킹turboFan -&gt; 최적화된 코드
코드를 내가 짠 대로 실행시켜주지 않는 optimizerJit Compiler
자바에서 hotspot vn chrom v8에 주로 사용
1970년대
즉시 실행 -&gt; 인터프리터가 빠름
TurboFan -&gt; 반복적으로 사용되는 코드에 사용IOpolling
epoll 비동기 처리하기 위한 OS 커널에서 제공해주는 기능
windows에서는 iocp
bsd계열(mac) kqueue
io multiplexing - 한 소켓이 하나를 담당하도록 쓰레드를 만듦. 여러 io를 하나의 쓰레드에서 처리할 수 있도록 처리해주는 os 자체의 기능으로, nodejs와 비슷한 방식으로 응답됨
이전 select와 poll 같은 경우 busy waiting때문에 cpu 자원이 많이 소모됨. 이를 해결하기 위한 기술
운영체제의 비표준 kqueue
event loop의 처리를 위해 운영체제의 도움을 받고 있고, 운영체제마다 다르게 동작한다. ]]></description><link>부스트캠프/멤버십/1주차/마스터클래스_1주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/마스터클래스_1주차.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[멤버십_1주차]]></title><description><![CDATA[<a data-href="멤버십_1주차_주간계획" href="부스트캠프/멤버십/1주차/멤버십_1주차_주간계획.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_1주차_주간계획</a><br>
<a data-href="멤버십_학습정리_1주차" href="부스트캠프/멤버십/1주차/멤버십_학습정리_1주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_학습정리_1주차</a><br>
<a data-href="마스터클래스_1주차" href="부스트캠프/멤버십/1주차/마스터클래스_1주차.html#_0" class="internal-link" target="_self" rel="noopener nofollow">마스터클래스_1주차</a><br><a data-href="week1_1일차 PR" href="부스트캠프/멤버십/1주차/week1_1일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week1_1일차 PR</a><br>
<a data-href="week1_2일차 PR" href="부스트캠프/멤버십/1주차/week1_2일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week1_2일차 PR</a><br>
<a data-href="week1_3일차 PR" href="부스트캠프/멤버십/1주차/week1_3일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week1_3일차 PR</a><br>
<a data-href="week1_4일차 PR" href="부스트캠프/멤버십/1주차/week1_4일차-pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week1_4일차 PR</a>]]></description><link>부스트캠프/멤버십/1주차/멤버십_1주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/멤버십_1주차.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[멤버십_1주차_주간계획]]></title><description><![CDATA[2024 부스트캠프 웹 모바일 9기 멤버십 웹 풀스택 프로젝트 1 태스키파이
주간계획 세우기 ✅ 2024-08-19
색상 세팅 ✅ 2024-08-19
디자인 세팅 ✅ 2024-08-19
필요한 의존성 설치 ✅ 2024-08-19 scss 학습 ✅ 2024-08-19
nodemon 학습 main layout Header ✅ 2024-08-19
Column ✅ 2024-08-19 express 설치 및 기본 동작 세팅 ✅ 2024-08-22
nodemon express에 적용 ✅ 2024-08-22
폴더 구조 설계 ✅ 2024-08-22
서버로 보낼 데이터 구조 학습 ✅ 2024-08-22 eventlistener 학습 ✅ 2024-08-22
express 학습 ✅ 2024-08-22 서버 데이터 fetch
카드 데이터 불러오기(get)
카드 데이터 수정(patch)
카드 추가하기(post)
카드 삭제하기(delete) express pug 학습 ✅ 2024-08-22 card component ✅ 2024-08-22
카드 추가하기
등록 버튼
x hover -&gt; 빨간 색으로 변경
삭제 시 alert
카드 삭제
컴포넌트를 pug에 적용 ✅ 2024-08-22
SSR 방식으로 클라이언트-서버 연결 ✅ 2024-08-22
목업데이터 설정 ✅ 2024-08-22
렌더링 구조 변경 ✅ 2024-08-22
히스토리 컴포넌트 제작 ✅ 2024-08-22 drag &amp; drop 학습 ✅ 2024-08-22
디버깅 학습 ✅ 2024-08-22 Sorting card button ✅ 2024-08-22
생성 순 정렬
최신 순 정렬
drag &amp; drop box ✅ 2024-08-22
드래그 앤 드롭 시 색상 변경(잔상)
히스토리 아이템 컴포넌트 ✅ 2024-08-22
카드 수정 ✅ 2024-08-22
]]></description><link>부스트캠프/멤버십/1주차/멤버십_1주차_주간계획.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/멤버십_1주차_주간계획.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[멤버십_2주차]]></title><description><![CDATA[<a data-href="멤버십_2주차_주간계획" href="부스트캠프/멤버십/2주차/멤버십_2주차_주간계획.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_2주차_주간계획</a><br>
<a data-href="멤버십_2주차_학습정리" href="부스트캠프/멤버십/2주차/멤버십_2주차_학습정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_2주차_학습정리</a><br>
<a data-href="멤버십_2주차_마스터클래스" href="부스트캠프/멤버십/2주차/멤버십_2주차_마스터클래스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">멤버십_2주차_마스터클래스</a><br><a data-href="week2_1일차_PR" href="부스트캠프/멤버십/2주차/week2_1일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week2_1일차_PR</a><br>
<a data-href="week2_2일차_PR" href="부스트캠프/멤버십/2주차/week2_2일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week2_2일차_PR</a><br>
<a data-href="week2_3일차_PR" href="부스트캠프/멤버십/2주차/week2_3일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week2_3일차_PR</a><br>
<a data-href="week2_4일차_PR" href="부스트캠프/멤버십/2주차/week2_4일차_pr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">week2_4일차_PR</a>]]></description><link>부스트캠프/멤버십/1주차/멤버십_2주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/멤버십_2주차.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[멤버십_학습정리_1주차]]></title><description><![CDATA[학습 키워드
FSD <a rel="noopener nofollow" class="external-link is-unresolved" href="https://seo-tory.tistory.com/91" target="_self">https://seo-tory.tistory.com/91</a> SCSS <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://seokzin.tistory.com/entry/SCSS-SCSS-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC" target="_self">https://seokzin.tistory.com/entry/SCSS-SCSS-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC</a> bem 방법론 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://nykim.work/15" target="_self">https://nykim.work/15</a> Web Component <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/API/Web_components" target="_self">https://developer.mozilla.org/ko/docs/Web/API/Web_components</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://handhand.tistory.com/328" target="_self">https://handhand.tistory.com/328</a> 논블로킹/블로킹과 동기/비동기 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC" target="_self">https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://nodejs.org/en/learn/asynchronous-work/overview-of-blocking-vs-non-blocking" target="_self">https://nodejs.org/en/learn/asynchronous-work/overview-of-blocking-vs-non-blocking</a> nodejs 디버깅
express
JIT 컴파일러
express html 모듈
이벤트 위임 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://ingg.dev/event-delegation/" target="_self">https://ingg.dev/event-delegation/</a> DOM API <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://seokzin.tistory.com/entry/JavaScript-%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-DOM-API-%EC%A0%95%EB%A6%AC" target="_self">https://seokzin.tistory.com/entry/JavaScript-%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-DOM-API-%EC%A0%95%EB%A6%AC</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction" target="_self">https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://eyabc.github.io/Doc/dev/core-javascript/Browser_DOM_API.html#dom-interface" target="_self">https://eyabc.github.io/Doc/dev/core-javascript/Browser_DOM_API.html#dom-interface</a> 드래그앤드롭 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/%EB%93%9C%EB%9E%98%EA%B7%B8-%EC%95%A4-%EB%93%9C%EB%A1%AD-Drag-Drop-%EA%B8%B0%EB%8A%A5" target="_self">https://inpa.tistory.com/entry/%EB%93%9C%EB%9E%98%EA%B7%B8-%EC%95%A4-%EB%93%9C%EB%A1%AD-Drag-Drop-%EA%B8%B0%EB%8A%A5</a> scss는 브라우저가 읽을 수 없으므로, css로 컴파일한 다음에 css파일을 붙여야지 원할하게 작동할 수 있다.컴파일의 경우 vscode의 live sass Compiler를 쓰면 된다.<br>
<img src="https://i.imgur.com/hltyRUv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> "liveSassCompile.settings.generateMap": false, "liveSassCompile.settings.formats": [ { "format": "expanded", "extensionName": ".css", "savePath": "~/" } ]
sass Compile 옵션 추가하려면 vscode의 setting.json에서 수정
generateMap -&gt; 맵 파일(매핑할 때) 생성 여부 .map파일
sass를 컴파일할 때 생기는 map파일은 브라우저에게 제공하기 위한 목적으로 생성되는 파일이다
css파일이 압축되지 않고 .map파일이 생성되면 디버깅에서 scss 파일의 라인이 나오므로 개발자들이 브라우저의 개발 툴을 통해 라이브로 컴파일된 css가 아닌 scss 파일 자체의 디버깅이 가능해진다. format -&gt; 가독성이 높은 형태의 포맷
extensionName -&gt; 확장자 이름
savePath -&gt; 저장 경로
ES6 이전에는 가능한 한 코드를 재사용하는 것이 좋은 생각이라고 생각은 했지만, 당시 기술력으로는 한계가 있었다.
하지만 ES6가 나오면서 기본적인 html에서도 리액트와 같은 컴포넌트 개발 기법과 비슷한 개발 방법론을 사용할 수 있게 되었다.컴포넌트 기반 아키텍처(CBA)의 핵심 원칙을 지키면서 컴포넌트를 설계해보자
모듈성: 소프트웨어는 독립적인 컴포넌트로 나뉘며, 각 컴포넌트는 특정 기능을 수행하는 모듈 역할을 함
재사용성: 컴포넌트는 다양한 애플리케이션에서 재사용될 수 있어야 함
독립성: 컴포넌트는 독립적으로 운영될 수 있으며, 다른 컴포넌트에 최대한 의존하지 않아야 함
웹 컴포넌트는 세 가지 요소로 구성된다.
Custom elements 사용자 정의 요소 + 해당 동작을 정의하는 js Shadow DOM 메인 DOM에서가 아닌 독립적으로 렌더링되는 js api의 집합 HTML &lt;template&gt;과 &lt;slot&gt;과 같이 렌더링된 페이지에 나타나지 않는 마크업 템플릿과 커스텀 요소를 활용하여 재사용 가능한 컴포넌트 제작 class MyWebComponent extends HTMLElement {...};
window.customElements.define('my-web-component', MyWebComponent);
class MyComponent extends HTMLElement{ constructor() { super(); /*called when the class is instantiated */ } connectedCallback() { /*called when the element is connected to the page. This can be called multiple times during the element's lifecycle. for example when using drag&amp;drop to move elements around */ } disconnectedCallback() { /*called when the element is disconnected from the page */ }
}
여기서 중요한 점은 라이프사이클 콜백인 connectedCallback과 disconnetedCallback이다.
라이프사이클이란 웹 컴포넌트가 생성부터 소멸까지 주기가 있으며, 일어날 수 있는 일들이 정해져 있다는 것이다. 그래서 이 connectedCallback은 컴포넌트가 DOM 트리에 추가되었을 때 트리거 되는 콜백이며, disconnectedCallback은 요소가 제거되었을 때 트리거되는 콜백으로 이 둘을 통해 컴포넌트의 생명주기를 보다 유용하게 관리할 수 있다.ShadowDOM이란 숨겨진 DOM트리로, 기존 DOM에 붙일 수 있다.
shadowDOM에서 일어나는 스타일링, 자신의 append, attribute 설정 등은 외부의 트리에 어떠한 영향도 끼치지 않기 때문에 캡슐화가 가능하다.&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;template&gt; &lt;h1&gt;Hello Rick!&lt;/h1&gt;
&lt;/template&gt;
&lt;my-component&gt;&lt;/my-component&gt;
&lt;script&gt; class MyComponent extends HTMLElement { constructor() { super(); this.addEventListener('click', () =&gt; { this.style.color === 'red' ? this.style.color = 'blue': this.style.color = 'red'; }); } connectedCallback() { /*called when the element is connected to the page */ this.style.color = 'blue'; const template = document.querySelector('template'); const clone = document.importNode(template.content, true); //this.appendChild(clone); this.attachShadow({ mode: 'open' }); this.shadowRoot.appendChild(clone); } } customElements.define('my-component', MyComponent);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
shadowDOM을 붙이고 싶을 때에는 attachShadow를 통해 DOM에 추가한다.let shadow = this.attachShadow({mode: 'open'}); &lt;body&gt; &lt;!-- html 템플릿 --&gt; &lt;template id="helloWorld"&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;/template&gt; &lt;script src="main.js"&gt; // div태그 요소하나를 생성하고, const $div = document.createElement('div'); // helloWorld라는 id를 가진 템플릿요소의 내용을 복제하는 true 속성을 주면 children까지 복제합니다. // https://developer.mozilla.org/ko/docs/Web/API/Node/cloneNode $div.append(helloWorld.content.cloneNode(true)); // DOM의 바디에 붙임 document.body.append($div); &lt;/script&gt; &lt;/body&gt;
동기/비동기와 블로킹/논블로킹은 표현 형태가 비슷하지만, 서로 가르키는 차원이 다르다.
동기/비동기 -&gt; 요청한 작업에 대해 완료 여부와 이에 따른 작업의 수행 순서
블로킹/논블로킹 -&gt; I/O 작업이 차단/비차단으로 이루어져 다음 작업들이 곧바로 실행될 수 있는지
<br><img src="https://i.imgur.com/IrvNNN2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
동기와 비동기는 주로 성능과 연결되는 중요한 부분이다.클라이언트를 예시로 들어보자면 요청한 작업에 대해서 순차적으로 작업을 처리하게 된다면, 화면은 하나씩 켜져가는 사용자 경험을 겪을 것이고, 성능 또한 작업 시간이 오래 걸리게 된다.하지만 비동기의 경우는 작업의 처리에 대해서 클라이언트가 신경쓰지 않고 기존에 하던 일들을 그대로 작업한다. 그렇기 때문에 모든 작업들이 메인 스레드가 아닌 워커쓰레드에 작업이 위임되며, 넘겨주는 클로저를 통해 작업 완료 후에 콜백을 실행하는 형태가 되기 때문에 모든 작업들이 병렬적으로 처리가 될 수 있다.<br><img src="https://i.imgur.com/Lc0ezXG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그렇게 된다면 비동기는 동기 방식에 비해 성능이 훨씬 좋아질 수 있는 것이다.<br><img src="https://i.imgur.com/w4ENrs9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">블로킹과 논블로킹은 자바스크립트를 기준으로 할 때, 자바스크립트가 node.js를 통해서 IO를 수행하는 과정에서 커널의 도움을 받는다. 블로킹의 경우는 다른 요청의 작업을 처리하기 위해 현재 작업을 block, 즉 차단하는 것이다.
얼핏 보면 동기와 차이가 뭐가 있냐고 생각할 수 있는데, 동기의 경우는 작업의 흐름을 순차적으로 진행되도록 하는 것이라면, 블로킹의 경우는 작업의 흐름 자체를 막는 것이다. 이를 OS의 커널에서 사용하는 제어권이라는 개념으로 구별할 수 있는데, 블로킹의 경우 제어권을 호출된 함수가 호출한 함수에게 제어권을 넘기기 때문에 호출한 함수의 완료까지 제어권이 없는 상태이기 때문에 작업의 흐름 자체가 막히게 되는 것이다.공통적인 요소들에 대해서 똑같은 html 구조를 가진 부분들을 재사용성을 높여 다른 곳에서도 유용하게 사용할 뿐만 아니라 개별적인 서버의 templating 작업에서도 유용하게 쓰일 수 있는 방식을 사용하게 되면 전체적인 코드의 길이를 줄일 수 있을 뿐만 아니라 다른 페이지에서도 사용할 수 있어 활용도가 높다.pug 템플릿 엔진의 경우, 이를 mixin 기능을 통해 구현할 수 있었는데, 이 mixin은 argument를 받고 이에 해당하는 html 요소들을 동적으로 생성할 수 있다는 점에서 우리가 알던 리액트와 같은 컴포넌트의 구조와 비슷하여 알아보거나 처리하기 쉽다는 장점을 가졌다.mixin card(title,detail,author,date,id) style | @import url('/shared/card/css/card.css') include /shared/deleteConfirm/component/deleteConfirm.pug div.cardContainer(id=`${id}` draggable="true" data-date=`${date}`) form(action="post").editform(hidden) .form__div--cardForm input.form__input--title(type="text" placeholder="제목을 입력하세요" value=`${title}`) textarea.form__textarea--cardDetail(type="text" placeholder="내용을 입력하세요" rows=1 maxlength=500)#cardDetail #{detail} .form__div--buttonWrapper input.form__input__cancel-button(type="button", value="취소") input.form__input__submit-button(type="button", value="등록") li.generalCard(data-drag=id) .articleWrapper article p.title #{title} p.detail #{detail} p.author author by #{author} aside img.deleteTodo(src="../asset/close.svg", alt="delete", data-close=id) img.activeEditmode(src="../asset/pen.svg", alt="edit", data-edit=id) +deleteConfirm("todo")
해당하는 컴포넌트는 각각의 todolist 안의 카드들이며, 이를 +card(title,detail,author,date,id)를 통해 계속해서 재사용할 수 있는 형태로 바꿔주었다.하지만 개별 카드에 해당하는 이벤트를 등록하기 위해 해당 컴포넌트 안에서 스크립트를 제작하고 붙여주었는데, 문제는 해당하는 이벤트가 3번이 실행되었다.문제를 파악해보니 section이 3개로 나뉘어져 이 또한 컴포넌트로 구현했었는데, 재사용하는 컴포넌트의 문제점은 id가 모두 같아 이를 판별하기 어렵다는 점이다. 모든 컴포넌트들에서 등록했던 이벤트가 각각 실행되어 3번이 실행되는 문제가 생긴 것이다.기존의 문제를 해결하기 위해서는 상위 컴포넌트에서 각 컴포넌트에 해당하는 이벤트를 개별적으로 등록해주는 방법이 있었는데,
querySelectorAll를 통해 모든 컴포넌트들을 가져와 forEach문을 통해 각각의 요소에 이벤트 등록
상위 컴포넌트에서 이벤트를 위임하여 처리
가 있었다. 하지만 1번의 경우 개별적인 컴포넌트들이 많아지게 되면 각각에 대해서도 모든 이벤트 핸들러를 등록해줘야 하기 때문에 성능상에 이슈가 생길 수 있다. 따라서 상위에서 모두 공통적으로 작용할 수 있는 이벤트를 하나 등록하고, 위임하여 해당하는 컴포넌트를 구분 한 후에 처리할 수 있도록 하는 이벤트위임을 선택하였다.
document.getElementById("sections").addEventListener("click", (event) =&gt; { // 각 섹션별 이벤트들 let addTodo = event.target.dataset.addform; if (addTodo) { // 각 폼에 이벤트 위임 let form = document.getElementById(addTodo); // 보이게 하는 속성 form.hidden = false; // 할일 추가 폼 입력란 크기 조절 let detailInput = form.getElementsByClassName( "form__textarea--cardDetail" )[0]; detailInput.addEventListener("input", adjustTextInput); // 창 닫기 폼 let cancelButton = form.getElementsByClassName( "form__input__cancel-button" )[0]; cancelButton.addEventListener("click", () =&gt; closeForm(form)); let submitButton = form.getElementsByClassName( "form__input__submit-button" )[0]; submitButton.addEventListener("click", () =&gt; { console.log("submit event"); }); } // 각 카드 관련 이벤트들 // 카드 파트(편집 모드 열기) let editId = event.target.dataset.edit; if (editId) { const editComponent = document.getElementById(editId); // Edit mode 활성화 editComponent.getElementsByClassName("editform")[0].hidden = false; // 할일 추가 폼 입력란 크기 조절 let detailInput = editComponent.getElementsByClassName( "form__textarea--cardDetail" )[0]; detailInput.addEventListener("input", adjustTextInput); // 카드 수정 -&gt; 취소 눌렀을 때 let cancelButton = editComponent.getElementsByClassName( "form__input__cancel-button" )[0]; cancelButton.addEventListener("click", () =&gt; closeEditForm(editComponent)); // 일반 카드 숨기기 const generalCard = editComponent.getElementsByClassName("generalCard")[0]; if (generalCard) { generalCard.style.display = "none"; } } // 카드 삭제하기 let closeId = event.target.dataset.close; if (closeId) { const closeComponent = document.getElementById(closeId); closeComponent.getElementsByClassName("modalBackground")[0].style.display = "flex"; closeComponent .getElementsByClassName("cancelButton")[0] .addEventListener("click", () =&gt; { closeComponent.getElementsByClassName( "modalBackground" )[0].style.display = "none"; }); closeComponent .getElementsByClassName("conFirmButton")[0] .addEventListener("click", () =&gt; { closeComponent.getElementsByClassName( "modalBackground" )[0].style.display = "none"; closeComponent.remove(); }); }
});
Feature-sliced Design은 모듈 간의 느슨한 결합과 높은 응집력을 제공할 수 있으며, 쉽게 확장할 수 있는 아키텍처이다.<br>
<img src="https://i.imgur.com/tO9yswk.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이러한 패턴은 세 가지 구분 개념이 있다.<br>
<img src="https://i.imgur.com/iJJFpxc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
app 애플리케이션 로직이 초기화되는 곳
프로바이더, 라우터, 전역 스타일, 전역 타입 선언 등
애플리케이션의 진입점 역할 processes(depricated) 이 레이어는 여러 단계로 이루어진 등록과 같이 여러 페이지에 걸쳐 있는 프로세스를 처리
이 레이어는 더 이상 사용되지 않는 것으로 간주되지만 여전히 가끔씩 마주할 수 있습니다. 선택적 레이어입니다. pages 이 레이어에는 애플리케이션의 페이지가 포함됩니다. widgets 페이지에 사용되는 독립적인 UI 컴포넌트 features 이 레이어는 비즈니스 가치를 전달하는 사용자 시나리오와 기능
좋아요, 리뷰 작성, 제품 평가 등이 있습니다. 선택적 레이어 entities 비즈니스 엔티티
사용자, 리뷰, 댓글 등이 포함될 수 있습니다. 선택적 레이어 shared 이 레이어에는 특정 비즈니스 로직에 종속되지 않은 재사용 가능한 컴포넌트와 유틸리티
여기에는 UI 키트, axios 설정, 애플리케이션 설정, 비즈니스 로직에 묶이지 않은 헬퍼 등 슬라이스는 특정 엔티티에 대해서 코드를 그룹화 한다.<br>
<img src="https://i.imgur.com/yVam9En.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이와 같이 필요한 값에 대해서 독립적으로 다룰 수 있는 디렉토리를 생성한다.각 슬라이스는 세그먼트로 구성되며 목적에 따라 슬라이스 내의 코드를 나누는데 도움이 될 수 있다.
api - 필요한 서버 요청.
UI - 슬라이스의 UI 컴포넌트.
model - 비즈니스 로직, 즉 상태와의 상호 작용. actions 및 selectors가 이에 해당
lib - 슬라이스 내에서 사용되는 보조 기능.
config - 슬라이스에 필요한 구성값이지만 구성 세그먼트는 거의 필요하지 않음.
consants - 필요한 상수.
나는 이러한 FSD를 일부 참고하여 나만의 디렉토리 구조를 만드는데 활용하였다.
하지만 중요한 점인 슬라이스와 세그먼트의 본질에 어긋나지 않도록 조율하였다.<br><img src="https://i.imgur.com/BZgt0IG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/7jaWaf4.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">DOM API를 통해 이벤트를 등록하고 이를 실행할 때면, 내가 원하는 예상대로 동작하지 않는 경우가 꽤 많다. 이는 이벤트 전파에 의한 예외 상황을 고려하지 않았을 때 주로 발생하며, 이에 이벤트 전파와 위임에 대해 자세히 알아볼 필요가 있다.DOM 트리 상에 존재하는 DOM 요소의 노드에서 이벤트가 발생하면, 이벤트 객체는 DOM 트리를 통해 다른 DOM 요소 노드로 전파된다. 이를 이벤트 전파라고 한다.쉽게 말해보자면, 트리 구조로 이루어진 DOM이니만큼, 계층적인 구조를 가지고 있어 이벤트가 일어날 경우 해당 태그에서만 하나의 이벤트를 등록하고 싶어도, 부모 요소에도 이벤트가 달려 있다면 부모 요소의 이벤트도 연쇄적으로 일어난다는 것이다.이러한 이벤트의 전파는 전파 방향에 따라 버블링과 캡처링으로 나눌 수 있다.
버블링(Bubbling): 자식 요소 -&gt; 바깥 부모 요소로 전파
캡처링(Capturing): 부모 요소 -&gt; 자식 요소 순서대로 계속해서 이벤트 전파
<br><img src="https://i.imgur.com/i1TIkvz.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">표준 DOM 이벤트에서는 이벤트 흐름을 3단계로 정의한다.
캡처링 단계 -&gt; 이벤트가 하위 요소로 전파
타깃 단계 -&gt; 이벤트가 실제 타깃 요소에 전달
버블링 단계 -&gt; 이벤트가 상위 요소로 전파
위의 그림처럼 td를 클릭하면 맨 처음 캡처링 단계를 통해 이벤트가 전파되고, 이벤트가 타깃 요소에 도착하면 해당하는 이벤트가 실행되며, 다시 위로 올라가며 버블링 단계를 거치면서 요소들에 할당된 이벤트 핸들러들이 실행된다&lt;!doctype html&gt;
&lt;body&gt;
&lt;style&gt; body * { margin: 10px; border: 1px solid blue; }
&lt;/style&gt; &lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;
&lt;/form&gt; &lt;script&gt; for(let elem of document.querySelectorAll('*')) { elem.addEventListener("click", e =&gt; alert(`캡쳐링: ${elem.tagName}`), true); elem.addEventListener("click", e =&gt; alert(`버블링: ${elem.tagName}`)); }
&lt;/script&gt;
&lt;/body&gt;
이런 식으로 모든 요소에 이벤트를 달아주게 되면, 타깃을 눌렀을 때, 처음 해당 요소로 들어가기까지 캡처링을 통해 모든 이벤트들이 부모요소의 수만큼 실행되게 되고, 타깃에 다다른 후 다시 돌아올 때는 다시 노드를 올라가면서 버블링을 거치기 때문에 다시 부모요소의 수만큼 이벤트 핸들러가 실행된다.이를 단계별로 정리하면
HTML&nbsp;→&nbsp;BODY&nbsp;→&nbsp;FORM&nbsp;→&nbsp;DIV&nbsp;(캡처링)
P&nbsp;(타깃 단계로 캡쳐링과 버블링 둘 다 리스너를 설정해서 두 번 호출됨)
DIV&nbsp;→&nbsp;FORM&nbsp;→&nbsp;BODY&nbsp;→&nbsp;HTML&nbsp;(버블링)
으로 총 10번의 이벤트가 발생하게 되는 것이다.
사실 부모요소와 자식 요소 둘 다 이벤트가 등록되어 있을 경우, 자식요소의 이벤트만 실행시키려고 할 때, click을 예시로 들어보자면 사실상 자식요소만을 누른다고 해도 결국은 부모 요소의 자식이기 때문에 부모 요소의 이벤트 또한 작동할 수밖에 없다. 계층적인 구조에서는 당연한 일이라고 생각한다. 어찌보면 자식 요소를 클릭한 것이 부모 요소를 클릭한 것과 같은 셈이니까.상황에 따라서는 유용하게 사용할 수도 있지만, 캡처링의 경우는 부모 요소의 이벤트들을 따로 실행시키지 않고 내가 이벤트를 등록한 타겟요소의 이벤트핸들러만 실행시키고 싶은 때가 있을 수도 있다.그럴 때 필요한게 이벤트의 stopPropagation 메소드이다.
이 메소드는 버블링 또는 캡처링 설정에 따라 상위, 하위로 가는 이벤트 전파를 차단함으로써 내가 원하는 타겟 요소의 이벤트핸들러만 실행시킬 수 있는 환경을 제공할 수 있다.&lt;html&gt; &lt;script&gt; const ancestor = document.querySelector("#ancestor") const parent = document.querySelector("#parent") const child = document.querySelector("#child") let count = 1; ancestor.addEventListener("click", (e) =&gt; { e.stopPropagation() print('ancestor') }) parent.addEventListener("click", (e) =&gt; { e.stopPropagation() print('parent') }) child.addEventListener("click", (e) =&gt; { e.stopPropagation() print('child') }) function print(name) { document.querySelector("section") .insertAdjacentHTML("beforeend",`&lt;p&gt;${count++}. ${name} clicked&lt;/p&gt;`); } document.body.addEventListener("click", (e) =&gt; { [...document.querySelector("section").children].forEach(e =&gt; { e.remove(); }) count = 1; }, true) &lt;/script&gt; &lt;body&gt; &lt;div id="ancestor"&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;section&gt;&lt;/section&gt; &lt;/body&gt;
&lt;/html&gt;
이렇게 한다면 각 요소에 있는 이벤트를 버블링 및 캡처링 하는 과정에서 불필요한 이벤트 핸들러의 실행을 차단시킬 수 있다.
이를 통해 각 요소의 이벤트 리스너만 동작시킬 수 있는 것이다.이러한 부모-자식 요소의 html element 뿐만 아니라, 형제 요소들의 이벤트의 실행 또한 제어할 수 있는데, 이는 stopImmediatePropagation() 메소드를 통해 여러 개의 이벤트를 실행시키지 않고 하나의 이벤트만 실행시킬 수 있다.child.addEventListener("click", (e) =&gt; { if(조건) e.stopImmediatePropagation() print('child')
}) child.addEventListener("click", (e) =&gt; { print('child 2')
})
기존의 이벤트에 대해서 메소드들을 통해서 캡처링, 버블링을 중간에 차단시키는 방법도 있지만, target element에 dataset attribute를 이용해서 조작하는 방법도 있다.html의 dataset 속성은 커스텀 사용자 속성을 DOM 요소에 직접적으로 저장할 수 있는데, 이렇게 저장한 요소의 경우 html 내에서 동작하는 자바스크립트 변수와 같은 느낌이 있어 문자열 데이터를 넣어놓고 상태를 조작하거나 특정 target의 id 등을 저장해놓는 방식에도 잘 활용된다.&lt;input type="text" data-country="Norway" data-code="c03" name="Country"&gt;
이런 식으로 앞에 data- prefix를 붙이고 내가 쓰고 싶은 데이터의 속성명을 기재해주고, 이를 자바스크립트의 이벤트 핸들러안에서 찾아서 특정 요소만 검색하는 방식으로도 가능하다const $div = document.getElementById('post'); // 일반적인 객체 속성 접근
$div.dataset.code // "c03" // 배열 인덱스로 접근
$div.dataset['name'] // "Country" // data-country에서 dataset.country로 변환됨
$div.dataset.country // "Norway"
이러한 방식은 조금 더 각각의 요소에 유니크한 값을 넣어놓고 정밀하게 조정할 때 유용한데, 이 부분은 이벤트 위임에서 계속 쓸 예정이다.이처럼 브라우저는 3단계의 과정을 거치기 때문에, 버블링과 캡처링이 내가 예상한 동작 외의 이벤트들 또한 실행될 수 있다는 단점이 있지만, 이를 활용하여 유용하게 사용할 수도 있다.어차피 부모 요소의 이벤트 또한 자식 요소에도 영향을 끼치는데, 그렇게 한다면 여러 개의 컴포넌트가 있었을 때, 가장 상위에서 이벤트를 등록해놓는다면, 이를 통해서 여러 개가 있는 자식 요소들을 모두 하나의 이벤트 등록으로도 관리할 수 있다는 발상이 가능해진다. 이러한 방식을 이벤트 위임이라고 한다.&lt;table&gt; &lt;tr&gt; &lt;th colspan="3"&gt;&lt;em&gt;Bagua&lt;/em&gt; Chart: Direction, Element, Color, Meaning&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="nw"&gt;&lt;strong&gt;Northwest&lt;/strong&gt;&lt;br&gt;Metal&lt;br&gt;Silver&lt;br&gt;Elders&lt;/td&gt; &lt;td class="n"&gt;...&lt;/td&gt; &lt;td class="ne"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt;
&lt;/table&gt;
위와 같은 예시를 javascript.info 에서 가져왔다.
해당 테이블에 있는 각각의 td 요소들을 누르면 누른 td 요소가 highlight되는 효과를 부여하려 한다.이를 위해서는 크게 두 가지 방법이 있다.
해당하는 모든 td 요소를 querySelectorAll로 검색한 뒤 forEach를 통해 캡처링 &amp; 버블링 이벤트 제어 하는 이벤트를 등록한다.
부모요소에서 이벤트를 등록하면서 캡처링 방식으로 넘겨주되, 특정한 data attribute를 통해 각각의 요소를 구분하고, 뽑아낸 특정 요소에 대한 이벤트 핸들링
하지만 1번의 경우 모든 요소에 대해 이벤트를 일일이 등록해주는 행위 자체는 성능성의 이슈가 있기도 하고, 새로운 요소가 추가되었을 경우에도 계속해서 이벤트를 직접 추가해줘야 하므로 상당히 비효율적이라고 생각한다.따라서 2번의 방식을 생각하게 되는데, 이 부분의 경우 세심하게 고려할 부분이 있다.이벤트 핸들러에 parameter로 오는 event 객체에는 target이라는 속성이 있다. 해당 target 속성은 이 이벤트가 이루어진 요소가 어떤 html 요소인지를 보여준다.let selectedTd; table.onclick = function(event) { let target = event.target; // 클릭이 어디서 발생했을까요? if (target.tagName != 'TD') return; // TD에서 발생한 게 아니라면 아무 작업도 하지 않습니다, highlight(target); // 강조 함
}; function highlight(td) { if (selectedTd) { // 이미 강조되어있는 칸이 있다면 원상태로 바꿔줌 selectedTd.classList.remove('highlight'); } selectedTd = td; selectedTd.classList.add('highlight'); // 새로운 td를 강조 함
}
그래서 해당 타겟의 html element를 보고 해당 element에 효과를 넣어주는 방식으로 이벤트 위임을 할 수 있다.하지만 event.target의 중요한 점은 클릭이 이루어진 해당 '요소' 를 정확히 찾아내 리턴한다는 점이다.
따라서 td를 포함하는 td안의 들어있는 모든 요소 대해서 이벤트가 실행되도록 하고 싶은데, 만약에 td 요소 안의 strong 태그 안에 있는 텍스트를 누르게 되면 event.target 으로 받은 html element가 td 안에 들어있는 strong element만을 리턴한다.따라서 내가 이벤트를 등록하려는 Html element의 범위에 대해서 생각하고, 등록하려는 html element 안의 요소를 클릭했을 때, 어떤 방식으로 해당 부모 요소까지 조작할 지에 대해 고려해야 할 필요성이 있다.이를 쉽게 할 수 있는 방법 중 하나는 html element의 closest 메소드를 활용하는 것이다.closest메소드를 활용하여 내가 누른 요소와 가장 가까이에 있는 타켓 요소를 선택할 수 있도록 할 수 있다.table.onclick = function(event) { let td = event.target.closest('td'); // (1) if (!td) return; // (2) if (!table.contains(td)) return; // (3) highlight(td); // (4)
};
이를 통해 누른 요소의 가장 가까운 td 요소를 가져와 해당 요소에 대해서 조작을 해줌으로써 세심하게 이벤트를 제어할 수 있다. html 요소의 attribute에 데이터를 넣어 사용하는 dataset을 활용하는 방식은 closest만큼, 혹은 그보다 더 세심하게 자식 요소의 기능을 관리할 수 있는 방식이다.&lt;table&gt; &lt;tr&gt; &lt;th colspan="3"&gt;&lt;em&gt;Bagua&lt;/em&gt; Chart: Direction, Element, Color, Meaning&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="td0"&gt;&lt;strong&gt;Northwest&lt;/strong&gt;&lt;br&gt;Metal&lt;br data-action="silver" data-target="td0"&gt;Silver&lt;br&gt;Elders&lt;/td&gt; &lt;td class="td1"&gt;...&lt;/td&gt; &lt;td class="td2"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt;
&lt;/table&gt;
해당 코드에서는 dataset의 action이라는 데이터에 부모 요소의 안쪽 요소들의 세부적인 기능을 제어하기 위한 기능적인 명시를 해두었다.
이러한 div 태그에는 각각 유니크한 id가 붙어있고, 가장 상위에 있는 table이나 html의 body 자체에 이벤트를 등록해두는 것이다.let selectedTd; table.onclick = function(event) { if(event.target.dataset.action === "silver"){ let target = event.target.dataset.target; target = document.getElementByID(target) highlight(target); // 강조 함 }
}; function highlight(td) { if (selectedTd) { // 이미 강조되어있는 칸이 있다면 원상태로 바꿔줌 selectedTd.classList.remove('highlight'); } selectedTd = td; selectedTd.classList.add('highlight'); // 새로운 td를 강조 함
}
이벤트에 대한 세부 기능을 data-action attribute로 넣어놓고 이를 포함하는 부모 요소의 unique한 id를 data-target attribute로 부여해주었다. 이렇게 되었을 경우 보다 부모 요소에서 세부적인 기능을 발견했을 경우 해당 이벤트와 그 기능에 대해서만 처리할 수 있도록 핸들링 할 수 있는 것이 유용하다.&lt;div id="menu"&gt; &lt;button data-action="save"&gt;저장하기&lt;/button&gt; &lt;button data-action="load"&gt;불러오기&lt;/button&gt; &lt;button data-action="search"&gt;검색하기&lt;/button&gt;
&lt;/div&gt; &lt;script&gt; class Menu { constructor(elem) { this._elem = elem; elem.onclick = this.onClick.bind(this); // (*) } save() { alert('저장하기'); } load() { alert('불러오기'); } search() { alert('검색하기'); } onClick(event) { let action = event.target.dataset.action; if (action) { this[action](); } }; } new Menu(menu);
&lt;/script&gt;
class 컴포넌트를 이용해서 관리하는 방식은 보다 가독성이 뛰어나다고 생각한다. 클래스의 메소드를 활용하여 버튼마다 핸들러를 할당해주는 코드를 따로 작성할 필요가 없고, 다른 이벤트 핸들러의 수정 또한 메소드만 관리해주면 되기 때문에 각 기능들에 대해서도 관리하는 방식은 확실히 스마트하다.constructor에서 onclick 이벤트에는 this를 바인딩하게 되는데, 바인딩된 요소는 해당 Menu 객체의 요소를 가리킨다.
바인딩된 onClick 이벤트는 캡처링을 통해 자식의 요소들의 onclick 이벤트 또한 감지하고, 이를 action으로 나누어 세부적인 기능들을 메소드로 구분할 수 있기 때문에 활용성을 보다 높였다고 생각한다.이러한 이벤트위임의 장점은 앞에서도 이야기를 많이 했지만,
핸들러를 일일이 할당하지 않아 초기화가 단순해지고 메모리 절약
요소를 추가, 제거,수정 등에 대해서 할당된 핸들러를 따로 건들 필요가 없음
innerHTML이나 유사한 기능을 하는 스크립트로 요소 덩어리를 더하거나 뺄 수 있기 때문에 컴포넌트 기반 개발이 편리함
등이 있다.
하지만 그럼에도 불구하고, 이벤트 위임에도 단점은 있다.
이벤트 위임을 사용하기 위해서는 이벤트의 버블링이 필수인데, 몇몇 이벤트는 버블링이 불가능한 이벤트도 있음 + 낮은 레벨에 할당한 핸들러에 stopPropagation 사용 불가
부모 요소에서 핸들러를 관리하기 때문에 그 안쪽의 모든 요소에 대해서 등록된 이벤트가 실행되기 때문에 CPU 작업부하 무시할만한 수준이라고는 한다. 이벤트 전파와 위임에 대해 제대로 이해하는 것은 이번이 아마 처음이었던 것 같다. vanilla js를 거의 쓰지 않고 리액트만 주로 썼던 나에게는 어떠한 이벤트가 '전파'된다는 사실 자체가 생소하게 들렸다. 리액트는 주로 이벤트를 따로 등록할 때에는 attribute의 onClick 속성에 이벤트 핸들러 함수를 넣어주었고, 이러한 이벤트들은 각각의 이벤트 핸들러를 모두 가지고 있기 때문에 이벤트 위임 또한 생소하게 느껴졌다고 생각한다.
기본기가 탄탄해야 하나의 프레임워크에 의존되지 않고 여러 프레임워크를 빠르게 적응하고 사용할 수 있는 숙련도가 쌓이는 것 같다.
아무튼 이렇게 기존의 이벤트 핸들러를 보다 효율적이고 스마트하게 사용하는 법을 통해 다양하게 시도해보는 습관을 계속 쌓아나가는 것이 좋은 방식이라고 생각한다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%BA%A1%EC%B3%90%EB%A7%81" target="_self">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%BA%A1%EC%B3%90%EB%A7%81</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-HTML-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%85%8Bdata-%EC%86%8D%EC%84%B1" target="_self">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-HTML-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%85%8Bdata-%EC%86%8D%EC%84%B1</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.javascript.info/bubbling-and-capturing" target="_self">https://ko.javascript.info/bubbling-and-capturing</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.javascript.info/event-delegation" target="_self">https://ko.javascript.info/event-delegation</a>express로 처음 서버를 구동해보면서 이를 html+css+js와 섞는다면 SSR 뿐만 아니라 CSR 또한 내 마음대로 입맛따라 고를 수 있을 것 같았다. 그렇게 된다면 next.js와 비슷한 느낌이지 않을까도 싶다.아무튼 맨 처음에 express를 시작했을 때는 전체적인 html 템플릿을 그대로 출력시켜 열었던 로컬호스트 주소로 접속하면 통채로 웹사이트를 렌더링하여 보내주는 SSR 방식으로 시작했지만, pug라는 템플릿 엔진이 생각보다 여러가지 쓸만한 구석이 많아 이를 좀 더 활용해서 CSR을 만들기 보다 쉽지 않을까 생각해서 시도해보았다.pug를 처음 맛보기로 써봤는데, 생각보다 장점이 많았다.
그 중에서도 이번 templating에 사용하려는 pug의 api는 클라이언트 사이드 렌더링을 하기에 최적화된 api라고 생각했다.const pug = require('pug'); // Compile the source code
const compiledFunction = pug.compileFile('template.pug'); // Render a set of data
console.log(compiledFunction({ name: 'Timothy'
}));
// "&lt;p&gt;Timothy's Pug source code!&lt;/p&gt;" // Render another set of data
console.log(compiledFunction({ name: 'Forbes'
}));
// "&lt;p&gt;Forbes's Pug source code!&lt;/p&gt;"
compileFile은 파일을 읽어들여 해당 템플릿을 통해 templating을 하는 함수를 반환한다.
이 외에도 각종 메서드들은 컴파일에 필요한 여러가지 상황을 상정하여 다양한 방식으로 컴파일한 후 렌더링 할 수 있는 방법을 제시한다.
compile(source : string,?options : ?options) : function() 함수를 반환하고, 반환한 함수를 실행시키면 렌더링 시킬 수 있다 compileFile(source : string,?options : ?options) : function() pug 파일을 읽어들여, templating 하는 함수를 반환 compileClient(source : string,?options : ?options) : function() 문자열을 넣고 클라이언트 사이드에서 렌더링 compileClientWithDependenciesTracked(source, ?options): function() 의존성을 가진 template 클라이언트 사이드에서 렌더링 compileFileClient(path:string, ?options: ?options): function()
- 클라이언트 사이드에서 쓰일 수 있는 문자열로 templating
렌더링 관련 메서드
render(source: string, ?options: ?options): string 문자열을 넣고 html 문자열로 리턴 renderFile(source: string, ?options: ?options, ?callback: ?callback) : string html 문자열로 리턴 해당 경우는 어떠한 요소를 추가했을 때 가져오는 기능이라고 생각해보자app.post("/api", (req, res) =&gt; { const { title, detail, section } = req.body; const data = JSON.parse(readFileSync(`${DATAPATH}`, "utf-8")); const data2 = JSON.parse( readFileSync(`${DATAPATH}`, "utf-8") ); // 서버 데이터에 추가하는 코드 //JSON으로 컴파일한 html 문자열 stringify const template = JSON.stringify({ data: pug.compileFile( path.join( __dirname, 내 경로들 ), { basedir: path.join(__dirname, "views"), } )({argument : value}), }); res.type("Content-Type", "application/json"); res.json(template);
});
서버에서는
데이터를 갱신
갱신한 데이터를 다시 가져오거나 받은 데이터에서 직접적으로 추가(이건 보내는 용도로)
templating할 pug 파일을 pug의 compileFile을 통해 함수를 받기
갱신한 데이터를 compileFile의 리턴값으로 온 함수에 넣기
리턴값으로 온 string을 json 형식으로 만들어 클라이언트의 응답 body에 넣어 보내기
의 과정을 거쳐 새롭게 갱신된 데이터의 컴포넌트 html을 다시금 클라이언트로 보낼 수 있다.
function handler(sectionId) {
... submitButton.addEventListener("click", async () =&gt; { const title = targetSection.getElementsByClassName("form__input--title")[0].value; const detail = targetSection.getElementsByClassName( "form__textarea--cardDetail" )[0].value; const section = targetSection.id; const response = await fetch("/api/todo/new", { method: "POST", headers: { "Content-Type": "application/json", }, body: JSON.stringify({ title: title, detail: detail, section: section, }), }); let data = await response.json(); data = JSON.parse(data); document.getElementById("sections").innerHTML = data.data; });
}
사실상 서버에서 html 파일을 통채로 보내서 렌더링 시키는 서버 사이드 렌더링 방식인 만큼 클라이언트라고 불리는게 맞을까 싶다. 그냥 view라고 볼 수 있지만 편의를 위해 클라이언트라고 칭하겠다.클라이언트에서는 이벤트 위임 방식을 통해 이벤트들을 등록하기 때문에 기존의 html을 제외한 정적 파일들은 모두 남아있는 것들을 활용할 수 있다고 생각했다.<br>
<img src="https://i.imgur.com/AlMIpF9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
innerHTML을 통해서 html을 교체하기 전에 기존의 js script로 들어간 js 파일을 개발자도구로 열어 script에 console.log하는 코드를 실행했는데 새롭게 렌더링이 이루어졌음에도 불구하고 스크립트 파일은 여전히 기존 파일을 유지하는 것을 볼 수 있다. 이러한 점은 새롭게 렌더링하는 과정에서 불필요한 정적 파일들을 불러오지 않는다는 이점을 가진다고 생각했다.여러 컴포넌트로 복사된 html들에 이벤트 등록을 하는 방법은 이벤트 위임 뿐만이 아닌, querySelectorAll을 통해 해당하는 각각의 컴포넌트에 forEach를 돌면서 하나하나 이벤트 등록을 해줘야 하는 방식도 존재하지만 이러한 방식은 성능 상에 이슈가 있을 뿐만 아니라 새롭게 렌더링된 Html에는 이벤트 등록을 해주지 않은 상태에서 스크립트는 변하지 않았기 때문에 이벤트가 제대로 등록되지 않아 동작하지 않을 가능성이 있다. You should not have pug tags with multiple attributes.
사실 이건 해당 templating의 문제가 아닌 내 코드 문제였다<br>
<img src="https://i.imgur.com/b7reY7N.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">form(action="post").editform(hidden)
나도 모르게 그냥 여러 개의 attribute를 콤마로 구분하지 않고 써놔서 warning이 떴다. 정상적으로 인식은 되지만 주의하자이 문제에 대해서는 stackoverflow를 뒤져보고 했는데 결국 제대로 된 느낌의 답변을 찾지 못했다.<br>
<img src="https://i.imgur.com/hWYkzlh.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내 나름대로 생각한 점으로는 내가 이제까지 pug 파일을 컴파일 했던 때 사용했던 파일이 mixin형태로 arguments들을 받는 방식으로 될까 싶어서 했던건데, 다른 사용 예시들을 보니 mixin을 활용한 예시가 없었다.
아마도 html 컴파일 과정에서 mixin을 지원하지 않는건가 싶어서 일반 html으로 바로 컴파일이 가능한 pug 코드를 쓰니 정상작동되었다.
아무래도 mixin은 해당 템플릿 엔진에서 자체적으로 컴포넌트를 만드는 방식이나보니 compileFile에서는 아직 지원하지 않는 것이라 생각했다.기존에 있는 정적 파일들을 그대로 활용하면서 Html 파일만 교체했음에도 정상적으로 모두 작동한다는 점은 큰 이점을 가진다고 생각한다. ssr과 pug를 공부하면서, 'pug를 통해서 보다 컴포넌트 단위로 나누는 것이 쉬워졌는데, 이러한 방식으로 페이지 전체를 새로고침하지 않아도 문제없을 정도로 계속 사용 가능한 html만 바꿀 수 있지 않을까?'라는 생각에서부터 시작한 실험이었는데 생각보다 이벤트 위임 방식과 시너지를 잘 이루어 나름 야매(?) 클라이언트 사이드 렌더링 방식을 구현했다는 점이 의의가 있는 것 같다. 이번 시도를 통해 CSR과 SSR의 차이도 공부하고, 조금 더 잘 파악할 수 있는 기회가 되었다고 생각한다.하지만 CSR임에도 불구하고 문제가 남아있었으니,,
기존의 placeholder 안에서 모든 html을 통채로 갈아치우다 보니 SSR처럼 모든 화면이 깜빡이지는 않더라도, 컴포넌트의 placeHolder의 일부분이 깜빡이는 부분은 조금 킹받는 부분이 있다.
이를 위해서라면, 컴포넌트에 있는 DOM 노드들을 검사해서 변동사항이 있는 부분만 갱신하는 식으로 해도 될 것 같은데, 이거는 조금 더 깊게 파고 들어가야하기 때문에 조금 더 설계해보려고 한다.]]></description><link>부스트캠프/멤버십/1주차/멤버십_학습정리_1주차.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/멤버십_학습정리_1주차.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/hltyRUv.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/hltyRUv.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[베이직]]></title><description><![CDATA[<a data-href="Day 1" href="부스트캠프/베이직/day-1.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day 1</a><br>
<a data-href="Day 2" href="부스트캠프/베이직/day-2.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day 2</a><br>
<a data-href="Day_3" href="부스트캠프/베이직/day_3.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_3</a><br>
<a data-href="Day_4" href="부스트캠프/베이직/day_4.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_4</a><br>
<a data-href="Day_5" href="부스트캠프/베이직/day_5.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_5</a><br>
<a data-href="Day_6" href="부스트캠프/베이직/day_6.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_6</a><br>
<a data-href="Day_7" href="부스트캠프/베이직/day_7.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_7</a><br>
<a data-href="Day_8" href="부스트캠프/베이직/day_8.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_8</a><br>
<a data-href="Day_9" href="부스트캠프/베이직/day_9.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_9</a><br>
<a data-href="Day_10" href="부스트캠프/베이직/day_10.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Day_10</a>]]></description><link>부스트캠프/멤버십/1주차/베이직.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/베이직.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[이벤트 전파와 위임에 대한 고찰]]></title><description><![CDATA[DOM API를 통해 이벤트를 등록하고 이를 실행할 때면, 내가 원하는 예상대로 동작하지 않는 경우가 꽤 많다. 이는 이벤트 전파에 의한 예외 상황을 고려하지 않았을 때 주로 발생하며, 이에 이벤트 전파와 위임에 대해 자세히 알아볼 필요가 있다.DOM 트리 상에 존재하는 DOM 요소의 노드에서 이벤트가 발생하면, 이벤트 객체는 DOM 트리를 통해 다른 DOM 요소 노드로 전파된다. 이를 이벤트 전파라고 한다.쉽게 말해보자면, 트리 구조로 이루어진 DOM이니만큼, 계층적인 구조를 가지고 있어 이벤트가 일어날 경우 해당 태그에서만 하나의 이벤트를 등록하고 싶어도, 부모 요소에도 이벤트가 달려 있다면 부모 요소의 이벤트도 연쇄적으로 일어난다는 것이다.이러한 이벤트의 전파는 전파 방향에 따라 버블링과 캡처링으로 나눌 수 있다.
버블링(Bubbling): 자식 요소 -&gt; 바깥 부모 요소로 전파
캡처링(Capturing): 부모 요소 -&gt; 자식 요소 순서대로 계속해서 이벤트 전파
<img src="https://i.imgur.com/i1TIkvz.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">표준 DOM 이벤트에서는 이벤트 흐름을 3단계로 정의한다.
캡처링 단계 -&gt; 이벤트가 하위 요소로 전파
타깃 단계 -&gt; 이벤트가 실제 타깃 요소에 전달
버블링 단계 -&gt; 이벤트가 상위 요소로 전파
위의 그림처럼 td를 클릭하면 맨 처음 캡처링 단계를 통해 이벤트가 전파되고, 이벤트가 타깃 요소에 도착하면 해당하는 이벤트가 실행되며, 다시 위로 올라가며 버블링 단계를 거치면서 요소들에 할당된 이벤트 핸들러들이 실행된다&lt;!doctype html&gt;
&lt;body&gt;
&lt;style&gt; body * { margin: 10px; border: 1px solid blue; }
&lt;/style&gt; &lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;
&lt;/form&gt; &lt;script&gt; for(let elem of document.querySelectorAll('*')) { elem.addEventListener("click", e =&gt; alert(`캡쳐링: ${elem.tagName}`), true); elem.addEventListener("click", e =&gt; alert(`버블링: ${elem.tagName}`)); }
&lt;/script&gt;
&lt;/body&gt;
이런 식으로 모든 요소에 이벤트를 달아주게 되면, 타깃을 눌렀을 때, 처음 해당 요소로 들어가기까지 캡처링을 통해 모든 이벤트들이 부모요소의 수만큼 실행되게 되고, 타깃에 다다른 후 다시 돌아올 때는 다시 노드를 올라가면서 버블링을 거치기 때문에 다시 부모요소의 수만큼 이벤트 핸들러가 실행된다.이를 단계별로 정리하면
HTML&nbsp;→&nbsp;BODY&nbsp;→&nbsp;FORM&nbsp;→&nbsp;DIV&nbsp;(캡처링)
P&nbsp;(타깃 단계로 캡쳐링과 버블링 둘 다 리스너를 설정해서 두 번 호출됨)
DIV&nbsp;→&nbsp;FORM&nbsp;→&nbsp;BODY&nbsp;→&nbsp;HTML&nbsp;(버블링)
으로 총 10번의 이벤트가 발생하게 되는 것이다.
사실 부모요소와 자식 요소 둘 다 이벤트가 등록되어 있을 경우, 자식요소의 이벤트만 실행시키려고 할 때, click을 예시로 들어보자면 사실상 자식요소만을 누른다고 해도 결국은 부모 요소의 자식이기 때문에 부모 요소의 이벤트 또한 작동할 수밖에 없다. 계층적인 구조에서는 당연한 일이라고 생각한다. 어찌보면 자식 요소를 클릭한 것이 부모 요소를 클릭한 것과 같은 셈이니까.상황에 따라서는 유용하게 사용할 수도 있지만, 캡처링의 경우는 부모 요소의 이벤트들을 따로 실행시키지 않고 내가 이벤트를 등록한 타겟요소의 이벤트핸들러만 실행시키고 싶은 때가 있을 수도 있다.그럴 때 필요한게 이벤트의 stopPropagation 메소드이다.
이 메소드는 버블링 또는 캡처링 설정에 따라 상위, 하위로 가는 이벤트 전파를 차단함으로써 내가 원하는 타겟 요소의 이벤트핸들러만 실행시킬 수 있는 환경을 제공할 수 있다.&lt;html&gt; &lt;script&gt; const ancestor = document.querySelector("#ancestor") const parent = document.querySelector("#parent") const child = document.querySelector("#child") let count = 1; ancestor.addEventListener("click", (e) =&gt; { e.stopPropagation() print('ancestor') }) parent.addEventListener("click", (e) =&gt; { e.stopPropagation() print('parent') }) child.addEventListener("click", (e) =&gt; { e.stopPropagation() print('child') }) function print(name) { document.querySelector("section") .insertAdjacentHTML("beforeend",`&lt;p&gt;${count++}. ${name} clicked&lt;/p&gt;`); } document.body.addEventListener("click", (e) =&gt; { [...document.querySelector("section").children].forEach(e =&gt; { e.remove(); }) count = 1; }, true) &lt;/script&gt; &lt;body&gt; &lt;div id="ancestor"&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;section&gt;&lt;/section&gt; &lt;/body&gt;
&lt;/html&gt;
이렇게 한다면 각 요소에 있는 이벤트를 버블링 및 캡처링 하는 과정에서 불필요한 이벤트 핸들러의 실행을 차단시킬 수 있다.
이를 통해 각 요소의 이벤트 리스너만 동작시킬 수 있는 것이다.이러한 부모-자식 요소의 html element 뿐만 아니라, 형제 요소들의 이벤트의 실행 또한 제어할 수 있는데, 이는 stopImmediatePropagation() 메소드를 통해 여러 개의 이벤트를 실행시키지 않고 하나의 이벤트만 실행시킬 수 있다.child.addEventListener("click", (e) =&gt; { if(조건) e.stopImmediatePropagation() print('child')
}) child.addEventListener("click", (e) =&gt; { print('child 2')
})
기존의 이벤트에 대해서 메소드들을 통해서 캡처링, 버블링을 중간에 차단시키는 방법도 있지만, target element에 dataset attribute를 이용해서 조작하는 방법도 있다.html의 dataset 속성은 커스텀 사용자 속성을 DOM 요소에 직접적으로 저장할 수 있는데, 이렇게 저장한 요소의 경우 html 내에서 동작하는 자바스크립트 변수와 같은 느낌이 있어 문자열 데이터를 넣어놓고 상태를 조작하거나 특정 target의 id 등을 저장해놓는 방식에도 잘 활용된다.&lt;input type="text" data-country="Norway" data-code="c03" name="Country"&gt;
이런 식으로 앞에 data- prefix를 붙이고 내가 쓰고 싶은 데이터의 속성명을 기재해주고, 이를 자바스크립트의 이벤트 핸들러안에서 찾아서 특정 요소만 검색하는 방식으로도 가능하다const $div = document.getElementById('post'); // 일반적인 객체 속성 접근
$div.dataset.code // "c03" // 배열 인덱스로 접근
$div.dataset['name'] // "Country" // data-country에서 dataset.country로 변환됨
$div.dataset.country // "Norway"
이러한 방식은 조금 더 각각의 요소에 유니크한 값을 넣어놓고 정밀하게 조정할 때 유용한데, 이 부분은 이벤트 위임에서 계속 쓸 예정이다.이처럼 브라우저는 3단계의 과정을 거치기 때문에, 버블링과 캡처링이 내가 예상한 동작 외의 이벤트들 또한 실행될 수 있다는 단점이 있지만, 이를 활용하여 유용하게 사용할 수도 있다.어차피 부모 요소의 이벤트 또한 자식 요소에도 영향을 끼치는데, 그렇게 한다면 여러 개의 컴포넌트가 있었을 때, 가장 상위에서 이벤트를 등록해놓는다면, 이를 통해서 여러 개가 있는 자식 요소들을 모두 하나의 이벤트 등록으로도 관리할 수 있다는 발상이 가능해진다. 이러한 방식을 이벤트 위임이라고 한다.&lt;table&gt; &lt;tr&gt; &lt;th colspan="3"&gt;&lt;em&gt;Bagua&lt;/em&gt; Chart: Direction, Element, Color, Meaning&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="nw"&gt;&lt;strong&gt;Northwest&lt;/strong&gt;&lt;br&gt;Metal&lt;br&gt;Silver&lt;br&gt;Elders&lt;/td&gt; &lt;td class="n"&gt;...&lt;/td&gt; &lt;td class="ne"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt;
&lt;/table&gt;
위와 같은 예시를 javascript.info 에서 가져왔다.
해당 테이블에 있는 각각의 td 요소들을 누르면 누른 td 요소가 highlight되는 효과를 부여하려 한다.이를 위해서는 크게 두 가지 방법이 있다.
해당하는 모든 td 요소를 querySelectorAll로 검색한 뒤 forEach를 통해 캡처링 &amp; 버블링 이벤트 제어 하는 이벤트를 등록한다.
부모요소에서 이벤트를 등록하면서 캡처링 방식으로 넘겨주되, 특정한 data attribute를 통해 각각의 요소를 구분하고, 뽑아낸 특정 요소에 대한 이벤트 핸들링
하지만 1번의 경우 모든 요소에 대해 이벤트를 일일이 등록해주는 행위 자체는 성능성의 이슈가 있기도 하고, 새로운 요소가 추가되었을 경우에도 계속해서 이벤트를 직접 추가해줘야 하므로 상당히 비효율적이라고 생각한다.따라서 2번의 방식을 생각하게 되는데, 이 부분의 경우 세심하게 고려할 부분이 있다.이벤트 핸들러에 parameter로 오는 event 객체에는 target이라는 속성이 있다. 해당 target 속성은 이 이벤트가 이루어진 요소가 어떤 html 요소인지를 보여준다.let selectedTd; table.onclick = function(event) { let target = event.target; // 클릭이 어디서 발생했을까요? if (target.tagName != 'TD') return; // TD에서 발생한 게 아니라면 아무 작업도 하지 않습니다, highlight(target); // 강조 함
}; function highlight(td) { if (selectedTd) { // 이미 강조되어있는 칸이 있다면 원상태로 바꿔줌 selectedTd.classList.remove('highlight'); } selectedTd = td; selectedTd.classList.add('highlight'); // 새로운 td를 강조 함
}
그래서 해당 타겟의 html element를 보고 해당 element에 효과를 넣어주는 방식으로 이벤트 위임을 할 수 있다.하지만 event.target의 중요한 점은 클릭이 이루어진 해당 '요소' 를 정확히 찾아내 리턴한다는 점이다.
따라서 td를 포함하는 td안의 들어있는 모든 요소 대해서 이벤트가 실행되도록 하고 싶은데, 만약에 td 요소 안의 strong 태그 안에 있는 텍스트를 누르게 되면 event.target 으로 받은 html element가 td 안에 들어있는 strong element만을 리턴한다.따라서 내가 이벤트를 등록하려는 Html element의 범위에 대해서 생각하고, 등록하려는 html element 안의 요소를 클릭했을 때, 어떤 방식으로 해당 부모 요소까지 조작할 지에 대해 고려해야 할 필요성이 있다.이를 쉽게 할 수 있는 방법 중 하나는 html element의 closest 메소드를 활용하는 것이다.closest메소드를 활용하여 내가 누른 요소와 가장 가까이에 있는 타켓 요소를 선택할 수 있도록 할 수 있다.table.onclick = function(event) { let td = event.target.closest('td'); // (1) if (!td) return; // (2) if (!table.contains(td)) return; // (3) highlight(td); // (4)
};
이를 통해 누른 요소의 가장 가까운 td 요소를 가져와 해당 요소에 대해서 조작을 해줌으로써 세심하게 이벤트를 제어할 수 있다. html 요소의 attribute에 데이터를 넣어 사용하는 dataset을 활용하는 방식은 closest만큼, 혹은 그보다 더 세심하게 자식 요소의 기능을 관리할 수 있는 방식이다.&lt;table&gt; &lt;tr&gt; &lt;th colspan="3"&gt;&lt;em&gt;Bagua&lt;/em&gt; Chart: Direction, Element, Color, Meaning&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="td0"&gt;&lt;strong&gt;Northwest&lt;/strong&gt;&lt;br&gt;Metal&lt;br data-action="silver" data-target="td0"&gt;Silver&lt;br&gt;Elders&lt;/td&gt; &lt;td class="td1"&gt;...&lt;/td&gt; &lt;td class="td2"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt;
&lt;/table&gt;
해당 코드에서는 dataset의 action이라는 데이터에 부모 요소의 안쪽 요소들의 세부적인 기능을 제어하기 위한 기능적인 명시를 해두었다.
이러한 div 태그에는 각각 유니크한 id가 붙어있고, 가장 상위에 있는 table이나 html의 body 자체에 이벤트를 등록해두는 것이다.let selectedTd; table.onclick = function(event) { if(event.target.dataset.action === "silver"){ let target = event.target.dataset.target; target = document.getElementByID(target) highlight(target); // 강조 함 }
}; function highlight(td) { if (selectedTd) { // 이미 강조되어있는 칸이 있다면 원상태로 바꿔줌 selectedTd.classList.remove('highlight'); } selectedTd = td; selectedTd.classList.add('highlight'); // 새로운 td를 강조 함
}
이벤트에 대한 세부 기능을 data-action attribute로 넣어놓고 이를 포함하는 부모 요소의 unique한 id를 data-target attribute로 부여해주었다. 이렇게 되었을 경우 보다 부모 요소에서 세부적인 기능을 발견했을 경우 해당 이벤트와 그 기능에 대해서만 처리할 수 있도록 핸들링 할 수 있는 것이 유용하다.&lt;div id="menu"&gt; &lt;button data-action="save"&gt;저장하기&lt;/button&gt; &lt;button data-action="load"&gt;불러오기&lt;/button&gt; &lt;button data-action="search"&gt;검색하기&lt;/button&gt;
&lt;/div&gt; &lt;script&gt; class Menu { constructor(elem) { this._elem = elem; elem.onclick = this.onClick.bind(this); // (*) } save() { alert('저장하기'); } load() { alert('불러오기'); } search() { alert('검색하기'); } onClick(event) { let action = event.target.dataset.action; if (action) { this[action](); } }; } new Menu(menu);
&lt;/script&gt;
class 컴포넌트를 이용해서 관리하는 방식은 보다 가독성이 뛰어나다고 생각한다. 클래스의 메소드를 활용하여 버튼마다 핸들러를 할당해주는 코드를 따로 작성할 필요가 없고, 다른 이벤트 핸들러의 수정 또한 메소드만 관리해주면 되기 때문에 각 기능들에 대해서도 관리하는 방식은 확실히 스마트하다.constructor에서 onclick 이벤트에는 this를 바인딩하게 되는데, 바인딩된 요소는 해당 Menu 객체의 요소를 가리킨다.
바인딩된 onClick 이벤트는 캡처링을 통해 자식의 요소들의 onclick 이벤트 또한 감지하고, 이를 action으로 나누어 세부적인 기능들을 메소드로 구분할 수 있기 때문에 활용성을 보다 높였다고 생각한다.이러한 이벤트위임의 장점은 앞에서도 이야기를 많이 했지만,
핸들러를 일일이 할당하지 않아 초기화가 단순해지고 메모리 절약
요소를 추가, 제거,수정 등에 대해서 할당된 핸들러를 따로 건들 필요가 없음
innerHTML이나 유사한 기능을 하는 스크립트로 요소 덩어리를 더하거나 뺄 수 있기 때문에 컴포넌트 기반 개발이 편리함
등이 있다.
하지만 그럼에도 불구하고, 이벤트 위임에도 단점은 있다.
이벤트 위임을 사용하기 위해서는 이벤트의 버블링이 필수인데, 몇몇 이벤트는 버블링이 불가능한 이벤트도 있음 + 낮은 레벨에 할당한 핸들러에 stopPropagation 사용 불가
부모 요소에서 핸들러를 관리하기 때문에 그 안쪽의 모든 요소에 대해서 등록된 이벤트가 실행되기 때문에 CPU 작업부하 무시할만한 수준이라고는 한다. 이벤트 전파와 위임에 대해 제대로 이해하는 것은 이번이 아마 처음이었던 것 같다. vanilla js를 거의 쓰지 않고 리액트만 주로 썼던 나에게는 어떠한 이벤트가 '전파'된다는 사실 자체가 생소하게 들렸다. 리액트는 주로 이벤트를 따로 등록할 때에는 attribute의 onClick 속성에 이벤트 핸들러 함수를 넣어주었고, 이러한 이벤트들은 각각의 이벤트 핸들러를 모두 가지고 있기 때문에 이벤트 위임 또한 생소하게 느껴졌다고 생각한다.
기본기가 탄탄해야 하나의 프레임워크에 의존되지 않고 여러 프레임워크를 빠르게 적응하고 사용할 수 있는 숙련도가 쌓이는 것 같다.
아무튼 이렇게 기존의 이벤트 핸들러를 보다 효율적이고 스마트하게 사용하는 법을 통해 다양하게 시도해보는 습관을 계속 쌓아나가는 것이 좋은 방식이라고 생각한다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%BA%A1%EC%B3%90%EB%A7%81" target="_self">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%BA%A1%EC%B3%90%EB%A7%81</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-HTML-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%85%8Bdata-%EC%86%8D%EC%84%B1" target="_self">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-HTML-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%85%8Bdata-%EC%86%8D%EC%84%B1</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.javascript.info/bubbling-and-capturing" target="_self">https://ko.javascript.info/bubbling-and-capturing</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.javascript.info/event-delegation" target="_self">https://ko.javascript.info/event-delegation</a>]]></description><link>부스트캠프/멤버십/1주차/이벤트-전파와-위임에-대한-고찰.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/이벤트 전파와 위임에 대한 고찰.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/i1TIkvz.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/i1TIkvz.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week1_3일차 PR]]></title><description><![CDATA[
컴포넌트별 폴더 구조 정리 및 제작 히스토리
카드 추가 서버 연결 및 templating 작업중
히스토리 열기/닫기 기능 추가
목업 데이터 추가 이벤트 위임
pug mixin
templating 서버에서 html 요소를 만들어서 보내주고, 이를 각 컴포넌트에서 받아서 html 요소를 이후에 렌더링 시키는 리액트와 비슷한 방식으로 설계를 하려고 했으나 아직까지 제대로 pug템플릿에서 html 템플릿으로 변환하여 보내주는 과정에서 막혀 있어 어떤 방식으로 서버에서 html 요소를 보내줘야 할지 고민중이다.
]]></description><link>부스트캠프/멤버십/1주차/week1_3일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/week1_3일차 PR.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[week1_4일차 PR]]></title><description><![CDATA[
Sorting card button ✅ 2024-08-22
생성 순 정렬
최신 순 정렬
drag &amp; drop box ✅ 2024-08-22
드래그 앤 드롭 시 색상 변경(잔상)
카드 컴포넌트 상태 관리 ✅ 2024-08-22
히스토리 아이템 컴포넌트 ✅ 2024-08-22
카드 수정 ✅ 2024-08-22 이벤트 위임
pug mixin
templating
addEventListener
DOM API
1주차 학습정리
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1-baed698a7b3c40bbbd6b94fb1097dc42?pvs=4" target="_self">https://luxurious-share-af6.notion.site/1-baed698a7b3c40bbbd6b94fb1097dc42?pvs=4</a>삭제와 같은 경우, 해당 서비스에서는 할일 카드에 대한 삭제와 전체적인 히스토리에 대한 삭제가 있으며 이를 위한 확인 모달이 존재한다.
확인 모달같은 경우 버튼이나 요소들은 대부분 동일하지만 텍스트가 조금 달랐다. 하지만 이거때문에 굳이 각각 다른 pug 파일에 일일이 작업하는 것은 다소 하드코딩 같다고 생각하여 이를 어떻게 하면 컴포넌트화를 시킬 수 있을까 생각했다.mixin deleteConfirm(target) style | @import "/shared/deleteConfirm/css/deleteConfirm.css" .modalBackground .deleteConfirmContainer if target==="user" p 모든 사용자 기록을 삭제할까요? else if target==="todo" p 선택한 카드를 삭제할까요? .deleteConfirmContainer button.cancelButton 취소 button.conFirmButton 삭제
삭제 모달을 컴포넌트화시켜 백그라운드와 가운데 들어가는 확인 창을 재사용할 수 있는 형태로 만들었다.
여기서 html 중간에 js문법을 사용할 수 있다는 장점을 활용했는데, if else문을 통해 target이라는 attribute에 따라서 각각 다른 텍스트만 나올 수 있도록 설계했다.또한 상위 컴포넌트에서 이벤트 등록을 통해 해당 모달을 제어하며, 원할하게 작동할 수 있게 보완하였다.SSR로 클라이언트를 만들어 가면서 가장 고민이 됐던 부분이라고 생각한다. 카드나 히스토리 등 정보를 조작하는 데이터 fetching api들이 필요한 부분이 많은데, 이를 반영하고 새로고침하느냐, 아니면 원할한 사용자 경험을 위해서 임시적으로 띄우느냐의 차이라고 생각한다.중요한 점은 수정을 하고 저장을 하는 것과 같은 기능들은 괜찮지만, 새롭게 카드 등록을 하는 경우는 기존 SSR 방식에서 처음에 페이지를 로딩하면서 필요한 데이터를 모두 가져와 해당 페이지에 필요한 히스토리와 등록한 할일 데이터를 넣어 렌더링을 시켜주기 때문에 이를 임시적으로 보이게 하고 나중에 새로고침할 때부터 반영이 되느냐 혹은 새롭게 data post를 한 뒤에 다시금 전체적인 페이지 refresh의 하느냐의 차이가 난다고 생각했다.
이를 맨 처음에는 반대로 생각해서 그냥 임시로 보여주되, 서버에서 templating을 하고 보내면 되지 않을까?라고 생각해서 맨 처음에는 서버의 templating 방법을 생각했다.<br>
<img src="https://i.imgur.com/cB1qe1C.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
pug에는 pug 파일을 가져와 해당 파일을 렌더링 시킬 수 있는 문자열을 반환하는 함수를 리턴한다. 이러한 Pug의 API를 사용하면 내가 일일이 귀찮게 템플릿을 문자열로 한땀한땀 만들지 않고 함수만 실행시키면 알아서 렌더링 가능한 문자열로 나오니 이를 활용하면 좋겠다 생각했었다..// 'client' 폴더를 정적 파일로 제공
app.use(express.static(path.join(__dirname, "client"))); // Pug 템플릿 파일이 위치할 디렉토리 설정
app.set("views", path.join(__dirname, "client"));
// 템플릿 엔진을 Pug로 설정
app.set("view engine", "pug");
app.locals.basedir = path.join(__dirname, "client"); // '/' 경로로 들어오는 요청을 처리
app.get("/", (req, res, next) =&gt; { console.log("refresh"); const filePath = path.join(__dirname, "mockups"); const todoData = JSON.parse(readFileSync(`${filePath}/todo.json`, "utf-8")); const historyData = JSON.parse( readFileSync(`${filePath}/history.json`, "utf-8") ); // home.pug 템플릿을 렌더링하여 클라이언트에 전송 res.render("app", { todoData: todoData, historyData: historyData.history });
});
하지만 내 서버의 세팅 자체가 문제였다. 나는 SSR 방식으로 했기 때문에 전체 페이지 자체를 렌더링해서 넘겨주는 방식을 택했다. 해당 방식만을 생각하면서 폴더구조를 짰는데, 나중에 이를 컴파일한 것을 templating해서 보내기 위해서는 Res.render 메서드를 사용해야 하는데, 해당 메서드에서는 위에서 설정한 디렉토리를 기준으로 더 깊게 디렉토리 구조를 인자로 줄 수 없었다. 처음에는 이 부분이 왜 이러는지 잘 몰랐고, 이거때문에 시간이 많이 걸린 것 같다. const compiled = pug.compileFile( path.join(__dirname, "client", "shared", "card", "component", "card.pug"), { basedir: path.join(__dirname, "client"), } ); console.log( "뭐여", compiled({ title: "임시", detail: "임시디테일", author: "민형", date: "2023-10-24 11:00", id: "temp-1", }) );
이에 compileFile을 통해 pug 파일을 컴파일 해서 문자열만 클라이언트로 받아 출력하는 방식을 생각해보았는데, 기존의 카드 컴포넌트가 여러 개의 attiribute를 받아서인지 You should not have pug tags with multiple attributes. 에러가 떴다. 시간이 남을 때 이 구조를 보다 학습해서 알맞을 템플릿 형태로 제작한 뒤 적용할 예정이다.]]></description><link>부스트캠프/멤버십/1주차/week1_4일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/week1_4일차 PR.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/cB1qe1C.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/cB1qe1C.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1주차_코드리뷰 마스터클래스]]></title><description><![CDATA[
일단 요구사항을 토대로 다 만들기
리팩토링
리팩토링을 하는 과정에서 필요한 공부하기
1을 하면서 문제를 많이 느낄 것 같음 -&gt; 문제를 개선하면서 느끼는게 많음 -&gt; 글로 남길 수 있는 껀덕지
코드의 일관성 고려하기(함수명, 안의 로직)
prefix 붙이기
렌더링을 온전히 담당하는 코드
데이터 업데이트 코드
범용적으로 쓰일 수 있는 함수 -&gt; util
종속적인 함수는 util의 성격과는 맞지 않음코드의 재활용
컴포넌트에 대한 템플릿을 만들어서 관리 fe에서도 불러오고, be에서도불러오기 컴포넌트의 이름은 ui가 아닌 보여지는 형태로 만들어야 함]]></description><link>부스트캠프/멤버십/1주차/1주차_코드리뷰-마스터클래스.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/1주차_코드리뷰 마스터클래스.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[express+pug로 templating해서 SSR + CSR 구현하기]]></title><description><![CDATA[express로 처음 서버를 구동해보면서 이를 html+css+js와 섞는다면 SSR 뿐만 아니라 CSR 또한 내 마음대로 입맛따라 고를 수 있을 것 같았다. 그렇게 된다면 next.js와 비슷한 느낌이지 않을까도 싶다.아무튼 맨 처음에 express를 시작했을 때는 전체적인 html 템플릿을 그대로 출력시켜 열었던 로컬호스트 주소로 접속하면 통채로 웹사이트를 렌더링하여 보내주는 SSR 방식으로 시작했지만, pug라는 템플릿 엔진이 생각보다 여러가지 쓸만한 구석이 많아 이를 좀 더 활용해서 CSR을 만들기 보다 쉽지 않을까 생각해서 시도해보았다.pug를 처음 맛보기로 써봤는데, 생각보다 장점이 많았다.
그 중에서도 이번 templating에 사용하려는 pug의 api는 클라이언트 사이드 렌더링을 하기에 최적화된 api라고 생각했다.const pug = require('pug'); // Compile the source code
const compiledFunction = pug.compileFile('template.pug'); // Render a set of data
console.log(compiledFunction({ name: 'Timothy'
}));
// "&lt;p&gt;Timothy's Pug source code!&lt;/p&gt;" // Render another set of data
console.log(compiledFunction({ name: 'Forbes'
}));
// "&lt;p&gt;Forbes's Pug source code!&lt;/p&gt;"
compileFile은 파일을 읽어들여 해당 템플릿을 통해 templating을 하는 함수를 반환한다.
이 외에도 각종 메서드들은 컴파일에 필요한 여러가지 상황을 상정하여 다양한 방식으로 컴파일한 후 렌더링 할 수 있는 방법을 제시한다.
compile(source : string,?options : ?options) : function() 함수를 반환하고, 반환한 함수를 실행시키면 렌더링 시킬 수 있다 compileFile(source : string,?options : ?options) : function() pug 파일을 읽어들여, templating 하는 함수를 반환 compileClient(source : string,?options : ?options) : function() 문자열을 넣고 클라이언트 사이드에서 렌더링 compileClientWithDependenciesTracked(source, ?options): function() 의존성을 가진 template 클라이언트 사이드에서 렌더링 compileFileClient(path:string, ?options: ?options): function()
- 클라이언트 사이드에서 쓰일 수 있는 문자열로 templating
렌더링 관련 메서드
render(source: string, ?options: ?options): string 문자열을 넣고 html 문자열로 리턴 renderFile(source: string, ?options: ?options, ?callback: ?callback) : string html 문자열로 리턴 해당 경우는 어떠한 요소를 추가했을 때 가져오는 기능이라고 생각해보자app.post("/api", (req, res) =&gt; { const { title, detail, section } = req.body; const data = JSON.parse(readFileSync(`${DATAPATH}`, "utf-8")); const data2 = JSON.parse( readFileSync(`${DATAPATH}`, "utf-8") ); // 서버 데이터에 추가하는 코드 //JSON으로 컴파일한 html 문자열 stringify const template = JSON.stringify({ data: pug.compileFile( path.join( __dirname, 내 경로들 ), { basedir: path.join(__dirname, "views"), } )({argument : value}), }); res.type("Content-Type", "application/json"); res.json(template);
});
서버에서는
데이터를 갱신
갱신한 데이터를 다시 가져오거나 받은 데이터에서 직접적으로 추가(이건 보내는 용도로)
templating할 pug 파일을 pug의 compileFile을 통해 함수를 받기
갱신한 데이터를 compileFile의 리턴값으로 온 함수에 넣기
리턴값으로 온 string을 json 형식으로 만들어 클라이언트의 응답 body에 넣어 보내기
의 과정을 거쳐 새롭게 갱신된 데이터의 컴포넌트 html을 다시금 클라이언트로 보낼 수 있다.
function handler(sectionId) {
... submitButton.addEventListener("click", async () =&gt; { const title = targetSection.getElementsByClassName("form__input--title")[0].value; const detail = targetSection.getElementsByClassName( "form__textarea--cardDetail" )[0].value; const section = targetSection.id; const response = await fetch("/api/todo/new", { method: "POST", headers: { "Content-Type": "application/json", }, body: JSON.stringify({ title: title, detail: detail, section: section, }), }); let data = await response.json(); data = JSON.parse(data); document.getElementById("sections").innerHTML = data.data; });
}
사실상 서버에서 html 파일을 통채로 보내서 렌더링 시키는 서버 사이드 렌더링 방식인 만큼 클라이언트라고 불리는게 맞을까 싶다. 그냥 view라고 볼 수 있지만 편의를 위해 클라이언트라고 칭하겠다.클라이언트에서는 이벤트 위임 방식을 통해 이벤트들을 등록하기 때문에 기존의 html을 제외한 정적 파일들은 모두 남아있는 것들을 활용할 수 있다고 생각했다.
<img src="https://i.imgur.com/AlMIpF9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
innerHTML을 통해서 html을 교체하기 전에 기존의 js script로 들어간 js 파일을 개발자도구로 열어 script에 console.log하는 코드를 실행했는데 새롭게 렌더링이 이루어졌음에도 불구하고 스크립트 파일은 여전히 기존 파일을 유지하는 것을 볼 수 있다. 이러한 점은 새롭게 렌더링하는 과정에서 불필요한 정적 파일들을 불러오지 않는다는 이점을 가진다고 생각했다.여러 컴포넌트로 복사된 html들에 이벤트 등록을 하는 방법은 이벤트 위임 뿐만이 아닌, querySelectorAll을 통해 해당하는 각각의 컴포넌트에 forEach를 돌면서 하나하나 이벤트 등록을 해줘야 하는 방식도 존재하지만 이러한 방식은 성능 상에 이슈가 있을 뿐만 아니라 새롭게 렌더링된 Html에는 이벤트 등록을 해주지 않은 상태에서 스크립트는 변하지 않았기 때문에 이벤트가 제대로 등록되지 않아 동작하지 않을 가능성이 있다. You should not have pug tags with multiple attributes.
사실 이건 해당 templating의 문제가 아닌 내 코드 문제였다<br>
<img src="https://i.imgur.com/b7reY7N.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">form(action="post").editform(hidden)
나도 모르게 그냥 여러 개의 attribute를 콤마로 구분하지 않고 써놔서 warning이 떴다. 정상적으로 인식은 되지만 주의하자이 문제에 대해서는 stackoverflow를 뒤져보고 했는데 결국 제대로 된 느낌의 답변을 찾지 못했다.<br>
<img src="https://i.imgur.com/hWYkzlh.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
내 나름대로 생각한 점으로는 내가 이제까지 pug 파일을 컴파일 했던 때 사용했던 파일이 mixin형태로 arguments들을 받는 방식으로 될까 싶어서 했던건데, 다른 사용 예시들을 보니 mixin을 활용한 예시가 없었다.
아마도 html 컴파일 과정에서 mixin을 지원하지 않는건가 싶어서 일반 html으로 바로 컴파일이 가능한 pug 코드를 쓰니 정상작동되었다.
아무래도 mixin은 해당 템플릿 엔진에서 자체적으로 컴포넌트를 만드는 방식이나보니 compileFile에서는 아직 지원하지 않는 것이라 생각했다.사실 서버 자체에서 렌더링을 하고 있지는 않지만, html 템플릿을 기존에 있는 정적 파일들을 그대로 활용하면서 Html 파일만 교체했음에도 정상적으로 모두 작동한다는 점은 큰 이점을 가진다고 생각한다. ssr과 pug를 공부하면서, 'pug를 통해서 보다 컴포넌트 단위로 나누는 것이 쉬워졌는데, 이러한 방식으로 페이지 전체를 새로고침하지 않아도 문제없을 정도로 계속 사용 가능한 html만 바꿀 수 있지 않을까?'라는 생각에서부터 시작한 실험이었는데 생각보다 이벤트 위임 방식과 시너지를 잘 이루어 나름 야매(?) 클라이언트 사이드 렌더링 방식을 구현했다는 점이 의의가 있는 것 같다. 이번 시도를 통해 CSR과 SSR의 차이도 공부하고, 조금 더 잘 파악할 수 있는 기회가 되었다고 생각한다.하지만 CSR임에도 불구하고 문제가 남아있었으니,,
기존의 placeholder 안에서 모든 html을 통채로 갈아치우다 보니 SSR처럼 모든 화면이 깜빡이지는 않더라도, 컴포넌트의 placeHolder의 일부분이 깜빡이는 부분은 조금 킹받는 부분이 있다.
이를 위해서라면, 컴포넌트에 있는 DOM 노드들을 검사해서 변동사항이 있는 부분만 갱신하는 식으로 해도 될 것 같은데, 이거는 조금 더 깊게 파고 들어가야하기 때문에 조금 더 설계해보려고 한다.]]></description><link>부스트캠프/멤버십/1주차/express+pug로-templating해서-ssr-+-csr-구현하기.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/express+pug로 templating해서 SSR + CSR 구현하기.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/AlMIpF9.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/AlMIpF9.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[this 바인딩과 간접 호출]]></title><description><![CDATA[this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)이다. this는 C++이나 자바와 같은 클래스 기반 언어에서 클래스가 생성하는 인스턴스를 가리키는데, 자바스크립트의 경우 특이 케이스로, 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.함수의 호출 방식은
함수 호출
메소드 호출
생성자 함수 호출
apply/call/bind 호출
로 나누어지는데, 이러한 함수의 호출 방식에 따라 this 바인딩이 그때그때 결정된다는 의미기도 하다. 바인딩이란?
식별자와 값을 연결하는 과정
var foo = function () { console.dir(this);
}; // 1. 함수 호출
foo(); // window
// window.foo(); // 2. 메소드 호출
var obj = { foo: foo };
obj.foo(); // obj // 3. 생성자 함수 호출
var instance = new foo(); // instance // 4. apply/call/bind 호출
var bar = { name: 'bar' };
foo.call(bar); // bar
foo.apply(bar); // bar
foo.bind(bar)(); // bar
그러면 각각의 함수 호출하는 방식에 따라서 binding이 어떻게 이루어지는지 파헤쳐보자일반 함수에서 this를 가리키는 경우 전역 객체를 가리킨다.
전역 객체란?
모든 객체의 유일한 최상위 객체
Browser-side에서는 window를, Server-side(Node.js)에서는 global 객체를 가리키게 된다.// in browser console
this === window // true // in Terminal
node
this === global // true
사실 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수로 쓰이기 때문에,]]></description><link>부스트캠프/멤버십/1주차/this-바인딩과-간접-호출.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/this 바인딩과 간접 호출.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[week1_1일차 PR]]></title><description><![CDATA[
주간계획서 작성
프로젝트 초기세팅(의존성 설치, 폴더구조, sass 변수 설정)
기본 메인 페이지 구조 html 작성
카드 컴포넌트 구조 제작 FSD
SCSS와 SASS
bem 방법론
Web Component shadow DOM
template과 slot 학습정리
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1-baed698a7b3c40bbbd6b94fb1097dc42?pvs=4" target="_self">https://luxurious-share-af6.notion.site/1-baed698a7b3c40bbbd6b94fb1097dc42?pvs=4</a><br><img src="https://i.imgur.com/EGoN63z.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
폴더 구조를 찾아보던 중 이전에는 항상 리액트 프로젝트를 했기 때문에 대부분 많이 쓰던 hooks, server, pages, components 등으로 나눴던 폴더 구조가 여기선 적용하기 어렵겠다고 판단하여 다른 폴더구조를 찾던 중 슬랙에서 다른 캠퍼분이 FSD 패턴을 추천해주셨다.
하지만 이를 내 프로젝트에 적용시키는 과정에서 어떻게 폴더구조를 잡아야 할지 고민이 많이 됐었다.<br><img src="https://i.imgur.com/CWILLlr.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">전체적으로는 app, pages, processes, pages, widgets, features, entitites, shared가 있었지만 내 프로젝트에서 이를 모두 쓰기에는 너무 과하다는 생각이 들어 정말 필요할 것 같은 4가지를 골랐다.
app 애플리케이션의 시작점 entities 다양한 데이터를 서버와 통신할 수 있도록 설정 pages 각 페이지를 담을 디렉토리(메인밖에 없긴 하지만 보다 가독성을 위해 추가했다) shared 공통 스타일
공통 컴포넌트 사실상 이제까지는 리액트만 주로 사용했기 때문에 웹 컴포넌트를 사용할 기회가 없었다. 사실 기회가 있었어도 피했었던 것 같다. 기존 HTMLElement를 상속하는 객체를 만들어 shadowDOM을 통해 렌더링시키는 로직 자체가 나에게 너무 생소하여 이해가 잘 되지 않았기 때문이다.
하지만 이번에는 아무래도 하나의 페이지에 정말 많은 html 요소들이 들어가는 만큼 컴포넌트를 사용해야 할 필요가 있다고 생각했다. 하지만 리액트처럼 컴포넌트를 만들 수 있는 환경이 아니기에 웹 컴포넌트를 사용해보기로 하였다.class Card extends HTMLElement { constructor() { super(); this.attachShadow({ mode: "open" }); this.render(); } get title() { return this.getAttribute("title") || null; } get detail() { return this.getAttribute("detail") || null; } get id() { return this.getAttribute("id") || null; } connectedCallback() { this.render(); } render() { this.shadowRoot.innerHTML = this.template({ title: this.title, detail: this.detail, id: this.id, }); } template(state) { return ` &lt;li&gt; &lt;article&gt; &lt;p&gt;${state.title}&lt;/p&gt; &lt;p&gt;${state.detail}&lt;/p&gt; &lt;/article&gt; &lt;aside&gt; &lt;img src="../asset/close.svg" alt="delete" /&gt; &lt;img src="../asset/pen.svg" alt="edit" /&gt; &lt;/aside&gt; &lt;/li&gt; `; }
}
window.customElements.define("todo-card", Card); 현재는 골대만 잡아 처음으로 렌더링을 시켜보았다. 아직까지는 이벤트를 처리하는 부분이나 리스트 전부를 렌더링하지 못하는 상태지만 이 부분을 보다 보완하여 각 카드들의 리스트를 렌더링하는 컴포넌트를 만들고, 이를 메인 페이지에서 활용할 계획이다.]]></description><link>부스트캠프/멤버십/1주차/week1_1일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/week1_1일차 PR.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/EGoN63z.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/EGoN63z.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week1_2일차 PR]]></title><description><![CDATA[
파일 구조 일부 수정
express 연결 및 작동 확인
서버에서 html 요소를 보내주는 방식으로 교체
express와 pug 연결하여 pug 형식으로 템플릿 교체
카드 컴포넌트 제작(default)
기존 메인페이지 각 컴포넌트화
nodemon 연결 논블로킹/블로킹
비동기
이벤트루프
nodejs 디버깅
express
JIT 컴파일러
학습정리(1주차)
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/1-baed698a7b3c40bbbd6b94fb1097dc42?pvs=4" target="_self">https://luxurious-share-af6.notion.site/1-baed698a7b3c40bbbd6b94fb1097dc42?pvs=4</a>기존에 계획했던 방식으로는 컴포넌트를 모두 클래스 객체로 만들어 웹 컴포넌트의 형식으로 shadowDOM에 추가하여 렌더링을 시키는 방식을 구상했었다.하지만 이후에 금일에는 express와 클라이언트를 연결시키는 과정에서 서버 자체가 페이지의 모든 요소들을 보낼 수 있도록 하게 만들면서 웹 컴포넌트가 어떤 과정으로 렌더링되는지 그 흐름을 보다 알기 어렵게 느껴졌다. 또한, 문자열로 내보내는 html 요소들은 안에서 이벤트 등을 다루기에는 너무 복잡해지면서 나중에는 알아보기도 어려워질 것이라 생각해서 이를 어떻게 할지 고민을 많이 했었다.이 과정에서 맨 처음 계획했듯이, 카드를 Pug 를 통해서 미리 만들어진 html을 보낼 수 있도록 하려고 했는데, 그냥 모든 html 요소들을 모두 pug로 만들어도 괜찮을 것 같다는 생각에 기존의 메인페이지들을 컴포넌트로 나누고, 이를 pug확장자로 제작하여 서버에서 응답으로 보내도록 구상하였다.style | @import url('/app/css/app.css')
.body include ../shared/card/component/card.pug include ../shared/section/component/section.pug header TASKIFY main +section("해야 할 일") +section("하고 있는 일") +section("완료한 일") pug의 mixin과 attribute, include와 같이 가독성이 훨씬 좋은 장점이 있어 아직까지는 컴포넌트를 만들면서 그렇게 문제가 되는 점은 발견하지 못했다. 나중에는 이를 발전시켜 해당 pug로 만들어진 html 요소를 어떻게 동적으로 관리할 수 있을지 고민해봐야 될 것 같다.]]></description><link>부스트캠프/멤버십/1주차/week1_2일차-pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/1주차/week1_2일차 PR.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[[백준 1004] 어린왕자]]></title><description><![CDATA[import sys # 시작점 혹은 도착점이 원 안에 들어있는지 확인
def in_circle(x,y,r,temp_x,temp_y): if r**2 &gt; (( x - temp_x)**2) + ((y - temp_y)**2): return True else: return False # 테스트 케이스
T = int(sys.stdin.readline()) result_print = []
#테스트 케이스 동안
for i in range(T): #시작점, 도착점 start_x, start_y, end_x, end_y = map(int, sys.stdin.readline().split()) # 행성 개수 받기 planet = int(sys.stdin.readline()) # 행성 개수만큼 행성 좌표 받기 result = 0 for j in range(planet): planet_x, planet_y, r = map(int,sys.stdin.readline().split()) # 출발점과 도착점이 원 안에 있을 경우만 생각 if in_circle(planet_x,planet_y,r,start_x,start_y) and in_circle(planet_x,planet_y,r,end_x,end_y): pass elif in_circle(planet_x,planet_y,r,start_x,start_y): result += 1 elif in_circle(planet_x,planet_y,r,end_x,end_y): result += 1 result_print.append(result) for k in result_print: print(k) 적혀있는 문제와 좌표와 원이 난무하는 그림을 보면 정말 풀기 싫어지는 문제
하지만 어떻게 풀지 초반에 생각만 잘 하면 쉽다처음에는 테스트 케이스를 받고 해당 테스트 케이스 수만큼 행성의 좌표를 받아서 저장 받는건 쉽게 할 수 있고 문제는 어떻게 행성으로 진입/이탈하는 것을 아느냐이다.<img height="300/" src="https://i.imgur.com/vaknXFl.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="width: 400px; max-width: 100%;">보면 어떤 행성이 어디에 있건 간에 어린왕자가 출발하고 도착점에 도달하면서 진입/이탈하는 경우는 출발점이나 도착점이 원 안에 있을 경우밖에 없다. 다른 행성들은 어린왕자가 알아서 무빙치면서 피해갈 것이기 때문에 해당 경우만 생각하면 된다. 이미 원 안에 있으면 무조건 진입/이탈이 필요하니까.하지만 이 경우에도 생각해야 할 것이 출발점과 도착점이 모두 같은 원 안에 있을 경우를 생각해야 한다. 출발점과 도착점이 같은 원 안에 있다면 굳이 진입/이탈할 필요가 없이 행성 안에서 이동할 수 있기 때문이다.그러면 우리가 생각할 수 있는 로직은
출발점과 도착점이 같은 원 안에 있을 경우는 패스
출발점만 원 안에 있을 경우에 진입/이탈 횟수 1회 추가
도착점만 원 안에 있을 경우에 진입/이탈 횟수 1회 추가
이다. 이 경우만 생각해주면 나머지는 어린왕자가 알아서 할 것이다.
원 안에 있는지 확인하는 방법은 쉽다. 피타고라스의 방정식을 이용하면 된다.
x^2 + y^2 = r^2 이므로 해당 반지름의 제곱보다 출발점/도착점의 좌표가 작으면 안에 있다고 생각할 수 있다.def in_circle(x,y,r,temp_x,temp_y): if r**2 &gt; (( x - temp_x)**2) + ((y - temp_y)**2): return True else: return False
해당 함수는 행성의 x,y좌표와 반지름, 출발점/도착점을 받아 만약 행성 안에 있으면 True를 반환한다. 이럴 경우에만 result에 1을 추가해주면 된다.<br><img src="https://i.imgur.com/sL7DX4a.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
하지만 메모리는 오지게 갉아먹는 모오습]]></description><link>알고리즘/[백준-1004]-어린왕자.html</link><guid isPermaLink="false">알고리즘/[백준 1004] 어린왕자.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/vaknXFl.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/vaknXFl.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week2_3일차_PR]]></title><description><![CDATA[
sql과 nodejs 연결 ✅ 2024-08-28
erd 작성 ✅ 2024-08-28
함수형 변경 리팩토링(계속 진행중) ✅ 2024-08-28
api별로 만들기(진행중) sql문 ✅ 2024-08-28
sql workbench ✅ 2024-08-28
ssh 터널링 ✅ 2024-08-28
Locale ✅ 2024-08-28
MVC 패턴 ✅ 2024-08-28
Primary Key, Foreign Key, Unique Key ✅ 2024-08-28
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/2-bfaf16a16f8743eb9ee0e08af52673be?pvs=4" target="_self">https://luxurious-share-af6.notion.site/2-bfaf16a16f8743eb9ee0e08af52673be?pvs=4</a>
나는 이제까지 쭉 프론트엔드만 하던 터라 데이터베이스를 설계하는 것 자체가 익숙치 않아 이 점이 매우 어려웠던 것 같다.
기존의 데이터 구조나 자료형 등을 선택하는 과정에서는 해당하는 문제에만 집중하면 됐기 때문에 데이터베이스의 의존성과 같은 점을 생각해볼 기회가 거의 없었는데, 이번에 기본 키, 외래 키 설정 등 신경 쓸 요소들이 많은 만큼 erd 자체를 설계하고, 이러한 값들을 어떻게 sql문으로 효율적으로 가져올 수 있을까에 대해서 많이 고민했다.신경 쓴 요소들로는
유저를 따로 둘 것인가?
히스토리는 어디에 관계를 두어야 하는가?
필드명은 무엇으로 정해야 하는가?
type의 varchar 또한 어느정도까지 허용해야 하는가?
히스토리는 각각 action마다 받아야 하는 데이터가 달라야 할텐데, 이를 어떻게 데이터베이스에 넣고 어떻게 가공하여 사용할 것인가?
등에 대한 고민들을 하나씩 해결해가며 ERD를 짜기 시작했다.<br>
<img src="https://i.imgur.com/pKu9z8I.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이러한 고민들에 대한 해결책으로 나온 ERD인데, 고민거리를 어떻게 해소하였는지를 써보려고 한다.
유저를 따로 둘 것인가? 유저를 따로 두어야만 author가 의미를 가질 것 같다고 생각했다. 아마 일부러 author을 둔 이유는 유저를 만든다는 전제 하에 기획서가 작성된 것 같다고 판단하여 간단하게 유저아이디와 이름만을 받도록 했다.
나중에 로그인이나 다른 기능들이 추가된다면, 해당 유저 테이블의 레코드를 추가하면 될 것 같다고 판단하였다. 히스토리는 어디에 관계를 두어야 하는가? 히스토리는 유저와 관계를 가지고, action은 기획서에 정의된 등록, 이동, 변경 세 가지 경우만 받을 수 있도록 한 다음, 이에 따라 상세 활동읋 따로 파싱하여 각 action에 맞게 서버에서 가공하면 될 것 같다고 생각했다. 레코드명은 무엇으로 정해야 하는가? 레코드명의 경우 최대한 내가 무엇을 가리키는지 명료하게 볼 수 있도록 이름을 작성하였다. type의 varchar 또한 어느정도까지 허용해야 하는가? 일반적인 것들은 50자까지 허용하되, 투두카드의 본문이 500자까지 허용되는 만큼 제목과 상세 내용에 예외를 두었다
또한 히스토리의 상세 활동 또한 파싱해서 사용해야 하기 때문에, 글자수가 많이 늘어날 가능성이 있다고 판단하여 임의로 늘렸지만, 합리적인 기준에서 조금 더 손볼 예정이다. 히스토리는 각각 action마다 받아야 하는 데이터가 달라야 할텐데, 이를 어떻게 데이터베이스에 넣고 어떻게 가공하여 사용할 것인가? 위에서 말한 것과 같이 action_detail에 필요한 JSON 데이터를 전부 string으로 파싱한 뒤에 이를 가져와서 파싱하고 가공하여 사용하면 되지 않을까 생각했다. 굳이 JSON 데이터가 아니더라도 일반 문자열을 일정 기준을 두고 파싱하여 사용하는 방법도 생각해보았지만, JSON.stringify된 문자열이 된다면 이를 그대로 사용하는 것이 보다 합리적으로 보인다. ]]></description><link>부스트캠프/멤버십/2주차/week2_3일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/week2_3일차_PR.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/pKu9z8I.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/pKu9z8I.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[week2_4일차_PR]]></title><description><![CDATA[
api 개발(진행중)
get 카드 불러오기(완료)
post 카드 추가하기(완료)
get 히스토리 불러오기(완료)
delete 카드 히스토리 전체 삭제(리렌더링 로직 진행중) MVC 패턴 프로젝트 적용 ✅ 2024-08-29 sql(학습 진행중) ✅ 2024-08-29
reverse engineering ✅ 2024-08-29
트랜잭션 ✅ 2024-08-29
비즈니스 로직 ✅ 2024-08-29
function CardListModel(cardsList) { this.cards = modelProcessing(cardsList); function modelProcessing(cardsList) { cardsList.map((card) =&gt; new CardModel(card)); }
} function CardModel(card) { this.id = card.card_id; this.author = card.author; this.title = card.title; this.detail = card.detail; this.timestamp = card.timestamp.toDateString(); this.col_name = card.col_name;
} export default CardListModel; sql 쿼리문을 통해 가져온 각각의 카드들에는 칼럼의 이름에 대한 정보가 들어가 있다.
문제는 카드 모델 -&gt; 카드 리스트 모델 -&gt; 섹션 모델 -&gt; 섹션 리스트 모델 순으로 데이터를 처리하는 방식으로 생각했었는데, 이 과정에서 카드에 있는 col_name 값을 어떻게 추출하여 카드 리스트에 넣어줘야 하는지에 대한 고민이 있었다.각각의 요소에 대해서 여러번 for문을 돌면 해결될 수도 있는 방법이긴 하지만 이는 한번 돌았던 요소들에 대해서 다시금 반복문을 도는 것이 과연 좋은 방법일까라는 생각이 들었다.
물론 task card의 특수성을 고려할 때, 대부분 100개를 넘는 일이 그렇게 많지도 않을 것이라 생각할 수 있고, 이정도의 수를 도는 것은 티도 나지 않는 속도이지만서도 보다 효율적으로 칼럼을 추출할 수 있는 방법이 무엇이 있을까 생각해보았다.
forEach문을 통해 columnlist, card 배열을 따로 두고 각각 push
col_list에 대해서 쿼리문을 통해 컬럼 리스트를 가져오기
현재는 1번을 이용한 방식으로 로직을 작성했는데, 후에 이러한 두 방식 중에 어떤 방식이 나을지에 대해서 계속해서 고민해봐야할 문제인 것 같다.import { onColumnDataChanged } from "../../../feature/mainsection/rendering.js";
import apicall from "../../../shared/utils/apicall.js"; export function submitNewCard(targetForm) { try { const title = targetForm.getElementsByClassName("form__input--title")[0].value; const detail = targetForm.getElementsByClassName( "form__textarea--cardDetail" )[0].value; const section = targetForm.id; apicall.post("/api/todo/new", { title: title, detail: detail, section: section, }); onColumnDataChanged(); } catch (error) { console.error(`error while data fetching : ${error}`); }
} 새로운 task를 추가했을 경우에 post 메서드의 api를 호출하여 데이터를 갱신하고, 이후에는 다시금 리렌더링을 촉발시킬 수 있도록 렌더링을 위한 파일을 feature에 놓고 끝나면 리렌더링을 시킬 수 있도록 이벤트를 전달하는 방식으로 설계하였다.
하지만 이러한 경우에 제대로 된 정보의 갱신이 이루어지지 않은 데이터를 다시 오는 오류가 있었다.해당 코드를 자세히 본 결과 비동기적으로 동작하는 코드에서 post가 이루어진 후에 get요청이 이루어져야 하기 때문에 동기적으로 실행할 수 있도록 해야 하는데, 이러한 부분을 간과하고 async/await을 활용하지 않아 비동기적으로 post와 get 요청이 이어지기 때문에 갱신되지 않은 데이터를 fetch해오고 있음을 알게 되었다.router.post("/new", async (req, res) =&gt; { const { title, detail, section } = req.body; await transaction(todoRepository.addCard, [title, detail, section]); res.type("Content-Type", "application/json"); res.status(201).json({ message: "Card created successfully" });
});
하지만 async/await을 사용하여 동기적으로 처리했음에도 똑같은 문제가 발생하게 되었고, api를 호출하는 함수 안에서 post 이후의 코드가 동작하지 않음을 알게 되었다. 문제는 post 요청을 받았을 때 따로 보내줄 데이터가 없다고 생각해서 응답을 추가해주었다.]]></description><link>부스트캠프/멤버십/2주차/week2_4일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/week2_4일차_PR.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[week2_1일차_PR]]></title><description><![CDATA[
주간 계획 작성
webpack 번들링 학습
제대로 하지 못했던 css 속성 부여
webpack 번들링을 통한 csr 사용 fsd 패턴
esm
Webpack과 babel
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/2-bfaf16a16f8743eb9ee0e08af52673be?pvs=4" target="_self">https://luxurious-share-af6.notion.site/2-bfaf16a16f8743eb9ee0e08af52673be?pvs=4</a>
기존의 내 프로젝트의 경우, SSR로 데이터를 엔트리 포인트부터 전해주어 각 pug 템플릿에 이를 전해주고, 해당하는 값을 그대로 받아 렌더링시키는 방식으로 설계 및 구현을 하였다.
하지만 이러한 경우, 함수들을 활용한 방식에 대해서 어떻게 이를 활용해서 컴포넌트 별로 렌더링을 하기 위해서는 값이 변경되었을 때나 처음에 렌더링이 시작되고 이후에 데이터를 가져와 클라이언트 측에서 템플릿을 만들어야 할지 막막하기만 했다.이에 해결책으로 내놓은 방식이 서버에서는 ssr 방식과 csr을 합치되, 기존에는 templating을 해서 보내줬지만 이벤에는 서버에서 데이터만 받아서 클라이언트에서 templating을 거친 뒤 리렌더링을 하는 방식으로 생각해보았다.
이를 위해서는 웹팩을 통해 번들링을 하고, 번들링 과정에서 라이브러리의 의존성을 넘겨주어 이를 사용하는 방식을 생각해보았는데, 현재 마스터클래스가 끝난 시점부터 지금까지 계속해서 웹팩 설정을 하고 있는데도 아직까지 제대로 되지가 않아 문제다.]]></description><link>부스트캠프/멤버십/2주차/week2_1일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/week2_1일차_PR.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[week2_2일차_PR]]></title><description><![CDATA[
폴더 구조 및 모듈 구조 변경 ✅ 2024-08-27
express api와 데이터 연결 ✅ 2024-08-27
리렌더링 로직 작성 ✅ 2024-08-27 fsd 패턴 ✅ 2024-08-27
esm ✅ 2024-08-27
Webpack과 babel ✅ 2024-08-27
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://luxurious-share-af6.notion.site/2-bfaf16a16f8743eb9ee0e08af52673be?pvs=4" target="_self">https://luxurious-share-af6.notion.site/2-bfaf16a16f8743eb9ee0e08af52673be?pvs=4</a>
어제까지만 해도 웹팩을 통해 라이브러리 의존성을 웹팩에 넘겨주어 이러한 모듈을 사용하는 방식을 고려했었다.
하지만 어제 계속해서 실패를 거듭한 결과, 이러한 웹팩의 스크립트 파일에서 실행하다는 것이 불가능하다는 결론을 내렸다.나는 어제 총 세 가지 방식을 사용했다.
웹팩에서 모듈 번들링 후 import 해서 사용 -&gt; 실패 Pug는 fs에 의존하는 모듈이기 때문에, 브라우저에서 pug를 Import하게 되면 의존성이 있는 fs 모듈 또한 사용해야 하는데, fs 모듈은 node.js가 아닌 브라우저 환경에서는 작동하지 않기 때문에 실패했다.
not defined 에러와 not relative path~와 같은 에러만 이어졌다. commonjs의 require문을 통해 import commonjs를 통해 import 하는 방식도 시도해봤지만, 애초에 브라우저에서 require 문법 자체가 동작하지 않으므로 소용없었다.
require is not defined 에러만 떴다. 스트립트 태그로 cdn jsdeliver을 통해 모듈을 가져와 사용 스크립트 태그로 가져온 pug esm에서 export default를 설정해주지 않아 나오는 에러만 나왔다. 어제 하루종일 이거만 잡고 있었기에 거의 포기하고 그냥 pug 파일을 온라인 컴파일러를 통해 변환한 뒤 사용하려던 찰나, 문득 'Pug online compiler'는 어떻게 컴파일을 하는걸까? 싶어서 해당 컴파일러의 스크립트 태그를 봤는데 https://gnjo.github.io/pug/pug.js?v=1라는 주소로 import 해와서 사용했다. 나도 이 태그를 활용해서 사용하고, module에서 window.pug를 통해 사용했더니 제대로 compileClient 메소드가 동작했다!하지만 기존에 가지고 있던 pug 파일 중에 import 해서 mixin을 사용하거나 템플릿 자체를 Import 해오는 작업은 fs 모듈을 거치기 때문에 브라우저에서 활용할 수 없다.import deleteConfirm from "/shared/deleteConfirm/index.js"; function Card() { const template = `style | @import url('/entities/card/style/card.css')
div.cardContainer(id=card.id draggable="true" data-date=card.date) form(action="post").editform(hidden) .form__div--cardForm input.form__input--title(type="text" placeholder="제목을 입력하세요" value=card.title) textarea.form__textarea--cardDetail(type="text" placeholder="내용을 입력하세요" rows=1 maxlength=500)#cardDetail #{card.detail} .form__div--buttonWrapper input.form__input__cancel-button(type="button", value="취소") input.form__input__submit-button(type="button", value="등록") li.generalCard(data-drag=card.id) .articleWrapper article p.title #{card.title} p.detail #{card.detail} p.author author by #{card.author} aside img.deleteTodo(src="/asset/close.svg", alt="delete", data-close=card.id) img.activeEditmode(src="/asset/pen.svg", alt="edit", data-edit=card.id)`; const compiledFunction = window.pug.compile(template, { basedir: "/Users/miguel/Desktop/naver/membership/week1/views", }); function render(section, cards) { cards.forEach((card) =&gt; { section.innerHTML += compiledFunction({ card: card }); deleteConfirm.render(card.id); }); } return { render, };
} const card = new Card();
export default card; 이처럼 esm을 활용하여 함수형의 특징을 활용하여 사용할 수 있도록 하였다. 함수 안에 함수를 넣고, 클로저를 활용한 내부 함수에 대해서는 캡슐화가 적용되어 보안에도 이점을 지닌다.위와 같은 카드 컴포넌트의 경우, mainsection 컴포넌트 내부 -&gt; section 컴포넌트 내부를 거쳐 import 해온 컴포넌트를 해당 부모 요소의 함수 안에서 렌더링하는 로직을 포함하는 방식으로 하여금 연쇄적으로 렌더링을 시키도록 설계하였다.이러한 방식의 렌더링은 모듈화가 잘 되어 있기 때문에, 이를 보다 계층적으로 보다 잘 파악하고, 구체적인 방식으로 모듈을 사용하면 가독성이나 구조 측면에서 가지는 이점이 크다. 이에 기존의 fsd 원칙은 그저 개념을 내가 편한대로 해석하여 설계했다면, 이번에는 fsd 원칙에 충실한 디렉토리 구조를 짜려 한다.]]></description><link>부스트캠프/멤버십/2주차/week2_2일차_pr.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/week2_2일차_PR.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate></item><item><title><![CDATA[MVC패턴]]></title><description><![CDATA[MVC 패턴이란 Model-View-Controller의 앞글자만 따온 약자로, 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴이다.
디자인 패턴이란?
프로그램이나 어떤 특정한 것을 개발하는 중에 발생했던 문제점들을 정리해서 상황에 따라 간편하게 적용하여 쓸 수 있는 것을 정리한 규약
해당 패턴은 소프트웨어의 비즈니스 로직과 화면을 구분하는데 중점을 두고 있다. 즉, 하나의 애플리케이션을 설계함에 있어서 구성 요소를 세 가지 역할로 나누어 구분한 것이다.
세 가지 역할은
모델(Model) : 데이터와 비즈니스 로직 관리
뷰(View) : 레이아웃과 화면 처리
컨트롤러(Controller) : 모델과 뷰로 명령을 전달
로 구분된다
<img src="https://i.imgur.com/ZqqejMn.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
위의 그림처럼 서로의 관계가 정의되어 있다.
각각의 요소에 대해서 자세히 알아보자애플리케이션의 정보, 데이터를 나타낸다.
데이터베이스, 상수, 초기화값, 변수 등을 뜻하며, 이러한 정보들을 가공하는 역할을 한다.
사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 함
뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 함 뷰를 참조하는 내부 속성값을 지니면 안됨 변경이 일어나면, 변경 통지에 대한 처리방법을 구현 정보 변경이 일어나면, 이벤트를 발생시켜 전달하고, 이를 뷰에서 수신하여 처리하거나 하는 처리 방법이 따로 있어야 함
모델은 재사용가능해야 하며 다른 인터페이스에서도 변하지 않아야 함 사용자 ui를 담당하는 요소이다. 데이터 및 객체의 입력, 출력을 담당한다.
데이터를 기반으로 사용자들이 볼 수 있는 화면이다. 즉, 표시할 데이터를 모델로부터 받아 출력한다.
모델이 가지고 있는 정보를 따로 저장해서는 안됨 임의의 뷰 내부에 저장 금지 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 함 모델과 같은 자기 자신을 제외하고 다른 요소들의 참조나 동작을 모름
데이터를 받으면 단순히 화면에 표시만 함 변경이 일어나면 변경 통지에 대한 처리 방법 구현 모델과 같이 변경이 일어났을 때 변경을 알려줘야 하는 방법 구현
재사용가능하게끔 설계 컨트롤러는 데이터와 ui(사용자 인터페이스) 요소들을 잇는 다리 역할이다.
사용자가 데이터를 클릭하면 수정하는 것에 대한 이벤트들을 처리한다
모델이나 뷰에 대해서 알고 있어야 함 모델이나 뷰는 서로 모르즈만 컨트롤러는 그 사이에 둘을 모두 알고 있는 상태에서 변경을 외부로 알리거나 수신할 수 있어야 함 모델이나 뷰의 변경을 모니터링 해야함
이러한 3개의 구성 요소로 나누어 동작하는 웹 서버의 구조를 활용하면 가지는 장점들이 뚜렷하다.
유지보수성 향상 모델, 뷰, 컨트롤러가 명확하게 나누어져 있어 코드의 수정이나 확장이 용이하다
유지보수가 필요한 부분을 집어 해당 부분만 수정하면 됨 개발의 병렬성 증가 따로따로 개발이 가능해서 협업을 할 경우 개발의 분업화가 잘 이루어질 수 있음 유연성과 확장성 애플리케이션의 기능을 쉽게 추가 및 확장 가능하다
각각의 요소에 맞추어 추가하기만 하면 된다 테스트 용이성 mvc 패턴은 각 컴포넌트가 독립적으로 동작하도록 설계되었기 때문에 단위 테스트를 수행하기 쉬움 코드의 명확한 구조 코드의 구조가 명확해짐
코드의 가독성을 높임 중복 코드 감소 중복 코드를 하나로 묶음으로써 재사용이 용이하고 코드의 중복이 사라짐 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Glossary/MVC" target="_self">https://developer.mozilla.org/ko/docs/Glossary/MVC</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://m.blog.naver.com/jhc9639/220967034588" target="_self">https://m.blog.naver.com/jhc9639/220967034588</a>]]></description><link>부스트캠프/멤버십/2주차/mvc패턴.html</link><guid isPermaLink="false">부스트캠프/멤버십/2주차/MVC패턴.md</guid><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/ZqqejMn.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/ZqqejMn.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>