<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Minhyung's Dev Log]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://alsgud8311.github.io/</link><image><url>https://alsgud8311.github.io/site-lib/media/favicon.png</url><title>Minhyung's Dev Log</title><link>https://alsgud8311.github.io/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 08 Feb 2025 15:31:56 GMT</lastBuildDate><atom:link href="https://alsgud8311.github.io/site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 08 Feb 2025 15:31:54 GMT</pubDate><copyright><![CDATA[Cho Minhyung]]></copyright><ttl>60</ttl><dc:creator>Cho Minhyung</dc:creator><item><title><![CDATA[알고리즘]]></title><description><![CDATA[<a data-href="[백준 1004] 어린왕자" href="https://alsgud8311.github.io/알고리즘/[백준-1004]-어린왕자.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 1004] 어린왕자</a><br>
<a data-href="[프로그래머스] 방금그곡" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-방금그곡.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 방금그곡</a><br>
<a data-href="[프로그래머스] 두 원 사이의 정수 쌍" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 두 원 사이의 정수 쌍</a><br>
<a data-href="[프로그래머스] 행렬 테두리 회전하기" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-행렬-테두리-회전하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 행렬 테두리 회전하기</a><br>
<a data-href="[프로그래머스] 주차 요금 계산" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-주차-요금-계산.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 주차 요금 계산</a><br>
<a data-href="[백준 12865] 평범한 배낭" href="https://alsgud8311.github.io/알고리즘/[백준-12865]-평범한-배낭.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 12865] 평범한 배낭</a><br>
<a data-href="[백준 7576] 토마토" href="https://alsgud8311.github.io/알고리즘/[백준-7576]-토마토.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 7576] 토마토</a><br>
<a data-href="[프로그래머스] 석유 시추" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-석유-시추.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 석유 시추</a><br>
<a data-href="[프로그래머스] 요격 시스템" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-요격-시스템.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 요격 시스템</a><br>
<a data-href="[백준 9251] LCS" href="https://alsgud8311.github.io/알고리즘/[백준-9251]-lcs.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 9251] LCS</a><br>
<a data-href="[백준 1912] 연속합" href="https://alsgud8311.github.io/알고리즘/[백준-1912]-연속합.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 1912] 연속합</a><br>
<a data-href="[백준11631] ASCII Addition" href="https://alsgud8311.github.io/알고리즘/[백준11631]-ascii-addition.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준11631] ASCII Addition</a><br>
<a data-href="[백준14596] Quilting(smaill)" href="https://alsgud8311.github.io/알고리즘/[백준14596]-quilting(smaill).html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준14596] Quilting(smaill)</a><br>
<a data-href="[백준 17123] 배열 놀이" href="https://alsgud8311.github.io/알고리즘/[백준-17123]-배열-놀이.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 17123] 배열 놀이</a><br>
<a data-href="[백준31784] 포닉스의 문단속" href="https://alsgud8311.github.io/알고리즘/[백준31784]-포닉스의-문단속.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준31784] 포닉스의 문단속</a><br>
<a data-href="[백준 6064] 카잉 달력" href="https://alsgud8311.github.io/알고리즘/[백준-6064]-카잉-달력.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 6064] 카잉 달력</a><br>
<a data-href="[백준 10597] 순열장난" href="https://alsgud8311.github.io/알고리즘/[백준-10597]-순열장난.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 10597] 순열장난</a><br>
<a data-href="[백준 31836] 피보나치 기념품" href="https://alsgud8311.github.io/알고리즘/[백준-31836]-피보나치-기념품.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 31836] 피보나치 기념품</a> - 미완성<br>
<a data-href="[백준26091] 현대모비스 소프트웨어 아카데미" href="https://alsgud8311.github.io/알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준26091] 현대모비스 소프트웨어 아카데미</a><br>
<a data-href="[백준 23307] 드디어 시작한 화석 발굴 이벤트" href="https://alsgud8311.github.io/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html" class="internal-link" target="_self" rel="noopener nofollow">[백준 23307] 드디어 시작한 화석 발굴 이벤트</a><br>
<a data-href="[백준 12891] DNA 비밀번호" href="https://alsgud8311.github.io/알고리즘/[백준-12891]-dna-비밀번호.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 12891] DNA 비밀번호</a><br>
<a data-href="백준 18113 그르다 김가놈" href="https://alsgud8311.github.io/백준-18113-그르다-김가놈.html" class="internal-link" target="_self" rel="noopener nofollow">백준 18113 그르다 김가놈</a>]]></description><link>https://alsgud8311.github.io/알고리즘/알고리즘.html</link><guid isPermaLink="false">알고리즘/알고리즘.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sat, 08 Feb 2025 15:31:37 GMT</pubDate></item><item><title><![CDATA[HELLO👋]]></title><description><![CDATA[안녕하세요. 프론트엔드 개발자로 열심히 공부중인 조민형입니다.<img height="400/" src="https://i.imgur.com/4YbV9wp.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="width: 300px; max-width: 100%;">어떤 기술이든지 노력이면 해낼 수 있다는 믿음 하에 일단 도전하는 것을 좋아합니다.&nbsp;&nbsp;UX를 고려한 서비스 제작, 추상화를 활용한 컴포넌트와 프로젝트 설계에 관심이 있습니다.합리적이고 논리적인 근거를 가진 코드를 작성하기 위해 노력중입니다 💪<br><img alt="React Native" src="https://img.shields.io/badge/React%20Native-61DAFB?style=for-the-badge&amp;logo=react&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <img alt="React" src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&amp;logo=react&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <img alt="Next.js" src="https://img.shields.io/badge/Next.js-000000?style=for-the-badge&amp;logo=next.js&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img alt="Tailwind CSS" src="https://img.shields.io/badge/Tailwind%20CSS-38B2AC?style=for-the-badge&amp;logo=tailwind-css&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <img alt="styled-components" src="https://img.shields.io/badge/styled--components-DB7093?style=for-the-badge&amp;logo=styled-components&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img alt="JavaScript" src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&amp;logo=javascript&amp;logoColor=black" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <img alt="TypeScript" src="https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&amp;logo=typescript&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img alt="Zustand" src="https://img.shields.io/badge/Zustand-FF8800?style=for-the-badge&amp;logo=zustand&amp;logoColor=white" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
한국외국어대학교 영미문학문화학과/ai융합전공(sw&amp;ai) - 재학중 멋쟁이사자처럼 한국외국어대학교(2023~2024)
네이버 부스트캠프 웹모바일 9기(2024.7 ~ 2024.12) 멋쟁이사자처럼 연합해커톤 간지톤 최우수상
리눅스마스터 2급 <br><a data-href="알고리즘" href="https://alsgud8311.github.io/알고리즘/알고리즘.html#_0" class="internal-link" target="_self" rel="noopener nofollow">알고리즘</a>
<br><a data-href="학습 정리" href="https://alsgud8311.github.io/학습-정리/학습-정리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">학습 정리</a> <br>adhd인을 위한 서비스 - <a data-href="forA" href="https://alsgud8311.github.io/프로젝트/fora/fora.html#_0" class="internal-link" target="_self" rel="noopener nofollow">forA</a>
<br>생성형 ai로 나만의 웹소설 만들기 - <a data-href="Neo" href="https://alsgud8311.github.io/프로젝트/neo/neo.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Neo</a>
<br>ai가 도와주는 마인드맵 저작도구 - <a data-href="Boomap" href="https://alsgud8311.github.io/프로젝트/boomap/boomap.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Boomap</a>
]]></description><link>https://alsgud8311.github.io/index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 07 Feb 2025 15:52:12 GMT</pubDate><enclosure url="https://i.imgur.com/4YbV9wp.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/4YbV9wp.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[forA_트러블슈팅]]></title><description><![CDATA[<img src="https://i.imgur.com/DJXqyXM.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="max-width: 100%;">
유효성 검사가 제대로 이루어지지 않아 6글자일 때 인증번호가 제대로 된 인증번호인지 띄워줘야 하는데 다짜고짜 인증번호를 다시 확인해달라고 나온다. 인증 확인 버튼을 누른 상태도 아니었다.
```tsx
useEffect(() =&gt; { const intervalId = setInterval(() =&gt; { if (timer &gt; 0) { setTimer(timer - 1) } }, 1000) return () =&gt; clearInterval(intervalId)
}, [timer])
타이머에서 유효성 검증 상태 안바꿀거면 장식용으로 둔건가 ```tsx const gotoBeforeScreen = () =&gt; { navigation.navigate('EmailDuplicateCheck' as never) } const gotoNextScreen = () =&gt; { navigation.navigate('SetPassword' as never) }
navigate의 타입제네릭을 써주지 않아서 never로 타입]]></description><link>https://alsgud8311.github.io/프로젝트/fora/fora_트러블슈팅.html</link><guid isPermaLink="false">프로젝트/forA/forA_트러블슈팅.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 07 Feb 2025 15:38:37 GMT</pubDate><enclosure url="https://i.imgur.com/DJXqyXM.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/DJXqyXM.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[forA]]></title><description><![CDATA[<a data-href="forA_트러블슈팅" href="https://alsgud8311.github.io/프로젝트/fora/fora_트러블슈팅.html#_0" class="internal-link" target="_self" rel="noopener nofollow">forA_트러블슈팅</a><br>
<a data-href="forA_리팩토링_Navigation 추상화하기" href="https://alsgud8311.github.io/fora_리팩토링_navigation-추상화하기.html" class="internal-link" target="_self" rel="noopener nofollow">forA_리팩토링_Navigation 추상화하기</a>]]></description><link>https://alsgud8311.github.io/프로젝트/fora/fora.html</link><guid isPermaLink="false">프로젝트/forA/forA.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 07 Feb 2025 15:38:21 GMT</pubDate></item><item><title><![CDATA[화면 기록 2025-02-07 오후 11.20.09]]></title><description><![CDATA[<img src="https://alsgud8311.github.io/프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif" target="_self">]]></description><link>https://alsgud8311.github.io/프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html</link><guid isPermaLink="false">프로젝트/forA/화면 기록 2025-02-07 오후 11.20.09.gif</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 07 Feb 2025 14:24:09 GMT</pubDate><enclosure url="https://alsgud8311.github.io/프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src="https://alsgud8311.github.io/프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 12891] DNA 비밀번호]]></title><description><![CDATA[<img src="https://i.imgur.com/j2BxAFf.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">DNA 문자열을 가지고 만들 수 있는 비밀번호의 종류의 수를 구하는 문제이다.
DNA 문자열은 모든 문자열에 등장하는 문자가 A, C, G, T인 문자열을 의미한다.
또한 일정 길이의 DNA 문자열과 A, C, G, T가 각각 가져야 하는 문자열의 개수를 세봤을 때 이보다 이상이어야 성립한다.
어차피 비밀번호로 사용할 부분문자열의 길이는 주어져있고, 문자열에서 임의로 뽑아내는 것이 아닌 이어져 있는 문자열이기 때문에 슬라이딩 윈도우를 통해 풀면 될 것 같다.const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const inputs = require("fs") .readFileSync(INPUT_FILE) .toString() .trim() .split("\n");
const [s, p] = inputs[0].split(" ").map(Number);
const str = inputs[1];
const [A, C, G, T] = inputs[2].split(" ").map(Number);
let result = 0;
for (let i = 0; i &lt;= s - p; i++) { let a = A; let c = C; let g = G; let t = T; const partition = Array.from(str.slice(i, i + p)); partition.forEach((char) =&gt; { if (char === "A") a--; else if (char === "C") c--; else if (char === "G") g--; else if (char === "T") t--; }); if (a &lt;= 0 &amp;&amp; c &lt;= 0 &amp;&amp; g &lt;= 0 &amp;&amp; t &lt;= 0) result++;
}
console.log(result); 처음에는 switch - case문을 사용해 풀었지만 메모리 초과가 나와서 if문으로 바꿨는데도 역시 났다.
사실 switch case문과는 솔직히 별 시간 차이가 나지 않을 것 같긴 해서 다른 곳이 문제라는 건데..const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const inputs = require("fs") .readFileSync(INPUT_FILE) .toString() .trim() .split("\n");
const [s, p] = inputs[0].split(" ").map(Number);
const str = inputs[1];
const [a, c, g, t] = inputs[2].split(" ").map(Number);
const testSum = a + c + g + t;
const regex = new RegExp( `^(?=(?:[^A]*A){${a}})(?=(?:[^C]*C){${c}})(?=(?:[^G]*G){${g}})(?=(?:[^T]*T){${t}}).*$`
); if (testSum &gt; s) { console.log(0);
} else { let result = 0; for (let i = 0; i &lt;= s - p; i++) { const testStr = str.slice(i, i + p); if (regex.test(testStr)) result++; } console.log(result);
} 킹받아서 정규표현식으로도 해봤는데 이젠 시간 초과가 뜬다다시 생각해보니 나는 슬라이딩 윈도우를 어떻게 효율적으로 사용하는지 제대로 몰랐던 것 같다.슬라이딩 윈도우는 일정한 크기의 윈도우를 가지고 계속 옆으로 옮겨가면서 검사를 하는 방식이지만, 이 과정에서 계속해서 변수에 새롭게 문자열을 잘라 할당하게 되면 결국 메모리 손해로 이어지고 만다. 그렇기 때문에 매번 새롭게 할당하는 방식이 아니라 기존 데이터를 일정한 크기만큼 계속 움직이는 만큼 쓸 수 있는 데이터는 그대로 쓰면서 넘어가야만 효율적인 알고리즘이 될 수 있다.const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const inputs = require("fs") .readFileSync(INPUT_FILE) .toString() .trim() .split("\n"); const [s, p] = inputs[0].split(" ").map(Number);
const str = inputs[1];
const [a, c, g, t] = inputs[2].split(" ").map(Number);
const testSum = a + c + g + t; if (testSum &gt; s) { console.log(0); process.exit(0);
} const count = { A: 0, C: 0, G: 0, T: 0 };
let result = 0;
for (let i = 0; i &lt; p; i++) count[str[i]]++;
if (count["A"] &gt;= a &amp;&amp; count["C"] &gt;= c &amp;&amp; count["G"] &gt;= g &amp;&amp; count["T"] &gt;= t) result++; for (let i = p; i &lt; s; i++) { count[str[i]]++; count[str[i - p]]--; if (count["A"] &gt;= a &amp;&amp; count["C"] &gt;= c &amp;&amp; count["G"] &gt;= g &amp;&amp; count["T"] &gt;= t) result++;
} console.log(result); 그렇기 때문에 객체에 기존 문자열을 모두 저장해놓고 옆으로 옮겨가면서 추가된 문자열만 하나씩 추가해주는 방식으로 바꿨더니 정답이 되었다.<br><img src="https://i.imgur.com/jFLzfRi.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">앞으로 슬라이딩 윈도우를 쓸 때는 딱 그렇게만 생각하는 것이 아닌, 쓰는 방식에 대해서도 고민을 하고 코드를 작성해야 할 것 같다.]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-12891]-dna-비밀번호.html</link><guid isPermaLink="false">알고리즘/[백준 12891] DNA 비밀번호.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 07 Feb 2025 04:38:51 GMT</pubDate><enclosure url="https://i.imgur.com/j2BxAFf.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/j2BxAFf.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준26091] 현대모비스 소프트웨어 아카데미]]></title><description><![CDATA[<img src="https://i.imgur.com/EokJAxy.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
PPL문제는 참신하네요..두 조건을 만족하는 팀만 견학 할 수 있는데, 최대 몇 팀이나 견학을 보낼 수 있는지 구하면 된다.
팀원은 무조건 두명인 걸 보니 생각해볼 수 있는 알고리즘의 폭이 많이 줄어들 수 있다고 생각한다.<br><img src="https://i.imgur.com/LzcehEB.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
예제를 보자.
예제 1의 경우 6명이 있고 최소 능력치는 두명이 합쳐서 10이 넘어야 한다.
여기서 나오는 조합들 중 10이 넘는 조합들을 구하고, 최대로 보낼 수 있는 팀 수를 출력하면 된다.const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const inputs = require("fs") .readFileSync(INPUT_FILE) .toString() .trim() .split("\n"); const [n, m] = inputs[0].split(" ").map(Number);
const students = inputs[1] .split(" ") .map(Number) .sort((a, b) =&gt; a - b); let left = 0;
let right = n - 1;
let team = 0;
while (left &lt; right) { if (students[left] + students[right] &gt;= m) { team++; left++; right--; } else { left++; continue; }
}
console.log(team);
어차피 한 번 참가한 팀원은 다시 참여할 수 없고, 무조건 두 명씩 팀을 해야 한다는 전제가 있기 때문에 간단하게 투포인터를 활용해서 풀 수 있었다.]]></description><link>https://alsgud8311.github.io/알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html</link><guid isPermaLink="false">알고리즘/[백준26091] 현대모비스 소프트웨어 아카데미.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Wed, 05 Feb 2025 05:18:19 GMT</pubDate><enclosure url="https://i.imgur.com/EokJAxy.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/EokJAxy.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 31836] 피보나치 기념품]]></title><description><![CDATA[<img src="https://i.imgur.com/KSslIhp.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">세림이랑 성주는 왜 대체 피보나치 수열을 좋아하는 걸까...?
아무튼 두 사람이 받게 될 기념품에 적힌 피보나치 수의 합이 같아야 하면서 최대한 많은 개수의 기념품을 나눠줄 수 있도록 해야한다.<br><img src="https://i.imgur.com/rJt8KiI.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
입출력을 보자.
예제 1의 경우 2개의 기념품이 있다.
이 때, 세림이는 1이 적혀있는 기념품 한개를 받았고, 성주는 2가 적혀있는 기념품 한 개를 받았다.
여기서 1과 2 모두 피보나치 수로 1이기 때문에 두 사람이 받은 기념품들의 합은 1로 같다.예제2의 경우 4개의 기념품을 받았다.
세림이는 1, 3 두 개의 기념품을 받았고, 성주는 4로 된 기념품 하나를 받았다.
세림이의 기념품들의 피보나치 수 합은 F1+F3 = 1+2 = 3
성주의 기념품들의 피보나치 수 합은 F4 = 3 이므로 두 사람이 받은 기념품의 피보나치 수 합은 같다.이 문제는 어떻게 풀어야 할까?
N이 주어지면 거기에서 공통의 합의 나오도록 해야 하는데, 이는 한 사람의 기념품을 받은 수를 가지고 계속 쪼갤 수 있다.
예제 2처럼 N이 4라고 한다면 F4부터 시작해서 계속해서 피보나치 수로 쪼갤 수 있도록 하는 것이다.
예제 2의 경우도 4로 시작해서 F4 = F2 + F3이므로 한도를 넘지 않는 선에서 2개의 기념품을 가지도록 한 것이다.
또한 여기서 최대의 값을 가져야 하므로 기존에 나온 값들 중에서 가장 큰 값을 고르는 것이기 때문에 분할정복 혹은 dp로 풀어야 할 것 같다.
흠 일단 피보나치로 나올 수 있는 수들에 대해서 미리 메모이제이션 한 다음에, 여기에서 가장 크게 나눠가질 수 있는 경우를 찾아보면 될 것 같다.
샀던 N개의 기념품은 모두 N보다 작은 x의 수가 적혀있는 피보나치 수이다.
가장 큰 수부터 시작해서 계속 피보나치를 나눠가면서 개수를 더하면?]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-31836]-피보나치-기념품.html</link><guid isPermaLink="false">알고리즘/[백준 31836] 피보나치 기념품.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Wed, 05 Feb 2025 02:51:19 GMT</pubDate><enclosure url="https://i.imgur.com/KSslIhp.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/KSslIhp.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 10597] 순열장난]]></title><description><![CDATA[<img src="https://i.imgur.com/lK7ssOY.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하나의 문자열로 합쳐진 순열을 다시 복구하는 문제이다.
일단 순열의 정의부터 아는 것이 좋다.
순열은 서로 다른 n개의 원소를 가지는 어떤 집합에서 중복 없이 순서에 상관 있게 r개의 원소를 선택하거나 혹은 나열하는 것이다.kriii는 이러한 순열을 생각해서 중복되는 수가 없도록 수열을 다시 복구하면 된다.
중복되는 수가 없도록 하기 위해서는 루프를 돌면서 이전에도 중복된 수가 있는지 검사를 해야한다.따라서 해당 문제는 각 수를 분할하여 계산
메모이제이션이 필요
하기 때문에, dp로 풀어야 할 것 같다고 생각했다.
const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const inputs = require("fs").readFileSync(INPUT_FILE).toString().trim();
const dpArr = new Array(); let pstring = "";
for (let i = 0; i &lt; inputs.length; i++) { pstring += inputs[i]; if (!dpArr.includes(pstring)) { dpArr.push(pstring); pstring = ""; continue; } for (let j = i + 1; j &lt; inputs.length; j++) { pstring += inputs[j]; if (!dpArr.includes(pstring)) { dpArr.push(pstring); pstring = ""; i = j; break; } }
}
console.log(dpArr.join(" ")); 그렇게 처음 만들어진 코드
제출하자마자 바로 컷당했다..결국 알고리즘 분류를 보았는데 백트래킹으로 풀어야 한다고 한다.
kriii의 순열은 최소 1개 최대 50개의 수로 이루어져 있다.
조건 중 하나를 제대로 보지 않았다. 순열에 들어가는 수는 제한이 있었다.
이 말의 뜻은 곧 순열은 1부터 50까지의 수 중에 N개의 수를 고르면 해당 N개의 수는 1부터 N까지 숫자가 무조건 한 번씩은 사용이 되어야 하고, 중복이 없어야 한다.그렇다면 매 수가 가면서 해당 수를 넣었을 때와 넣지 않았을 때로 나누어 계산한 후, 중간에 조건이 맞지 않는다면 빠꾸 시키는 백트래킹 형식으로 가면 되지 않을까?결국 ai의 도움을 통해 풀었다... 백트래킹이 익숙치 않다보니 로직은 조금 더 보면서 익혀야 할 것 같다.// 백트래킹 함수
function backtrack(index, path, used) { // 문자열 끝에 도달했을 때 if (index === inputs.length) { return path.length &gt; 0 ? path : null; } for (let length = 1; length &lt;= 2; length++) { if (index + length &gt; inputs.length) continue; // 현재 위치에서 length만큼의 숫자 추출 const num = parseInt(inputs.slice(index, index + length)); // 유효한 숫자인지 확인 if (isValid(num, used)) { // 현재 숫자를 사용했다고 표시 const newUsed = new Set(used); newUsed.add(num); // 다음 단계로 진행 const result = backtrack(index + length, [...path, num], newUsed); if (result) { return result; } } }
}
순열의 숫자의 경우 1~50까지의 수여야만 하기 때문에 수는 1자리 수가 될 수도 있고, 2자리 수가 될 수도 있다. 하지만 그 이상은 가지 못한다.
따라서 1자리 수와 2자리 수를 구분하여 백트래킹을 진행했다.function isValid(num, used) { return num &gt;= 1 &amp;&amp; num &lt;= Math.min(inputs.length, 50) &amp;&amp; !used.has(num);
}
해당 수가 유효한지 검사하는 함수의 경우 맨 처음엔 고정적으로 50까지의 수라 했으니 50을 해야겠다!라고만 생각했다. 하지만 이렇게 될 경우 나중에 더 큰 수가 나오면서 순열의 조건을 해치는 경우가 있을 수 있으므로 받은 문자열의 길이를 통해 최대한 가질 수 있는 순열의 수를 유추했다. 하지만 이렇게 유추했을 때 50을 넘어버리는 경우가 있기 때문에 Math.min을 통해 조건부로 조건을 넘겨줄 수 있도록 하였다.const result = backtrack(0, [], new Set()); // 결과가 있고, 유효한 순열인지 확인
if (result) { const maxNum = Math.max(...result); const expectedSet = new Set(Array.from({ length: maxNum }, (_, i) =&gt; i + 1)); const resultSet = new Set(result); // 1부터 maxNum까지의 모든 숫자가 정확히 한 번씩 사용되었는지 확인 if ( result.length === maxNum &amp;&amp; JSON.stringify([...expectedSet].sort()) === JSON.stringify([...resultSet].sort()) ) { console.log(result.join(" ")); }
} 백트래킹을 진행한 후에는 result에 순열이 담기게 되는데, 조건을 만족하는 것들이 여러개라면 하나만 받으면 되므로 조건이 맞았을 때 바로 return하도록 해서 그 후에 가져온 결과를 검사했다.
유효한 수인지를 검사하고 이에 따라 1~최대 순열의 길이까지의 수들이 모두 사용되었는지를 검사하여 결과를 내보냈다.백트래킹,,,,어렵군,,,,]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-10597]-순열장난.html</link><guid isPermaLink="false">알고리즘/[백준 10597] 순열장난.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Tue, 04 Feb 2025 03:14:41 GMT</pubDate><enclosure url="https://i.imgur.com/lK7ssOY.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/lK7ssOY.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[구현의 상세 추상화]]></title><description><![CDATA[한 사람이 코드를 읽을 때 동시에 고려할 수 있는 총 맥락의 숫자는 제한되어 있다고 한다.
그렇기 때문에 우리는 추상화를 통해서 불필요한 맥락을 줄여 코드를 읽기 쉽게 만듦으로써 좋은 코드를 만들 수 있다. 근데 이 프로그래밍에서 빠질 수 없는 추상화는 대체 무엇일까?추상화는 객체 지향 프로그래밍의 개념 중 하나이다.
"추상" 이라는 용어의 사전적 의미는 "사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것" 이라 정의한다.소프트웨어적으로 말하자면 복잡한 시스템의 세부 구현을 숨기고, 필요한 핵심적인 개념만을 드러내어 다룰 수 있도록 하는 개념이라고 말할 수 있다. 즉, 불필요한 세부사항을 감추고 중요한 정보만을 제공하는 방식인 것이다.그렇다면 추상화를 통해 우리가 얻는 것은 무엇일까?
복잡성 감소 불필요한 내부 동작을 숨기고 중요한 부분만 노출하여 코드의 가독성을 높이고 유지보수를 용이하게 함 모듈화와 재사용성 향상 여러 기능을 추상화하여 모듈화하면 코드가 독립적으로 동작할 수 있어 재사용성이 증가 유지보수성 향상 세부 구현을 감추고 인터페이스만 제공하면 내부 구현이 변경되어도 외부 코드에 미치는 영향을 최소화 아래 예시를 보자.function fetchUserData(userId: string) { return fetch(`https://api.example.com/users/${userId}`) .then((res) =&gt; res.json());
} // 사용자는 내부 요청 방식(Fetch API 등)을 몰라도 데이터를 가져올 수 있음
fetchUserData("123").then((data) =&gt; console.log(data)); fetchUserData()는 유저의 정보를 가져오는 api라는 것을 우리는 함수의 명을 통해 알 수 있다.
하지만 이 api는 그냥 부른다고 띡 되는게 아니다.이 안에는 Fetch문을 통해 Promise 기반의 http 요청을 보내야 하고, 이렇게 받은 요청에 대해서 체이닝을 통해 json 데이터로 변환하는 작업까지 담겨 있다.위에서 말하는 불필요한 세부사항은 바로 위에서 말한 것들이다. 우리는 요청을 보내는 과정에서 일어나는 것들을 굳이 그대로 쓰지 않고 한 단계 fetchUserData라는 함수로 추상화 함으로써 위와 같은 단계들을 하나의 함수명(중요한 정보) 을 통해서 알 수 있도록 하였다.이를 통해서 아 우리가 인식하지 않고 하고 있던 것들이 다 추상화였구나!를 깨달을 수 있었다. 함수를 나눠서 쓰는 것도 해당 함수에 꼭 필요한 내부 기능을 담게 코드를 작성하고 있었기 때문에 이 또한 추상화이기 때문이다.이번 Neo 프로젝트를 하면서 운이 좋게도 지인에게 코드 리뷰를 받을 수 있게 되었다.
나는 이 코드 리뷰에서 집중적으로 봐줬으면 좋을 것 같은 부분 중 '추상화'를 꼽았다.추상화는 물론 많은 작업들을 보다 간단하게 이해할 수 있게끔 해주는 좋은 역할을 가지고 있지만, 그렇다고 무조건 해야만 좋은 것도 아니다.
내가 쓰는 하나하나의 로직들을 전부 추상화하게 된다면, 프론트엔드에서는 컴포넌트를 계속 링크를 파고파고 들어가는 형태가 되어버린다. 결국 우리가 추상화를 하게 된 근본적인 이유는 보다 코드를 쉽게 이해하고 잘 재사용하기 위해서인데, 코드를 쉽게 이해하지도 못하고 재사용도 애매해지는 결과를 낳기도 한다. 이번에 직접 '섣부른 추상화'를 행하면서 깨달은 점이기도 하다.원래 코드는 아래와 같았다.// app/login/page.tsx
export default function Page() { const loginFormSchema = z.object({ email: z.string().email({ message: "유효한 이메일 주소가 아닙니다." }), password: z .string() .regex( /^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[@$!%*#?&amp;])[A-Za-z\d@$!%*#?&amp;]{8,}$/, { message: "비밀번호는 영문 대/소문자, 숫자, 특수문자를 포함하여 8자 이상이어야 합니다.", } ), }); const form = useForm&lt;z.infer&lt;typeof loginFormSchema&gt;&gt;({ resolver: zodResolver(loginFormSchema), defaultValues: { email: "", password: "", }, }); function onSubmit(values: z.infer&lt;typeof loginFormSchema&gt;) { console.log(values); } return ( &lt;div className="h-screen grid px-8"&gt; &lt;div className="flex flex-col items-center justify-center"&gt; &lt;Image src="/neo_emblem.svg" alt="logo" width={100} height={100} /&gt; &lt;span className="text-xl font-bold"&gt;NEO&lt;/span&gt; &lt;/div&gt; &lt;Form {...form}&gt; &lt;form onSubmit={form.handleSubmit(onSubmit)} className="flex flex-col gap-6" &gt; &lt;div className="flex flex-col gap-4"&gt; &lt;FormField control={form.control} name="email" render={({ field }) =&gt; ( &lt;FormItem&gt; &lt;FormLabel className="flex justify-between"&gt; &lt;span className="text-sm font-medium"&gt;이메일 주소&lt;/span&gt; &lt;/FormLabel&gt; &lt;FormControl&gt; &lt;Input placeholder="example@gmail.com" className="p-6 bg-gray-100 rounded-lg" {...field} /&gt; &lt;/FormControl&gt; &lt;/FormItem&gt; )} /&gt; &lt;FormField control={form.control} name="password" render={({ field }) =&gt; ( &lt;FormItem&gt; &lt;FormLabel className="flex justify-between"&gt; &lt;span className="text-sm font-medium"&gt;비밀번호&lt;/span&gt; &lt;/FormLabel&gt; &lt;FormControl&gt; &lt;Input className="p-6 bg-gray-100 rounded-lg" {...field} /&gt; &lt;/FormControl&gt; &lt;div className="flex justify-between"&gt; &lt;div className="flex items-center space-x-2"&gt; &lt;Checkbox id="remember" className="data-[state=checked]:bg-primary border-muted-foreground" /&gt; &lt;Label htmlFor="remember" className="text-sm font-medium text-muted-foreground leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70" &gt; 비밀번호 기억하기 &lt;/Label&gt; &lt;/div&gt; &lt;Button variant="link" className="text-sm text-primary" asChild &gt; &lt;Link href="/forgot-password"&gt; 계정을 잃어버리셨나요? &lt;/Link&gt; &lt;/Button&gt; &lt;/div&gt; &lt;/FormItem&gt; )} /&gt; &lt;/div&gt; &lt;div className="flex flex-col gap-2"&gt; &lt;Button type="submit" variant="default" className="w-full flex items-center justify-center gap-2 p-6 rounded-lg hover:opacity-90 hover:bg-primary" &gt; &lt;span className="text-lg font-base"&gt;다음&lt;/span&gt; &lt;ChevronRight className="w-6 h-6" /&gt; &lt;/Button&gt; &lt;div className="flex justify-center items-center gap-2"&gt; &lt;span className="text-sm text-muted-foreground"&gt; 아직 회원이 아니신가요? &lt;/span&gt; &lt;Button variant="link" className="text-sm text-primary" asChild&gt; &lt;Link href="/signup"&gt;회원가입하기&lt;/Link&gt; &lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/Form&gt; &lt;div className="flex flex-col gap-8"&gt; &lt;div className="relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t after:border-border"&gt; &lt;span className="relative z-10 bg-background px-2 text-muted-foreground"&gt; 또는 10초만에 로그인 · 회원가입 하기 &lt;/span&gt; &lt;/div&gt; &lt;Button variant="outline" className="w-full p-6 rounded-lg"&gt; &lt;Image src="/auth/google_emblem.svg" alt="google" width={20} height={20} /&gt; &lt;span className="text-base font-light"&gt;구글 로그인&lt;/span&gt; &lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; );
}
나는 처음에 거의 150줄이 넘어가는 코드의 개수를 보자마자 '아 이건 추상화를 해야겠다'라고 생각했다.
일단 나는 100줄이 넘어가는 하나의 페이지는 무조건 지양해야 한다고 생각했기 때문이다.
그래서 내가 생각했던 추상화는
자체 로그인 부분만 loginForm으로 추상화 loginForm에서 공통으로 쓰이는 FormField내의 컴포넌트 구성을 loginFormField로 추상화 소셜 로그인 버튼을 socialLoginButton으로 추상화
로그인에 필요한 스키마를 해당 파일에서 선언하는 것이 아닌 다른 곳으로 분리
login에 필요한 server action을 추상화
react-hook-form에서 쓰이는 훅을 추상화
정도로 나눠지게 되었다.
import { LoginForm } from "@/app/(auth)/login/loginForm";
import SocialLoginButton from "@/components/ui/socialLoginButton";
import Image from "next/image"; export default function Page() { return ( &lt;div className="h-screen grid px-8 relative"&gt; &lt;div className="flex flex-col items-center justify-center"&gt; &lt;Image src="/neo_emblem.svg" alt="logo" width={100} height={100} /&gt; &lt;span className="text-xl font-bold"&gt;NEO&lt;/span&gt; &lt;/div&gt; &lt;LoginForm /&gt; &lt;div className="flex flex-col gap-8"&gt; &lt;div className="relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t after:border-border"&gt; &lt;span className="relative z-10 bg-background px-2 text-muted-foreground"&gt; 또는 10초만에 로그인 · 회원가입 하기 &lt;/span&gt; &lt;/div&gt; &lt;div className="w-full flex flex-col justify-center items-center gap-5"&gt; &lt;SocialLoginButton type="kakao" /&gt; &lt;SocialLoginButton type="google" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );
}
그렇게 추상화한 결과 page는 이렇게 확실히 코드가 줄어지게 되었다.
하지만 해당 추상화가 정말 잘된 추상화일까?이번에 내가 했던 코드 리뷰에서 이런 이야기가 나왔다.
<img src="https://i.imgur.com/NyroIXU.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">나는 요게 맞는 말이라고 생각한다.
url은 비단 링크 정도의 기능만을 하는 것이 아니다. 각각의 페이지 모두 html 문서, js, css를 불러오는 get api를 불러오기 때문에 routing 또한 RESTFUL하게 이루어져야 한다.Next.js에서 app 라우터는 page라는 파일에 라우팅된다. 그러므로 app/login은 로그인이라는 자원을 불러온다는 의미기도 한데, 이미 route를 통해서 login이라는 추상화를 이루어냈음에도 불구하고 여기서 form을 따로 나누는 것은 불필요한 추상화가 아니었나 생각한다.
또한 loginForm을 나누고, 이 form에서 가지고 있는 hook까지 커스텀 훅으로 빼게 되니 코드의 수가 더 늘어났다.물론 이게 나와 협업하는 다른 개발자들이 보기에 조금 더 편할 수 있다면 LOC가 늘어나는 것은 괜찮다고 생각하지만 문제는 평탄하게 뿌려진 폴더 구조였다.
나는 어찌보면 route 하나하나가 각 도메인을 의미한다고 생각했기에 여기에 필요한 훅, 컴포넌트, 스키마 등을 나누었다.<br><img src="https://i.imgur.com/9xqqng5.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">원래대로라면 page.tsx가 하나만 있어야 할텐데 너무 늘어나 이에 대한 배경지식이 없다면 코드의 가독성이 더 떨어져 보이는 듯한 효과를 주는 것을 느끼게 되었다.또한 Login쪽에서 관리하는 Hook을 보자export function useLogin() { const { supabase } = useAuth(); const router = useRouter(); const { open: openErrorModal, switchModal, setMessage: setErrorMessage, message: errorMessage, } = useModal(); const form = useForm&lt;loginFormSchemaType&gt;({ resolver: zodResolver(loginFormSchema), defaultValues: { email: "", password: "", }, }); const { mutate, isPending } = useMutation({ mutationFn: handleEmailLogin, onSuccess: () =&gt; router.push("/"), onError: (error) =&gt; { if (error instanceof Error) { setErrorMessage(error.message); switchModal(); } else { setErrorMessage( "서버 상의 이유로 실패하였습니다.\n 잠시 후 다시 시도해 주세요." ); switchModal(); } }, }); function submit(values: loginFormSchemaType) { const { email, password } = values; mutate({ email, password, supabase }); } return { form, submit, openErrorModal, switchModal, setErrorMessage, isPending, errorMessage, };
} useLoginForm이라는 비즈니스 로직을 추상화한 하나의 커스텀 훅에 너무 많은 역할들이 혼재하고 있다.
서버 상태 관리, 에러 상태 관리, 폼 관리를 하나의 훅으로 추상화하면서 어찌보면 이렇게 많은 역할들을 한번에 이해하기란 쉽지 않을 것 같다고 다시 코드를 봤을 때 느끼게 되었다.이번 코드 리뷰를 통해 '추상화' 라는 것이 무조건 내 코드의 품질을 높여주는 silver bullet이 아닌, '잘' 추상화 해야지만 추상화의 이점을 가질 수 있음을 깨달았다. 따라서 이번에 조금 더 추상화를 어떻게 더 '좋은 코드' 로 만들 수 있을까에 대해서 계속해서 고민하고 시도해가면서 감을 익혀나가야겠다. ]]></description><link>https://alsgud8311.github.io/프로젝트/neo/구현의-상세-추상화.html</link><guid isPermaLink="false">프로젝트/Neo/구현의 상세 추상화.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Mon, 03 Feb 2025 16:06:04 GMT</pubDate><enclosure url="https://i.imgur.com/NyroIXU.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/NyroIXU.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Neo]]></title><description><![CDATA[Neo는 생성형 ai를 활용한 개인별 웹소설 창작 서비스입니다.
Neo를 통해서는
개인별 생성형 ai를 통한 맞춤 소설 제작
Neo에 존재하는 웹소설을 내 마음대로 다시쓰기
등의 서비스를 제공합니다.
<a data-href="axios를 떠나보내기" href="https://alsgud8311.github.io/프로젝트/neo/axios를-떠나보내기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">axios를 떠나보내기</a><br>
<a data-href="반응형을 자바스크립트로 해보기" href="https://alsgud8311.github.io/프로젝트/neo/반응형을-자바스크립트로-해보기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">반응형을 자바스크립트로 해보기</a><br>
<a data-href="구현의 상세 추상화" href="https://alsgud8311.github.io/프로젝트/neo/구현의-상세-추상화.html#_0" class="internal-link" target="_self" rel="noopener nofollow">구현의 상세 추상화</a>]]></description><link>https://alsgud8311.github.io/프로젝트/neo/neo.html</link><guid isPermaLink="false">프로젝트/Neo/Neo.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Mon, 03 Feb 2025 15:24:33 GMT</pubDate></item><item><title><![CDATA[[백준 6064] 카잉 달력]]></title><description><![CDATA[<img src="https://i.imgur.com/HAeNjXs.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">카잉 제국의 달력은 각 년도를 &lt;x:y&gt;와 같은 형식으로 표현한다
시초에 해당하는 첫번째 해를 &lt;1:1&gt;로 표현하고
두번째 해를 &lt;2:2&gt;로 표현한다.&lt;x:y&gt;의 다음 해는 &lt;x':y'&gt;로, x&lt;M이면 x' = x+1, x=M이면 x'=1이다. 이는 y도 N과 비교했을 때 똑같이 작용한다.
M=10, N=12일 때
첫번째 해 &lt;1:1&gt; 11번째 해의 경우 &lt;11:11&gt;이지만 10번째 해로 넘어갈 때 x쪽의 값은 10까지 갔지만 열한번째 해로 넘어가면서 x는 M과 같은 상태이기 때문에 다시 1로 변했다. y의 경우는 N이 12이므로 11이 그대로 넘어가 &lt;1:11&gt; 이 되었다. 13번째 해의 경우
- &lt;13:13&gt;이지만 11번째 해로 넘어갈 때 이미 x는 1로 변했다. 그렇기 때문에 2가 더해져 3이 되고, y의 경우는 N이 12이기 때문에 13이 되는 순간 1이 되었다.
따라서 여기에서 알 수 있는 내용은 각 M, N에 따라서 x는 x%M, y는 y%N이 된다는 점이다.
이런 식으로 달력은 넘어간다.
우리가 풀어야 할 것은 각 줄마다 M, N, x, y가 주어지는데, 여기서 &lt;x:y&gt;를 보고 몇번째 해인지 맞춰야 한다.하지만 여기서 고려해야 할 사항이 있다.<br>
<img src="https://i.imgur.com/mqbQsxR.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
위 예제처럼 카잉 달력이 유효하지 않은 경우, -1을 출력하도록 하였다. 그러므로 선형으로 브루트포스하게 푸는 것은 되지 않는다.
그러므로 제대로 계산이 되지 않을 수도 있다는 것이다. 이 예외까지 고려할 수 있는 로직을 생각해보아야 한다.가장 먼저 생각난 것은 재귀 방식으로 푸는 것이다.
어디서 시작했든 현재 가지고 있는 카잉 달력에서 계속 계산을 해나가다보면 유효한 달력일 경우 언젠가 1 1의 형태가 나올 것이다.
또한 유효하지 않은 카잉 달력일 경우, 계속 재귀적으로 달력을 구해 나가다가 x에서 가장 큰 수인 M이고, N이 가장 큰 수가 된다면 이건 영원히 끝나지 않을 것이라 생각할 수 있다.다시금 x는 x%M, y는 y%N이 된다는 사실을 떠올리자.
그렇다면 한 년도에 각각 M,N으로 나누었을 때 나머지가 x,y처럼 나와야 한다는 뜻이기도 하다.
그럼 그 년도를 어떻게 찾을까?
x,y의 나머지가 남는 년도에서 교집합을 찾으면 될 것 같다
첫번째 입력의 경우
10의 배수 + 3 해서 나오는 수들과 12의 배수 + 9 해서 나오는 수들 중에 교집합이 있는지 보면 x의 경우 -&gt; 3, 13, 23, 33, 43, 53..(3 + 10n)
y의 경우 -&gt; 9, 21, 33, 45, 57, 69...(9 + 12n)
이렇게 첫 수를 각각 x, y로 둔 M, N의 등차수열임을 알 수 있다.
그렇다면 이 두 공차의 최소공배수를 기준으로 이 달력이 반복된다는 것이기 때문에 해당 최대공배수 전까지 루프를 돌면서 x,y가 조건에 만족하는 해가 있는지 찾아보면 된다.
유클리드 호제법은 x를 y로 나눈 나머지는 r일 때, x, y의 최대공약수는 y, r의 최대공약수와 같다는 원리이다.
이 원리를 사용해 x값에 y를 대입하고, y값에 r을 대입하면 r이 0이 될 때 둘의 최대공약수인 것이다.
그리고 최소공배수는 두 수의 곱에 최대공약수로 나누면 나온다.function gcd(a, b) { if (a &lt; b) { const temp = a; a = b; b = temp; } while (b != 0) { const temp = a % b; a = b; b = temp; }
} function lcm(a, b) { (a * b) / gcd(a, b);
} 10과 12의 최대공약수를 구해보면 2가 나온다.
최소공배수는 두 수의 곱 / 최대공약수 이므로10 * 12 / 2 = 60이다.
따라서 우리는 최소공배수인 60을 주기로 달력이 반복된다는 사실을 알 수 있고, 이전까지만 루프를 돌아서 공통되는 년도를 찾으면 된다.function findYear(M, N, x, y) { const maxYear = lcm(M, N); let year = x; while (year &lt;= maxYear) { if (year === 0) { if (y === x) return maxYear; } else if (year % N === y || (year % N === 0 &amp;&amp; y === N)) { return year; } year += M; } return -1;
}
x를 기준으로 3, 13, 23, 33...이렇게 올라가지만서도 최소공배수인 120까지만 루프를 돌면서 y가 조건에 맞을 때가 있는지 확인한다.
조건에 맞는 경우는
x가 가지는 연도 중에 N으로 나눴을 때 y의 나머지가 나오는 경우
x가 가지는 연도 중에 N으로 나눴을 때 나머지가 없고 최대년도에 딱 맞춘 숫자일 때
이기 때문에 루프를 돌면서 검사하고, 만약 return문으로 빠져나가지 못했다면 서로 공통이 되는 숫자가 없다는 뜻이므로 -1을 출력한다.
const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const [t, ...rest] = require("fs") .readFileSync(INPUT_FILE) .toString() .trim() .split("\n"); function gcd(a, b) { while (b !== 0) { const r = a % b; a = b; b = r; } return a;
} function lcm(a, b) { return (a * b) / gcd(a, b);
} function findYear(M, N, x, y) { const maxYear = lcm(M, N); let year = x; while (year &lt;= maxYear) { if (year === 0) { if (y === x) return maxYear; } else if (year % N === y || (year % N === 0 &amp;&amp; y === N)) { return year; } year += M; } return -1;
} rest.forEach((input) =&gt; { const [M, N, x, y] = input.split(" ").map(Number); console.log(findYear(M, N, x, y));
}); ]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-6064]-카잉-달력.html</link><guid isPermaLink="false">알고리즘/[백준 6064] 카잉 달력.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Mon, 03 Feb 2025 07:58:57 GMT</pubDate><enclosure url="https://i.imgur.com/HAeNjXs.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/HAeNjXs.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Backend]]></title><description><![CDATA[
<a data-href="트랜잭션과 비즈니스 로직" href="https://alsgud8311.github.io/학습-정리/backend/트랜잭션과-비즈니스-로직.html#_0" class="internal-link" target="_self" rel="noopener nofollow">트랜잭션과 비즈니스 로직</a>
<br><a data-href="express+pug로 templating해서 SSR + CSR 구현하기" href="https://alsgud8311.github.io/학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">express+pug로 templating해서 SSR + CSR 구현하기</a>
<br><a data-href="mysql Join" href="https://alsgud8311.github.io/학습-정리/backend/mysql-join.html#_0" class="internal-link" target="_self" rel="noopener nofollow">mysql Join</a>
<br><a data-href="Node.js Libuv에 대한 고찰" href="https://alsgud8311.github.io/학습-정리/backend/node.js-libuv에-대한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Node.js Libuv에 대한 고찰</a>
<br><a data-href="Passport의 로컬 인증전략" href="https://alsgud8311.github.io/학습-정리/backend/passport의-로컬-인증전략.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Passport의 로컬 인증전략</a>
<br><a data-href="REST API" href="https://alsgud8311.github.io/학습-정리/backend/rest-api.html#_0" class="internal-link" target="_self" rel="noopener nofollow">REST API</a>
<br><a data-href="sql 트리거" href="https://alsgud8311.github.io/학습-정리/backend/sql-트리거.html#_0" class="internal-link" target="_self" rel="noopener nofollow">sql 트리거</a>
<br><a data-href="sql 기본문법" href="https://alsgud8311.github.io/학습-정리/backend/sql-기본문법.html#_0" class="internal-link" target="_self" rel="noopener nofollow">sql 기본문법</a>
]]></description><link>https://alsgud8311.github.io/학습-정리/backend/backend.html</link><guid isPermaLink="false">학습 정리/Backend/Backend.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 16:45:06 GMT</pubDate></item><item><title><![CDATA[학습 정리]]></title><description><![CDATA[
<a data-href="배럴 파일에 대한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">배럴 파일에 대한 고찰</a>
<br><a data-href="클로저에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/javascript/클로저에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">클로저에 관한 고찰</a>
<br><a data-href="setInterval과 setTimeout에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">setInterval과 setTimeout에 관한 고찰</a>
<br><a data-href="this 바인딩과 간접 호출" href="https://alsgud8311.github.io/학습-정리/frontend/javascript/this-바인딩과-간접-호출.html#_0" class="internal-link" target="_self" rel="noopener nofollow">this 바인딩과 간접 호출</a> <br><a data-href="Concurrent mode" href="https://alsgud8311.github.io/학습-정리/frontend/react/concurrent-mode.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Concurrent mode</a>
<br><a data-href="Error boundary와 Suspense" href="https://alsgud8311.github.io/학습-정리/frontend/react/error-boundary와-suspense.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Error boundary와 Suspense</a>
<br><a data-href="JSX에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/react/jsx에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">JSX에 관한 고찰</a>
<br><a data-href="React 19 베타에서 새롭게 추가된 것들" href="https://alsgud8311.github.io/학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React 19 베타에서 새롭게 추가된 것들</a>
<br><a data-href="React Fiber에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/react/react-fiber에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React Fiber에 관한 고찰</a>
<br><a data-href="React Portal" href="https://alsgud8311.github.io/학습-정리/frontend/react/react-portal.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React Portal</a>
<br><a data-href="useEffect에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/react/useeffect에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">useEffect에 관한 고찰</a>
<br><a data-href="useMemo와 useCallback에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">useMemo와 useCallback에 관한 고찰</a> <br><a data-href="Tailwind 설정하기" href="https://alsgud8311.github.io/학습-정리/frontend/others/tailwind-설정하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Tailwind 설정하기</a>
<br><a data-href="Prettier 설정하기" href="https://alsgud8311.github.io/학습-정리/frontend/others/prettier-설정하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Prettier 설정하기</a>
<br><a data-href="aws 배포" href="https://alsgud8311.github.io/학습-정리/frontend/others/aws-배포.html#_0" class="internal-link" target="_self" rel="noopener nofollow">aws 배포</a>
<br><a data-href="firebase functions" href="https://alsgud8311.github.io/학습-정리/frontend/others/firebase-functions.html#_0" class="internal-link" target="_self" rel="noopener nofollow">firebase functions</a>
<br><a data-href="NOSQL 맛보기" href="https://alsgud8311.github.io/학습-정리/frontend/others/nosql-맛보기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">NOSQL 맛보기</a> <br><a data-href="트랜잭션과 비즈니스 로직" href="https://alsgud8311.github.io/학습-정리/backend/트랜잭션과-비즈니스-로직.html#_0" class="internal-link" target="_self" rel="noopener nofollow">트랜잭션과 비즈니스 로직</a>
<br><a data-href="express+pug로 templating해서 SSR + CSR 구현하기" href="https://alsgud8311.github.io/학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">express+pug로 templating해서 SSR + CSR 구현하기</a>
<br><a data-href="mysql Join" href="https://alsgud8311.github.io/학습-정리/backend/mysql-join.html#_0" class="internal-link" target="_self" rel="noopener nofollow">mysql Join</a>
<br><a data-href="Node.js Libuv에 대한 고찰" href="https://alsgud8311.github.io/학습-정리/backend/node.js-libuv에-대한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Node.js Libuv에 대한 고찰</a>
<br><a data-href="Passport의 로컬 인증전략" href="https://alsgud8311.github.io/학습-정리/backend/passport의-로컬-인증전략.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Passport의 로컬 인증전략</a>
<br><a data-href="REST API" href="https://alsgud8311.github.io/학습-정리/backend/rest-api.html#_0" class="internal-link" target="_self" rel="noopener nofollow">REST API</a>
<br><a data-href="sql 트리거" href="https://alsgud8311.github.io/학습-정리/backend/sql-트리거.html#_0" class="internal-link" target="_self" rel="noopener nofollow">sql 트리거</a>
<br><a data-href="sql 기본문법" href="https://alsgud8311.github.io/학습-정리/backend/sql-기본문법.html#_0" class="internal-link" target="_self" rel="noopener nofollow">sql 기본문법</a> <br><a data-href="fsd 패턴" href="https://alsgud8311.github.io/학습-정리/design-pattern/fsd-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">fsd 패턴</a>
<br><a data-href="MVC패턴" href="https://alsgud8311.github.io/학습-정리/design-pattern/mvc패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">MVC패턴</a>
<br><a data-href="Observer 패턴" href="https://alsgud8311.github.io/학습-정리/design-pattern/observer-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Observer 패턴</a>
<br><a data-href="Pub-Sub 패턴" href="https://alsgud8311.github.io/학습-정리/design-pattern/pub-sub-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Pub-Sub 패턴</a>
]]></description><link>https://alsgud8311.github.io/학습-정리/학습-정리.html</link><guid isPermaLink="false">학습 정리/학습 정리.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 16:44:45 GMT</pubDate></item><item><title><![CDATA[Computer Science]]></title><description><![CDATA[
<a data-href="운영체제" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제</a>
<br><a data-href="브라우저의 렌더링과 캔버스" href="https://alsgud8311.github.io/학습-정리/computer-science/브라우저의-렌더링과-캔버스.html#_0" class="internal-link" target="_self" rel="noopener nofollow">브라우저의 렌더링과 캔버스</a>
<br><a data-href="쓰레드 풀이란?" href="https://alsgud8311.github.io/.html" class="internal-link" target="_self" rel="noopener nofollow">쓰레드 풀이란?</a>
<br><a data-href="이벤트 루프와 비동기" href="https://alsgud8311.github.io/학습-정리/computer-science/이벤트-루프와-비동기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">이벤트 루프와 비동기</a>
<br><a data-href="이벤트 전파와 위임에 대한 고찰" href="https://alsgud8311.github.io/학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">이벤트 전파와 위임에 대한 고찰</a>
<br><a data-href="쿠키와 세션" href="https://alsgud8311.github.io/학습-정리/computer-science/쿠키와-세션.html#_0" class="internal-link" target="_self" rel="noopener nofollow">쿠키와 세션</a>
<br><a data-href="Broadcast, Unicast, Multicast" href="https://alsgud8311.github.io/학습-정리/computer-science/broadcast,-unicast,-multicast.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Broadcast, Unicast, Multicast</a>
<br><a data-href="OSI 7 Layer" href="https://alsgud8311.github.io/학습-정리/computer-science/osi-7-layer.html#_0" class="internal-link" target="_self" rel="noopener nofollow">OSI 7 Layer</a>
<br><a data-href="TCP-IP" href="https://alsgud8311.github.io/학습-정리/computer-science/tcp-ip.html#_0" class="internal-link" target="_self" rel="noopener nofollow">TCP-IP</a>
<br><a data-href="TELNET과 SSH" href="https://alsgud8311.github.io/학습-정리/computer-science/telnet과-ssh.html#_0" class="internal-link" target="_self" rel="noopener nofollow">TELNET과 SSH</a>
<br><a data-href="HTTP란?" href="https://alsgud8311.github.io/.html" class="internal-link" target="_self" rel="noopener nofollow">HTTP란?</a>
<br><a data-href="HTTP 세션" href="https://alsgud8311.github.io/학습-정리/computer-science/http-세션.html#_0" class="internal-link" target="_self" rel="noopener nofollow">HTTP 세션</a>
<br><a data-href="HTTP 메시지" href="https://alsgud8311.github.io/학습-정리/computer-science/http-메시지.html#_0" class="internal-link" target="_self" rel="noopener nofollow">HTTP 메시지</a>
<br><a data-href="HTTP3" href="https://alsgud8311.github.io/학습-정리/computer-science/http3.html#_0" class="internal-link" target="_self" rel="noopener nofollow">HTTP3</a>
]]></description><link>https://alsgud8311.github.io/학습-정리/computer-science/computer-science.html</link><guid isPermaLink="false">학습 정리/Computer Science/Computer Science.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 16:44:42 GMT</pubDate></item><item><title><![CDATA[Design Pattern]]></title><description><![CDATA[
<a data-href="fsd 패턴" href="https://alsgud8311.github.io/학습-정리/design-pattern/fsd-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">fsd 패턴</a>
<br><a data-href="MVC패턴" href="https://alsgud8311.github.io/학습-정리/design-pattern/mvc패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">MVC패턴</a>
<br><a data-href="Observer 패턴" href="https://alsgud8311.github.io/학습-정리/design-pattern/observer-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Observer 패턴</a>
<br><a data-href="Pub-Sub 패턴" href="https://alsgud8311.github.io/학습-정리/design-pattern/pub-sub-패턴.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Pub-Sub 패턴</a>
]]></description><link>https://alsgud8311.github.io/학습-정리/design-pattern/design-pattern.html</link><guid isPermaLink="false">학습 정리/Design Pattern/Design Pattern.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 16:43:58 GMT</pubDate></item><item><title><![CDATA[Others(Frontend)]]></title><description><![CDATA[
<a data-href="Tailwind 설정하기" href="https://alsgud8311.github.io/학습-정리/frontend/others/tailwind-설정하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Tailwind 설정하기</a>
<br><a data-href="Prettier 설정하기" href="https://alsgud8311.github.io/학습-정리/frontend/others/prettier-설정하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Prettier 설정하기</a>
<br><a data-href="aws 배포" href="https://alsgud8311.github.io/학습-정리/frontend/others/aws-배포.html#_0" class="internal-link" target="_self" rel="noopener nofollow">aws 배포</a>
<br><a data-href="firebase functions" href="https://alsgud8311.github.io/학습-정리/frontend/others/firebase-functions.html#_0" class="internal-link" target="_self" rel="noopener nofollow">firebase functions</a>
<br><a data-href="NOSQL 맛보기" href="https://alsgud8311.github.io/학습-정리/frontend/others/nosql-맛보기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">NOSQL 맛보기</a>
]]></description><link>https://alsgud8311.github.io/학습-정리/frontend/others/others(frontend).html</link><guid isPermaLink="false">학습 정리/Frontend/Others/Others(Frontend).md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 16:43:37 GMT</pubDate></item><item><title><![CDATA[React]]></title><description><![CDATA[
<a data-href="Concurrent mode" href="https://alsgud8311.github.io/학습-정리/frontend/react/concurrent-mode.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Concurrent mode</a>
<br><a data-href="Error boundary와 Suspense" href="https://alsgud8311.github.io/학습-정리/frontend/react/error-boundary와-suspense.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Error boundary와 Suspense</a>
<br><a data-href="JSX에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/react/jsx에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">JSX에 관한 고찰</a>
<br><a data-href="React 19 베타에서 새롭게 추가된 것들" href="https://alsgud8311.github.io/학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React 19 베타에서 새롭게 추가된 것들</a>
<br><a data-href="React Fiber에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/react/react-fiber에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React Fiber에 관한 고찰</a>
<br><a data-href="React Portal" href="https://alsgud8311.github.io/학습-정리/frontend/react/react-portal.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React Portal</a>
<br><a data-href="useEffect에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/react/useeffect에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">useEffect에 관한 고찰</a>
<br><a data-href="useMemo와 useCallback에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">useMemo와 useCallback에 관한 고찰</a>
]]></description><link>https://alsgud8311.github.io/학습-정리/frontend/react/react.html</link><guid isPermaLink="false">학습 정리/Frontend/React/React.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 16:42:25 GMT</pubDate></item><item><title><![CDATA[Javascript]]></title><description><![CDATA[
<a data-href="배럴 파일에 대한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">배럴 파일에 대한 고찰</a>
<br><a data-href="클로저에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/javascript/클로저에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">클로저에 관한 고찰</a>
<br><a data-href="setInterval과 setTimeout에 관한 고찰" href="https://alsgud8311.github.io/학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html#_0" class="internal-link" target="_self" rel="noopener nofollow">setInterval과 setTimeout에 관한 고찰</a>
<br><a data-href="this 바인딩과 간접 호출" href="https://alsgud8311.github.io/학습-정리/frontend/javascript/this-바인딩과-간접-호출.html#_0" class="internal-link" target="_self" rel="noopener nofollow">this 바인딩과 간접 호출</a>
]]></description><link>https://alsgud8311.github.io/학습-정리/frontend/javascript/javascript.html</link><guid isPermaLink="false">학습 정리/Frontend/Javascript/Javascript.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 16:41:46 GMT</pubDate></item><item><title><![CDATA[Boomap]]></title><description><![CDATA[<a data-href="react-konva를 이용하여 원 사이 라인 그리기" href="https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">react-konva를 이용하여 원 사이 라인 그리기</a><br>
<a data-href="react-konva를 이용하여 노드 추가기능 구현하기" href="https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">react-konva를 이용하여 노드 추가기능 구현하기</a><br>
<a data-href="react-konva를 이용하여 원 사이 충돌 방지 시키기" href="https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">react-konva를 이용하여 원 사이 충돌 방지 시키기</a>]]></description><link>https://alsgud8311.github.io/프로젝트/boomap/boomap.html</link><guid isPermaLink="false">프로젝트/Boomap/Boomap.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 16:39:03 GMT</pubDate></item><item><title><![CDATA[운영체제]]></title><description><![CDATA[ <a data-href="운영체제_1주차_기본 구성요소, 명령어 수행, 인터럽트" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_1주차_기본 구성요소, 명령어 수행, 인터럽트</a><br>
<a data-href="운영체제_메모리 계층 구조, 캐시 메모리, IO연산 기법, 멀티프로세서와 멀티코어" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_메모리 계층 구조, 캐시 메모리, IO연산 기법, 멀티프로세서와 멀티코어</a><br>
<a data-href="운영체제_운영체제의 목적 및 기능" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_운영체제의 목적 및 기능</a><br>
<a data-href="운영체제_운영체제 개요_최근 운영체제로의 발전" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_운영체제 개요_최근 운영체제로의 발전</a><br>
<a data-href="운영체제_운영체제 개요_결함 허용" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_운영체제 개요_결함 허용</a><br>
<a data-href="운영체제_운영체제 개요_멀티프로세서와 멀티코어를 위한 운영체제 설계 사항" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_운영체제 개요_멀티프로세서와 멀티코어를 위한 운영체제 설계 사항</a><br>
<a data-href="운영체제_프로세스 기술과 제어_프로세스란?,프로세스 상태" href="https://alsgud8311.github.io/.html" class="internal-link" target="_self" rel="noopener nofollow">운영체제_프로세스 기술과 제어_프로세스란?,프로세스 상태</a><br>
<a data-href="운영체제_프로세스 기술과 제어_프로세스 기술" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_프로세스 기술과 제어_프로세스 기술</a><br>
<a data-href="운영체제_프로세스 기술과 제어_프로세스 제어" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_프로세스 기술과 제어_프로세스 제어</a><br>
<a data-href="운영체제_프로세스 기술과 제어_운영체제의 수행" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_프로세스 기술과 제어_운영체제의 수행</a><br>
<a data-href="운영체제_스레드_프로세스와 스레드" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_스레드_프로세스와 스레드</a><br>
<a data-href="운영체제_스레드_스레드의 유형" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_스레드_스레드의 유형</a><br>
<a data-href="운영체제_스레드_멀티코어와 멀티스레딩" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_스레드_멀티코어와 멀티스레딩</a><br>
<a data-href="운영체제_병행성_병행성의 원리" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_병행성_병행성의 원리</a><br>
<a data-href="운영체제_병행성_상호 배제-하드웨어 지원" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_병행성_상호 배제-하드웨어 지원</a><br>
<a data-href="운영체제_병행성_세마포어" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_병행성_세마포어</a><br>
<a data-href="운영체제_병행성_모니터" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_병행성_모니터</a><br>
<a data-href="운영체제_병행성_교착상태와 기아상태_교착상태의 원리" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_병행성_교착상태와 기아상태_교착상태의 원리</a><br>
<a data-href="운영체제_병행성_교착상태와 기아상태_교착상태 예방,회피,발견" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_병행성_교착상태와 기아상태_교착상태 예방,회피,발견</a><br>
<a data-href="운영체제_병행성_교착상태와 기아상태_교착상태 발견" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_병행성_교착상태와 기아상태_교착상태 발견</a><br>
<a data-href="운영체제_병행성_교착상태와 기아상태_식사하는 철학자 문제" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_병행성_교착상태와 기아상태_식사하는 철학자 문제</a><br><a data-href="운영체제_메모리 관리_메모리 관리 요구조건" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_메모리 관리_메모리 관리 요구조건</a><br>
<a data-href="운영체제_메모리 관리_메모리 분할(memory partitioning)" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_메모리 관리_메모리 분할(memory partitioning)</a><br>
<a data-href="운영체제_메모리 관리_페이징" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_메모리 관리_페이징</a><br>
<a data-href="운영체제_메모리 관리_세그먼테이션" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_메모리 관리_세그먼테이션</a><br>
<a data-href="운영체제_가상 메모리_하드웨어와 제어구조" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_가상 메모리_하드웨어와 제어구조</a><br>
<a data-href="운영체제_가상메모리_운영체제 소프트웨어" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_가상메모리_운영체제 소프트웨어</a><br>
<a data-href="운영체제_가상메모리_Linux, Windows의 가상 메모리" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_가상메모리_Linux, Windows의 가상 메모리</a><br>
<a data-href="운영체제_단일처리기 스케줄링_처리기 스케줄링의 유형" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_단일처리기 스케줄링_처리기 스케줄링의 유형</a><br>
<a data-href="운영체제_단일처리기 스케줄링_스케줄링 알고리즘" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_단일처리기 스케줄링_스케줄링 알고리즘</a><br>
<a data-href="운영체제_입출력 관리와 디스크 스케줄링_입출력 장치, 입출력 기능 구성" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_입출력 관리와 디스크 스케줄링_입출력 장치, 입출력 기능 구성</a><br>
<a data-href="운영체제_입출력 관리와 디스크 스케줄링_운영체제 설계 이슈" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_입출력 관리와 디스크 스케줄링_운영체제 설계 이슈</a><br>
<a data-href="운영체제_입출력 관리와 디스크 스케줄링_입출력 버퍼링" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_입출력 관리와 디스크 스케줄링_입출력 버퍼링</a><br><a data-href="운영체제_입출력 관리와 디스크 스케줄링_디스크 스케줄링" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_입출력 관리와 디스크 스케줄링_디스크 스케줄링</a><br>
<a data-href="운영체제_입출력 관리와 디스크 스케줄링_RAID" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_입출력 관리와 디스크 스케줄링_RAID</a><br>
<a data-href="운영체제_입출력 관리와 디스크 스케줄링_디스크 캐시" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_입출력 관리와 디스크 스케줄링_디스크 캐시</a><br>
<a data-href="운영체제_입출력 관리와 디스크 스케줄링_UNIX SVR4의 입출력" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_입출력 관리와 디스크 스케줄링_UNIX SVR4의 입출력</a><br>
<a data-href="운영체제_파일 관리_개요" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_파일 관리_개요</a><br>
<a data-href="운영체제_파일 관리_파일 구성과 접근" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_파일 관리_파일 구성과 접근</a><br>
<a data-href="운영체제_파일 관리_B-트리, 파일 디렉토리" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_파일 관리_B-트리, 파일 디렉토리</a><br>
<a data-href="운영체제_파일관리_파일 공유와 레코드 블로킹" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_파일관리_파일 공유와 레코드 블로킹</a><br>
<a data-href="운영체제_파일관리_보조 저장공간 관리" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_파일관리_보조 저장공간 관리</a><br>
<a data-href="운영체제_파일 관리_UNIX의 파일 관리" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_파일 관리_UNIX의 파일 관리</a><br>
<a data-href="운영체제_파일 관리_Linux의 가상파일시스템과 windows 파일 시스템" href="https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html#_0" class="internal-link" target="_self" rel="noopener nofollow">운영체제_파일 관리_Linux의 가상파일시스템과 windows 파일 시스템</a>]]></description><link>https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제.html</link><guid isPermaLink="false">학습 정리/Computer Science/운영체제/운영체제.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 16:36:43 GMT</pubDate></item><item><title><![CDATA[반응형을 자바스크립트로 해보기]]></title><description><![CDATA[이제는 어느 사이트를 가든 반응형 페이지가 디폴트로 되어 있다. 항상 고정적인 레이아웃을 가지게 되면 모바일 디바이스부터 데스크톱까지 다양한 환경이 있음에도 불구하고 같은 화면을 보게 되는 거니 사용자 경험상으로 좋지 않다. 그렇기에 서비스를 디자인 할 때는 반응형으로 많이 신경쓰는 편이다.웹 페이지의 디자인과 레이아웃이 모든 화면 크기에 자동으로 맞춰지는 디자인이다. 데스크탑에서 페이지를 늘렸다 줄였다 하면 이에 맞춰서 화면의 디자인이 바뀌는게 반응형 디자인이다.다른 방식의 유연한 웹 디자인 기술로는 적응형 디자인이 있다.
적응형 디자인의 경우 웹 페이지에서 감지된 기기를 기반으로 미리 만드레어진 정적인 레이아웃을 불러오는 것으로 각 화면 크기마다 이에 맞는 레이아웃을 따로 디자인을 해야 한다. 이 방식은 각각 저마다의 장단점을 지닌다.import * as React from "react" const MOBILE_BREAKPOINT = 768 export function useIsMobile() { const [isMobile, setIsMobile] = React.useState&lt;boolean | undefined&gt;(undefined) React.useEffect(() =&gt; { const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`) const onChange = () =&gt; { setIsMobile(window.innerWidth &lt; MOBILE_BREAKPOINT) } mql.addEventListener("change", onChange) setIsMobile(window.innerWidth &lt; MOBILE_BREAKPOINT) return () =&gt; mql.removeEventListener("change", onChange) }, []) return !!isMobile
} 나는 여기서 모바일과 데스크톱 환경 정도만 구분한 뒤에, 데스크톱의 경우에는 따로 미디어 쿼리를 추가하는 방식으로 ]]></description><link>https://alsgud8311.github.io/프로젝트/neo/반응형을-자바스크립트로-해보기.html</link><guid isPermaLink="false">프로젝트/Neo/반응형을 자바스크립트로 해보기.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 31 Jan 2025 11:25:02 GMT</pubDate></item><item><title><![CDATA[axios를 떠나보내기]]></title><description><![CDATA[이제까지 리액트 프로젝트를 하면서 가장 고정적으로 쓰였던 리액트 외의 라이브러리라고 한다면 단언컨데 axios일 것이다.axios는 &nbsp;XMLHttpRequest를 기반으로 만들어진 라이브러리로, 우리가 이제까지 귀찮게 http요청을 보내면서 하던 인터셉터, timeout 등의 설정을 간단하게 구현할 수 있기 때문에 확실히 개발비용을 줄여주던 라이브러리이다.하지만 이번에 Nextjs 프로젝트를 시작하면서 예상치 못하게 axios의 필요성에 대해서 다시금 생각해보았다.
XMLHttpRequest의 경우 매우 오래된 http 요청이기 때문에 상대적으로 최근에 나온 fetch api의 성능이 좋아 굳이 XMLHttpRequest를 써야 하나?에 대한 의문을 가지는 사람이 많아졌다.
서버 컴포넌트에서 window 객체 참조 문제
Next.js의 자체 캐싱 시스템과의 충돌
JavaScript가 비활성화된 환경에서 무한 로딩 이슈
]]></description><link>https://alsgud8311.github.io/프로젝트/neo/axios를-떠나보내기.html</link><guid isPermaLink="false">프로젝트/Neo/axios를 떠나보내기.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Tue, 28 Jan 2025 08:49:49 GMT</pubDate></item><item><title><![CDATA[부스트캠프 회고]]></title><description><![CDATA[<img src="https://i.imgur.com/ueLbsul.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
부스트캠프 멤버십을 수료했다.
살면서 개발을 이렇게 열심히 해본 적은 처음이었던 것 같다(개발시작 1.5년차)
매일 슬랙에 체크인아웃을 하던게 엊그제같은데 이제는 평일에 체크인아웃이 없으니 뭔가 허전한 느낌이 들기도 한다.아무튼 부스트캠프가 끝나고 헐레벌떡 바로 어제 리눅스 마스터 시험이 있어서 급하게 준비하고 보고 이제는 조금 여유가 생겨 회고를 쓰기로 했다.
그냥 깨달은 것들을 중점적으로 생각나는 대로 두서없이 쓸 예정이니 의식의 흐름 주의,,,이번 회고에서는 특히 내가 성장한 경험을 위주로 작성할 예정이다.솔직히 냉정하게 말하자면.. 내가 이전까지 했던 프로젝트나 동아리 활동 모두 프론트엔드 개발에 있어서는 크게 동료에게 받는 깨달음 내지 배움은 거의 없었다고 생각한다.항상 내가 주도적으로 말하면 동료들이 어찌저찌 따라오기만 할 뿐, 기술적인 인사이트를 얻거나 코드에 대한 생산적인 리뷰 하나 받아보지 못했다. 물론 다들 인간적으로 너무 좋은 사람들이지만 이런 부분에 대해서는 항상 아쉬움을 느꼈던 것 같다.<br>
<img src="https://i.imgur.com/4he9qEP.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
물론 제대로 된 PR을 올리지도 못했던 내 잘못도 있다고 생각한다.
하지만 이런 LGTM 남발만 받다보니 내 스스로도 이게 좋은 코드인지에 대해서 의구심이 들었지만 물어볼 사람조차 없었다. 그렇기 때문에 더더욱 스터디 그룹별로 계속해서 코드리뷰를 받는다는 부스트캠프의 운영방식이 괜찮을까? 생각했었다.하지만 부스트캠프에 들어오면서 동료 피드백에 대한 많은 생각이 바뀌게 되었다.
예상 외로 부스트캠프에 함께 하는 사람들은 정말 열심히 코드를 리뷰해주었으며, 내가 생전 처음 들어보는 키워드나 기능들을 말씀하시는걸 캐치하여 학습하면서 많은 것들을 새롭게 알아낼 수 있었다.
더불어 나도 다른 분들이 정성들여 해주시는 만큼 나도 열심히 해야겠다고 생각하다보니 열심히 다른 분들의 코드를 읽게 되고, 자연스럽게 남들의 코드를 읽는 능력 또한 많이 늘었다.프로젝트에서는 매일 평균적으로 14시간정도를 코딩을 하는데 쓰면서 심적으로나 육체적으로 많이 약해졌었다. 그러다보니 나도 모르게 예민했던 적이 많았던 것 같다.<br> <img src="https://i.imgur.com/YKj0zpS.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그럼에도 불구하고 좋은 동료가 있었기에 제대로 프로젝트를 끝낼 수 있었다고 생각한다.
트러블이 생길 수도 있을 뻔한 일이 있었다. 하지만 그렇다고 서로가 감정이 끝나는 상태에서 끝내지 않고, 솔직하게 서로의 감정을 털어내고 진심으로 사과하면서 모두가 다시 힘낼 수 있었다. 성숙한 태도를 가지는 동료들을 만난게 정말 행운이라고 생각한다.<br><img src="https://i.imgur.com/71VG8i8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그리고 무엇보다 다같이 힘들면 더 끈끈해진다고 하지 않는가.
다같이 힘들다보니 서로 배려해주고 응원해주면서 동료와의 끈끈한 우정을 통해 함께 프로젝트까지 야무지게 끝낼 수 있었다.<br><img src="https://i.imgur.com/HHqg3Se.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">무엇보다 부스트캠프를 통해 가장 많이 얻어간 것은 학습 방법과 다양한 학습 키워드라고 생각한다.
부스트캠프에 들어오기 이전까지는 뭘 해야할 지 몰라서 제대로 학습을 못했었다면, 부스트캠프에서는 너무 공부하고 싶은 것들도 많았고 공부해야 하는 것들도 많았다.생전 처음 들어보는 키워드들이 난무했다. 하지만 부스트캠프에서는 이를 무조건 A부터 Z까지 알려주는 것이 아닌 스스로 학습하고 깨달아야 한다. 결국 이를 어떻게 학습해서 소화시키냐는 온전히 학습하는 사람의 몫인 것이다.<br><img src="https://i.imgur.com/Bzw1VfA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">나 또한 그렇게 던져주는 학습 키워드들을 모두 흡수하지는 못했다고 생각한다. 부스트캠프가 끝난 지금까지도 학습 부채는 있기 때문에 시간이 날 때마다 틈틈히 정리해둘 예정이다.<br><img src="https://i.imgur.com/31FM193.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">아무튼 이렇게 던져주는 학습 키워드들을 줍고 이 학습 키워드에 대해서 직접 처음부터 정리해가며 문서화해나가는 과정을 통해 어떻게 '학습'해야 하는지에 대해 나름 나에게 가장 잘 맞는 학습 방식을 정립해 나갔다고 생각한다. 이러한 과정을 체험하길 장려했던 부스트캠프가 정말 개발자의 기본을 가르치는 곳이구나 깨달았다.부스트캠프에서는 모든 활동에 대해서 기록, 즉 문서화를 강조한다.
나 또한 문서화는 조금씩 하고 있었지만 사실 이 문서화가 정말 중요한 걸까에 대해서는 스스로도 제대로 답을 내리지 못했다. 비록 기술 블로그는 조금씩 정리하고 있다고는 해도 부스트캠프가 강조하는 정도를 보면 이정도는 살짝 광기인 것 같은데.. 라는 생각이 들고는 했다.하지만 요즘 들어서는 문서화의 중요성을 깨달아가고있다.
가장 기본적으로 문서화 과정은 나의 경험이나 학습을 글로 정리하는 과정인데, 사실 한번에 제대로 완벽한 문서를 만들기 쉽지 않다. 결국 일반 글쓰기와 다름 없이 몇 번의 퇴고를 통해서 비로소 온전한 문서 하나가 완성된다. 이 과정에서 내가 어떻게 이 경험, 학습을 기억해야 할 지 정리하면서 글을 써내려가다보니 머릿속에서도 자연스럽게 정리되는 느낌이 들었다. 그러다보니 비단 문서뿐만 아니라 머리에서도 이 글의 맥락을 모두 이해할 수 있었기에 이를 다시 말로 풀 때면 술술 나오는 느낌을 받았다. 또한 학습 과정에서 연관된 키워드 중에 까먹는 경우도 있기 때문에 이게 뭐였더라 싶은게 꽤 있었는데 내 문서를 찾아보면 내가 이해하기 쉽게 정리해놓은 문서가 있는 경우가 있었다. 이를 다시 읽고 개념을 다시금 이해하는 과정을 통해서 보다 장기적으로 기억이 저장되는 느낌을 받을 수 있었다.결국 이러한 문서화를 하는 일련의 과정 자체가 전부 나에게 알게모르게 영향을 끼치고 있었음을 깨닫고 아 이래서 문서화가 중요했구나를 깨닫게 되었다.<br><img src="https://i.imgur.com/apguQFZ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">문서화의 중요성을 깨달은 만큼 이제는 문서화를 귀찮아 하지 않고 열심히 퀄리티 좋은 문서를 만들기 위해서 노력할 생각이다.위에서도 말했다시피 부스트캠프가 끝난 후 나는 바로 리눅스마스터 시험을 준비하고 보고 왔다.<br><img src="https://i.imgur.com/z1TX6hP.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">솔직히 부스트캠프 전까지는 내가 리눅스를 공부하게 될 줄은 꿈에도 상상하지 못했다. 프론트엔드 개발자가 리눅스를? 이라는 생각이 들었기 때문이다.하지만 부스트캠프 과정에서 백엔드, 프론트엔드를 모두 경험하며 내가 내린 결론은 프론트엔드 개발자, 백엔드 개발자는 모두 개발자이다 였다.<br>
<img src="https://i.imgur.com/LQTjYbM.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
무슨 당연한 소리냐고 물어볼 수도 있다.
내가 생각하는 프론트엔드 개발자나 백엔드 개발자는 자신이 조금 더 특화되어있는 분야가 앞에 붙을 뿐이지 이들은 모두 개발자로 추상화된다. 따라서 프백 상관없이 개발자로서 서로의 코드를 어느정도는 알고 있어야 하며 이를 위한 배경지식은 '개발자'에게의 공통사항이라고 생각한다. 물론 각자가 공부해야 하는 것들은 엄청 다르기 때문에 차이는 날 수 있더라도 이를 완전히 프백이 서로 완전히 독립적인 객체라고 생각하고 학습하게 되면 시야의 폭이 좁아질 수밖에 없다고 생각한다. 부캠 전의 나처럼아무튼 나는 그래서 부스트캠프가 끝난 후 프백을 가리지 않고 다양하게 학습할 계획이다. 기본적인 CS지식을 다시금 탄탄하게 잡고, 이를 기반으로 프론트엔드 개발을 하면서도 백엔드의 아키텍처와 객체 지향 프로그래밍 등등 폭넓게 학습할 것이다.<br>
<img src="https://i.imgur.com/ioFEXUX.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
벌써부터 공부해야 할 것들이 태산이라 잘 할 수 있을까 걱정도 되지만서도 나름 부캠도 잘 끝냈는데 앞으로도 잘 되겠지! 하는 마음으로 열심히 해보려고 한다.<br><img src="https://i.imgur.com/9KbOMTr.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>https://alsgud8311.github.io/회고/부스트캠프-회고.html</link><guid isPermaLink="false">회고/부스트캠프 회고.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 15 Dec 2024 16:19:23 GMT</pubDate><enclosure url="https://i.imgur.com/ueLbsul.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/ueLbsul.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Error boundary와 Suspense]]></title><description><![CDATA[클라이언트에서 오류를 받게 되면 UI가 그대로 없어지는 현상을 많이 보았을 것이다.
하지만 이러한 현상은 사용자경험에 있어서는 치명적인 오류가 아닐 수 없다.
그렇기 때문에 Error boundary를 설정함으로써 깨진 컴포넌트 트리 대신 Fallback UI, 즉 대체할 수 있는 UI를 보여줄 수 있도록 해서 에러를 관리하는 패턴이다.리액트에서는 버전 16부터 이를 도입하여 렌더링 도중의 생명주기 / 하위 트리 에서 에러를 잡아낼 수 있도록 클래스형 컴포넌트에 두 가지 생명주기 메서드를 도입했다.
static getDerivedStateFromError()
componentDidCatch() 하지만 다음과 같은 에러는 잡지 못하니 주의하자. 이벤트 핸들러
비동기적 코드 (예: setTimeout 혹은 requestAnimationFrame 콜백)
서버 사이드 렌더링
자식에서가 아닌 에러 경계 자체에서 발생하는 에러 class ErrorBoundary extends React.Component { constructor(props) { super(props) this.state = { hasError: false } } static getDerivedStateFromError(error) { // 다음 렌더링에서 폴백 UI가 보이도록 상태를 업데이트 return { hasError: true } } componentDidCatch(error, errorInfo) { // 에러 로그 찍기 logErrorToMyService(error, errorInfo) } render() { if (this.state.hasError) { // 폴백 UI를 커스텀하여 렌더링시키기 return &lt;h1&gt;Something went wrong.&lt;/h1&gt; } return this.props.children }
}
이렇게 만들어진 클래스형 컴포넌트는 &lt;ErrorBoundary&gt; &lt;App /&gt;
&lt;/ErrorBoundary&gt;
이런 식으로 프로젝트 자체를 전부 래핑하여 오류를 발견하고, 에러가 보일 시에 다른 텍스트를 통해 UI로 돌아가게끔 할 수 있다.
하지만 위와 같이 제공해준 생명주기 메서드는 훅이 있는 함수형 컴포넌트에서는 사용이 불가능하다.그래서 클래스형으로 고차 컴포넌트를 만들고, 이를 감싸는 바운더리 컴포넌트를 통해 관리하는 것으로 보인다.import React from "react" type ErrorHandler = (error: Error, info: React.ErrorInfo) =&gt; void
type ErrorHandlingComponent&lt;Props&gt; = (props: Props, error?: Error) =&gt; React.ReactNode type ErrorState = { error?: Error } export default function withCatch&lt;Props extends {}&gt;( component: ErrorHandlingComponent&lt;Props&gt;, errorHandler?: ErrorHandler
): React.ComponentType&lt;Props&gt; { function Inner(props: { error?: Error, props: Props }) { return &lt;React.Fragment&gt;{component(props, error)}&lt;/React.Fragment&gt; } return class extends React.Component&lt;Props, ErrorState&gt; { state: ErrorState = { error: undefined } static getDerivedStateFromError(error: Error) { return { error } } componentDidCatch(error: Error, info: React.ErrorInfo) { if (errorHandler) { errorHandler(error, info) } } render() { return &lt;Inner error={this.state.error} props={this.props} /&gt; } }
}
해당 컴포넌트는 고차 컴포넌트(Higher-Order Component, HOC)로 만들어 졌으며, 자식 컴포넌트의 에러를 잡아내고 처리하는 기능을 추가한 버전이다. 함수형 컴포넌트처럼 생겼지만서도 내부에서는 클래스형 컴포넌트를 이용해서 구현하였다.
해당 컴포넌트는 children을 받는 것처럼 안쪽의 요소를 받아 그대로 컴포넌트로 에러 상태를 내려준다.Inner라는 함수형 컴포넌트를 통해 안쪽에 에러 바운더리를 설정하는데, 이를 에러의 상태를 잡아 캐치하게 되면 error에는 해당 에러의 내용이 담기게 되고, 에러가 있을 경우 getDerivedStateFromError에 에러가 담기게 되며, state가 업데이트 되고, componentDidCatch가 실행되어 해당 에러에 대해 처리를 하게 된다.따라서 에러 처리를 단계별로 나누어보자면
컴포넌트 생성: Catch 함수를 통해 에러 바운더리 역할을 하는 클래스형 컴포넌트를 반환
렌더링: 컴포넌트가 렌더링될 때, 자식 컴포넌트(Inner)가 호출되어 에러 또는 정상적인 props로 렌더링됩니다.
에러 발생 시: 자식 컴포넌트에서 에러가 발생하면, getDerivedStateFromError 메서드가 호출되어 state.error가 설정되고 이 상태에 따라 에러가 렌더링됩니다.
에러 후처리: 에러가 발생하면 componentDidCatch에서 에러 핸들러가 동작할 수 있습니다.
이러한 방식은 라이브러리인 react-error-boundary에서도 비슷한 방식으로 활용한다.import { isDevelopment } from "#is-development";
import { Component, createElement, ErrorInfo, isValidElement } from "react";
import { ErrorBoundaryContext } from "./ErrorBoundaryContext";
import { ErrorBoundaryProps, FallbackProps } from "./types"; type ErrorBoundaryState = | { didCatch: true; error: any; } | { didCatch: false; error: null; }; const initialState: ErrorBoundaryState = { didCatch: false, error: null,
}; export class ErrorBoundary extends Component&lt; ErrorBoundaryProps, ErrorBoundaryState
&gt; { constructor(props: ErrorBoundaryProps) { super(props); this.resetErrorBoundary = this.resetErrorBoundary.bind(this); this.state = initialState; } static getDerivedStateFromError(error: Error) { return { didCatch: true, error }; } resetErrorBoundary(...args: any[]) { const { error } = this.state; if (error !== null) { this.props.onReset?.({ args, reason: "imperative-api", }); this.setState(initialState); } } componentDidCatch(error: Error, info: ErrorInfo) { this.props.onError?.(error, info); } componentDidUpdate( prevProps: ErrorBoundaryProps, prevState: ErrorBoundaryState ) { const { didCatch } = this.state; const { resetKeys } = this.props; // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array, // we'd end up resetting the error boundary immediately. // This would likely trigger a second error to be thrown. // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set. if ( didCatch &amp;&amp; prevState.error !== null &amp;&amp; hasArrayChanged(prevProps.resetKeys, resetKeys) ) { this.props.onReset?.({ next: resetKeys, prev: prevProps.resetKeys, reason: "keys", }); this.setState(initialState); } } render() { const { children, fallbackRender, FallbackComponent, fallback } = this.props; const { didCatch, error } = this.state; let childToRender = children; if (didCatch) { const props: FallbackProps = { error, resetErrorBoundary: this.resetErrorBoundary, }; if (typeof fallbackRender === "function") { childToRender = fallbackRender(props); } else if (FallbackComponent) { childToRender = createElement(FallbackComponent, props); } else if (fallback === null || isValidElement(fallback)) { childToRender = fallback; } else { if (isDevelopment) { console.error( "react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop" ); } throw error; } } return createElement( ErrorBoundaryContext.Provider, { value: { didCatch, error, resetErrorBoundary: this.resetErrorBoundary, }, }, childToRender ); }
} function hasArrayChanged(a: any[] = [], b: any[] = []) { return ( a.length !== b.length || a.some((item, index) =&gt; !Object.is(item, b[index])) );
}
보다 리액트의 안쪽까지 들어가서 createElement를 통해 컴포넌트를 생성하고, Context를 이용해서 내려주는 방식을 사용하고 있다.아무튼 다시 위의 보다 간소화된 코드로 돌아가서,,import { Fragment } from "react/jsx-runtime";
import withCatch from "./withCatch"; type Props = { children: React.ReactNode;
}; const ErrorBoundary = withCatch(function ErrorBoundary( props: Props, error?: Error,
) { if (error) { return ( &lt;div&gt; &lt;h1&gt;{error.message}&lt;/h1&gt; &lt;/div&gt; ); } else { return &lt;Fragment&gt;{props.children}&lt;/Fragment&gt;; }
}); export default ErrorBoundary; 고차컴포넌트를 활용한 방식이다. 아까 만들어진 withCatch을 사용한다.해당 에러 바운더리 컴포넌트는 현재 withCatch 고차 컴포넌트 안에 컴포넌트가 들어가 있는 방식이다. function App() { return ( &lt;ErrorBoundary&gt; &lt;div className="flex w-[930px] flex-col gap-9"&gt; &lt;Header /&gt; &lt;ComponentA /&gt; &lt;ComponentB /&gt; &lt;/div&gt; &lt;/ErrorBoundary&gt; );
}
이런 식으로 Error Boundary 안에 children으로 안쪽 요소를 채워넣게 되는 형태가 되는데, 이 함수들의 흐름을 따라가면서 보다 자세하게 이해해보자.ErrorBoundary 컴포넌트의 props로는 children 속성으로 안에 들어가 있는 요소들이 들어가게 된다. container와 비슷한 느낌이라고 볼 수 있다.type Props = { children: React.ReactNode;
}; const ErrorBoundary = withCatch(function ErrorBoundary( props: Props, error?: Error,
) { if (error) { return ( &lt;div&gt; &lt;h1&gt;{error.message}&lt;/h1&gt; &lt;/div&gt; ); } else { return &lt;Fragment&gt;{props.children}&lt;/Fragment&gt;; }
});
ErroBoundary에는 컴포넌트를 withCatch가 감싸고 있다.
witchCatch로 넘어가보자export default function withCatch&lt;Props extends {}&gt;( component: ErrorHandlingComponent&lt;Props&gt;, errorHandler?: ErrorHandler
): React.ComponentType&lt;Props&gt;
withCatch는 에러를 핸들링하는 컴포넌트와 errorHandler를 가지게 된다.
이 component의 타입을 보자type ErrorHandlingComponent&lt;Props&gt; = ( props: Props, error?: Error,
) =&gt; React.ReactNode;
필요한 props를 제네릭을 통해 넘겨받고, 여기에 error까지 서비스로 받는다(없을 수도 있음).
그 error를 처리하는 로직을 담은 ErrorBoundary가 여기에 들어가는 것이다.type ErrorState = { error?: Error };
...
function Inner({ error, props }: { error?: Error; props: Props }) { return &lt;Fragment&gt;{component(props, error)}&lt;/Fragment&gt;; } return class extends Component&lt;Props, ErrorState&gt; { state: ErrorState = { error: undefined, }; static getDerivedStateFromError(error: Error) { return { error }; } componentDidCatch(error: Error, info: React.ErrorInfo) { if (errorHandler) { errorHandler(error, info); } } render() { return &lt;Inner error={this.state.error} props={this.props} /&gt;; } };
이렇게 Errorboundary를 넣었을 경우에, withCatch는 다시금 컴포넌트를 내뱉는다. 하지만 이번엔 ErrorState까지 상태로 가진 컴포넌트이다.클래스형 컴포넌트에서는 리액트의 생명주기가 있는데, 이 생명주기에서 getDerivedStateFromError를 통해 에러를 잡는다. 얘는 하위 컴포넌트에서 오류가 발생하면 호출되면서 해당 오류를 인자로 받는다.
에러가 발생한 뒤에 fallback UI를 렌더링 시키기 위해서는getDerivedStateFromError 를 통해 에러를 잡아야 한다. 얘는 하위 자식 컴포넌트에서 오류가 발생했을 때 render단계에서 호출된다.
호출이 되면서 state라는 프로퍼티에는 error가 들어가게 되고, 그 다음 Inner 컴포넌트를 리턴한다. 이 컴포넌트에서 받았던 props 속성 + error를 서비스로 받게 되는 것이다.function Inner({ error, props }: { error?: Error; props: Props }) { return &lt;Fragment&gt;{component(props, error)}&lt;/Fragment&gt;; }
그렇게 되면 해당 함수형 컴포넌트는 error와 props를 받아 Fragment 사이에 해당 컴포넌트 자체를 실행시켜 렌더링된 요소를 안쪽에 넣게 된다.const ErrorBoundary = withCatch(function ErrorBoundary( props: Props, error?: Error,
) { if (error) { return ( &lt;div&gt; &lt;h1&gt;{error.message}&lt;/h1&gt; &lt;/div&gt; ); } else { return &lt;Fragment&gt;{props.children}&lt;/Fragment&gt;; }
});
그렇게 안쪽으로 들어간 애가 얘다. 보면 서비스로 받은 error를 달고 있다.
그래서 얘는 하위 컴포넌트에서 에러가 발생했을 경우 error를 서비스로 받고 돌아오니까 이 error에 대해 처리를 해주기 위해 fallback UI를 띄우게 된다.
하지만 error가 없을 경우 정상적으로 실행되었다는 소리니 ErrorBoundary로 감쌌던 children들을 그대로 넣어준다.<img src="https://i.imgur.com/dhpGn7A.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이렇게 해서 만약 처음에 오류가 생기면 이와같이 에러를 받아 ErrorBoundary로 넘겨주고 Errorboundary가 이를 인지하고 해당 오류를 띄워주는 것이다!리액트에서는 throw에 대해서도 일반적으로 다 오류 취급하지 않는다.
만약 throw한 것이 Promise 객체라면 리액트는 이에 대해서 Pending상태인 Promise구나! 하고 해당 작업에 대해서 비동기적으로 실행시켜놓는다.
Promise는 resolve될 때해당 Promise에 대해서 실행한 결과를 const response = getHeadlines();
export default function ShortNews() {
...
}
...
//fetch하는 함수
export default function getHeadlines() { return fetchData&lt;Article[]&gt;(fetcher.get(HEADLINE_URI));
} 중요한 점은 컴포넌트의 밖에다가 선언해야 한다는 점이다
밖에다가 선언해놓지 않을 경우 리액트는 아무것도 모르는 상태에서 컴포넌트를 렌더링하려고 할 것이고, 그 과정에서 함수형 컴포넌트를 실행시키는데 fetch하게 된다면 이 때마다 Promise를 받고 다시금 요청하려고 하는데, 리렌더링이 무한히 되는 루프에 빠져버리고 만다.]]></description><link>https://alsgud8311.github.io/학습-정리/frontend/react/error-boundary와-suspense.html</link><guid isPermaLink="false">학습 정리/Frontend/React/Error boundary와 Suspense.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Tue, 19 Nov 2024 11:50:11 GMT</pubDate><enclosure url="https://i.imgur.com/dhpGn7A.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/dhpGn7A.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[react-konva를 이용하여 노드 추가기능 구현하기]]></title><description><![CDATA[
function averageLocation(children: number[], data: NodeData, parentNode?: Node) { if (!children.length) { return parentNode ? { x: parentNode.location.x + 30, y: parentNode.location.y + 30 } : { x: 0, y: 0 }; } const x = children.reduce((acc, curr) =&gt; data[curr.toString()].location.x + acc, 0) / children.length; const y = children.reduce((acc, curr) =&gt; data[curr.toString()].location.y + acc, 0) / children.length; return { x, y };
}
만약 x,y값을 기준으로 좌표를 평균내어 추가하게 된다면, 처음엔 문제 없이 children들의 평균값을 내거나, 만약 children이 없을 경우에는 자식이 생길 예정인 부모 노드의 x,y좌표에서 30씩 떨어져서 생성될 수 있도록 했다.하지만 해당 코드의 문제점은 만약 2개의 노드 사이에서 평균 x,y좌표를 구한 노드 1개가 생성된다고 할 때, 위치를 하나도 변경하지 않고 그대로 다시 추가를 누르면 평균값으로 나온 노드와 함께 평균을 다시 구하게 되므로 사실상 똑같은 평균 x,y좌표가 나올 수밖에 없다.더 큰 문제는 내가 데이터를 상태로 다루고 있는데, 이 상태가 업데이트 될 때마다 데이터를 dependency array에 두고 useEffect로 충돌 방지를 실행시키고 있다는 사실이었다.useEffect(() =&gt; { checkCollision(layer, updateNode); }, [data]);
내 충돌 방지의 로직의 허점은 두 노드가 완벽하게 포개질 때, 서로 무한대로 x +축을 향해 움직인다는 점이었다.//vector.ts
export function verticalVector(a: Location, b: Location) { return { x: a.y - b.y, y: b.x - a.x };
} export function unitVector(a: Location, b: Location) { const v = verticalVector(a, b); const vectorLength = Math.sqrt(v.x ** 2 + v.y ** 2); return { x: v.x / vectorLength, y: v.y / vectorLength };
} //addNode.ts
function getNewNodePosition(children: number[], data: NodeData, parentNode: Node) { if (!children.length) { return parentNode ? { x: parentNode.location.x + 30, y: parentNode.location.y + 30 } : { x: 0, y: 0 }; } const lastChildren = data[children[children.length - 1]]; const uv = unitVector(parentNode.location, lastChildren.location); return { x: lastChildren.location.x + uv.x * 50, y: lastChildren.location.y + uv.y * 50, };
}
요소에서 수직벡터를 구하는 공식은 기존 벡터를 구하는 공식에서 반대로 해서 x,y좌표를두 점 와 가 있을 때, 벡터 는 의 공식으로 구할 수 있다.하지만 우리가 구하는 것은 벡터에 대해 수작으로 그어지는 수직벡터를 구해 수직벡터 방향에서 내가 원하는 정도만큼 떨어진 거리를 만들어내는 것이므로, 수직벡터의 공식을 활용하여 구해야 한다.벡터 의 수직 벡터는 두 가지 방향으로 구할 수 있는데, 시계방향으로의 수직벡터와 반시계방향으로의 수직벡터이다. 시계 방향의 경우 로 계산할 수 있으며, 반시계방향의 경우는 의 공식으로 계산이 가능하다.
하지만 우리 프로젝트의 경우 처음 초기 데이터 생성 과정에서 만약에 ai를 통해 회의록을 업로드하고 여기서 키워드를 뽑아내어 마인드맵을 만든다고 할 때, 생성되는 키워드 노드들은 각각 시계방향으로 돌아가면서 생성되는 규칙을 가지고 있기 때문에 새롭게 만드는 하위 생성 노드의 경우도 시계방향으로 구하기로 했다.
// 두 점 사이의 벡터 구하기
export function vector(a: Location, b: Location) { return { x: b.x - a.x, y: b.y - a.y };
} // 벡터의 수직 벡터 구하기
export function perpendicularVector(v: { x: number; y: number }, clockwise: boolean = true) { return clockwise ? { x: -v.y, y: v.x } : { x: v.y, y: -v.x };
} vector 함수는 두 점 a와 b 사이의 벡터를 반환합니다.
perpendicularVector 함수는 주어진 벡터 v에 대해 clockwise 파라미터에 따라 시계 방향 또는 반시계 방향으로 회전된 수직 벡터를 반환합니다.
]]></description><link>https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html</link><guid isPermaLink="false">프로젝트/Boomap/react-konva를 이용하여 노드 추가기능 구현하기.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Wed, 13 Nov 2024 01:10:24 GMT</pubDate></item><item><title><![CDATA[react-konva를 이용하여 원 사이 충돌 방지 시키기]]></title><description><![CDATA[이번에 마인드맵을 react-konva로 구현하는 과정을 거치면서 마인드맵의 각 노드 간에 충돌을 방지시키지 않으면 여러 요소들이 겹쳐져 있는 상태가 나올 것이기 때문에, 이러한 충돌을 방지하고자 이에 관련되어 로직을 보강하기로 했다.type NodeProps = { parentNode?: Node; node: Node; depth: number; text: string; updateNode: (id: number, updatedNode: Node) =&gt; void;
}; function NodeComponent({ parentNode, node, depth, text, updateNode }: NodeProps) { return ( &lt;&gt; &lt;Circle id={node.id.toString()} onDragMove={(e) =&gt; { updateNode(node.id, { ...node, location: { x: e.target.x(), y: e.target.y(), }, }); }} onDragEnd={(e) =&gt; updateNode(node.id, { ...node, location: { x: e.target.x(), y: e.target.y(), }, }) } draggable x={node.location.x} y={node.location.y} fill={"white"} width={100} height={100} radius={70 - depth * 10} stroke="black" strokeWidth={3} /&gt; &lt;Text name="text" text={text} x={node.location.x - 20} y={node.location.y - 10} /&gt; {parentNode &amp;&amp; ( &lt;ConnectedLine from={parentNode.location} to={node.location} fromRadius={70 - (depth - 1) * 10 + 10} toRadius={70 - depth * 10 + 10} /&gt; )} &lt;/&gt; );
}
기본적인 노드의 정보는 이러하다. 만약 노드 간에 부모-자식 관계가 있다면 이런 식으로 react-konva의 Line을 커스텀한 ConnectedLine이라는 컴포넌트를 추가적으로 렌더링 하도록 했다.추가적으로 각 노드에는 dragmove와 dragend 이벤트를 달아서 해당 요소를 드래그 앤 드롭 시에 계속해서 상태를 바꾸면서 노드의 위치를 갱신할 수 있도록 했다.export type Node = { id: number; keyword: string; depth: number; location: Location; children: number[] | [];
}; type DrawNodeProps = { data: Node[]; root: Node; depth?: number; parentNode?: any; update?: (id: number, node: Node) =&gt; void;
}; export function DrawNodefromData({ data, root, depth = 0, parentNode, update }: DrawNodeProps) { return ( &lt;&gt; {/* from */} &lt;NodeComponent text={root.keyword} depth={depth} parentNode={parentNode} node={root} updateNode={update} /&gt; {/* to */} {root.children?.map((childNode, index) =&gt; ( &lt;DrawNodefromData data={data} key={index} root={data[childNode - 1]} depth={depth + 1} parentNode={root} update={update} /&gt; ))} &lt;/&gt; );
}
노드의 부모-자식을 렌더링하는 방식은 위와 같다. 모든 노드는 직렬화 되어있는 상태이고, children에는 노드의 id만을 가지고 있다.
노드의 id는 index를 1부터 시작하여 만들었기 때문에 계속해서 서브트리의 루트로 가게 될 때에는 root를 id값에서 1을 빼어 인덱스로 접근할 수 있도록 하였다.그렇다면 이 노드 사이에서 어떻게 충돌할 때의 문제를 해결할 수 있을까?
내가 생각했을 때 가장 기본적인 해결 방식은 '충돌이 됐을 때, 충돌당한 노드를 겹치지 않도록 밀어낸다' 였다. 그렇기 때문에, 나는 충돌한 각도를 어느정도 알고 있고, 밀어낼 때마다 각 원이 가져야 하는 최소 사이의 길이만 정한다면 이를 통해 리렌더링 과정에서 노드들을 피하게 할 수 있을 것 같았다.//...
const layer = useRef(null); useEffect(() =&gt; { layer.current.on("dragmove", (event) =&gt; checkCollision(layer, event, updateNodeList)); }, []);
가장 먼저 필요한 것은 layer에 이벤트를 다는 일이다. react-konva에서는 useRef를 layer에 달게 되면 layer 안의 모든 요소들이 jsx와 같은 요소처럼 접근할 수 있기 때문에, children에도 접근할 수 있다. 가장 처음에 생각한 방식은 무조건 맨 처음에 어떤 요소를 드래그해서 옮기기 시작하면 옮기는 이벤트가 발동될 때마다 layer 안에 있는 children들에 대해 모두 collision을 확인하고, 드래그하고 있는 요소들과 충돌하는 노드가 있는지 확인을 해야 했다.export function checkCollision(layer, event, update) { const dragTarget = event.target; const dragTargetRect = event.target.getClientRect(); layer.current.children.forEach((child) =&gt; { if ( !(child.attrs.name === "text") &amp;&amp; !(child.attrs.name === "line") &amp;&amp; isCollided(child, dragTarget, dragTargetRect) ) { const newPosition = moveOnCollision(child, dragTarget); update(parseInt(child.attrs.id), { location: newPosition }); } });
}
dragmove 이벤트가 발동될 때마다 해당 checkCollision 함수가 실행된다. 이벤트가 발동되면서 해당 함수에 이벤트 객체를 그대로 넘겨주어 이 함수에서 확인할 수 있도록 해주었다.
dragTarget의 경우, 현재 드래그 하고 있는 Target의 객체를 넘겨준다.
event 객체의 target property에서 getClientRect 메서드는 해당 요소가 가지고 있는 크기범위를 직사각형 형태로 나타내준다.<img src="https://i.imgur.com/6luPbOC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
요런 식으로 각도가 있는 요소들도 전부 직사각형의 범위로 측정한 값을 보내준다. 대부분 충돌 감지를 할 때는 위와 같이 충돌이라고 할 수 있는 범위를 직사각형 형태로 측정하여 감지하는 것으로 보았기 때문에 나 또한 이를 기준으로 측정했다. getClientRect()를 실행한 값을 dragTargetRect에 할당하였다.layer.current.children.forEach((child) =&gt; { if ( !(child.attrs.name === "text") &amp;&amp; !(child.attrs.name === "line") &amp;&amp; isCollided(child, dragTarget, dragTargetRect)
다음으로는 layer의 children에 접근하여 각각의 요소에 대해서 모두 해당 요소가 현재 드래그하고 있는 요소와 충돌되는지를 검사하도록 했다.여기서 !(child.attrs.name === "text") &amp;&amp; !(child.attrs.name === "line")가 들어간 이유는 layer의 children 안에는 비단 Circle 객체만 있는 것이 아닌, 같은 depth에 text와 line을 두었기 때문이다. 그렇게 되면 text와 line에 대해서도 충돌 감지를 하기 때문에 예상치 못한 부수효과를 가져올 수 있어 원에 대해서만 충돌 감지를 할 수 있도록 했다.export function isCollided(node, target, targetRect) { if (node === target) return false; return haveIntersection(node.getClientRect(), targetRect);
} function haveIntersection(r1, r2) { return !(r2.x &gt; r1.x + r1.width || r2.x + r2.width &lt; r1.x || r2.y &gt; r1.y + r1.height || r2.y + r2.height &lt; r1.y);
}
충돌을 감지하는 로직은 생각보다 어렵지 않다. 드래그 하고 있는 요소를 제외시키기만 하고, 나머지는 x,y 좌표가 서로 겹치는지만 검사하면 된다.
두 개의 원 r1,r2가 있다고 할 때, 각각의 요소에 대해서 x,y 좌표를 모두 충돌되어 있는지 검사하는 조건문을 넣었다.만약 충돌 검사 조건문에서 충돌이 되었다고 판단이 되면, 조건문 블록으로 넘어가 노드를 이동시키는 로직을 실행한다. const newPosition = moveOnCollision(child, dragTarget); update(parseInt(child.attrs.id), { location: newPosition });
moveOnCollision은 충돌된 요소가 가야 할 x,y좌표를 계산하는 함수이다. 이 함수의 결과를 newPosition에 할당하고 해당 좌표를 상태 업데이트 시켜주어 리렌더링이 바로 일어나면서 위치가 업데이트된다.function moveOnCollision(targetNode, draggedNode) { const dx = targetNode.attrs.x - draggedNode.attrs.x; const dy = targetNode.attrs.y - draggedNode.attrs.y; const angle = Math.atan2(dy, dx); const minDistance = 5; const moveX = Math.cos(angle) * minDistance; const moveY = Math.sin(angle) * minDistance; return { x: targetNode.attrs.x + moveX, y: targetNode.attrs.y + moveY, };
}
moveOnCollision은 충돌이 된targetNode와 충돌을 시킨draggedNode를 인자로 받는다. 각 객체에는 내가 attribute로 넘겼던 x,y,radius 등의 정보가 attrs에 담겨 있으므로 여기에 접근하여 값을 계산한다.dx,dy는 두 점 사이의 거리를 x,y좌표로 계산한 값이다. 먼저 두 점을 잇는 선을 빗변으로 직각삼각형을 그린 뒤, 역탄젠트를 통해서 각도를 구해야 하기 때문이다. Math.atan2는 아크탄젠트, 즉 역탄젠트를 구하는 Math 모듈의 함수이다.<br>
<a data-tooltip-position="top" aria-label="https://ko.khanacademy.org/math/geometry/hs-geo-trig/hs-geo-solve-for-an-angle/a/inverse-trig-functions-intro" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.khanacademy.org/math/geometry/hs-geo-trig/hs-geo-solve-for-an-angle/a/inverse-trig-functions-intro" target="_self">역탄젠트 알아보기</a> 아크탄젠트를 구했다면 해당 각도가 곧 충돌했을 때의 방향을 나타내는 각도이며, 라디안 값으로 나타난다.
이 각도에 x축의 경우 Math.cos, y축의 경우 Math.sin을 이용하여 각도 값을 x,y축 성분으로 변환하여 해당 방향으로 minDistance만큼 가도록 했다. 이 부분의 계산은 sin(angle) = a/c, cos(angle) = b/c 인 것을 생각했을 때, minDistance가 c로 간다고 생각했더니 이해가 나름 편했다(사실 아직도 잘 모름) 아무튼 여기서 minDistance는 두 원 사이에 어느 정도의 거리가 있어야 하는지를 나타내는 변수이며, 이를 각 사인(아크탄젠트값), 코사인(아크탄젠트값)에 곱해주면 x,y 축을 어느정도 옮겨야 하는지 알 수 있다.
마지막에는 기존 요소의 x,y 좌표에 이동해야 할 x,y의 값만큼을 더해주었다.그렇게 moveOnCollistion은 충돌이 일어난 요소들에 대해서 피할 수 있는 좌표 값을 주고, 이를 update(parseInt(child.attrs.id), { location: newPosition });를 통해서 업데이트 함으로서 노드의 상태를 다시금 업데이트하고 리렌더링이 일어나면서 캔버스에 반영된다.내가 생각했던 로직의 경우 이벤트가 일어난 타겟, 즉 해당 노드에서 다른 모든 노드들을 검색하고 현재 드래그 하고 있는 노드 객체와 충돌되는 다른 노드들에 대해서 충돌을 방지할 수 있도록 했다.
하지만 그럴 경우, 해당 노드와 충돌하는 경우만을 검색하기 때문에 사실상 충돌로 인해 움직인 노드가 움직이게 된다면, 사실상 움직인 노드가 다른 요소들과 충돌할 경우에 대해서는 고려하지 않았기 때문에 이 경우 움직인 노드가 다른 노드와 충돌하는 예외가 생기게 된다. 이런 식으로 충돌된 요소들끼리의 충돌은 적용하지 않는다.]]></description><link>https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html</link><guid isPermaLink="false">프로젝트/Boomap/react-konva를 이용하여 원 사이 충돌 방지 시키기.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 10 Nov 2024 14:21:23 GMT</pubDate><enclosure url="https://i.imgur.com/6luPbOC.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/6luPbOC.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[react-konva를 이용하여 원 사이 라인 그리기]]></title><description><![CDATA[import { Node } from "@/types/Node";
import { useEffect, useState } from "react";
import { Circle, Group, Layer, Line, Stage, Text } from "react-konva"; type NodeProps = { x: number; y: number; depth: number; text: string; setNodeLocation?: any;
}; function NodeComponent({ x, y, depth, text, setNodeLocation }: NodeProps) { return ( &lt;Group&gt; &lt;Circle draggable x={x} y={y} fill={"white"} radius={50 - depth * 5} stroke="black" strokeWidth={3} onDragMove={(e) =&gt; { setNodeLocation({ x: e.target.x(), y: e.target.y(), }); }} onDragEnd={(e) =&gt; setNodeLocation({ x: e.target.x(), y: e.target.y(), }) } /&gt; &lt;Text text={text} x={x - 20} y={y - 10} /&gt; &lt;/Group&gt; );
} type DrawNodeProps = { root: Node; x: number; y: number; depth?: number; parentPosition?: any; update?: () =&gt; void;
}; export function DrawNodefromData({ root, x, y, depth = 0, parentPosition, update }: DrawNodeProps) { const [nodeLocation, setNodeLocation] = useState(root.location); const nodeSpacing = 150; useEffect(() =&gt; { console.log(nodeLocation); }, [nodeLocation]); return ( &lt;&gt; {parentPosition &amp;&amp; ( &lt;Line points={[parentPosition.x, parentPosition.y, nodeLocation.x, nodeLocation.y]} stroke="gray" strokeWidth={2} /&gt; )} &lt;NodeComponent x={nodeLocation.x} y={nodeLocation.y} text={root.content} depth={depth} setNodeLocation={setNodeLocation} /&gt; {root.children?.map((childNode, index) =&gt; ( &lt;DrawNodefromData key={childNode.id} root={childNode} x={nodeLocation.x + (index - root.children!.length / 2) * nodeSpacing} y={nodeLocation.y + nodeSpacing} depth={depth + 1} parentPosition={nodeLocation} update={update} /&gt; ))} &lt;/&gt; );
} Line 함수형 컴포넌트는 points에 배열을 인자로 받음인자에는 [시작점x,시작점y, 끝점x, 끝점y] 가 들어감. 그럼 그대로 그 두 요소의 x,y 좌표 사이에 선을 그어줌state로 관리하고 있는 노드를 해당 인자의 값에 넣어주어 상태가 변할 때, 즉 x,y 좌표가 움직일 때 setter함수가 실행되는데 그 때마다 렌더링이 이루어지기 때문에 선은 이 x,y좌표에 따라 움직이게 됨<img src="https://i.imgur.com/c5Bekmc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 끝점, 만약 대분류-중분류-소분류로 이루어져 있는 마인드 맵에서 선을 이을 때, 끝점이 가르키는 x,y 좌표의 경우에는 원이 위로 가서 선이 보이지 않는 형태가 되지만 시작하는 점의 x,y좌표에서는 앞으로 와서 원의 중심저메에서 뻗어나가는 형태가 되어버림z-index를 주고 노드가 위로 올라가게 할 수도 있지만, 이는 정상적인 해결 방식이 아닌 임시 방편에 불과하다고 생각한다.따라서 다른 방식으로 노드를 이어보려고 하는데, 문제는 원 안에 있는 노드를 어떻게 잘라내느냐였다.현재 내가 알고 있는 정보는 시작점으로 되어 있는 점과 끝점이다. 이 점 사이의 거리를 이용하여 시작점에서 끝점으로 이어지는 선이 그어졌다고 가정했을 때, 이어져 있는 두 노드 간의 선에서 시작점의 선이 노드를 빠져나올 때의 가장자리가 가지는 x,y 값을 알 수 있을 것 같았다. 벡터 구하기:
시작 점의 좌표가 xc, yc이고, 이를 이어주려는 끝점의 좌표가 xp,yp라고 하자. 먼저, 원의 중심으로 향하는 방향을 나타내는 벡터를 구할 수 있다. 이 벡터는 임의의 점과 원의 중심 사이의 차이로 계산할 수 있다 벡터의 길이 구하기: 이제 이 벡터의 길이를 구해 방향을 정규화한다. 여기까지는 피타고라스의 정리를 통해 쉽게 구할 수 있다. 단위 벡터 구하기
벡터를 단위 벡터로 정규화하여 방향만 남기고 크기를 1로 만듭니다. 단위 벡터를 구하려면 원래 벡터의 각 성분을 벡터의 길이로 나눈다 가장자리 좌표 구하기
단위 벡터 방향으로 반지름만큼 이동하면, 원의 가장자리 좌표를 구할 수 있습니다. 원의 중심점에 단위 벡터의 성분을 각각 반지름 r만큼 곱해서 더하면 된다. // from 원의 중점에서 to 원의 중점으로 이어지는 선에서 from 선의 위치를 원의 중점이 아닌 가장자리의 위치 구하는 함수
function getCircleEdgePoint(from: Location, to: Location, r: number) { const dx = to.x - from.x; const dy = to.y - from.y; const vector = Math.sqrt(dx * dx + dy * dy); const xEdgePoint = Math.ceil(from.x + (r * dx) / vector); const yEdgePoint = Math.ceil(from.y + (r * dy) / vector); return { xEdgePoint, yEdgePoint, };
}
해당 함수를 통해 벡터 길이를 구하고, 반지름에 단위 벡터를 곱하여 가장자리가 어떤 좌표인지 x,y 각각의 좌표에 더해주어 곱했다.// Point의 인자로 만들어주는 함수
// 각각의 원에 대해서 가장자리 쪽으로 갈 수 있게끔 해줌
function getLinePoints(from: Location, to: Location, r: number) { const fromCircleEdgePoint = getCircleEdgePoint(from, to, r); const toCircleEdgePoint = getCircleEdgePoint(to, from, r); return [ fromCircleEdgePoint.xEdgePoint, fromCircleEdgePoint.yEdgePoint, toCircleEdgePoint.xEdgePoint, toCircleEdgePoint.yEdgePoint, ];
} type ConnectedLineProps = { from: Location; to: Location; radius: number;
}; export function ConnectedLine({ from, to, radius }: ConnectedLineProps) { return &lt;Line points={getLinePoints(from, to, radius)} stroke="gray" strokeWidth={2} /&gt;;
}
기존의 Line을 계속 활용하면서도 여기서 이어지는 선에 대해 원의 중점이 아닌, 각 원에서 뻗어나온 가장자리의 좌표로 선을 잇는 것이 이상적이기 때문에 이를 함수화했다.points 인자에 들어갈 값은 from과 to의 원 가장자리 좌표를 구해야 하는데, getCircleEdgePoint는 단일책임원칙을 지키기 위해 함수를 분리하여 한 원의 가장자리 좌표를 구하는 함수로 만들었다. 따라서 getLinePoints라는 함수를 따로 만들어 인자로 그대로 넣을 수 있는 함수로 활용할 수 있도록 하였다.<br><img src="https://i.imgur.com/Ymf6Gep.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
어딘가 미묘하게 두 선이 어느정도 띄워져있는지가 다른 것 같다..// from 원의 중점에서 to 원의 중점으로 이어지는 선에서 from 선의 위치를 원의 중점이 아닌 가장자리의 위치 구하는 함수
function getCircleEdgePoint(from: Location, to: Location, r: number) { const dx = to.x - from.x; const dy = to.y - from.y; const vector = Math.sqrt(dx * dx + dy * dy); const xEdgePoint = Math.ceil(from.x + (r * dx) / vector); const yEdgePoint = Math.ceil(from.y + (r * dy) / vector); return { xEdgePoint, yEdgePoint, };
}
코드를 살펴보며 생각해보니 나는 현재 분류에 따라서 하위 요소의 경우 depth를 조금씩 줄이고 있었는데, 더 작아지거나 커지는 선의 경우에는 사실상 from의 반지름을 가지고 계산했기 때문에 더 커졌던 문제를 가져온 것으로 보인다.// Point의 인자로 만들어주는 함수
// 각각의 원에 대해서 가장자리 쪽으로 갈 수 있게끔 해줌
export function getLinePoints(from: Location, to: Location, r: number) { const fromCircleEdgePoint = getCircleEdgePoint(from, to, r); const toCircleEdgePoint = getCircleEdgePoint(to, from, r); return [ fromCircleEdgePoint.xEdgePoint, fromCircleEdgePoint.yEdgePoint, toCircleEdgePoint.xEdgePoint, toCircleEdgePoint.yEdgePoint, ];
}
그러므로 고쳐야 할 것은 여기였던 것이다. from의 원이 가지는 원의 반지름과 to 원이 가지는 원의 반지름을 모두 받아야 했다.//depth가 70 - depth * 10 이라고 할 때
&lt;ConnectedLine from={parentPosition} to={nodeLocation} fromRadius={70 - (depth - 1) * 10 + 10} toRadius={70 - depth * 10 + 10} /&gt;
그렇게 되면 이런 식으로 두 원의 반지름을 모두 받고export function getLinePoints(from: Location, to: Location, fromRadius: number, toRadius: number) { const fromCircleEdgePoint = getCircleEdgePoint(from, to, fromRadius); const toCircleEdgePoint = getCircleEdgePoint(to, from, toRadius); return [ fromCircleEdgePoint.xEdgePoint, fromCircleEdgePoint.yEdgePoint, toCircleEdgePoint.xEdgePoint, toCircleEdgePoint.yEdgePoint, ];
}
계산 과정에서 각각의 반지름을 넣어주어 각각의 원에서 가장자리 좌표를 구할 수 있도록 해 주었다.<br><img src="https://i.imgur.com/aYk7867.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
어어... 그만..<br><img src="https://i.imgur.com/Y2MWzT2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">넘어가버리기~내가 기대한 것은 선이 서로에게 어느정도 가까이 닿거나 교집합이 생기기 시작하면 둘을 잇는 선이 생기지 않는 것이었다.하지만 이를 고려하지 않고 둘의 좌표를 무조건 계산하여 선을 그리다 보니 원이 근접했을 대에 원이 안쪽으로 파고드는 문제를 가지게 되었다.
나중에 충돌 방지를 넣는다면 이러한 문제는 어느정도 해소될 수 있지만, 나중에 예상치 못한 오류를 낳을 수도 있기 때문에 이러한 점도 고려하여 선을 그려야겠다 싶었다.// from 원의 중점에서 to 원의 중점으로 이어지는 선에서 from 선의 위치를 원의 중점이 아닌 가장자리의 위치 구하는 함수
export function getCircleEdgePoint(from: Location, to: Location, fromRadius: number, toRadius: number) { const dx = to.x - from.x; const dy = to.y - from.y; const vector = Math.sqrt(dx * dx + dy * dy); if (fromRadius + toRadius - vector &gt; 0) { return { xEdgePoint: 0, yEdgePoint: 0, }; } const xEdgePoint = Math.ceil(from.x + (fromRadius * dx) / vector); const yEdgePoint = Math.ceil(from.y + (fromRadius * dy) / vector); return { xEdgePoint, yEdgePoint, };
}
기존에 가장자리 구하는 함수에서도 그냥 fromRadius와 toRadius 를 둘 다 받은 다음에, 만약 두 원의 반지름을 더한 것이 벡터보다 커지게 된다면 이는 최대한 근접해있다는 사실을 알 수 있기 때문에 이런 경우 x좌표와 y좌표를 모두 0으로 줌으로써 라인이 생성되지 않도록 했다.]]></description><link>https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html</link><guid isPermaLink="false">프로젝트/Boomap/react-konva를 이용하여 원 사이 라인 그리기.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sat, 09 Nov 2024 07:25:20 GMT</pubDate><enclosure url="https://i.imgur.com/c5Bekmc.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/c5Bekmc.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[브라우저의 렌더링과 캔버스]]></title><description><![CDATA[나는 개인적으로 html canvas를 활용한 서비스는 프론트엔드의 정수라고 생각한다. 아마 극한으로 프론트엔드에서 극한까지 사용하게 된다면 figma와 같은 궁극의 결과물이 나오지 않을까.. 생각해서 찍먹해보지 않을 수 없었다.
그래서 새롭게 프로젝트를 시작하는 과정에서 나는 마인드맵을 캔버스로 그려주는 서비스를 만들려고 했는데, 여기서 고민이 하나 있었다.html 캔버스는 그래픽 요소를 그리기 위한 html 내장 콘텐츠로, 원하고자 하는 것을 비트맵 기반으로 그려낼 수 있다.
하지만 사실 다이어그램같은 요소들을 그려내는 과정에서 캔버스는 굳이 필수사항이 아니라고 생각한다.<img src="https://i.imgur.com/Wk5GFIn.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
당장 react-flow만 보아도 각 다이어그램들을 모두 div로 표현하면서, 여기서 CSS를 붙여 사용하는 방식인데, 캔버스로 굳이 할 필요가 없다는 생각도 들었다.
하지만 canva와 excalidraw와 같은 서비스들은 모두 canvas 기반으로 작동하는 서비스들이었기 때문에, 문득 이 html 요소들과 canvas 중에 무엇이 더 성능에 좋을까? 하는 의문이 들었다.이에 대해서는 보다 브라우저의 렌더링에 대해 이해해야지 이유를 찾을 수 있을 것 같다고 판단하여 브라우저의 렌더링에 대해 간략하게나마 정리해보았다.우리는 브라우저가 어떻게 보여지는지에 대해서 말해보라는 질문을 받으면 아마 간단하게 'HTML를 해석해서 DOM Tree로 파싱하고 CSS도 파싱한 담에 그려냅니다'라고 말할 수 있다. 하지만 이 '그려냅니다'라는 말은 많은 과정이 함축되어 있는 말이다.<br><img src="https://i.imgur.com/LeIQ6n2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">브라우저는 Rendering Engine, Javascript Engine, Graphics Library 3가지 요소로 렌더링이 처리된다. 각 요소들은 가지는 한계가 명확하기 때문에 각자의 역할만을 담당한다.
렌더링 엔진 HTML 파싱 후 DOM트리 생성 자바스크립트 엔진(V8) 자바스크립트 코드 실행 그래픽 라이브러리 화면에 그리기 렌더링 엔진의 경우 자바스크립트를 읽을 수 없기 때문에 html의 렌더링만 담당한 후, 구글의 V8 자바스크립트 엔진을 통해 자바스크립트를 해석하고 그래픽 라이브러리를 통해 우리가 보는 화면을 그려낸다.
이 일련의 과정은 모두 메인 쓰레드에서 작동한다.<br>
<img src="https://i.imgur.com/Y1kZrdv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
하지만 이 DOM 요소를 만들고 자바스크립트를 해석하여 화면을 그리는 과정 자체가 16ms를 넘다 보니까 모니터의 주사율 60Hz의 관점에서도 프레임 드랍이 발생한다.<br>
<img src="https://i.imgur.com/aC7OzHT.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이 문제는 메인 쓰레드가 이 세 가지 작업을 모두 하려고 하다 보니까 생기는 문제이다.
그렇다면 이 문제를 해결하기 위한 방법은 무엇이 있을까?
바로 메인 스레드가 모든 작업을 처리하지 않게 하는 것이다.<br><img src="https://i.imgur.com/6sYm0n8.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">브라우저에서 사용되는 스레드는 비단 메인스레드만 있지 않다.
웹페이지를 효율적이고 부드럽게 렌더링하기 위해 별도의 컴포지터 스레드와 래스터 스레드가 렌더러 프로세스에서 실행된다.
그렇다면 이 컴포지터 스레드와 래스터 스레드가 무엇인지, 또 그것의 역할이 무엇인지에 대해서는 다시 브라우저 렌더링을 파악하면서 알아보도록 하자.앞에서 말했던 것처럼 브라우저는 DOM 트리를 만들고, CSS를 파싱하여 스타일 시트를 생성하고, 스타일을 계산한다.스타일을 계산한다고 모든 요소들이 우리가 예상한 대로 화면에 그려지는 과정에서도 많은 과정들이 수반된다.해당 단계에서는 여러 파싱 단계를 거친다.
HTML을 파싱하여 DOM Tree 생성
CSS를 파싱하여 CSSOM 생성
DOM + CSSOM의 렌더 트리 생성
이 과정 자체도 많지만 사실 이 정도는 기본으로 알고 있는 브라우저의 렌더링 단계이니 더 깊은 설명은 생략한다
<br><img src="https://i.imgur.com/9Vsu0Qv.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="max-width: 100%;">이 단계에서는 어디에 그려야 할 지에 대해서 결정한다.<br><img src="https://so-so.dev/c6dc3877cfc2c9133a2cfd37ba174120/layout_cost.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">위 예시에서도 글자 크기가 커지면서 박스를 넘어가게 되면 이 부분에 대해서도 줄바꿈 등의 계산을 모두 해당 과정에서 수행해야 한다.<br><img src="https://i.imgur.com/1yipANC.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그렇기에 브라우저는 스타일이 적용된 DOM을 다시금 훑으면서 레이아웃 트리를 만든다. 이 레이아웃 트리에는 오로지 '보이는' 요소들이 '어디에' 보여야 할 지에 대한 정보를 가지고 있다.레이아웃 트리가 만들어지면 다음에는 Pre-paint와 paint과정을 거친다. pre-paint는 말 그대로 그리기 전에 하는 작업과 그리는 작업이다.Pre-painting는 다음 단계에서 화면에 그려낼 레이어를 구성하기 위한 준비 단계이다. 해당 단계에서는 두가지 단계로 이루어진다.
paint Invalidation
브라우저가 화면의 일부를 다시 그려야 한다고 판단할 때 기존의 페인팅 정보를 무효화한다. 이 과정은 페이지의 시각적 상태가 바뀌어 현재의 그리기 정보가 더 이상 유효하지 않다고 판단될 때 실행된다.<br>
<img src="https://i.imgur.com/3BkJTo9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Property Tree<br>
<img src="https://i.imgur.com/2h5NdF4.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
무효화가 끝나면 transform, opacity 등의 속성을 트리화시켜 각 노드에서 이 Property Tree의 노드를 참조하여 레이어를 합치는 단계에서 필요한 효과를 빠르게 적용할 수 있다.
이 DOM, 스타일, 레이아웃을 기반으로 브라우저에게 '어떻게 그려야 할 지' 에 대해 정의하는 paint records를 생성한다. 위에서 말한 것과 같이 z-index를 두는 경우 요소들을 브라우저 내에서 그리게 된다면 그리는 순서에도 차이가 발생하기 때문이다. 페인트 레코드에는 세 가지 정보가 포함된다.
Action (e.g. Draw Rect)
Position (e.g. 0, 0, 300, 300)
Style (e.g. backgroundColor: red)
<br><img src="https://i.imgur.com/IZ6wQSy.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 이 받은 정보들을 기반으로 실제로 그리는 작업은 여기서 수행되지 않는다는 점을 기억해야 한다.<br><img src="https://i.imgur.com/GOoIoqa.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Paint Records를 만들었으면 그 paint records를 가지고 일정한 기준에 따라 layer로 분리한 다음에 Paint Layer를 생성한다.
이렇게 페인트 레이어를 분리하는 과정을 Layerize 과정이라고 한다. 이 과정에서 나오는 결과물은 여러개의 paint layer이다. 이 paint layer는 보통
최상위 요소(root element)
position: relative, absolute&nbsp;사용
3D(translate3d,&nbsp;preserve-3d, ,..)나 perspective transform 사용
&lt;video&gt;,&nbsp;&lt;canvas&gt;&nbsp;태그 사용
CSS&nbsp;filter나 alpha mask 사용
정도로 구분된다.
Paint Layer중 Compositing Trigger 를 가지고 있거나 스크롤 가능한 컨텐츠가 있을 경우 별도의 Graphics Layer가 생성된다.Compositing Trigger
3D 변형:&nbsp;translate3d,&nbsp;translateZ&nbsp;…
&lt;video&gt;,&nbsp;&lt;canvas&gt;,&nbsp;&lt;iframe&gt;&nbsp;요소
position: fixed
CSS 트랜지션과 애니메이션을 사용해 구현한&nbsp;transform과opacity&nbsp;애니메이션
position: fixed
will-change
filter
분리된 graphnics Layer들은 독립적인 픽셀화가 가능하여 프레임마다 후에 설명할 단계인 래스터하는 과정을 다시 실행하지 않고 GPU 연산이 가능하기 때문에 빠른 스크롤링이나 애니메이션이 가능하다.<br><img src="https://i.imgur.com/d3pIRBM.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">아무튼 이 Composited Layer List 과정에서 각 레이어를 그리는 스레드는 래스터 스레드, 이를 통해 만들어진 결과물을 웹페이지에 합성하는 작업은 컴포지트 스레드가 담당하면서 메인스레드와는 별개로 작동한다.Layerize단계의 출력인 Composited Layer List는 PrePaint단계에서 생성한 Property Tree와 함께 합성 스레드(Composite Thread)로 복사되는 과정을 ‘Commit’이라 한다.<br><img src="https://i.imgur.com/SFctXRI.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">메인 스레드의 작업은 여기에서 끝난다는 사실도 중요하게 기억해야 할 점이다. 커밋 이후에는 자바스크립트를 실행하거나 렌더링 파이프라인을 다시 실행할 수 있다.이 과정에서는
요소들을 작은 단위로 나누어 "그려내는" 래스터화 작업 (Tilling)
이를 통해 만들어진 요소들을 한 곳에 "합치는" 작업인 컴포지트 작업(Composite)
으로 나누어진다.
Tilling단계에서는 받았던 Paint Layer를 기반으로 각 레이어들을 따로 그려야 할 필요성이 있다. 레이어를 따로 그린 다음에 이를 합쳐 하나의 결과물이 나오도록 하기 때문이다.하지만 이 레이어는 크기가 클 수도 있기 때문에 이를 다수의 타일(Tile) 형태로 나눠 래스터 스레드로 보내면서 래스터화해 GPU 메모리에 저장한다. <br><img src="https://i.imgur.com/0Mbs6pd.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Tilling은 이렇게 타일 형태로 분할하는 작업을 의미한다. 각 타일에는 PaintRecord가 포함되고, 뷰 포트 포함 여부나 인접성 등에 따라 다른 우선순위를 가지면서 래스터화된다.이 Raster 단계가 실질적으로 그리는 단계이다.<br>
<img src="https://i.imgur.com/2ZUerC4.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">각 타일을 래스터화 시키는 작업은 skia라는 그래픽 라이브러리를 사용하여 비트맵 이미지를 생성하고 이를 GPU 메모리에 저장한다.<br><img src="https://i.imgur.com/77UTyqh.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이 과정 자체를 cpu가 아닌 gpu에게 담당하도록 하면서 보다 자연스러운 애니메이션 등을 연출할 수 있는 환경이 주어진다.이렇게 타일들이 래스터화되면 drawquad라는 데이터가 생성되고, 쿼드에는 메모리에서 타일의 위치와 웹 페이지 합성을 고려해 타일을 웹 페이지의 어디에 그려야 하는지에 관한 정보를 가지고 있으며, 앞서 생성한 레이어와 Property Tree 정보를 바탕으로 생성된다.<br><img src="https://i.imgur.com/cX8ejby.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이 쿼드들이 모인 것을 컴포지터(합성) 프레임이라고 하는데, 이는 웹 페이지의 프레임을 나타낸다. <br><img src="https://i.imgur.com/D8qVSjE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">컴포지트 스레드의 경우에는 pending tree와 active tree를 가지고 서로 swap하는 멀티버퍼링 패턴을 가지고 있다. 비동기로 진행되는 래스터 작업 중에 이전 커밋에 대한 내용을 보여주어야 하기 때문에 가지는 패턴이다.pending tree는 커밋을 받고 렌더링에 필요한 작업이 완료되면 pending tree를 active tree로 복제한다. 이렇게 분리 된 트리구조로 인해 active tree에서 GPU작업을 하는 동안 pending tree에서 커밋된 변경사항을 대기시킬 수 있다.마지막으로 activate된 쿼드들은 Compositor Frame, 즉 위에서 말한 합성 프레임이라는 데이터로 묶여 GPU프로세스로 전달된다.
컴포지트 스레드의 최종 목표는 commit받은 레이어를 쪼개서(tiling) 래스터화하고 Frame으로 만들어 GPU에 전달하는 것이다.만약 스크롤 이벤트가 발생하면 컴포지터 스레드는 GPU에게 보내질 다른 컴포지터 프레임을 생성한다.<br><img src="https://i.imgur.com/Q1Ow2Ed.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
마지맞 Display에서는 GPU 프로세스의 viz 스레드에서 여러 개의 합성 프레임을 단일 합서으 프레임으로 합치는 작업을 하며, 화면에 픽셀을 렌더링하면서 한 프레임을 그리는 과정까지가 렌더링의 파이프라인이다.앞의 렌더링 과정에서 보면 어느정도 왜 캔버스를 사용하는 것이 성능적으로 이점을 가지는 지에 대해서는 감이 조금은 올 수도 있다.기존 DOM 요소를 통해 다이어그램을 조작한다고 생각해보자.
다이어그램을 조작하는 과정에서 사용자는 계속해서 클라이언트와 상호작용할 일이 많다. 이를 다른 말로 생각하면 그만큼 요소가 변할 일이 많고, 기존 DOM 요소가 변경되거나 수정이 되면 HTML 파싱, Layout, Pre-paint 등의 과정이 반복해서 이루어지면서 오버헤드가 생길 수 있다는 이야기기도 하다.<br><img src="https://i.imgur.com/yBCtbGX.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 캔버스의 경우에는 다르다. 캔버스의 경우에는 자바스크립트로 canvas api를 통해서 각 요소들을 어떻게 그려야 하는 지에 대해 Paint Record의 형태로 이미 정의되어 있다. 그렇기 때문에 캔버스에서 그려지는 요소들이 메인 스레드에서 하는 작업이라고는 자바스크립트를 통해 paint record들을 정의하는 작업정도밖에 되지 않는다. 따라서 위 사진처럼 메인쓰레드에서는 Recording만을 수행하여 그림을 그리는 방법을 정의하기만 하고, 컴포지터 스레드와 래스터 스레드를 통해 타일링과 래스터링하는 과정이 진행되면서, 보다 CPU의 부담은 낮아짐으로써 프레임 드랍이 일어날 확률 또한 줄어들게 된다.<br><img src="https://i.imgur.com/uJCIKSa.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">추가적으로 현재는 Offscreen Canvas API가 새롭게 생기며, canvas를 조작하는 자바스크립트만을 또 떼어내 이를 Web worker에서 처리함으로써 기존에 메인 스레드에서 동작하던 코드를 워커 스레드에서 실행 및 비트맵 그리기를 수행하면서 보다 성능이 향상될 수 있다.<br><img src="https://i.imgur.com/XZ5IBsq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이 OffscreenCanvas는 기존의 DOM에서 완전히 분리되고 동기화 기능이 없기 때문에 일반 캔버스에 비해 속도가 향상되는 효과를 가질 수 있다.이를 통해 쓰레드의 경우에는 계속해서 리렌더링할 DOM이 줄어들면서 자원을 더 사용할 수 있는 여유가 생기기 때문에 이 부분에서도 이점을 가질 수 있다.캔버스에 그릴만한 요소가 많아지면 많아질수록 DOM 객체로 만들게 되면 그만큼 걸리는 과정에서 오버헤드가 크므로 캔버스의 경우가 DOM 객체를 그리는 과정보다는 보다 성능이 좋을 수 있다.<br><a data-tooltip-position="top" aria-label="https://idchoi2.medium.com/javascript-%EB%8F%84%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0-html-vs-svg-vs-canvas-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-9e1ce2396fcd" rel="noopener nofollow" class="external-link is-unresolved" href="https://idchoi2.medium.com/javascript-%EB%8F%84%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0-html-vs-svg-vs-canvas-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-9e1ce2396fcd" target="_self">도형 그리기 html vs svg vs canvas 성능 비교</a>
이는 레퍼런스에서 또한 확연하게 좋아지는 성능을 통해서도 증명할 수 있는 사실이다.하지만 캔버스의 경우 또한 반복해서 렌더링하는 방식이다보니, 이 과정에서 애니메이션의 처리와 같은 부분에서 성능이 저하될 수 있는 가능성 또한 배제할 수 없다. 따라서 이러한 부분의 경우에는 캔버스의 최적화를 최대한 고려하면서 개발하는 편이 가장 이상적이라고 생각한다.처음에 개발을 시작하면서 브라우저가 어떻게 띄워지는지에 대해서는 DOM tree와 CSSOM 정도로만 알고 있었는데, 이번 기회에 렌더 트리를 만들고 '그려내는' 작업에 대해서 딥다이브를 해보니 브라우저가 정말 많은 기술의 집합체였구나를 깨달았다. 하긴 그렇게 쉬우면 다 만들었지..
아무튼 이번 기회를 통해 브라우저의 렌더링 과정을 이해하면서 캔버스를 활용할 때 좋은 배경 지식이 생긴 것 같아 나름 만족스럽다.
지금 쓴 것도 나름 축약해서 정리한 것이긴 한데, 나중에 시간이 된다면 보다 더 면밀하게 살펴볼 예정이다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://d2.naver.com/helloworld/5237120" target="_self">https://d2.naver.com/helloworld/5237120</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.chrome.com/blog/inside-browser-part3" target="_self">https://developer.chrome.com/blog/inside-browser-part3</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://so-so.dev/web/browser-rendering-process/" target="_self">https://so-so.dev/web/browser-rendering-process/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.chrome.com/docs/chromium/blinkng#composite-after-paint-pipelining-paint-and-compositing" target="_self">https://developer.chrome.com/docs/chromium/blinkng#composite-after-paint-pipelining-paint-and-compositing</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://onlydev.tistory.com/82" target="_self">https://onlydev.tistory.com/82</a>]]></description><link>https://alsgud8311.github.io/학습-정리/computer-science/브라우저의-렌더링과-캔버스.html</link><guid isPermaLink="false">학습 정리/Computer Science/브라우저의 렌더링과 캔버스.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 03 Nov 2024 14:45:40 GMT</pubDate><enclosure url="https://i.imgur.com/Wk5GFIn.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/Wk5GFIn.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[React 19 베타에서 새롭게 추가된 것들]]></title><description><![CDATA[React 19가 2024년 4월 25일 베타버전이 나오게 되었다.
여기에 대해서도 조금 더 자세히 알아보고 이를 어떻게 활용하면 좋을지 생각하기 위해 새롭게 추가된 주요 기능들을 정리해 보려고 한다.리액트에서 말하는 Actions는 비동기적인 작업의 수행을 의미한다. 그렇다고 일반적인 data를 가져오기 위한 fetching이 아니라, form에 대한 action과 같이 사용자의 상호작용에 따라 비동기적으로 http 요청을 보내는 등의 작업을 정의한 것으로 보인다.
React 19는 이러한 Actions에 대해 정의하고 이를 기반으로 구축되었다. 따라서 이를 통한 여러가지 기능들이 추가되었다.이전까지의 비동기적으로 http 요청을 보내고 받아서 응답에 따라 뷰를 렌더링 하는 방식으로 많이 사용했었다.// Before Actions
function UpdateName({}) { const [name, setName] = useState(""); const [error, setError] = useState(null); const [isPending, setIsPending] = useState(false); const handleSubmit = async () =&gt; { setIsPending(true); const error = await updateName(name); setIsPending(false); if (error) { setError(error); return; } redirect("/path"); }; return ( &lt;div&gt; &lt;input value={name} onChange={(event) =&gt; setName(event.target.value)} /&gt; &lt;button onClick={handleSubmit} disabled={isPending}&gt; Update &lt;/button&gt; {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;} &lt;/div&gt; );
}
따라서 이를 위한 isPending, error와 같은 state가 필요했다. data fetching하는 로직의 경우에는 사용자 경험을 위해서 로딩 상태와 에러 상태를 기록하는 것은 중요한 관심사였다.이에 fetching에서는 항상 loading과 error의 상태를 관리하는 로직 자체가 반복이 되다보니 과거에는 useFetch라는 커스텀 훅을 만들어 이를 다양한 api fetching에 활용했었다.import { useState, useEffect } from 'react'; type Status = 'initial' | 'pending' | 'fulfilled' | 'rejected'; interface UseFetch&lt;T&gt; { data?: T; status: Status; error?: Error;
} export const useFetch = &lt;T&gt;( fetchFunction: (...args: any[]) =&gt; Promise&lt;T&gt;, ...args: any[]
): UseFetch&lt;T&gt; =&gt; { const [state, setState] = useState&lt;UseFetch&lt;T&gt;&gt;({ status: 'initial', data: undefined, error: undefined, }); useEffect(() =&gt; { let ignore = false; const fetchData = async () =&gt; { setState({ ...state, status: 'pending' }); try { const data = await fetchFunction(...args); if (!ignore) { setState({ status: 'fulfilled', data }); } } catch (error) { if (!ignore) { setState({ status: 'rejected', error: error as Error }); } } }; fetchData(); return () =&gt; { ignore = true; }; }, [fetchFunction]); return state;
}; 이를 통해서 코드의 재사용성이나 가독성을 더 높일 수 있었다.
React 19에서는 이러한 비동기 처리 코드에 대해서 useTransition에서 pending상태를 리액트 내부에서 관리할 수 있도록 해주어 로딩 상태에 대해서 따로 상태로 선언하여 관리할 필요성이 줄어들었다.// Using pending state from Actions
function UpdateName({}) { const [name, setName] = useState(""); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const handleSubmit = () =&gt; { startTransition(async () =&gt; { const error = await updateName(name); if (error) { setError(error); return; } redirect("/path"); }) }; return ( &lt;div&gt; &lt;input value={name} onChange={(event) =&gt; setName(event.target.value)} /&gt; &lt;button onClick={handleSubmit} disabled={isPending}&gt; Update &lt;/button&gt; {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;} &lt;/div&gt; );
}
비동기 함수가 실행되면서 isPending은 즉시 true값으로 바뀌고 비동기 처리가 일어난 후에는 다시 false값으로 바뀐다. startTransition을 통해 렌더링의 우선순위를 낮추어 isPending에 대한 리렌더링을 우선적으로 수행한 후에 비동기 작업을 처리함으로써 보다 상호작용이 가능하고 반응형이 될 수 있는 UI가 될 수 있다.이러한 Actions에 대해서 보다 범용적이고 쉽게 사용될 수 있도록 React 19에서는 useActionState라는 훅을 새롭게 추가했다.const [error, submitAction, isPending] = useActionState( async (previousState, newName) =&gt; { const error = await updateName(newName); if (error) { // You can return any result of the action. // Here, we return only the error. return error; } // handle success return null; }, null,
위에서 본 useFetch와 비슷하게 useActionState가 작동하고 있음을 볼 수 있다. 이 actionState는 기존에 ReactDOM.useFormState로 사용되었지만 현재는 deprecated되고 useActionState로 이름이 바뀌어 나오게 되었다.
인자로 콜백 함수가 들어가며, 래핑된 상태로 action이 반환된다. 이를 통해 사용자의 action에 대해서 로딩, 에러 상태 처리를 위한 코드를 보다 간편하고 가독성 있게 작성할 수 있다.&lt;form action={actionFunction}&gt;
form에 대한 액션 처리는 이전까지만 해도 쓰기가 어려운 부분이 있었다. form에 대한 action을 처리하는 방법은 onSubmit과 같은 방법을 통해 이벤트를 처리했지만, action이라는 어트리뷰트를 추가하여 여기에 action에 대한 핸들러 함수를 넣게 된다면 form 자체 뿐만 아니라 input, button요소의 action과 formAction 프로퍼티로 넘겨줄 수 있다.&lt;form&gt;은 action이 성공했을 경우에 제어되지 않은 컴포넌트에 대해 form을 재설정한다. action 뿐만이 아니라 따로 수동으로 form을 초기화 할 때는 requestFormReset이라는 새로운 React DOM API를 통해서 폼을 초기화시킬 수 있다.form의 상태를 보고 이에 대한 처리를 하기 위해서는 다른 버튼과 같은 컴포넌트 요소들에게도 따로 props를 내려줘서 이에 대한 상태를 처리해야 했다.
이전까지의 경우 그대로 props로 받아 내려주거나, useContext훅을 사용하여 내려주고, 이를 컴포넌트에서 받아 사용할 수 있었다.이번에 React 19에서는 이러한 부분에 대해 useFormStatus라는 새로운 훅을 추가하여 props를 직접 내려받거나 context api를 사용할 일 없이 폼 하위의 요소들에서 useFormStatus 훅을 실행시키면서 부모 폼에 대해서 pending state를 받을 수 있게 되었다.import {useFormStatus} from 'react-dom'; function DesignButton() { const {pending} = useFormStatus(); return &lt;button type="submit" disabled={pending} /&gt;
}
데이터의 변경이 이루어질 때 UI 패턴에서 많이 이루어지던 방식이 낙관적 업데이트이다. 낙관적인 업데이트는 서버로 보낸 요청이 정상적일 것이라고 예상하고,&nbsp;클라이언트의 요청에 대한 응답이 오기 전에 클라이언트의 데이터를 미리 변경시키는 작업을 말한다.
이러한 낙관적 업데이트의 경우는 React에서 없었던 기능이었기에 React Query를 이용하여 사용하였다. 하지만 React 19에서 새롭게 useOptimistic 훅이 추가되어 이를 사용하여 낙관적 업데이트를 할 수 있다.function ChangeName({currentName, onUpdateName}) { const [optimisticName, setOptimisticName] = useOptimistic(currentName); const submitAction = async formData =&gt; { const newName = formData.get("name"); setOptimisticName(newName); const updatedName = await updateName(newName); onUpdateName(updatedName); }; return ( &lt;form action={submitAction}&gt; &lt;p&gt;Your name is: {optimisticName}&lt;/p&gt; &lt;p&gt; &lt;label&gt;Change Name:&lt;/label&gt; &lt;input type="text" name="name" disabled={currentName !== optimisticName} /&gt; &lt;/p&gt; &lt;/form&gt; );
}
위의 예시를 볼 때, useOptimistic을 실행하면 낙관적 업데이트를 시킬 상태와 이 상태를 조작하는 setter 함수를 반환한다. optimisticName를 사용하여 action이 일어남과 동시에 setOptimisticName을 통해 기존의 데이터를 업데이트가 일어난 후의 데이터로 바꿔주면 그 즉시 렌더링에 반영된 후, action에 대한 비동기 요청이 이루어진다. 만약 이 과정에서 비동기 요청이 실패하거나 끝났을 경우, optimisticName는 다시 setter함수를 실행하기 전, 즉 newName에서 currentName으로 돌아가게 된다.React 19에서는 렌더링에서 리소스를 읽을 수 있는 use라는 새로운 API를 도입했다.
use중인 Promise를 읽으면 Promise가 resolve 될 때까지 React는 Suspend, 즉 중단 상태로 기다린다. import {use} from 'react'; function Comments({commentsPromise}) { // `use` will suspend until the promise resolves. const comments = use(commentsPromise); return comments.map(comment =&gt; &lt;p key={comment.id}&gt;{comment}&lt;/p&gt;);
} function Page({commentsPromise}) { // When `use` suspends in Comments, // this Suspense boundary will be shown. return ( &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;Comments commentsPromise={commentsPromise} /&gt; &lt;/Suspense&gt; )
}
따라서 use를 사용하는 컴포넌트는 렌더링을 하지 않고 Promise가 resolve될 때까지 기다린 다음에 resolve가 되면(Promise가 fulfilled된 상태) 그때부터 렌더링을 하기 시작한다.그렇기 때문에 선언적 프로그래밍이 가능해지고, 이는 곧 가독성과 유지보수성을 높여준다. 선언적 프로그래밍
무엇을(WHAT) 나타내야 하는지를 프로그래밍적으로 표현하는 것
어떻게(HOW) 나타내야 하는지를 프로그래밍적으로 표현하는 명령형 프로그래밍보다 한 단계 더 추상화된 프로그래밍 방식
무엇보다 이 use가 쓸만하다고 느낀 점은 Suspense와 합쳐졌을 때이다.
기존의 Suspense의 경우는 데이터를 fetching하는 컴포넌트의 모듈에서 Promise를 throw하고, Suspense가 이를 받아 Promise가 resolve되지 않은 상태면 fallback 프로퍼치에 들어가 있는 UI를 렌더링하고, resolve된 이후에는 선언형으로 작성된 코드에 데이터를 넣어 렌더링만 하는 방식으로 활용했었다.export function fetchData&lt;T&gt;(fn: Promise&lt;T&gt;): { read: () =&gt; T } { let status = "pending"; let result: T; const suspender = fn.then( (r) =&gt; { status = "success"; result = r; }, (e) =&gt; { status = "error"; result = e; }, ); function read() { switch (status) { case "pending": throw suspender; case "error": throw result; default: return result; } } return { read };
}
그래서 이런 식으로 fetchData라는 함수를 따로 만들어 활용하는 방식으로 했었지만 함수형 컴포넌트 안에 들어가게 된다면 무한루프가 돌게 되기 때문에 바깥쪽에서 가져와야만 했다.const response = getHeadlines();
export default function ShortNews() { const headlines = response.read(); return ( &lt;div&gt;...&lt;/div&gt; )
}
이런 식으로 바깥쪽에서 함수를 실행하고 read 함수를 통해 데이터를 가져오는 방법도 있고&lt;Suspense fallback={&lt;p&gt;사용자 정보 로딩중...&lt;/p&gt;}&gt; &lt;User resource={fetchData("1")} /&gt;
&lt;/Suspense&gt;
...
function User({ resource }) { const user = resource.user.read(); return ( &lt;div&gt; &lt;p&gt; {user.name}({user.email}) 님이 작성한 글 &lt;/p&gt; &lt;Suspense fallback={&lt;p&gt;글목록 로딩중...&lt;/p&gt;}&gt; &lt;Posts resource={resource} /&gt; &lt;/Suspense&gt; &lt;/div&gt; );
} 이런 식으로 아예 함수를 실행한 결과를 컴포넌트의 props로 넘겨주는 방식도 있다.나 또한 waterfall 현상과 같은 부분을 해결하고 지긋지긋한 useEffect-fetchData의 늪에서 벗어날 수 있다는 점에서 좋은 기능이라고 생각했지만 이런 식으로 데이터를 가져오는 방식이 정말 마음에 들지 않았다. 선언형 프로그래밍으로 가독성은 높아졌지만, 코드의 흐름이 원래 알던 방식과는 달라서 불편했다.
waterfall 현상
UI가 마치 폭포처럼 위에서 아래로 순차적으로 나타나는 현상
상위 컴포넌트의 렌더링이 끝난 후에 하위 컴포넌트의 렌더링이 시작되기 때문에 발생하는 현상
react Query를 쓸 수도 있겠지만 이제까지 react Query를 쓰지 않은 내 입장에서는 use의 기능 추가가 매우 반가웠다!use 안에 Promise, fetching하는 함수를 실행하면 이에 따라 promise가 reosolve 될 때까지 Suspense의 fallback ui가 띄워지기 때문에 보다 코드의 흐름을 명확히 알 수 있다는 점이 좋았다.하지만 use는 맨 처음 렌더링 과정에서 만들어진 Promise에 대해서는 지원하지 않는 특징을 가지고 있다. 따라서 아직은 맨 처음 데이터를 가져올 때만 유용하게 사용될 수 있을 것 같다. 아니면 react-Query와 함께 사용하는 방법도 방법 중 하나가 될 수 있을 것 같다.또 하나 강력한 기능으로, context 또한 use를 통해 읽어오는 것이 가능하다.const ColorContext = createContext(""); function App() { return ( &lt;ColorContext value="blue"&gt; &lt;Form /&gt; &lt;/ColorContext&gt; );
} function Form() { return ( &lt;div&gt; &lt;Button show={true}&gt;True&lt;/Button&gt; &lt;Button show={false}&gt;False&lt;/Button&gt; &lt;/div&gt; );
} function Button({ show, children,
}: { show: boolean; children: React.ReactNode;
}) { if (show) { const theme = use(ColorContext); return &lt;button style={{ backgroundColor: theme }}&gt;{children}&lt;/button&gt;; } return false;
}
컴포넌트의 최상위 레벨에서만 호출해야 하는 useContext의 단점을 보완하고 조건분이나 반복문 내부에서도 사용할 수 있어 보다 유연하게 사용될 수 있으며, 추가적으로 Provider를 쓰지 않고도 context를 내려줄 수 있는 기능 또한 추가되어 use와의 시너지가 잘 맞을 것 같다.React Server Component는 리액트의 새로운 패러다임으로, 기존 클라이언트 사이드 렌더링만 지원하는 React에서 보다 Next.js같이 발전한 방식으로 볼 수 있다.리액트의 서버 컴포넌트는 기존에 CSR 방식으로 운영되던 리액트가 한 번에 모든 리소스를 다운로드 받고 띄워야 하는 만큼 이에 대한 대기 시간이 점차 길어지자 이를 개선하기 위해 설계된 방식이다.사용자와의 상호작용 없이 정적 요소만 담은 컴포넌트의 경우, 훨씬 빨리 컴포넌트를 렌더링할 수 있는 환경인 서버에서 직접 렌더링하는 편이 낫다. 이를 통해
리렌더링의 필요성을 없애 성능 개선
자바스크립트의 번들링 크기 축소
초기 페이지 로드 속도 개선
이외에도 많은 성능적, 사용자 환경적 개선을 기대할 수 있기 때문에 React 또한 next.js처럼 서버 컴포넌트에 대한 지원을 계속 업데이트하고 있다.
React는 서버사이드 렌더링을 지원하기 위해 기존 SSR 서버와는 다른 별도의 서버를 사용했다. 별도의 서버에서 미리 서버 컴포넌트를 렌더링 한 다음, 이를 띄워주는 방식이다. 해당 서버 컴포넌트는 빌드 시 CI 서버에서 한번 실행할 수도 있고, 웹 서버를 사용하여 각 요청마다 새롭게 실행할 수도 있다. import db from './database'; async function Note({id}) { const note = await db.notes.get(id); return ( &lt;div&gt; &lt;Author id={note.authorId} /&gt; &lt;p&gt;{note}&lt;/p&gt; &lt;/div&gt; ); } async function Author({id}) { const author = await db.authors.get(id); return &lt;span&gt;By: {author.name}&lt;/span&gt;; } ```
이런 식으로 함수형 컴포넌트 자체를 비동기 함수로 만든 다음에, 서버에서 데이터를 가지고 와 렌더링하여 사용자와 상호작용 없는 컴포넌트를 빠르게 보여줄 수 있다.
앱이 로드될 때 클라이언트는 사용된 라이브러리를 보지 못하고 오로지 렌더링된 출력물만 볼 수 있기 때문에 상호작용과 상태 관리는 되지 않지만, 상호작용이 필요한 부분과 필요없는 부분을 나누어 서버 컴포넌트와 클라이언트 컴포넌트를 나누어 개발하면 보다 성능이 올라갈 것이다. ```jsx
// Server Component
import db from './database'; async function Page({id}) { // Will suspend the Server Component. const note = await db.notes.get(id); // NOTE: not awaited, will start here and await on the client. const commentsPromise = db.comments.get(note.id); return ( &lt;div&gt; {note} &lt;Suspense fallback={&lt;p&gt;Loading Comments...&lt;/p&gt;}&gt; &lt;Comments commentsPromise={commentsPromise} /&gt; &lt;/Suspense&gt; &lt;/div&gt; );
} ... // Client Component
"use client";
import {use} from 'react'; function Comments({commentsPromise}) { // NOTE: this will resume the promise from the server. // It will suspend until the data is available. const comments = use(commentsPromise); return comments.map(commment =&gt; &lt;p&gt;{comment}&lt;/p&gt;);
}
서버에서 직접 Suspense에 대한 스트리밍이 지원되기 때문에 보다 Suspense가 활용될만한 곳이 많아진 것 같다고 생각한다.
위에 보이는 예시처럼 서버 컴포넌트는 직접 서버에서 비동기 컴포넌트에 대해 fetching하는 함수를 넘겨주고, use를 사용하여 Promise를 인자로 넣음으로써 서버 컴포넌트 안에 클라이언트 컴포넌트가 작동하는 방식으로도 활용이 가능하다.
여기서 suspense 또한 Comments의 부모로 있기 때문에 정상적으로 Suspense fallback UI가 렌더링되고, 클라이언트 컴포넌트에서 비동기적으로 데이터가 들어오면 이에 따라 안쪽 요소를 채우도록 할 수 있다.// Server Component
import Button from './Button'; function EmptyNote () { async function createNoteAction() { // Server Action 'use server'; await db.notes.create(); } return &lt;Button onClick={createNoteAction}/&gt;;
}
"use server" 지시어를 사용하여 서버에서 실행하는 비동기 함수를 서버 컴포넌트에서 사용할 수 있도록 할 수 있다.
위와 같이 액션에 대해서 비동기적으로 처리해야 하는 부분에서 use server를 쓰고, 서버에서 이 액션에 대해 처리할 수 있다.리액트가 컴포넌트를 생성하는 과정에서 이렇게 서버에서 사용하는 비동기 함수를 가져오게 되면 함수에 대한 참조를 Button의 onClick 인자에 넘겨준다. "use server"; export async function createNoteAction() { await db.notes.create();
}
클라이언트 컴포넌트의 경우에는 "use server" 지시어를 사용하는 파일에서 서버 액션을 가져올 수 있다."use client";
import {createNoteAction} from './actions'; function EmptyNote() { console.log(createNoteAction); // {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNoteAction'} return &lt;button onClick={createNoteAction} /&gt;
}
그러면 클라이언트 컴포넌트가 빌드되는 과정에서 함수에 대한 참조를 생성하여 넘겨줌으로써 서버 액션을 사용할 수 있도록 할 수 있다.액션으로 서버 액션을 구성한다는 것이 무슨 뜻일까?
이는 아래의 예시를 보면 어느정도 이해가 가능하다."use server"; export async function updateName(name) { if (!name) { return {error: 'Name is required'}; } await db.users.updateName(name);
}
...
"use client"; import {updateName} from './actions'; function UpdateName() { const [name, setName] = useState(''); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const submitAction = async () =&gt; { startTransition(async () =&gt; { const {error} = await updateName(name); if (!error) { setError(error); } else { setName(''); } }) return ( &lt;form action={submitAction}&gt; &lt;input type="text" name="name" disabled={isPending}/&gt; {state.error &amp;&amp; &lt;span&gt;Failed: {state.error}&lt;/span&gt;} &lt;/form&gt; ) }
예시에서는 "use server" 지시어를 사용하여 updateName이라는 서버 액션을 만들었다. 이 서버 액션의 경우 직접적으로 db에 접근하여 이름을 수정하는 로직이 담겨있다.
아래 "use client"를 사용한 코드에서는 안에서 submitAction이라는 액션을 하나 더 만들었다. 이 액션은 클라이언트에서 서버와의 데이터 통신에 한 겹 더 래핑한 구조를 가지고 있다. 추가적으로 비동기적으로 동작하는 서버 액션에 대해 에러 상태와 pending 상태를 추가하기 위해서 error라는 state와 useTransition을 통해 pending 상태를 관리하고 있다. 이를 통해 서버 액션에 대해 pending 상태에 접근할 수 있기 때문에 이런 식으로도 액션을 둘 다 활용하여 로직을 더 보완할 수 있다.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.jeong-min.com/64-react-19-use/" target="_self">https://www.jeong-min.com/64-react-19-use/</a>]]></description><link>https://alsgud8311.github.io/학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html</link><guid isPermaLink="false">학습 정리/Frontend/React/React 19 베타에서 새롭게 추가된 것들.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sat, 26 Oct 2024 17:36:59 GMT</pubDate></item><item><title><![CDATA[Concurrent mode]]></title><description><![CDATA[동시성 모드(concurrent mode)는 한 가지 일이 끝날 때 까지 무조건 다음 작업을 기다리는 것이 아닌, 한 가지 일이 실행 중일 동안 다른 일을 수행하는 것을 의미한다.
그렇다면 이 동시성(concurrency)이 병행성(parallelism)과 같은 의미를 가진 동의어가 아닌가? 라고 생각할 수 있겠지만 둘이 말하는 작업의 동시성은 조금 다르다.동시성의 경우 한 가지 일이 무조건 끝날 때까지 기다리는 것이 아니라, 그 사이에 다른 일을 할 수 있으면 하는 것이다.
반면 병행성의 경우는 동시에 두 가지 이상의 일을 하는 것이다. 그러니 한 가지 일이 끝날 때까지 기다리는 것과는 상관이 없고 작업마다 각각 알아서 수행하는 것이다.
가장 쉬운 예로, 손이 두개지만 빠른 사람과 손이 여덟개인 사람을 생각하면 동시성과 병행성이 무엇을 의미하는 것인지 느낌이 올 것이다.리액트에서의 동시성 처리는 여러 작업을 처리할 수 있도록 작업들을 작은 조각들로 나누고, 스케줄러를 통하여 각 작업들의 중요도에 따른 우선순위를 부여한다(time-slicing). 아무리 손이 빠른 사람이라고 하더라도 사실상 단계별로 하지 않으면 결국 전체적인 작업은 망가지기 마련이다.
샌드위치 만드는 과정에서 빵을 굽는 작업과 잼을 바르는 작업을 할 때, 빵을 먼저 굽고 잼을 바르듯이 작업에도 우선순위를 부여하고 이에 따라 작업을 처리할 필요가 있다.리액트가 이렇게 나눈 작업들을 처리하는 과정에서 메인스레드는 블록되지 않으며, 동시에 여러 작업을 처리하면서 우선 순위에 따라 각 작업들 간에 전환이 가능하게 되었다.이와 같이 리액트 18버전부터는 동시성 렌더링을 통해서 렌더링 자체에 개임하고, 이를 중단하거나 재개, 폐기하는 등 작업들을 단위별로 조정할 수 있게 되었다.React 18 이전에는 렌더링이 동기적으로 처리되었기 때문에 이 중간에 어떤 것도 개입할 수 없었다. 이는 곧 렌더링이 실행되면 렌더링이 끝날 때까지 무조건 기다려야 했다는 이야기기도 했다.그래서 만약 렌더링이 오래 걸리는 작업의 경우에는, 다음 수행한 작업이 블로킹되어 애플리케이션 자체가 렉을 먹는 듯한 모습을 보여주어 UX가 현저히 떨어지게 된다.이러한 문제를 해결하기 위해서 개발자들은 Debounce와 Throttle 방식을 사용하여 어느정도 해소할 수 있었다.
Debounce
사용자의 입력이 연속으로 들어올 때 마지막 입력 후 일정 시간이 지난 다음에 무거운 작업을 수행하는 방식 Throttle
특정 시간 동안 한 번만 함수를 실행할 수 있도록 제한하는 방식.
하지만 이러한 방식 또한 Debounce의 경우에는 성능이 좋아도 모든 기기에서 같은 시간동안 대기 후에 작업 수행을 해야했고, Throttle의 경우에는 Throttle 주기를 짧게 가져갈수록 성능은 점점 떨어진다는 한계가 보였다.그렇기 때문에 이러한 동기적 렌더링의 한계를 해소하고자 동시성의 필요성이 대두되어 나오게 되었다.기존의 ReactDOM 함수의 프로토타입 함수로 사용하던 render를 사용하지 않고 ReactDOM의 프로토타입 함수인 createRoot를 통해서 객체를 생성한 뒤, 해당 객체의 render 함수를 통해 엔트리 포인트를 렌더링시킨다.import ReactDOM from 'react-dom';
import App from 'App'; const container = document.getElementById('app'); // 이전 버전(React 17)
const container = document.getElementById('app'); ReactDOM.render(&lt;App /&gt;, container); // Concurrent Mode 도입 이후(React 18)
// 루트 생성
const root = ReactDOM.createRoot(container); // 루트 객체의 메서드로 앱을 렌더링
root.render(&lt;App /&gt;);
{루트객체}.render를 통해서 앱을 렌더링시키게 되면 개선된 기능들과 동시 처리를 위한 startTransition, useTransition, useDeferredValue 훅을 사용할 수 있다.<img src="https://i.imgur.com/VbEpPyR.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
여러 개의 상태를 업데이트할 경우, 기존에는 하나의 state의 업데이트 -&gt; 변경된 상태를 리렌더링 -&gt; 다음 state의 업데이트의 단계로 상태가 업데이트 되었기 때문에 여러번 리렌더링이 발생하였고, 이에 성능적으로 좋지 않은 효과를 가져왔다.기존의 React 17까지도 Automatic Batching이 적용은 되어 있었지만, 적용되는 곳이 이벤트 핸들러 함수 내부로 한정적인 특성을 가졌다.
그러다보니 네트워크 호출(Promise)에 대한 .then 메서드의 콜백 함수에 여러개의 상태 업데이트가 들어가 있다거나 setTimeout의 콜백 함수 안의 여러 상태 업데이트 등에서는 상태 업데이트가 일괄처리가 아닌, 순차처리 방식으로 동작하면서 변경된 state의 수만큼 리렌더링을 수행하게 된다. 그러다보니 성능적으로 떨어지는 효과를 가지게 된 것이다.이에 React18부터 Concurrent Mode가 활성화되면, 모든 Promise나 setTimeout, 이벤트 콜백 등에서 다수 개의 상태 업데이트가 일괄로 처리되도록 변경되었다.<br><img src="https://i.imgur.com/rwH08eL.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Transition 관련 훅들은 전부 우선순위를 직접 관리하여 렌더링 과정에서 성능을 개선하기 위해 새롭게 추가된 훅들이다.
위에서 말한 것과 같이 이전의 렌더링 방식은 동기적으로 계속해서 UI에 대한 업데이트 실행 -&gt; 리렌더링의 반복이었다. <br><img src="https://i.imgur.com/CQ49j39.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 동시성 렌더링 방식으로 변경되면서 첫 상태 업데이트부터 최종적으로 보여야 하는 화면의 렌더링까지 가는 과정에서 중간에 계속해서 우선순위가 낮은, 즉 가벼운 업데이트를 끼워 비교적 가벼운 업데이트 -&gt; 무거운 업데이트순으로 업데이트를 시킬 수 있도록 처리하여 UI blocking 없이 동시에 다른 작업이 수행되는 것과 같은 사용자 경험을 제공할 수 있게 되었다.useTransition은 이러한 동시성을 구현하기 위해 필요한 훅이다. 이 훅은 리액트 컴포넌트 안에서 동시성 모드에 접근할 수 있도록 해준다.import { useState } from 'react'; export function FilterList({ names }) { const [query, setQuery] = useState(''); const changeHandler = ({ target: { value } }) =&gt; setQuery(value); return ( &lt;div&gt; &lt;input onChange={changeHandler} value={query} type="text" /&gt; {names.map((name, i) =&gt; ( &lt;ListItem key={i} name={name} highlight={query} /&gt; ))} &lt;/div&gt; );
} function ListItem({ name, highlight }) { const index = name.toLowerCase().indexOf(highlight.toLowerCase()); if (index === -1) { return &lt;div&gt;{name}&lt;/div&gt;; } return ( &lt;div&gt; {name.slice(0, index)} &lt;span className="highlight"&gt; {name.slice(index, index + highlight.length)} &lt;/span&gt; {name.slice(index + highlight.length)} &lt;/div&gt; );
}
해당 코드를 보면 input의 내용이 바뀔 때마다 setState를 실행하고 있고, state가 바뀌게 되면 리렌더링이 이루어지며, names를 map하는 함수가 리렌더링 때마다 실행되며 UI를 다시금 화면에 띄운다.하지만 이러한 name들이 점점 많아질 수록, input에 빠르게 입력하게 된다면 리렌더링 속도가 input 이벤트핸들러의 setState가 실행되는 속도를 따라가지 못하게 되고, 결극 input의 value가 빠르게 입력될 수 없는 문제를 가지게 된다.<br>
<a data-tooltip-position="top" aria-label="https://codesandbox.io/p/sandbox/heavy-update-as-urgent-ejwbg" rel="noopener nofollow" class="external-link is-unresolved" href="https://codesandbox.io/p/sandbox/heavy-update-as-urgent-ejwbg" target="_self">예시 보기</a>이럴때, 무거운 작업은 List의 리렌더링이 될 것이고, 비교적 가벼운 작업은 input의 eventHandler 안에 들어있는 setState에 대한 input의 value 리렌더링이다. 그렇다면 이 input의 리렌더링에 대해서 우선순위를 높여 input먼저 계속 먼저 리렌더링 될 수 있게만 한다면 input이 밀리게 되는 현상을 방지할 수 있는 것이다. 그럴 때 사용하는 훅이 useTransition 훅이다.[isPending, startTransition] = useTransition()
useTransition을 사용하면 isPending, startTranstion의 리턴값을 받는다.
isPending: transition이 pending 상태인지 알려주는 boolean 값
startTransition(callbackFn): UI 업데이트에 관한 로직을 콜백 함수로 넘겨줌
이 startTransition을 통해서 콜백함수의 setState를 통한 리렌더링 로직을 우선순위가 낮도록 설정하여 후순위로 렌더링이 이루어질 수 있도록 하면서 성능을 개선한다.
`startTransition` lets you update the state without blocking the UI.
라고 React의 공식문서에서 나와 있는 설명과 같이, UI를 따로 블로킹하지 않고 상태를 업데이트 하도록 시킴으로써 비교적 무거워서 다른 UI의 렌더링을 막는 작업들을 의도적으로 지연시킬 수 있다.import { startTransition } from 'react'; function TabContainer() { const [tab, setTab] = useState('about'); function selectTab(nextTab) { startTransition(() =&gt; { setTab(nextTab); }); } // ...
}
이런 식으로 setState가 있는 부분의 경우 렌더링 과정에서 막히지 않고 따로 진행되기 때문에 가벼운 UI의 업데이트 등이 막히지 않고 바로바로 렌더링이 될 수 있는 환경을 제공한다.useDeferredValue는 상태의 업데이트 우선순위를 낮춘다는 점에서 useTransition과 유사하게 동작하는 면이 있다.
하지만 startTransition은 콜백함수 내부에 setState를 사용하는 방식이고, useDeferredValue는 state값을 인자로 받아서 지연된 값을 반환하는 함수이다. 따라서 useTransition은 상태를 변화시키는 행동 자체를 래핑하는 것이고, useDeferredValue은 값 자체를 래핑해서 사용하는 형태이다.useDeferredValue로 래핑한 상태의 경우에는 다른 상태값이 모두 상태 변경이 이루어진 이후에 자신이 바뀌게 된다. 값 변화의 우선순위가 낮아지기 때문에 다른 상태들의 업데이트 이후에 실행되는 것이다.그렇기에 사용하는 방식에 따라 useTransition과 useDeferredValue를 취사 선택하여 사용한다.
useTransition : 상태 변경에 대한 리렌더링이 모두 이루어진 후 콜백 함수 실행 콜백 함수 안에 setState를 넣어 사용 useDeferredValue: 상태 변경에 대한 리렌더링이 모두 이루어진 후에 변한 값에 대한 리렌더링
추가적으로 useDeferredValue는 Suspense와 함께 사용이 가능하다 .
만약 useDeferredValue의 인자로 설정한 상태가 변경하게 되면 새로운 값으로 인한 백그라운드 업데이트 동안 이전의 상태를 보여준다. 업데이트 이전의 상태를 보여주면서 다음 컴포넌트들의 렌더링이 모두 이루어진 후에 해당 상태를 참조하는 컴포넌트에서 다시금 렌더링을 시도한다. 이 렌더링을 시도하는 과정에서 기존에는 훅을 사용하여 새롭게 데이터를 fetching하는 동안 나올 ui를 설정하거나 Suspense를 활용하여 fallback UI를 보여줌으로써 사용자에게 로딩중임을 보여줄 수 있다.
Suspense
콘텐츠가 렌더링할 준비가 되기 전까지 대체 UI를 보여주는 태그
export default function App() { const [query, setQuery] = useState(''); return ( &lt;&gt; &lt;label&gt; Search albums: &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt; &lt;/label&gt; &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt; &lt;SearchResults query={query} /&gt; &lt;/Suspense&gt; &lt;/&gt; );
} 기본적으로 컴포넌트가 일시 중단됐을 때 lazy loading이나 use, Next.js와 같은 suspense 지원하는 프레임워크의 데이터 페칭 등을 사용하게 되면 가장 가까운 상위 Suspense 컴포넌트가 fallback ui를 띄워주게 된다. import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return ( &lt;&gt; &lt;label&gt; Search albums: &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt; &lt;/label&gt; &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt; &lt;SearchResults query={deferredQuery} /&gt; &lt;/Suspense&gt; &lt;/&gt; );
}
여기서 useDeferredValue를 사용하게 되면 기존 상태를 업데이트한 값에 대해서 지연된 렌더링이 이루어지고, 그 렌더링이 다시금 이루어지는 동안 이전의 값이 있을 경우 이를 표시함으로써 이전의 값을 나타낼 수 있다.또한 이 방식을 조금 더 활용하여 기존의 값과 만약 값이 바뀌었다면 이를 비교하는 변수 하나를 만들어 refetching하고 있는 상태를 알 수 있는 ui로 보여줄 수도 있다.import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return ( &lt;&gt; &lt;label&gt; Search albums: &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt; &lt;/label&gt; &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt; &lt;div style={{ opacity: isStale ? 0.5 : 1, transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear' }}&gt; &lt;SearchResults query={deferredQuery} /&gt; &lt;/div&gt; &lt;/Suspense&gt; &lt;/&gt; );
}
위 예시에서는 새롭게 업데이트된 deferredQuery와 이전의 값이어던 query를 비교한 변수인 isStale을 따로 선언하여 이에 따라 transition을 주며 refetching중인 상태를 나타내었다. 이를 비교하여 ui를 띄울 때는 suspense의 fallback ui보다는 기존의 값을 띄우는 방식으로도 사용할 수 있다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://dmitripavlutin.com/react-usetransition/" target="_self">https://dmitripavlutin.com/react-usetransition/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@heelieben/React-18-Concurrent-Rendering" target="_self">https://velog.io/@heelieben/React-18-Concurrent-Rendering</a>]]></description><link>https://alsgud8311.github.io/학습-정리/frontend/react/concurrent-mode.html</link><guid isPermaLink="false">학습 정리/Frontend/React/Concurrent mode.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 25 Oct 2024 12:07:25 GMT</pubDate><enclosure url="https://i.imgur.com/VbEpPyR.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/VbEpPyR.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[React Portal]]></title><description/></item><item><title><![CDATA[[백준31784] 포닉스의 문단속]]></title><description><![CDATA[<img src="https://i.imgur.com/p4MrRmQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
N개의 다이얼이 연결된 자물쇠를 돌려서 풀어야 하는데 다이얼 중 하나를 골라 1번 돌리는 작업을 해야 하는데, K번을 돌려서 나올 수 있는 단어 중에 가장 사전순으로 앞인 단어를 찾으면 된다.내가 가진 정보는 자물쇠의 길이 N과 작업의 횟수 K
그리고 다음 줄에는 문자열 S가 주어진다
해당 문자열에서 돌려서 가장 사전순으로 작은 문자열을 만들면 된다.<br><img src="https://i.imgur.com/zSYDvvb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
예제를 보자.4 3
ABCD
의 경우, 3번을 돌려 나올 수 있는 사전순으로 가장 작은 단어는 ABCG이다.
ABC는 어차피 사전순으로 가장 앞이므로 D를 세번 돌려 D -&gt; E -&gt; F -&gt; G를 만들었다.4 5
XYZW
해당 문자열은 XYZW가 AAZW로 변했다.
X -&gt; Y -&gt; Z -&gt; A
Y -&gt; Z -&gt; A
로 총 5번을 돌렸다.이를 통해 가장 앞인 문자부터 검사해서 돌려서 만약 알파벳 앞 순위의 숫자로 변환할 수 있다면 변환하는 것을 알 수 있다.
그리디 알고리즘이 이에 대해 가장 잘 맞는 알고리즘같다.
앞문자열부터 하나씩 검사
알파벳의 아스키코드를 더했을 때 이전보다 사전순으로 앞인 알파벳이 나오면 더한다.
없으면 뒤로 돌린다
마지막에 남은 횟수를 다 돌린다.
정도로 생각할 수 있다.
]]></description><link>https://alsgud8311.github.io/알고리즘/[백준31784]-포닉스의-문단속.html</link><guid isPermaLink="false">알고리즘/[백준31784] 포닉스의 문단속.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sat, 01 Feb 2025 02:45:38 GMT</pubDate><enclosure url="https://i.imgur.com/p4MrRmQ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/p4MrRmQ.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 17123] 배열 놀이]]></title><description><![CDATA[<img src="https://i.imgur.com/XDa3R5Q.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">N x N의 행렬에서 [r1,c1] - [r2,c2]로 이루어진 사각형에 v를 더하면 된다
각 대각선으로 된 꼭짓점의 좌표이므로
[r1,c1] - [r1,c2] - [r2,c1] - [r2,c2] 가 각 꼭짓점인 사각형의 값들에 대해서 전부 v씩 더하면 된다.특정한 알고리즘이 딱히 필요한 것 같지는 않다const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const inputs = require("fs") .readFileSync(INPUT_FILE) .toString() .trim() .split("\n"); const t = +inputs[0]; for (let i = 1; i &lt; inputs.length; i++) { const [n, m] = inputs[i].split(" ").map(Number); const map = inputs .slice(i + 1, i + n + 1) .map((row) =&gt; row.split(" ").map(Number)); const tests = inputs .slice(i + n + 1, i + n + m + 1) .map((test) =&gt; test.split(" ").map(Number)); for (const [r1, c1, r2, c2, v] of tests) { for (let k = r1 - 1; k &lt;= r2 - 1; k++) { for (let j = c1 - 1; j &lt;= c2 - 1; j++) { map[k][j] += v; } } } const resultRow = map.map((row) =&gt; row.reduce((acc, curr) =&gt; acc + curr, 0)); const resultCol = Array(n).fill(0); //열 for (let l = 0; l &lt; n; l++) { let acc = 0; for (let h = 0; h &lt; n; h++) { acc += map[h][l]; } resultCol[l] = acc; } console.log(resultRow.join(" ")); console.log(resultCol.join(" ")); i += n + m;
} 그래서 그냥 했다
근데 시간 초과가 떴다]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-17123]-배열-놀이.html</link><guid isPermaLink="false">알고리즘/[백준 17123] 배열 놀이.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 31 Jan 2025 03:14:43 GMT</pubDate><enclosure url="https://i.imgur.com/XDa3R5Q.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/XDa3R5Q.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준14596] Quilting(smaill)]]></title><description><![CDATA[두 패턴의 이미지를 포개면서, 가장 최적의 동선을 통해 부자연스러움의 정도가 가장 낮은 경계를 골라 해당 동선의 부자연스러움의 정도를 출력해야 한다.<img src="https://i.imgur.com/aR713da.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/jU8rnI2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
문제 드럽게 기네;일단 여기서 주의해야 할 점은
아래 같은 인덱스거나 +-1 의 경계까지만 움직일 수 있으므로 여기서 가장 주의를 해야한다그렇다면 맨 위에서부터 가장 최적의 동선을 골라야 할텐데, 이게 어디서 시작하느냐에 따라서도 최적의 경계가 바뀔 수도 있다. 그러므로 해당 문제는 가장 위쪽 모든 인덱스에서 출발하면서 최적의 동선을 가지는 쪽으로 움직여야 하기 때문에 dp로 풀어야 함을 알 수 있다.그렇다면 시작점을 기준으로 배열을 만든 다음, 해당 시작점에서 가지는 최소의 부자연스러움을 각각 구한다음에 그 중 최소인 부자연스러움 정도를 가지고 오면 된다.]]></description><link>https://alsgud8311.github.io/알고리즘/[백준14596]-quilting(smaill).html</link><guid isPermaLink="false">알고리즘/[백준14596] Quilting(smaill).md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Wed, 29 Jan 2025 14:24:49 GMT</pubDate><enclosure url="https://i.imgur.com/aR713da.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/aR713da.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준11631] ASCII Addition]]></title><description><![CDATA[아.. 이거 전에 모 코테에서 본 문제와 비슷한 문제
그 때 제대로 풀지 못해서 멘붕 왔었는데 이번엔 제대로 풀어본다.<img src="https://i.imgur.com/xQr9x8I.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">아스키 아트는 칠해지는 부분이 x로 되어 있고, 총 7개의 row와 5개의 column으로 되어 있다.
a+b의 형태로 아스키 아트가 주어지면 이를 인식하고 이에 대한 두 수의 합을 다시 아스키 코드로 나타내야 한다.const fs = require("fs"); const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const input = fs.readFileSync(INPUT_FILE).toString().trim().split("\n"); const asciiPatterns = [ `xxxxx\nx...x\nx...x\nx...x\nx...x\nx...x\nxxxxx`, `....x\n....x\n....x\n....x\n....x\n....x\n....x`, `xxxxx\n....x\n....x\nxxxxx\nx....\nx....\nxxxxx`, `xxxxx\n....x\n....x\nxxxxx\n....x\n....x\nxxxxx`, `x...x\nx...x\nx...x\nxxxxx\n....x\n....x\n....x`, `xxxxx\nx....\nx....\nxxxxx\n....x\n....x\nxxxxx`, `xxxxx\nx....\nx....\nxxxxx\nx...x\nx...x\nxxxxx`, `xxxxx\n....x\n....x\n....x\n....x\n....x\n....x`, `xxxxx\nx...x\nx...x\nxxxxx\nx...x\nx...x\nxxxxx`, `xxxxx\nx...x\nx...x\nxxxxx\n....x\n....x\nxxxxx`, `.....\n..x..\n..x..\nxxxxx\n..x..\n..x..\n.....`,
]; const asciiToCharMap = {};
asciiPatterns.forEach((pattern, index) =&gt; { asciiToCharMap[pattern] = index === 10 ? "+" : index.toString();
}); const ROWS = 7;
const COLS = 5; const splitInput = [];
for (let i = 0; i &lt; input[0].length; i += COLS + 1) { const block = []; for (let j = 0; j &lt; ROWS; j++) { block.push(input[j].slice(i, i + COLS)); } splitInput.push(block.join("\n"));
} const expression = splitInput.map((block) =&gt; asciiToCharMap[block]).join("");
const [a, b] = expression.split("+").map(BigInt); const result = (a + b).toString(); const charToAsciiMap = Object.fromEntries( asciiPatterns.map((pattern, index) =&gt; [ index === 10 ? "+" : index.toString(), pattern, ])
); const resultAscii = Array(ROWS).fill("");
for (const char of result) { const asciiBlock = charToAsciiMap[char].split("\n"); for (let i = 0; i &lt; ROWS; i++) { resultAscii[i] += (resultAscii[i] ? "." : "") + asciiBlock[i]; }
} console.log(resultAscii.join("\n")); 응 다 노가다로 아스키 맵 만들면 그만이야~
이딴 문제 만들지좀 마라]]></description><link>https://alsgud8311.github.io/알고리즘/[백준11631]-ascii-addition.html</link><guid isPermaLink="false">알고리즘/[백준11631] ASCII Addition.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Tue, 28 Jan 2025 06:56:39 GMT</pubDate><enclosure url="https://i.imgur.com/xQr9x8I.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/xQr9x8I.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 1912] 연속합]]></title><description><![CDATA[
n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
문제에서 나온 예시로 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌을 때, 여기서 정답은 12+21인 33이 정답이 된다.해당 문제에서 주목해야 할 점은 연속된 몇 개의 수와 구할 수 있는 합 중 가장 큰 합이다.
그럼 연속된 몇 개의 수는 어떻게 구해야 하는가?
일단은 계속 배열을 돌아가면서 최대한 큰 수를 만들 수 있도록 해야 하는데 이를 기록하고 가장 큰 값을 도출해내기 위해선 동적 계획법을 통해 풀어야 함을 알았다.그렇다면 동적 계획법에서 중요한 것은 점화식인데, 어떤 식으로 점화식을 도출해 낼까?
일단 우리에게 주어지는 것은 n의 정보와 수열의 정보이다. 이를 가지고 연속된 수 중에 가장 최대한 큰 수를 계속 기록하기 위해서는 수열이 배열이라는 가정 하에 생각해보면 된다.
배열을 처음부터 끝까지 돌면서 우리는 연속된 수들을 만날 것이다. 이 연속된 수에서 우리는 기존의 누적된 값을 현재 보고 있는 값과 비교해야 한다.
여기서 중요한 점은 무조건 음수라고 해서 거기서 끊어야 하는게 아닌, 음수라고 하더라도 그 뒤에 연속되는 값을 더했을 때 가장 큰 수가 된다면 음수라도 포함할 수 있는 경우를 생각해야 한다.
그렇다면 점화식은 이전까지 누적된 값과 현재 보고 있는 값을 더했을 때와 현재 값 중에 더 큰 값을 골라야 한다. dp[n] = max(dp[n-1] + arr[n], arr[n])]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-1912]-연속합.html</link><guid isPermaLink="false">알고리즘/[백준 1912] 연속합.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Tue, 07 Jan 2025 01:33:34 GMT</pubDate></item><item><title><![CDATA[[백준 9251] LCS]]></title><description><![CDATA[
해를 분석해서 부문제로 분할하기 부문제의 해로 큰 문제의 해를 표현(점화식)
부문제들의 해를 가지고 있는 dp table을 채우기 table에서 해를 계산하여 알고리즘의 correctness 검증
stringA : ACAYKP
stringB: CAPCAKAn과 Bm의 최장길이 공통 부문자열의 길이를 구해야 함
이를 어떻게 작은 문제들로 쪼갤 수 있을까?
LCS(i,j) =&gt; Ai과 Bj의 LCS 길이
Ai와 Bj가 서로 같다면 최장길이 공통 문자열에 추가된다.
이는 곧 이 두 문자열을 비교했을 때, 두 문자열이 서로 같다면 길이가 1 증가한다는 뜻이다.
나머지는 A1,A2,...Ai-1
B1,B2,...Bj-1
로 나뉘어 질 수 있다.
그렇다면 이 문자열들에 대해서도 계속 공통 문자열을 비교하면서 나아가면 되지 않을까?
마지막 두 문자열이 같을 때 : LCS(i,j) = LCS(i-1,j-1) + 1
라고 볼 수 있다. 하지만 마지막 두 문자열이 다를 때는 간단하게 LCS(i,j) = LCS(i-1,j-1)라고만 생각하면 안된다. 왜냐면 나중에 A의 마지막 문자열이 포함되어 있지만 B의 마지막 문자열은 포함되어 있지 않을 수 있고, B의 마지막 문자열이 포함되어 있지만 A의 마지막 문자열을 포함되어 있지 않을 수 있기 때문이다. (여기서 A,B문자열이 모두 같은 경우는 이미 아니기 때문에 제외한다)
그렇기 때문에 우리가 원하는 LCS는 LCS(i,j-1) 과 LCS(i-1,j) 중 더 길이가 긴 것으로 선택해야 한다.
그렇다면 이 LCS(i,j-1)과 LCS(i-1,j)를 미리 구해놔야 한단 소리기 때문에 dp 테이블을 만들어서 이에 대한 값을 메모이제이션 해놓으면 된다.]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-9251]-lcs.html</link><guid isPermaLink="false">알고리즘/[백준 9251] LCS.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Wed, 18 Dec 2024 08:54:21 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 요격 시스템]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/181188" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/181188</a>A 나라와 B 나라 간에 전쟁중에 A는 x축에 평행한 미사일을 발사하고, B 나라는 이를 수직으로 요격한다.
조건은 미사일의 양 끝에서는 요격을 할 수 없다는 조건만 붙어있고, 미사일의 개구간 (s,e) 사이의 값이라면 어느 곳이든 가능하다.아무튼 A 나라에서 미사일을 여러발 쏠 때, 이를 요격할 수 있는 최소한의 미사일 수를 구하는 문제이다.<br>
<img src="https://i.imgur.com/UzM9He1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이런 식으로 B가 최대한 많은 미사일을 요격할 수 있는 x좌표를 구하고, 이를 위해 최소 몇 개의 미사일이 필요한 지에 대해서 구해야 한다.맨 처음에는 2차원 배열로 기록한 다음에 열마다 확인하려고 했는데, 이 경우에는 targets의 길이가 500,000의 길이까지 커질 수 있고, 개구간 (s,e)는 100,000,000까지 갈 수 있으므로 배열로 풀기에는 너무 많은 메모리와 시간이 소모되어 불가능 할 것 같다. 최대한 많은 미사일을 한 번에 요격할 수 있어야 한다.
그렇다면 최대한 많은 미사일들이 지나가는 x좌표를 그때마다 선택하게 된다면 최소한으로 필요한 요격 미사일을 구할 수 있을 것 같다.
그렇다면 가장 많은 곳을 지나는 미사일 구간을 어떻게 찾느냐가 문제인데,,, 여전히 1억개의 구성 요소를 지닌 배열을 만들기에는 부담이 있다. 이를 배열이 아닌 다른 방식으로 풀 수 있는 방법이 있을까?
라는 생각에 그냥 처음에 sort로 s를 기준으로 한 오름차순 정렬을 한 뒤에 순차적으로 가면서 최대한 많이 미사일을 요격할 수 있는 방법으로 범위를 조정하면 되지 않을까? 생각했다.function solution(targets) { let missile = 0; let start = 0; let end = 0; targets.sort((a,b) =&gt; a[0] - b[0]) targets.forEach((target) =&gt; { if(end &lt;= target[0]) { missile++; start = target[0]; end = target [1]; } else{ if(start &lt; target[0]) start = target[0]; if(end &gt; target[1]) end = target[1]; } }) return missile
}
그래서 forEach로 요소들을 돌면서 미사일이 최대한 많이 요격할 수 있도록 미사일이 쏠 수 있는 범위를 start, end 따로 선언하여 미사일을 돌 때마다 조정했으며, 조정할 수 있는 범위를 넘겼을 경우에는 필요한 미사일이 하나 더 추가된다고 판단하여 이 때 미사일의 개수를 올려주었다.<br><img src="https://i.imgur.com/JLxRO1M.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
요격성공]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-요격-시스템.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 요격 시스템.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sat, 26 Oct 2024 10:18:38 GMT</pubDate><enclosure url="https://i.imgur.com/UzM9He1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/UzM9He1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[프로그래머스] 석유 시추]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/250136" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/250136</a>한 열을 수직으로 뚫는 시추관에서 한 번 뚫었을 때 가장 많이 받을 수 있는 석유의 양을 계산하는 문제
맨 처음에는 그냥 루프 돌아서 석유만 골라내면 되는거 아닌가 생각했지만,, 석유가 이어져 있을 경우 이어져있는 석유가 모두 들어오기 때문에 이에 대해서도 계산이 필요함DFS로 석유의 양을 계산한다고 하면 지나간 길을 표시해야 하는데, 이걸 얕은 복사로 해버리면 다음 열에서 시추를 할 때 지나간 길이 표시된 석유의 경우 판단하기 어렵다
그렇다고 깊은 복사로 해버리면, 열을 도는 과정에서 function solution(land) { const oilMap = new Map(); land.forEach((rowArr,row) =&gt; { rowArr.forEach((colArr, col) =&gt; { const oilRoad = []; const drilled = drilling(oilMap, land, row, col, oilRoad); oilRoad.forEach((oiledCol) =&gt; { if(oilMap.has(oiledCol)) oilMap.set(oiledCol,oilMap.get(oiledCol) + drilled); else oilMap.set(oiledCol, drilled); }) }) }) let max = 0; for (let val of oilMap.values()){ if(max&lt;val) max = val; } return max;
} function drilling(oilMap,land,row,col,road){ if(!land[row][col]) return 0; if(!road.includes(col)) road.push(col); land[row][col] = 0; let oils = 1; // dfs if(row &gt; 0) oils += drilling(oilMap,land, row-1, col, road); if(row&lt;land.length-1) oils += drilling(oilMap, land, row+1, col, road); if(col &gt; 0) oils += drilling(oilMap,land, row, col-1, road); if(col&lt;land[0].length-1) oils += drilling(oilMap, land, row, col+1, road); return oils;
}
이런 식으로 dfs 탐색을 하면서 지나간 자리를 0으로 만들고, 지나갔던 열에 대해서 모두 배열에 넣은 뒤에 map에서 col의 키값에 해당 석유 덩이의 크기만큼을 더해주는 방식으로 순회를 돌고, 마지막에는 만들어진 map에 대해서 최댓값을 찾도록 했다.<br><img src="https://i.imgur.com/OAVtMef.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
정확성 테스트는 모두 통과했으나, 효율성 테스트에서는 2개가 런타임 에러가 떴다.
다른 사람들이 질문한 것을 보았을 때, 아마 재귀가 깊어지면서 나오는 에러때문이 아닐까 싶었다.function solution(land) { const oilMap = new Map(); for (let row = 0; row &lt; land.length; row++) { for (let col = 0; col &lt; land[row].length; col++) { if (land[row][col]) { const oilRoad = []; const drilled = drilling(oilMap, land, row, col, oilRoad); oilRoad.forEach((oiledCol) =&gt; { if (oilMap.has(oiledCol)) { oilMap.set(oiledCol, oilMap.get(oiledCol) + drilled); } else { oilMap.set(oiledCol, drilled); } }); } } } let max = 0; for (let val of oilMap.values()) { if (max &lt; val) max = val; } return max;
} function drilling(oilMap, land, startRow, startCol, road) { const queue = [[startRow, startCol]]; let oils = 0; while (queue.length &gt; 0) { const [row, col] = queue.shift(); if (land[row][col] === 0) continue; oils++; land[row][col] = 0; if (!road.includes(col)) road.push(col); if (row &gt; 0 &amp;&amp; land[row - 1][col]) queue.push([row - 1, col]); if (row &lt; land.length - 1 &amp;&amp; land[row + 1][col]) queue.push([row + 1, col]); if (col &gt; 0 &amp;&amp; land[row][col - 1]) queue.push([row, col - 1]); if (col &lt; land[0].length - 1 &amp;&amp; land[row][col + 1]) queue.push([row, col + 1]); } return oils;
}
이번에는 BFS를 활용하여 문제를 풀었을 때 모두 정답이 떴다.
BFS의 경우에는 재귀를 이용하지 않고 큐를 이용하기 때문에, 런타임 에러가 발생하지 않아 정답이 뜬 것으로 보인다.]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-석유-시추.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 석유 시추.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 25 Oct 2024 11:18:02 GMT</pubDate><enclosure url="https://i.imgur.com/OAVtMef.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/OAVtMef.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 7576] 토마토]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.acmicpc.net/problem/7576" target="_self">https://www.acmicpc.net/problem/7576</a>격자 모양 상자의 칸에 하나씩 토마토가 들어가있음
익지 않은 토마토도 익은 토마토에 인접(상하좌우에 존재)하면 하루 뒤 익게 됨
토마토가 모두 익을 때까지의 최소 날짜 출력해당 문제는 BFS로 풀 수 있다.
날짜를 하루씩 더해가면서 익은 토마토 상하좌우에 있는 익지 않은 토마토를 익은 상태로바꿔주면 된다.
날짜를 하루씩 더해가면서 익은 토마토를 기준으로 전진하고, 익은 토마토가 인접해서 익은 토마토가 있다면 익은 토마토의 방향쪽으로 전진한 다음 일수를 누적시키면서 재귀적으로 호출을 시켜준다.
이렇게 계속 전진을 시켜주다 보면 마지막에 익지 않은 토마토가 모두 익은 경우에 결과만 출력시켜주면 된다.]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-7576]-토마토.html</link><guid isPermaLink="false">알고리즘/[백준 7576] 토마토.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 22 Sep 2024 23:39:17 GMT</pubDate></item><item><title><![CDATA[[백준 12865] 평범한 배낭]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.acmicpc.net/problem/12865" target="_self">https://www.acmicpc.net/problem/12865</a>한 달 뒤 입대하는 준서를 위해서..준서가 여행에 필요하다고 생각하는 N개의 물건에 대해 가져갈 수 있는 조합의 총 가치를 구한 다음에 여기서 최고의 가치를 지니는 조합을 리턴하면 된다.N개의 물건과 최대 K의 무게라는 조건이 붙는다.내가 처음에 선택했던 방식은 완전탐색방식이었다. let input = require("fs").readFileSync("/dev/stdin").toString().split("\n"); const [N, K] = input[0].split(" "); const stuffs = input.slice(1); let result = []; function takeStuff(left, val, allStuffs, result) { allStuffs.forEach((stuff, idx) =&gt; { const [w, v] = stuff.split(" ").map((t) =&gt; parseInt(t)); if (left - w &gt;= 0) takeStuff( left - w, val + v, allStuffs.filter((_, i) =&gt; i !== idx), result ); }); result.push(val); return;
} takeStuff(K, 0, stuffs, result);
console.log(Math.max(...result)); 해당 문제를 하위의 문제들로 나누어보면하나의 물건을 선택 -&gt; 총 무게에서 해당 무게를 뺀 무게에서 가능한 물건들을 모두 구하기해당 조건을 계속해서 반복해가면서, 바닥조건이 보일 때까지 반복하여 가치를 구해야 한다.
이러한 조건을 만족하기 위해서는 기존 내가 선택한 물건들에 대해서 어떤 물건을 이미 선택했는지를 알아야 하고, 현재까지 누적된 가치 또한 알아야 하기 때문에 나는 재귀적인 방식을 통해서 가치를 누적하면서도 모든 경우의 수에 대해서 배열에 넣어 해당 배열의 최댓값을 구하면 된다고 생각했다.하지만 이러한 완전탐색은 답은 맞지만 시간이 오래걸린다는 단점이 있다.따라서 해당 문제를 다이나믹 프로그래밍으로 다시금 접근해야 한다.let input = require("fs").readFileSync("/dev/stdin").toString().split("\n"); const [N, K] = input[0].split(" ").map(Number);
const stuffs = input.slice(1).map((line) =&gt; line.split(" ").map(Number)); const dp = Array(K + 1).fill(0); for (let i = 0; i &lt; N; i++) { const [w, v] = stuffs[i]; for (let j = K; j &gt;= w; j--) { dp[j] = Math.max(dp[j], dp[j - w] + v); }
} console.log(dp[K]);
해당 방식은 dp 테이블을 만들고 해당 테이블을 활용하는 방식이다.최대 K의 무게를 지닐 수 있을 때 가질 수 있는 최대의 가치를 dp[n] 에 기록해놓는다.
이후 만들어진 dp 테이블에 대해서 모든 물건들에 대해서 반복을 돌게 되는데, 하지만 이러한 물건에 대해서 그대로 dp 테이블을 도는 것이 아닌, 거꾸로 dp 테이블의 끝에서부터 해당하는 물건의 무게까지 dp 테이블을 돈다.
거꾸로 dp 테이블을 도는 이유는, 0부터 dp 테이블을 돌게 된다면 애초에 dp테이블의 w 이전 값들에 대한 값들은 전부 0이 될 수밖에 없다. n의 무게에서 최대로 가질 수 있는 가치를 기록해놓는 테이블이기 때문에 n 이전의 무게는 w가 더 무겁기 때문에 가치가 갱신될 것이 없다.테이블을 도는 과정에서 dp[n]에 있는 수는 Math.max를 통해 최댓값을 기존 dp에 있는 값과의 비교를 통해 가치가 현재가 더 크다면 업데이트를, 더 크지 않다면 기존 값을 선택해서 dp테이블의 값을 갱신시킨다. ]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-12865]-평범한-배낭.html</link><guid isPermaLink="false">알고리즘/[백준 12865] 평범한 배낭.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 22 Sep 2024 12:08:56 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 주차 요금 계산]]></title><description><![CDATA[입차와 출차요금표입차된 후 출차 x -&gt; 23:59
00:00 ~ 23:59 입출차 내역을 바탕으로 차량별 누적 주차 시간 계산 및 요금 일괄 정산누적 주차 시간
기본 시간 이하 -&gt; 기본 요금
기본 시관 초과 -&gt; 기본 요금 + 초과한 시간에 대해서 단위 시간마다 단위 요금 시간 나눈 값에 올림 ]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-주차-요금-계산.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 주차 요금 계산.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 20 Sep 2024 07:31:36 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 행렬 테두리 회전하기]]></title><description><![CDATA[rows x columns 크기의 행렬
한 줄씩 순서대로 적혀있는 숫자들
이 행렬에서 직사각형 모양의 범위를 선택해 테두리 부분만 시계 방향으로 회전(x1,y1,x2,y2) -&gt; x1행 y1열부터 x2행 y2열까지의 직사각형에서 테두리 숫자들을 한칸씩 시계방향으로 회전
움직이는 것들(테두리에 있는 수들) x1, x2행의 y1~y2까지 모든 수들 x1~x2행의 y1과 y2들
어떻게 회전시킬 것이냐? y1, y2의 위치일 경우 y1, y2, 오른쪽 상단 -&gt; x1행의 y2일 경우 -&gt; x1 + 1행의 y2위치 오른쪽 하단 -&gt; x2-1행의 y2일 경우 -&gt; x2행의 y2위치로 순서대로 x,y의 배열 만들어놓기
queries forEach로 받기 save에 이동시킬 수 저장해놓기 ]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-행렬-테두리-회전하기.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 행렬 테두리 회전하기.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Thu, 19 Sep 2024 02:54:13 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 두 원 사이의 정수 쌍]]></title><description><![CDATA[r1과 r2가 주어지면, r1에 해당하는 원과 r2에 해당하는 원 사이의 공간에 x좌표와 y좌표가 모두 정수인 점의 개수를 리턴하는 문제일단 r1 &lt; r2의 관계이기 떄문에 R1과 r2사이의 정수 좌표는 8개를 디폴트로 하고 시작한다
상하좌우 x좌표와 y좌표에 걸쳐있는 쪽은 무조건 사이에 있으면서도 반지름이 정수이기 때문에 x좌표와 y좌표 모두 걸쳐져 있는 좌표가 정수로 되어있기 때문이다
그렇다면 그 사이에 있는 것들이 문제인데..<img src="https://i.imgur.com/LZDU4AA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
요렇게 생긴 두 원의 사이에서 해당 원은 무조건 원점을 기준으로 하는 원이기 때문에 4가지의 영역 모두 사이에 있는 정수 x, y좌표가 서로의 부호만 다를 뿐이지 사실상 절대값으로 따지면 모두 같은 위치이다.<br><img src="https://i.imgur.com/5oOg924.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
따라서 굳이 하나하나 다 구하기 보다는, 한쪽을 구해놓고 x4를 하는 편이 합리적으로 보인다.
그럼 이제 남은 문제는 이 사이의 값을 어떻게 구할 것이냐인데,,
더 큰 원을 지나는 x좌표와 y좌표를 모두 구한다? 1,000,000까지 반지름의 길이가 될 수 있는데 이걸 모두 구하는 것은 비합리적이라고 생각해서 일단 보류 큰 원 안의 정수 좌표들에서 작은 원의 조건을 뺀 다음 거리를 계산해서 원 세기 작은 쪽의 원의 반지름만큼의 길이를 가진 정사각형부터 시작한다면, 조건의 수를 확실히 줄일 수 있다 2번 방식대로 풀 경우,
작은 원의 반지름을 구해서 정사각형의 각 변부터 시작 (큰 원의 반지름 - 작은 원의 반지름)
x좌표와 y좌표를 하나씩 올려가면서 큰 원 안에 들어오는지 확인 큰 원 안에 들어오는 경우는 피타고라스의 정리를 이용하여 구한 대각선이 큰 원의 반지름보다 작아야 함 a^2 + b^2 = r^2
r^2 -a^2 = b^2]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 두 원 사이의 정수 쌍.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Wed, 18 Sep 2024 11:49:00 GMT</pubDate><enclosure url="https://i.imgur.com/LZDU4AA.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/LZDU4AA.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[프로그래머스] 방금그곡]]></title><description><![CDATA[자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악 찾기반복 재생 -&gt; 끝과 처음이 이어서 재생된 멜로디일 수도 있음
중간에 음악을 끊을 경우 곡이 다를 수도 있음
=&gt; 기억한 멜로디를 재생 시간과 제공된 악보를 보면서 비교
음악제목, 재생되고 끝난시간, 악보
음 -&gt; C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개
악보의 총 음 개수를 구한다
시 -&gt; 분으로 바꾼 뒤, 얼마만큼 재생이 되었는지 분단위로 파악한다
분단위로 파악한 뒤에는 기존 음악의 멜로디에 반복된 수만큼 악보 또한 반복해준 악보를 배열에 저장한다
배열을 돌면서 해당 문자열이 포함되어 있는지 검색한다
이 과정에서 #이 포함된 음정이 있을경우 이를 어떻게 포함해서 문자열에 만드느냐?]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-방금그곡.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 방금그곡.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Tue, 17 Sep 2024 09:52:09 GMT</pubDate></item><item><title><![CDATA[[백준 1004] 어린왕자]]></title><description><![CDATA[import sys # 시작점 혹은 도착점이 원 안에 들어있는지 확인
def in_circle(x,y,r,temp_x,temp_y): if r**2 &gt; (( x - temp_x)**2) + ((y - temp_y)**2): return True else: return False # 테스트 케이스
T = int(sys.stdin.readline()) result_print = []
#테스트 케이스 동안
for i in range(T): #시작점, 도착점 start_x, start_y, end_x, end_y = map(int, sys.stdin.readline().split()) # 행성 개수 받기 planet = int(sys.stdin.readline()) # 행성 개수만큼 행성 좌표 받기 result = 0 for j in range(planet): planet_x, planet_y, r = map(int,sys.stdin.readline().split()) # 출발점과 도착점이 원 안에 있을 경우만 생각 if in_circle(planet_x,planet_y,r,start_x,start_y) and in_circle(planet_x,planet_y,r,end_x,end_y): pass elif in_circle(planet_x,planet_y,r,start_x,start_y): result += 1 elif in_circle(planet_x,planet_y,r,end_x,end_y): result += 1 result_print.append(result) for k in result_print: print(k) 적혀있는 문제와 좌표와 원이 난무하는 그림을 보면 정말 풀기 싫어지는 문제
하지만 어떻게 풀지 초반에 생각만 잘 하면 쉽다처음에는 테스트 케이스를 받고 해당 테스트 케이스 수만큼 행성의 좌표를 받아서 저장 받는건 쉽게 할 수 있고 문제는 어떻게 행성으로 진입/이탈하는 것을 아느냐이다.<img height="300/" src="https://i.imgur.com/vaknXFl.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="width: 400px; max-width: 100%;">보면 어떤 행성이 어디에 있건 간에 어린왕자가 출발하고 도착점에 도달하면서 진입/이탈하는 경우는 출발점이나 도착점이 원 안에 있을 경우밖에 없다. 다른 행성들은 어린왕자가 알아서 무빙치면서 피해갈 것이기 때문에 해당 경우만 생각하면 된다. 이미 원 안에 있으면 무조건 진입/이탈이 필요하니까.하지만 이 경우에도 생각해야 할 것이 출발점과 도착점이 모두 같은 원 안에 있을 경우를 생각해야 한다. 출발점과 도착점이 같은 원 안에 있다면 굳이 진입/이탈할 필요가 없이 행성 안에서 이동할 수 있기 때문이다.그러면 우리가 생각할 수 있는 로직은
출발점과 도착점이 같은 원 안에 있을 경우는 패스
출발점만 원 안에 있을 경우에 진입/이탈 횟수 1회 추가
도착점만 원 안에 있을 경우에 진입/이탈 횟수 1회 추가
이다. 이 경우만 생각해주면 나머지는 어린왕자가 알아서 할 것이다.
원 안에 있는지 확인하는 방법은 쉽다. 피타고라스의 방정식을 이용하면 된다.
x^2 + y^2 = r^2 이므로 해당 반지름의 제곱보다 출발점/도착점의 좌표가 작으면 안에 있다고 생각할 수 있다.def in_circle(x,y,r,temp_x,temp_y): if r**2 &gt; (( x - temp_x)**2) + ((y - temp_y)**2): return True else: return False
해당 함수는 행성의 x,y좌표와 반지름, 출발점/도착점을 받아 만약 행성 안에 있으면 True를 반환한다. 이럴 경우에만 result에 1을 추가해주면 된다.<br><img src="https://i.imgur.com/sL7DX4a.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
하지만 메모리는 오지게 갉아먹는 모오습]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-1004]-어린왕자.html</link><guid isPermaLink="false">알고리즘/[백준 1004] 어린왕자.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/vaknXFl.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/vaknXFl.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>