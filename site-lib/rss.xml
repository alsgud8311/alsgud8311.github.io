<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 1 at column 956: Input is not proper UTF-8, indicate encoding !
Bytes: 0x08 0xEC 0x84 0xA4
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[Minhyung's Dev Log]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://alsgud8311.github.io/</link><image><url>https://alsgud8311.github.io/site-lib/media/favicon.png</url><title>Minhyung's Dev Log</title><link>https://alsgud8311.github.io/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 02 Feb 2025 15:41:14 GMT</lastBuildDate><atom:link href="https://alsgud8311.github.io/site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 02 Feb 2025 15:38:26 GMT</pubDate><copyright><![CDATA[Cho Minhyung]]></copyright><ttl>60</ttl><dc:creator>Cho Minhyung</dc:creator><item><title><![CDATA[기술면접]]></title><description/></item><item><title><![CDATA[index]]></title><description><![CDATA[개발 관련한 모든 것들을 기록하는 저장소입니다.
<a data-href="알고리즘" href="https://alsgud8311.github.io/알고리즘/알고리즘.html#_0" class="internal-link" target="_self" rel="noopener nofollow">알고리즘</a>
<br><a data-href="학습 정리" href="https://alsgud8311.github.io/부스트캠프/챌린지/학습-정리.html" class="internal-link" target="_self" rel="noopener nofollow">학습 정리</a>
]]></description><link>https://alsgud8311.github.io/index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 02 Feb 2025 14:24:09 GMT</pubDate></item><item><title><![CDATA[[백준31784] 포닉스의 문단속]]></title><description><![CDATA[<img src="https://i.imgur.com/p4MrRmQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
N개의 다이얼이 연결된 자물쇠를 돌려서 풀어야 하는데 다이얼 중 하나를 골라 1번 돌리는 작업을 해야 하는데, K번을 돌려서 나올 수 있는 단어 중에 가장 사전순으로 앞인 단어를 찾으면 된다.내가 가진 정보는 자물쇠의 길이 N과 작업의 횟수 K
그리고 다음 줄에는 문자열 S가 주어진다
해당 문자열에서 돌려서 가장 사전순으로 작은 문자열을 만들면 된다.<br><img src="https://i.imgur.com/zSYDvvb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
예제를 보자.4 3
ABCD
의 경우, 3번을 돌려 나올 수 있는 사전순으로 가장 작은 단어는 ABCG이다.
ABC는 어차피 사전순으로 가장 앞이므로 D를 세번 돌려 D -&gt; E -&gt; F -&gt; G를 만들었다.4 5
XYZW
해당 문자열은 XYZW가 AAZW로 변했다.
X -&gt; Y -&gt; Z -&gt; A
Y -&gt; Z -&gt; A
로 총 5번을 돌렸다.이를 통해 가장 앞인 문자부터 검사해서 돌려서 만약 알파벳 앞 순위의 숫자로 변환할 수 있다면 변환하는 것을 알 수 있다.
그리디 알고리즘이 이에 대해 가장 잘 맞는 알고리즘같다.
앞문자열부터 하나씩 검사
알파벳의 아스키코드를 더했을 때 이전보다 사전순으로 앞인 알파벳이 나오면 더한다.
없으면 뒤로 돌린다
마지막에 남은 횟수를 다 돌린다.
정도로 생각할 수 있다.
]]></description><link>https://alsgud8311.github.io/알고리즘/[백준31784]-포닉스의-문단속.html</link><guid isPermaLink="false">알고리즘/[백준31784] 포닉스의 문단속.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sat, 01 Feb 2025 02:45:38 GMT</pubDate><enclosure url="https://i.imgur.com/p4MrRmQ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/p4MrRmQ.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[알고리즘]]></title><description><![CDATA[<a data-href="[백준 1004] 어린왕자" href="https://alsgud8311.github.io/알고리즘/[백준-1004]-어린왕자.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 1004] 어린왕자</a><br>
<a data-href="[프로그래머스] 방금그곡" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-방금그곡.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 방금그곡</a><br>
<a data-href="[프로그래머스] 두 원 사이의 정수 쌍" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 두 원 사이의 정수 쌍</a><br>
<a data-href="[프로그래머스] 행렬 테두리 회전하기" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-행렬-테두리-회전하기.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 행렬 테두리 회전하기</a><br>
<a data-href="[프로그래머스] 주차 요금 계산" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-주차-요금-계산.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 주차 요금 계산</a><br>
<a data-href="[백준 12865] 평범한 배낭" href="https://alsgud8311.github.io/알고리즘/[백준-12865]-평범한-배낭.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 12865] 평범한 배낭</a><br>
<a data-href="[백준 7576] 토마토" href="https://alsgud8311.github.io/알고리즘/[백준-7576]-토마토.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 7576] 토마토</a><br>
<a data-href="[프로그래머스] 석유 시추" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-석유-시추.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 석유 시추</a><br>
<a data-href="[프로그래머스] 요격 시스템" href="https://alsgud8311.github.io/알고리즘/[프로그래머스]-요격-시스템.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[프로그래머스] 요격 시스템</a><br>
<a data-href="[백준 9251] LCS" href="https://alsgud8311.github.io/알고리즘/[백준-9251]-lcs.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 9251] LCS</a><br>
<a data-href="[백준 1912] 연속합" href="https://alsgud8311.github.io/알고리즘/[백준-1912]-연속합.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 1912] 연속합</a><br>
<a data-href="[백준11631] ASCII Addition" href="https://alsgud8311.github.io/알고리즘/[백준11631]-ascii-addition.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준11631] ASCII Addition</a><br>
<a data-href="[백준14596] Quilting(smaill)" href="https://alsgud8311.github.io/알고리즘/[백준14596]-quilting(smaill).html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준14596] Quilting(smaill)</a><br>
<a data-href="[백준 17123] 배열 놀이" href="https://alsgud8311.github.io/알고리즘/[백준-17123]-배열-놀이.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준 17123] 배열 놀이</a><br>
<a data-href="[백준31784] 포닉스의 문단속" href="https://alsgud8311.github.io/알고리즘/[백준31784]-포닉스의-문단속.html#_0" class="internal-link" target="_self" rel="noopener nofollow">[백준31784] 포닉스의 문단속</a>]]></description><link>https://alsgud8311.github.io/알고리즘/알고리즘.html</link><guid isPermaLink="false">알고리즘/알고리즘.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sat, 01 Feb 2025 02:34:19 GMT</pubDate></item><item><title><![CDATA[[백준 17123] 배열 놀이]]></title><description><![CDATA[<img src="https://i.imgur.com/XDa3R5Q.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">N x N의 행렬에서 [r1,c1] - [r2,c2]로 이루어진 사각형에 v를 더하면 된다
각 대각선으로 된 꼭짓점의 좌표이므로
[r1,c1] - [r1,c2] - [r2,c1] - [r2,c2] 가 각 꼭짓점인 사각형의 값들에 대해서 전부 v씩 더하면 된다.특정한 알고리즘이 딱히 필요한 것 같지는 않다const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const inputs = require("fs") .readFileSync(INPUT_FILE) .toString() .trim() .split("\n"); const t = +inputs[0]; for (let i = 1; i &lt; inputs.length; i++) { const [n, m] = inputs[i].split(" ").map(Number); const map = inputs .slice(i + 1, i + n + 1) .map((row) =&gt; row.split(" ").map(Number)); const tests = inputs .slice(i + n + 1, i + n + m + 1) .map((test) =&gt; test.split(" ").map(Number)); for (const [r1, c1, r2, c2, v] of tests) { for (let k = r1 - 1; k &lt;= r2 - 1; k++) { for (let j = c1 - 1; j &lt;= c2 - 1; j++) { map[k][j] += v; } } } const resultRow = map.map((row) =&gt; row.reduce((acc, curr) =&gt; acc + curr, 0)); const resultCol = Array(n).fill(0); //열 for (let l = 0; l &lt; n; l++) { let acc = 0; for (let h = 0; h &lt; n; h++) { acc += map[h][l]; } resultCol[l] = acc; } console.log(resultRow.join(" ")); console.log(resultCol.join(" ")); i += n + m;
} 그래서 그냥 했다
근데 시간 초과가 떴다]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-17123]-배열-놀이.html</link><guid isPermaLink="false">알고리즘/[백준 17123] 배열 놀이.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 31 Jan 2025 03:14:43 GMT</pubDate><enclosure url="https://i.imgur.com/XDa3R5Q.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/XDa3R5Q.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준14596] Quilting(smaill)]]></title><description><![CDATA[두 패턴의 이미지를 포개면서, 가장 최적의 동선을 통해 부자연스러움의 정도가 가장 낮은 경계를 골라 해당 동선의 부자연스러움의 정도를 출력해야 한다.<img src="https://i.imgur.com/aR713da.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<img src="https://i.imgur.com/jU8rnI2.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
문제 드럽게 기네;일단 여기서 주의해야 할 점은
아래 같은 인덱스거나 +-1 의 경계까지만 움직일 수 있으므로 여기서 가장 주의를 해야한다그렇다면 맨 위에서부터 가장 최적의 동선을 골라야 할텐데, 이게 어디서 시작하느냐에 따라서도 최적의 경계가 바뀔 수도 있다. 그러므로 해당 문제는 가장 위쪽 모든 인덱스에서 출발하면서 최적의 동선을 가지는 쪽으로 움직여야 하기 때문에 dp로 풀어야 함을 알 수 있다.그렇다면 시작점을 기준으로 배열을 만든 다음, 해당 시작점에서 가지는 최소의 부자연스러움을 각각 구한다음에 그 중 최소인 부자연스러움 정도를 가지고 오면 된다.]]></description><link>https://alsgud8311.github.io/알고리즘/[백준14596]-quilting(smaill).html</link><guid isPermaLink="false">알고리즘/[백준14596] Quilting(smaill).md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Wed, 29 Jan 2025 14:24:49 GMT</pubDate><enclosure url="https://i.imgur.com/aR713da.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/aR713da.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준11631] ASCII Addition]]></title><description><![CDATA[아.. 이거 전에 모 코테에서 본 문제와 비슷한 문제
그 때 제대로 풀지 못해서 멘붕 왔었는데 이번엔 제대로 풀어본다.<img src="https://i.imgur.com/xQr9x8I.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">아스키 아트는 칠해지는 부분이 x로 되어 있고, 총 7개의 row와 5개의 column으로 되어 있다.
a+b의 형태로 아스키 아트가 주어지면 이를 인식하고 이에 대한 두 수의 합을 다시 아스키 코드로 나타내야 한다.const fs = require("fs"); const INPUT_FILE = process.platform === "linux" ? "/dev/stdin" : "./inputs.txt";
const input = fs.readFileSync(INPUT_FILE).toString().trim().split("\n"); const asciiPatterns = [ `xxxxx\nx...x\nx...x\nx...x\nx...x\nx...x\nxxxxx`, `....x\n....x\n....x\n....x\n....x\n....x\n....x`, `xxxxx\n....x\n....x\nxxxxx\nx....\nx....\nxxxxx`, `xxxxx\n....x\n....x\nxxxxx\n....x\n....x\nxxxxx`, `x...x\nx...x\nx...x\nxxxxx\n....x\n....x\n....x`, `xxxxx\nx....\nx....\nxxxxx\n....x\n....x\nxxxxx`, `xxxxx\nx....\nx....\nxxxxx\nx...x\nx...x\nxxxxx`, `xxxxx\n....x\n....x\n....x\n....x\n....x\n....x`, `xxxxx\nx...x\nx...x\nxxxxx\nx...x\nx...x\nxxxxx`, `xxxxx\nx...x\nx...x\nxxxxx\n....x\n....x\nxxxxx`, `.....\n..x..\n..x..\nxxxxx\n..x..\n..x..\n.....`,
]; const asciiToCharMap = {};
asciiPatterns.forEach((pattern, index) =&gt; { asciiToCharMap[pattern] = index === 10 ? "+" : index.toString();
}); const ROWS = 7;
const COLS = 5; const splitInput = [];
for (let i = 0; i &lt; input[0].length; i += COLS + 1) { const block = []; for (let j = 0; j &lt; ROWS; j++) { block.push(input[j].slice(i, i + COLS)); } splitInput.push(block.join("\n"));
} const expression = splitInput.map((block) =&gt; asciiToCharMap[block]).join("");
const [a, b] = expression.split("+").map(BigInt); const result = (a + b).toString(); const charToAsciiMap = Object.fromEntries( asciiPatterns.map((pattern, index) =&gt; [ index === 10 ? "+" : index.toString(), pattern, ])
); const resultAscii = Array(ROWS).fill("");
for (const char of result) { const asciiBlock = charToAsciiMap[char].split("\n"); for (let i = 0; i &lt; ROWS; i++) { resultAscii[i] += (resultAscii[i] ? "." : "") + asciiBlock[i]; }
} console.log(resultAscii.join("\n")); 응 다 노가다로 아스키 맵 만들면 그만이야~
이딴 문제 만들지좀 마라]]></description><link>https://alsgud8311.github.io/알고리즘/[백준11631]-ascii-addition.html</link><guid isPermaLink="false">알고리즘/[백준11631] ASCII Addition.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Tue, 28 Jan 2025 06:56:39 GMT</pubDate><enclosure url="https://i.imgur.com/xQr9x8I.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/xQr9x8I.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 1912] 연속합]]></title><description><![CDATA[
n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
문제에서 나온 예시로 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌을 때, 여기서 정답은 12+21인 33이 정답이 된다.해당 문제에서 주목해야 할 점은 연속된 몇 개의 수와 구할 수 있는 합 중 가장 큰 합이다.
그럼 연속된 몇 개의 수는 어떻게 구해야 하는가?
일단은 계속 배열을 돌아가면서 최대한 큰 수를 만들 수 있도록 해야 하는데 이를 기록하고 가장 큰 값을 도출해내기 위해선 동적 계획법을 통해 풀어야 함을 알았다.그렇다면 동적 계획법에서 중요한 것은 점화식인데, 어떤 식으로 점화식을 도출해 낼까?
일단 우리에게 주어지는 것은 n의 정보와 수열의 정보이다. 이를 가지고 연속된 수 중에 가장 최대한 큰 수를 계속 기록하기 위해서는 수열이 배열이라는 가정 하에 생각해보면 된다.
배열을 처음부터 끝까지 돌면서 우리는 연속된 수들을 만날 것이다. 이 연속된 수에서 우리는 기존의 누적된 값을 현재 보고 있는 값과 비교해야 한다.
여기서 중요한 점은 무조건 음수라고 해서 거기서 끊어야 하는게 아닌, 음수라고 하더라도 그 뒤에 연속되는 값을 더했을 때 가장 큰 수가 된다면 음수라도 포함할 수 있는 경우를 생각해야 한다.
그렇다면 점화식은 이전까지 누적된 값과 현재 보고 있는 값을 더했을 때와 현재 값 중에 더 큰 값을 골라야 한다. dp[n] = max(dp[n-1] + arr[n], arr[n])]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-1912]-연속합.html</link><guid isPermaLink="false">알고리즘/[백준 1912] 연속합.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Tue, 07 Jan 2025 01:33:34 GMT</pubDate></item><item><title><![CDATA[[백준 9251] LCS]]></title><description><![CDATA[
해를 분석해서 부문제로 분할하기 부문제의 해로 큰 문제의 해를 표현(점화식)
부문제들의 해를 가지고 있는 dp table을 채우기 table에서 해를 계산하여 알고리즘의 correctness 검증
stringA : ACAYKP
stringB: CAPCAKAn과 Bm의 최장길이 공통 부문자열의 길이를 구해야 함
이를 어떻게 작은 문제들로 쪼갤 수 있을까?
LCS(i,j) =&gt; Ai과 Bj의 LCS 길이
Ai와 Bj가 서로 같다면 최장길이 공통 문자열에 추가된다.
이는 곧 이 두 문자열을 비교했을 때, 두 문자열이 서로 같다면 길이가 1 증가한다는 뜻이다.
나머지는 A1,A2,...Ai-1
B1,B2,...Bj-1
로 나뉘어 질 수 있다.
그렇다면 이 문자열들에 대해서도 계속 공통 문자열을 비교하면서 나아가면 되지 않을까?
마지막 두 문자열이 같을 때 : LCS(i,j) = LCS(i-1,j-1) + 1
라고 볼 수 있다. 하지만 마지막 두 문자열이 다를 때는 간단하게 LCS(i,j) = LCS(i-1,j-1)라고만 생각하면 안된다. 왜냐면 나중에 A의 마지막 문자열이 포함되어 있지만 B의 마지막 문자열은 포함되어 있지 않을 수 있고, B의 마지막 문자열이 포함되어 있지만 A의 마지막 문자열을 포함되어 있지 않을 수 있기 때문이다. (여기서 A,B문자열이 모두 같은 경우는 이미 아니기 때문에 제외한다)
그렇기 때문에 우리가 원하는 LCS는 LCS(i,j-1) 과 LCS(i-1,j) 중 더 길이가 긴 것으로 선택해야 한다.
그렇다면 이 LCS(i,j-1)과 LCS(i-1,j)를 미리 구해놔야 한단 소리기 때문에 dp 테이블을 만들어서 이에 대한 값을 메모이제이션 해놓으면 된다.]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-9251]-lcs.html</link><guid isPermaLink="false">알고리즘/[백준 9251] LCS.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Wed, 18 Dec 2024 08:54:21 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 요격 시스템]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/181188" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/181188</a>A 나라와 B 나라 간에 전쟁중에 A는 x축에 평행한 미사일을 발사하고, B 나라는 이를 수직으로 요격한다.
조건은 미사일의 양 끝에서는 요격을 할 수 없다는 조건만 붙어있고, 미사일의 개구간 (s,e) 사이의 값이라면 어느 곳이든 가능하다.아무튼 A 나라에서 미사일을 여러발 쏠 때, 이를 요격할 수 있는 최소한의 미사일 수를 구하는 문제이다.<br>
<img src="https://i.imgur.com/UzM9He1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
이런 식으로 B가 최대한 많은 미사일을 요격할 수 있는 x좌표를 구하고, 이를 위해 최소 몇 개의 미사일이 필요한 지에 대해서 구해야 한다.맨 처음에는 2차원 배열로 기록한 다음에 열마다 확인하려고 했는데, 이 경우에는 targets의 길이가 500,000의 길이까지 커질 수 있고, 개구간 (s,e)는 100,000,000까지 갈 수 있으므로 배열로 풀기에는 너무 많은 메모리와 시간이 소모되어 불가능 할 것 같다. 최대한 많은 미사일을 한 번에 요격할 수 있어야 한다.
그렇다면 최대한 많은 미사일들이 지나가는 x좌표를 그때마다 선택하게 된다면 최소한으로 필요한 요격 미사일을 구할 수 있을 것 같다.
그렇다면 가장 많은 곳을 지나는 미사일 구간을 어떻게 찾느냐가 문제인데,,, 여전히 1억개의 구성 요소를 지닌 배열을 만들기에는 부담이 있다. 이를 배열이 아닌 다른 방식으로 풀 수 있는 방법이 있을까?
라는 생각에 그냥 처음에 sort로 s를 기준으로 한 오름차순 정렬을 한 뒤에 순차적으로 가면서 최대한 많이 미사일을 요격할 수 있는 방법으로 범위를 조정하면 되지 않을까? 생각했다.function solution(targets) { let missile = 0; let start = 0; let end = 0; targets.sort((a,b) =&gt; a[0] - b[0]) targets.forEach((target) =&gt; { if(end &lt;= target[0]) { missile++; start = target[0]; end = target [1]; } else{ if(start &lt; target[0]) start = target[0]; if(end &gt; target[1]) end = target[1]; } }) return missile
}
그래서 forEach로 요소들을 돌면서 미사일이 최대한 많이 요격할 수 있도록 미사일이 쏠 수 있는 범위를 start, end 따로 선언하여 미사일을 돌 때마다 조정했으며, 조정할 수 있는 범위를 넘겼을 경우에는 필요한 미사일이 하나 더 추가된다고 판단하여 이 때 미사일의 개수를 올려주었다.<br><img src="https://i.imgur.com/JLxRO1M.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
요격성공]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-요격-시스템.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 요격 시스템.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sat, 26 Oct 2024 10:18:38 GMT</pubDate><enclosure url="https://i.imgur.com/UzM9He1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/UzM9He1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[프로그래머스] 석유 시추]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/250136" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/250136</a>한 열을 수직으로 뚫는 시추관에서 한 번 뚫었을 때 가장 많이 받을 수 있는 석유의 양을 계산하는 문제
맨 처음에는 그냥 루프 돌아서 석유만 골라내면 되는거 아닌가 생각했지만,, 석유가 이어져 있을 경우 이어져있는 석유가 모두 들어오기 때문에 이에 대해서도 계산이 필요함DFS로 석유의 양을 계산한다고 하면 지나간 길을 표시해야 하는데, 이걸 얕은 복사로 해버리면 다음 열에서 시추를 할 때 지나간 길이 표시된 석유의 경우 판단하기 어렵다
그렇다고 깊은 복사로 해버리면, 열을 도는 과정에서 function solution(land) { const oilMap = new Map(); land.forEach((rowArr,row) =&gt; { rowArr.forEach((colArr, col) =&gt; { const oilRoad = []; const drilled = drilling(oilMap, land, row, col, oilRoad); oilRoad.forEach((oiledCol) =&gt; { if(oilMap.has(oiledCol)) oilMap.set(oiledCol,oilMap.get(oiledCol) + drilled); else oilMap.set(oiledCol, drilled); }) }) }) let max = 0; for (let val of oilMap.values()){ if(max&lt;val) max = val; } return max;
} function drilling(oilMap,land,row,col,road){ if(!land[row][col]) return 0; if(!road.includes(col)) road.push(col); land[row][col] = 0; let oils = 1; // dfs if(row &gt; 0) oils += drilling(oilMap,land, row-1, col, road); if(row&lt;land.length-1) oils += drilling(oilMap, land, row+1, col, road); if(col &gt; 0) oils += drilling(oilMap,land, row, col-1, road); if(col&lt;land[0].length-1) oils += drilling(oilMap, land, row, col+1, road); return oils;
}
이런 식으로 dfs 탐색을 하면서 지나간 자리를 0으로 만들고, 지나갔던 열에 대해서 모두 배열에 넣은 뒤에 map에서 col의 키값에 해당 석유 덩이의 크기만큼을 더해주는 방식으로 순회를 돌고, 마지막에는 만들어진 map에 대해서 최댓값을 찾도록 했다.<br><img src="https://i.imgur.com/OAVtMef.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
정확성 테스트는 모두 통과했으나, 효율성 테스트에서는 2개가 런타임 에러가 떴다.
다른 사람들이 질문한 것을 보았을 때, 아마 재귀가 깊어지면서 나오는 에러때문이 아닐까 싶었다.function solution(land) { const oilMap = new Map(); for (let row = 0; row &lt; land.length; row++) { for (let col = 0; col &lt; land[row].length; col++) { if (land[row][col]) { const oilRoad = []; const drilled = drilling(oilMap, land, row, col, oilRoad); oilRoad.forEach((oiledCol) =&gt; { if (oilMap.has(oiledCol)) { oilMap.set(oiledCol, oilMap.get(oiledCol) + drilled); } else { oilMap.set(oiledCol, drilled); } }); } } } let max = 0; for (let val of oilMap.values()) { if (max &lt; val) max = val; } return max;
} function drilling(oilMap, land, startRow, startCol, road) { const queue = [[startRow, startCol]]; let oils = 0; while (queue.length &gt; 0) { const [row, col] = queue.shift(); if (land[row][col] === 0) continue; oils++; land[row][col] = 0; if (!road.includes(col)) road.push(col); if (row &gt; 0 &amp;&amp; land[row - 1][col]) queue.push([row - 1, col]); if (row &lt; land.length - 1 &amp;&amp; land[row + 1][col]) queue.push([row + 1, col]); if (col &gt; 0 &amp;&amp; land[row][col - 1]) queue.push([row, col - 1]); if (col &lt; land[0].length - 1 &amp;&amp; land[row][col + 1]) queue.push([row, col + 1]); } return oils;
}
이번에는 BFS를 활용하여 문제를 풀었을 때 모두 정답이 떴다.
BFS의 경우에는 재귀를 이용하지 않고 큐를 이용하기 때문에, 런타임 에러가 발생하지 않아 정답이 뜬 것으로 보인다.]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-석유-시추.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 석유 시추.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 25 Oct 2024 11:18:02 GMT</pubDate><enclosure url="https://i.imgur.com/OAVtMef.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/OAVtMef.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[백준 7576] 토마토]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.acmicpc.net/problem/7576" target="_self">https://www.acmicpc.net/problem/7576</a>격자 모양 상자의 칸에 하나씩 토마토가 들어가있음
익지 않은 토마토도 익은 토마토에 인접(상하좌우에 존재)하면 하루 뒤 익게 됨
토마토가 모두 익을 때까지의 최소 날짜 출력해당 문제는 BFS로 풀 수 있다.
날짜를 하루씩 더해가면서 익은 토마토 상하좌우에 있는 익지 않은 토마토를 익은 상태로바꿔주면 된다.
날짜를 하루씩 더해가면서 익은 토마토를 기준으로 전진하고, 익은 토마토가 인접해서 익은 토마토가 있다면 익은 토마토의 방향쪽으로 전진한 다음 일수를 누적시키면서 재귀적으로 호출을 시켜준다.
이렇게 계속 전진을 시켜주다 보면 마지막에 익지 않은 토마토가 모두 익은 경우에 결과만 출력시켜주면 된다.]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-7576]-토마토.html</link><guid isPermaLink="false">알고리즘/[백준 7576] 토마토.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 22 Sep 2024 23:39:17 GMT</pubDate></item><item><title><![CDATA[[백준 12865] 평범한 배낭]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.acmicpc.net/problem/12865" target="_self">https://www.acmicpc.net/problem/12865</a>한 달 뒤 입대하는 준서를 위해서..준서가 여행에 필요하다고 생각하는 N개의 물건에 대해 가져갈 수 있는 조합의 총 가치를 구한 다음에 여기서 최고의 가치를 지니는 조합을 리턴하면 된다.N개의 물건과 최대 K의 무게라는 조건이 붙는다.내가 처음에 선택했던 방식은 완전탐색방식이었다. let input = require("fs").readFileSync("/dev/stdin").toString().split("\n"); const [N, K] = input[0].split(" "); const stuffs = input.slice(1); let result = []; function takeStuff(left, val, allStuffs, result) { allStuffs.forEach((stuff, idx) =&gt; { const [w, v] = stuff.split(" ").map((t) =&gt; parseInt(t)); if (left - w &gt;= 0) takeStuff( left - w, val + v, allStuffs.filter((_, i) =&gt; i !== idx), result ); }); result.push(val); return;
} takeStuff(K, 0, stuffs, result);
console.log(Math.max(...result)); 해당 문제를 하위의 문제들로 나누어보면하나의 물건을 선택 -&gt; 총 무게에서 해당 무게를 뺀 무게에서 가능한 물건들을 모두 구하기해당 조건을 계속해서 반복해가면서, 바닥조건이 보일 때까지 반복하여 가치를 구해야 한다.
이러한 조건을 만족하기 위해서는 기존 내가 선택한 물건들에 대해서 어떤 물건을 이미 선택했는지를 알아야 하고, 현재까지 누적된 가치 또한 알아야 하기 때문에 나는 재귀적인 방식을 통해서 가치를 누적하면서도 모든 경우의 수에 대해서 배열에 넣어 해당 배열의 최댓값을 구하면 된다고 생각했다.하지만 이러한 완전탐색은 답은 맞지만 시간이 오래걸린다는 단점이 있다.따라서 해당 문제를 다이나믹 프로그래밍으로 다시금 접근해야 한다.let input = require("fs").readFileSync("/dev/stdin").toString().split("\n"); const [N, K] = input[0].split(" ").map(Number);
const stuffs = input.slice(1).map((line) =&gt; line.split(" ").map(Number)); const dp = Array(K + 1).fill(0); for (let i = 0; i &lt; N; i++) { const [w, v] = stuffs[i]; for (let j = K; j &gt;= w; j--) { dp[j] = Math.max(dp[j], dp[j - w] + v); }
} console.log(dp[K]);
해당 방식은 dp 테이블을 만들고 해당 테이블을 활용하는 방식이다.최대 K의 무게를 지닐 수 있을 때 가질 수 있는 최대의 가치를 dp[n] 에 기록해놓는다.
이후 만들어진 dp 테이블에 대해서 모든 물건들에 대해서 반복을 돌게 되는데, 하지만 이러한 물건에 대해서 그대로 dp 테이블을 도는 것이 아닌, 거꾸로 dp 테이블의 끝에서부터 해당하는 물건의 무게까지 dp 테이블을 돈다.
거꾸로 dp 테이블을 도는 이유는, 0부터 dp 테이블을 돌게 된다면 애초에 dp테이블의 w 이전 값들에 대한 값들은 전부 0이 될 수밖에 없다. n의 무게에서 최대로 가질 수 있는 가치를 기록해놓는 테이블이기 때문에 n 이전의 무게는 w가 더 무겁기 때문에 가치가 갱신될 것이 없다.테이블을 도는 과정에서 dp[n]에 있는 수는 Math.max를 통해 최댓값을 기존 dp에 있는 값과의 비교를 통해 가치가 현재가 더 크다면 업데이트를, 더 크지 않다면 기존 값을 선택해서 dp테이블의 값을 갱신시킨다. ]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-12865]-평범한-배낭.html</link><guid isPermaLink="false">알고리즘/[백준 12865] 평범한 배낭.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Sun, 22 Sep 2024 12:08:56 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 주차 요금 계산]]></title><description><![CDATA[입차와 출차요금표입차된 후 출차 x -&gt; 23:59
00:00 ~ 23:59 입출차 내역을 바탕으로 차량별 누적 주차 시간 계산 및 요금 일괄 정산누적 주차 시간
기본 시간 이하 -&gt; 기본 요금
기본 시관 초과 -&gt; 기본 요금 + 초과한 시간에 대해서 단위 시간마다 단위 요금 시간 나눈 값에 올림 ]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-주차-요금-계산.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 주차 요금 계산.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Fri, 20 Sep 2024 07:31:36 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 행렬 테두리 회전하기]]></title><description><![CDATA[rows x columns 크기의 행렬
한 줄씩 순서대로 적혀있는 숫자들
이 행렬에서 직사각형 모양의 범위를 선택해 테두리 부분만 시계 방향으로 회전(x1,y1,x2,y2) -&gt; x1행 y1열부터 x2행 y2열까지의 직사각형에서 테두리 숫자들을 한칸씩 시계방향으로 회전
움직이는 것들(테두리에 있는 수들) x1, x2행의 y1~y2까지 모든 수들 x1~x2행의 y1과 y2들
어떻게 회전시킬 것이냐? y1, y2의 위치일 경우 y1, y2, 오른쪽 상단 -&gt; x1행의 y2일 경우 -&gt; x1 + 1행의 y2위치 오른쪽 하단 -&gt; x2-1행의 y2일 경우 -&gt; x2행의 y2위치로 순서대로 x,y의 배열 만들어놓기
queries forEach로 받기 save에 이동시킬 수 저장해놓기 ]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-행렬-테두리-회전하기.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 행렬 테두리 회전하기.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Thu, 19 Sep 2024 02:54:13 GMT</pubDate></item><item><title><![CDATA[[프로그래머스] 두 원 사이의 정수 쌍]]></title><description><![CDATA[r1과 r2가 주어지면, r1에 해당하는 원과 r2에 해당하는 원 사이의 공간에 x좌표와 y좌표가 모두 정수인 점의 개수를 리턴하는 문제일단 r1 &lt; r2의 관계이기 떄문에 R1과 r2사이의 정수 좌표는 8개를 디폴트로 하고 시작한다
상하좌우 x좌표와 y좌표에 걸쳐있는 쪽은 무조건 사이에 있으면서도 반지름이 정수이기 때문에 x좌표와 y좌표 모두 걸쳐져 있는 좌표가 정수로 되어있기 때문이다
그렇다면 그 사이에 있는 것들이 문제인데..<img src="https://i.imgur.com/LZDU4AA.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
요렇게 생긴 두 원의 사이에서 해당 원은 무조건 원점을 기준으로 하는 원이기 때문에 4가지의 영역 모두 사이에 있는 정수 x, y좌표가 서로의 부호만 다를 뿐이지 사실상 절대값으로 따지면 모두 같은 위치이다.<br><img src="https://i.imgur.com/5oOg924.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
따라서 굳이 하나하나 다 구하기 보다는, 한쪽을 구해놓고 x4를 하는 편이 합리적으로 보인다.
그럼 이제 남은 문제는 이 사이의 값을 어떻게 구할 것이냐인데,,
더 큰 원을 지나는 x좌표와 y좌표를 모두 구한다? 1,000,000까지 반지름의 길이가 될 수 있는데 이걸 모두 구하는 것은 비합리적이라고 생각해서 일단 보류 큰 원 안의 정수 좌표들에서 작은 원의 조건을 뺀 다음 거리를 계산해서 원 세기 작은 쪽의 원의 반지름만큼의 길이를 가진 정사각형부터 시작한다면, 조건의 수를 확실히 줄일 수 있다 2번 방식대로 풀 경우,
작은 원의 반지름을 구해서 정사각형의 각 변부터 시작 (큰 원의 반지름 - 작은 원의 반지름)
x좌표와 y좌표를 하나씩 올려가면서 큰 원 안에 들어오는지 확인 큰 원 안에 들어오는 경우는 피타고라스의 정리를 이용하여 구한 대각선이 큰 원의 반지름보다 작아야 함 a^2 + b^2 = r^2
r^2 -a^2 = b^2]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 두 원 사이의 정수 쌍.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Wed, 18 Sep 2024 11:49:00 GMT</pubDate><enclosure url="https://i.imgur.com/LZDU4AA.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/LZDU4AA.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[[프로그래머스] 방금그곡]]></title><description><![CDATA[자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악 찾기반복 재생 -&gt; 끝과 처음이 이어서 재생된 멜로디일 수도 있음
중간에 음악을 끊을 경우 곡이 다를 수도 있음
=&gt; 기억한 멜로디를 재생 시간과 제공된 악보를 보면서 비교
음악제목, 재생되고 끝난시간, 악보
음 -&gt; C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개
악보의 총 음 개수를 구한다
시 -&gt; 분으로 바꾼 뒤, 얼마만큼 재생이 되었는지 분단위로 파악한다
분단위로 파악한 뒤에는 기존 음악의 멜로디에 반복된 수만큼 악보 또한 반복해준 악보를 배열에 저장한다
배열을 돌면서 해당 문자열이 포함되어 있는지 검색한다
이 과정에서 #이 포함된 음정이 있을경우 이를 어떻게 포함해서 문자열에 만드느냐?]]></description><link>https://alsgud8311.github.io/알고리즘/[프로그래머스]-방금그곡.html</link><guid isPermaLink="false">알고리즘/[프로그래머스] 방금그곡.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Tue, 17 Sep 2024 09:52:09 GMT</pubDate></item><item><title><![CDATA[[백준 1004] 어린왕자]]></title><description><![CDATA[import sys # 시작점 혹은 도착점이 원 안에 들어있는지 확인
def in_circle(x,y,r,temp_x,temp_y): if r**2 &gt; (( x - temp_x)**2) + ((y - temp_y)**2): return True else: return False # 테스트 케이스
T = int(sys.stdin.readline()) result_print = []
#테스트 케이스 동안
for i in range(T): #시작점, 도착점 start_x, start_y, end_x, end_y = map(int, sys.stdin.readline().split()) # 행성 개수 받기 planet = int(sys.stdin.readline()) # 행성 개수만큼 행성 좌표 받기 result = 0 for j in range(planet): planet_x, planet_y, r = map(int,sys.stdin.readline().split()) # 출발점과 도착점이 원 안에 있을 경우만 생각 if in_circle(planet_x,planet_y,r,start_x,start_y) and in_circle(planet_x,planet_y,r,end_x,end_y): pass elif in_circle(planet_x,planet_y,r,start_x,start_y): result += 1 elif in_circle(planet_x,planet_y,r,end_x,end_y): result += 1 result_print.append(result) for k in result_print: print(k) 적혀있는 문제와 좌표와 원이 난무하는 그림을 보면 정말 풀기 싫어지는 문제
하지만 어떻게 풀지 초반에 생각만 잘 하면 쉽다처음에는 테스트 케이스를 받고 해당 테스트 케이스 수만큼 행성의 좌표를 받아서 저장 받는건 쉽게 할 수 있고 문제는 어떻게 행성으로 진입/이탈하는 것을 아느냐이다.<img height="300/" src="https://i.imgur.com/vaknXFl.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved" style="width: 400px; max-width: 100%;">보면 어떤 행성이 어디에 있건 간에 어린왕자가 출발하고 도착점에 도달하면서 진입/이탈하는 경우는 출발점이나 도착점이 원 안에 있을 경우밖에 없다. 다른 행성들은 어린왕자가 알아서 무빙치면서 피해갈 것이기 때문에 해당 경우만 생각하면 된다. 이미 원 안에 있으면 무조건 진입/이탈이 필요하니까.하지만 이 경우에도 생각해야 할 것이 출발점과 도착점이 모두 같은 원 안에 있을 경우를 생각해야 한다. 출발점과 도착점이 같은 원 안에 있다면 굳이 진입/이탈할 필요가 없이 행성 안에서 이동할 수 있기 때문이다.그러면 우리가 생각할 수 있는 로직은
출발점과 도착점이 같은 원 안에 있을 경우는 패스
출발점만 원 안에 있을 경우에 진입/이탈 횟수 1회 추가
도착점만 원 안에 있을 경우에 진입/이탈 횟수 1회 추가
이다. 이 경우만 생각해주면 나머지는 어린왕자가 알아서 할 것이다.
원 안에 있는지 확인하는 방법은 쉽다. 피타고라스의 방정식을 이용하면 된다.
x^2 + y^2 = r^2 이므로 해당 반지름의 제곱보다 출발점/도착점의 좌표가 작으면 안에 있다고 생각할 수 있다.def in_circle(x,y,r,temp_x,temp_y): if r**2 &gt; (( x - temp_x)**2) + ((y - temp_y)**2): return True else: return False
해당 함수는 행성의 x,y좌표와 반지름, 출발점/도착점을 받아 만약 행성 안에 있으면 True를 반환한다. 이럴 경우에만 result에 1을 추가해주면 된다.<br><img src="https://i.imgur.com/sL7DX4a.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
하지만 메모리는 오지게 갉아먹는 모오습]]></description><link>https://alsgud8311.github.io/알고리즘/[백준-1004]-어린왕자.html</link><guid isPermaLink="false">알고리즘/[백준 1004] 어린왕자.md</guid><dc:creator><![CDATA[Cho Minhyung]]></dc:creator><pubDate>Mon, 02 Sep 2024 05:14:18 GMT</pubDate><enclosure url="https://i.imgur.com/vaknXFl.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/vaknXFl.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>