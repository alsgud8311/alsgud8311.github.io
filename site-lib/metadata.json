{"createdTime":1738510562079,"shownInTree":["알고리즘/자바스크립트-알고리즘-강의/스택(stack)과-큐(queue).html","알고리즘/자바스크립트-알고리즘-강의/이진-탐색-트리(binary-search-tree).html","알고리즘/자바스크립트-알고리즘-강의/정렬-기수정렬(radix-sort).html","알고리즘/자바스크립트-알고리즘-강의/정렬-버블,-삽입,-선택정렬.html","알고리즘/자바스크립트-알고리즘-강의/정렬-퀵정렬(quick-sort).html","알고리즘/자바스크립트-알고리즘-강의/정렬-합병정렬(merge-sort).html","알고리즘/자바스크립트-알고리즘-강의/트리-순회(tree-traversal).html","알고리즘/자바스크립트-알고리즘-강의/udemy_자바스크립트-알고리즘.html","알고리즘/[백준-1004]-어린왕자.html","알고리즘/[백준-1912]-연속합.html","알고리즘/[백준-6064]-카잉-달력.html","알고리즘/[백준-7576]-토마토.html","알고리즘/[백준-9251]-lcs.html","알고리즘/[백준-10597]-순열장난.html","알고리즘/[백준-12865]-평범한-배낭.html","알고리즘/[백준-12891]-dna-비밀번호.html","알고리즘/[백준-17123]-배열-놀이.html","알고리즘/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html","알고리즘/[백준-31836]-피보나치-기념품.html","알고리즘/[백준11631]-ascii-addition.html","알고리즘/[백준14596]-quilting(smaill).html","알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html","알고리즘/[백준31784]-포닉스의-문단속.html","알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html","알고리즘/[프로그래머스]-방금그곡.html","알고리즘/[프로그래머스]-석유-시추.html","알고리즘/[프로그래머스]-요격-시스템.html","알고리즘/[프로그래머스]-주차-요금-계산.html","알고리즘/[프로그래머스]-행렬-테두리-회전하기.html","알고리즘/백준-18113-그르다-김가놈.html","알고리즘/알고리즘.html","프로젝트/boomap/boomap.html","프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html","프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html","프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html","프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif","프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html","프로젝트/fora/fora.html","프로젝트/fora/fora_리팩토링_navigation-추상화하기.html","프로젝트/fora/fora_트러블슈팅.html","프로젝트/neo/구현의-상세-추상화.html","프로젝트/neo/반응형을-자바스크립트로-해보기.html","프로젝트/neo/axios를-떠나보내기.html","프로젝트/neo/neo.html","학습-정리/backend/트랜잭션과-비즈니스-로직.html","학습-정리/backend/backend.html","학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html","학습-정리/backend/mysql-join.html","학습-정리/backend/node.js-libuv에-대한-고찰.html","학습-정리/backend/passport의-로컬-인증전략.html","학습-정리/backend/rest-api.html","학습-정리/backend/sql-기본문법.html","학습-정리/backend/sql-트리거.html","학습-정리/computer-science/운영체제/연결-리스트-이중-연결-리스트(doubly-linked-list).html","학습-정리/computer-science/운영체제/연결-리스트-단일-연결-리스트(singly-linked-lists).html","학습-정리/computer-science/운영체제/운영체제.html","학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html","학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html","학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html","학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html","학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html","학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html","학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html","학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html","학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html","학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html","학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html","학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html","학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html","학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html","학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html","학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html","학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html","학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html","학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html","학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html","학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html","학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html","학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html","학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html","학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html","학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html","학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html","학습-정리/computer-science/브라우저의-렌더링과-캔버스.html","학습-정리/computer-science/웹페이지,-웹사이트,-웹서버,-검색엔진의-차이.html","학습-정리/computer-science/이벤트-루프와-비동기.html","학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html","학습-정리/computer-science/쿠키와-세션.html","학습-정리/computer-science/broadcast,-unicast,-multicast.html","학습-정리/computer-science/computer-science.html","학습-정리/computer-science/frontend-roadmap.html","학습-정리/computer-science/http-메시지.html","학습-정리/computer-science/http-세션.html","학습-정리/computer-science/http3.html","학습-정리/computer-science/osi-7-layer.html","학습-정리/computer-science/tcp-ip.html","학습-정리/computer-science/telnet과-ssh.html","학습-정리/design-pattern/design-pattern.html","학습-정리/design-pattern/fsd-패턴.html","학습-정리/design-pattern/mvc패턴.html","학습-정리/design-pattern/observer-패턴.html","학습-정리/design-pattern/pub-sub-패턴.html","학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html","학습-정리/frontend/javascript/클로저에-관한-고찰.html","학습-정리/frontend/javascript/javascript.html","학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html","학습-정리/frontend/javascript/this-바인딩과-간접-호출.html","학습-정리/frontend/others/aws-배포.html","학습-정리/frontend/others/firebase-functions.html","학습-정리/frontend/others/nosql-맛보기.html","학습-정리/frontend/others/others(frontend).html","학습-정리/frontend/others/prettier-설정하기.html","학습-정리/frontend/others/tailwind-설정하기.html","학습-정리/frontend/others/xss-공격.html","학습-정리/frontend/react/concurrent-mode.html","학습-정리/frontend/react/error-boundary와-suspense.html","학습-정리/frontend/react/jsx에-관한-고찰.html","학습-정리/frontend/react/react.html","학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html","학습-정리/frontend/react/react-fiber에-관한-고찰.html","학습-정리/frontend/react/react-portal.html","학습-정리/frontend/react/useeffect에-관한-고찰.html","학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html","학습-정리/학습-정리.html","회고/부스트캠프-회고.html","index.html"],"attachments":["site-lib/scripts/graph-wasm.wasm","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css","site-lib/rss.xml","부스트캠프/멤버십/8주차/화면-기록-2024-11-10-오후-11.20.13.mov","site-lib/media/favicon.png","프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif"],"allFiles":["학습-정리/backend/sql-기본문법.html","학습-정리/학습-정리.html","알고리즘/백준-18113-그르다-김가놈.html","알고리즘/알고리즘.html","index.html","프로젝트/fora/fora_리팩토링_navigation-추상화하기.html","프로젝트/fora/fora_트러블슈팅.html","프로젝트/fora/fora.html","프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif","프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html","알고리즘/[백준-12891]-dna-비밀번호.html","알고리즘/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html","알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html","알고리즘/[백준-31836]-피보나치-기념품.html","알고리즘/[백준-10597]-순열장난.html","프로젝트/neo/구현의-상세-추상화.html","프로젝트/neo/neo.html","알고리즘/[백준-6064]-카잉-달력.html","학습-정리/backend/backend.html","학습-정리/computer-science/computer-science.html","학습-정리/design-pattern/design-pattern.html","학습-정리/frontend/others/others(frontend).html","학습-정리/frontend/react/react.html","학습-정리/frontend/javascript/javascript.html","프로젝트/boomap/boomap.html","학습-정리/computer-science/운영체제/운영체제.html","알고리즘/[백준31784]-포닉스의-문단속.html","프로젝트/neo/반응형을-자바스크립트로-해보기.html","알고리즘/[백준-17123]-배열-놀이.html","알고리즘/[백준14596]-quilting(smaill).html","프로젝트/neo/axios를-떠나보내기.html","알고리즘/[백준11631]-ascii-addition.html","알고리즘/[백준-1912]-연속합.html","알고리즘/[백준-9251]-lcs.html","회고/부스트캠프-회고.html","학습-정리/frontend/react/error-boundary와-suspense.html","프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html","프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html","프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html","학습-정리/computer-science/브라우저의-렌더링과-캔버스.html","학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html","알고리즘/[프로그래머스]-요격-시스템.html","학습-정리/frontend/react/concurrent-mode.html","알고리즘/[프로그래머스]-석유-시추.html","학습-정리/frontend/react/react-portal.html","학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html","학습-정리/frontend/others/nosql-맛보기.html","학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html","학습-정리/frontend/others/tailwind-설정하기.html","학습-정리/design-pattern/fsd-패턴.html","학습-정리/frontend/others/prettier-설정하기.html","학습-정리/frontend/others/firebase-functions.html","학습-정리/frontend/react/react-fiber에-관한-고찰.html","학습-정리/frontend/react/jsx에-관한-고찰.html","알고리즘/[백준-7576]-토마토.html","학습-정리/backend/node.js-libuv에-대한-고찰.html","학습-정리/computer-science/이벤트-루프와-비동기.html","알고리즘/[백준-12865]-평범한-배낭.html","알고리즘/[프로그래머스]-주차-요금-계산.html","알고리즘/[프로그래머스]-행렬-테두리-회전하기.html","알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html","알고리즘/[프로그래머스]-방금그곡.html","학습-정리/backend/rest-api.html","학습-정리/frontend/others/aws-배포.html","학습-정리/backend/mysql-join.html","학습-정리/backend/passport의-로컬-인증전략.html","학습-정리/backend/sql-트리거.html","학습-정리/computer-science/쿠키와-세션.html","학습-정리/frontend/others/xss-공격.html","학습-정리/backend/트랜잭션과-비즈니스-로직.html","학습-정리/frontend/javascript/클로저에-관한-고찰.html","학습-정리/computer-science/tcp-ip.html","학습-정리/computer-science/telnet과-ssh.html","학습-정리/design-pattern/pub-sub-패턴.html","학습-정리/computer-science/osi-7-layer.html","학습-정리/design-pattern/observer-패턴.html","학습-정리/computer-science/broadcast,-unicast,-multicast.html","학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html","학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html","학습-정리/frontend/javascript/this-바인딩과-간접-호출.html","학습-정리/computer-science/웹페이지,-웹사이트,-웹서버,-검색엔진의-차이.html","학습-정리/computer-science/frontend-roadmap.html","학습-정리/computer-science/http-메시지.html","학습-정리/computer-science/http-세션.html","학습-정리/computer-science/http3.html","알고리즘/자바스크립트-알고리즘-강의/정렬-버블,-삽입,-선택정렬.html","알고리즘/자바스크립트-알고리즘-강의/정렬-퀵정렬(quick-sort).html","알고리즘/자바스크립트-알고리즘-강의/정렬-합병정렬(merge-sort).html","알고리즘/자바스크립트-알고리즘-강의/트리-순회(tree-traversal).html","알고리즘/자바스크립트-알고리즘-강의/스택(stack)과-큐(queue).html","알고리즘/자바스크립트-알고리즘-강의/이진-탐색-트리(binary-search-tree).html","알고리즘/자바스크립트-알고리즘-강의/정렬-기수정렬(radix-sort).html","알고리즘/자바스크립트-알고리즘-강의/udemy_자바스크립트-알고리즘.html","알고리즘/[백준-1004]-어린왕자.html","학습-정리/frontend/react/useeffect에-관한-고찰.html","학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html","학습-정리/design-pattern/mvc패턴.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html","학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html","학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html","학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html","학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html","학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html","학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html","학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html","학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html","학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html","학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html","학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html","학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html","학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html","학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html","학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html","학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html","학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html","학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html","학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html","학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html","학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html","학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html","학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html","학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html","학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html","학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html","학습-정리/computer-science/운영체제/연결-리스트-이중-연결-리스트(doubly-linked-list).html","학습-정리/computer-science/운영체제/연결-리스트-단일-연결-리스트(singly-linked-lists).html","학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html","학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html","site-lib/scripts/graph-wasm.wasm","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css"],"webpages":{"알고리즘/[백준-1004]-어린왕자.html":{"title":"[백준 1004] 어린왕자","icon":"","description":"import sys # 시작점 혹은 도착점이 원 안에 들어있는지 확인\ndef in_circle(x,y,r,temp_x,temp_y): if r**2 &gt; (( x - temp_x)**2) + ((y - temp_y)**2): return True else: return False # 테스트 케이스\nT = int(sys.stdin.readline()) result_print = []\n#테스트 케이스 동안\nfor i in range(T): #시작점, 도착점 start_x, start_y, end_x, end_y = map(int, sys.stdin.readline().split()) # 행성 개수 받기 planet = int(sys.stdin.readline()) # 행성 개수만큼 행성 좌표 받기 result = 0 for j in range(planet): planet_x, planet_y, r = map(int,sys.stdin.readline().split()) # 출발점과 도착점이 원 안에 있을 경우만 생각 if in_circle(planet_x,planet_y,r,start_x,start_y) and in_circle(planet_x,planet_y,r,end_x,end_y): pass elif in_circle(planet_x,planet_y,r,start_x,start_y): result += 1 elif in_circle(planet_x,planet_y,r,end_x,end_y): result += 1 result_print.append(result) for k in result_print: print(k) 적혀있는 문제와 좌표와 원이 난무하는 그림을 보면 정말 풀기 싫어지는 문제\n하지만 어떻게 풀지 초반에 생각만 잘 하면 쉽다처음에는 테스트 케이스를 받고 해당 테스트 케이스 수만큼 행성의 좌표를 받아서 저장 받는건 쉽게 할 수 있고 문제는 어떻게 행성으로 진입/이탈하는 것을 아느냐이다.<img height=\"300/\" src=\"https://i.imgur.com/vaknXFl.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 400px; max-width: 100%;\">보면 어떤 행성이 어디에 있건 간에 어린왕자가 출발하고 도착점에 도달하면서 진입/이탈하는 경우는 출발점이나 도착점이 원 안에 있을 경우밖에 없다. 다른 행성들은 어린왕자가 알아서 무빙치면서 피해갈 것이기 때문에 해당 경우만 생각하면 된다. 이미 원 안에 있으면 무조건 진입/이탈이 필요하니까.하지만 이 경우에도 생각해야 할 것이 출발점과 도착점이 모두 같은 원 안에 있을 경우를 생각해야 한다. 출발점과 도착점이 같은 원 안에 있다면 굳이 진입/이탈할 필요가 없이 행성 안에서 이동할 수 있기 때문이다.그러면 우리가 생각할 수 있는 로직은\n출발점과 도착점이 같은 원 안에 있을 경우는 패스\n출발점만 원 안에 있을 경우에 진입/이탈 횟수 1회 추가\n도착점만 원 안에 있을 경우에 진입/이탈 횟수 1회 추가\n이다. 이 경우만 생각해주면 나머지는 어린왕자가 알아서 할 것이다.\n원 안에 있는지 확인하는 방법은 쉽다. 피타고라스의 방정식을 이용하면 된다.\nx^2 + y^2 = r^2 이므로 해당 반지름의 제곱보다 출발점/도착점의 좌표가 작으면 안에 있다고 생각할 수 있다.def in_circle(x,y,r,temp_x,temp_y): if r**2 &gt; (( x - temp_x)**2) + ((y - temp_y)**2): return True else: return False\n해당 함수는 행성의 x,y좌표와 반지름, 출발점/도착점을 받아 만약 행성 안에 있으면 True를 반환한다. 이럴 경우에만 result에 1을 추가해주면 된다.<br><img src=\"https://i.imgur.com/sL7DX4a.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n하지만 메모리는 오지게 갉아먹는 모오습","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-1004]-어린왕자.html","pathToRoot":"..","attachments":[],"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":3319,"sourcePath":"알고리즘/[백준 1004] 어린왕자.md","exportPath":"알고리즘/[백준-1004]-어린왕자.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준-1912]-연속합.html":{"title":"[백준 1912] 연속합","icon":"","description":"\nn개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.\n문제에서 나온 예시로 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌을 때, 여기서 정답은 12+21인 33이 정답이 된다.해당 문제에서 주목해야 할 점은 연속된 몇 개의 수와 구할 수 있는 합 중 가장 큰 합이다.\n그럼 연속된 몇 개의 수는 어떻게 구해야 하는가?\n일단은 계속 배열을 돌아가면서 최대한 큰 수를 만들 수 있도록 해야 하는데 이를 기록하고 가장 큰 값을 도출해내기 위해선 동적 계획법을 통해 풀어야 함을 알았다.그렇다면 동적 계획법에서 중요한 것은 점화식인데, 어떤 식으로 점화식을 도출해 낼까?\n일단 우리에게 주어지는 것은 n의 정보와 수열의 정보이다. 이를 가지고 연속된 수 중에 가장 최대한 큰 수를 계속 기록하기 위해서는 수열이 배열이라는 가정 하에 생각해보면 된다.\n배열을 처음부터 끝까지 돌면서 우리는 연속된 수들을 만날 것이다. 이 연속된 수에서 우리는 기존의 누적된 값을 현재 보고 있는 값과 비교해야 한다.\n여기서 중요한 점은 무조건 음수라고 해서 거기서 끊어야 하는게 아닌, 음수라고 하더라도 그 뒤에 연속되는 값을 더했을 때 가장 큰 수가 된다면 음수라도 포함할 수 있는 경우를 생각해야 한다.\n그렇다면 점화식은 이전까지 누적된 값과 현재 보고 있는 값을 더했을 때와 현재 값 중에 더 큰 값을 골라야 한다. dp[n] = max(dp[n-1] + arr[n], arr[n])","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-1912]-연속합.html","pathToRoot":"..","attachments":[],"createdTime":1736209726467,"modifiedTime":1736213614508,"sourceSize":1845,"sourcePath":"알고리즘/[백준 1912] 연속합.md","exportPath":"알고리즘/[백준-1912]-연속합.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준-7576]-토마토.html":{"title":"[백준 7576] 토마토","icon":"","description":"<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/7576\" target=\"_self\">https://www.acmicpc.net/problem/7576</a>격자 모양 상자의 칸에 하나씩 토마토가 들어가있음\n익지 않은 토마토도 익은 토마토에 인접(상하좌우에 존재)하면 하루 뒤 익게 됨\n토마토가 모두 익을 때까지의 최소 날짜 출력해당 문제는 BFS로 풀 수 있다.\n날짜를 하루씩 더해가면서 익은 토마토 상하좌우에 있는 익지 않은 토마토를 익은 상태로바꿔주면 된다.\n날짜를 하루씩 더해가면서 익은 토마토를 기준으로 전진하고, 익은 토마토가 인접해서 익은 토마토가 있다면 익은 토마토의 방향쪽으로 전진한 다음 일수를 누적시키면서 재귀적으로 호출을 시켜준다.\n이렇게 계속 전진을 시켜주다 보면 마지막에 익지 않은 토마토가 모두 익은 경우에 결과만 출력시켜주면 된다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-7576]-토마토.html","pathToRoot":"..","attachments":[],"createdTime":1727047559689,"modifiedTime":1727048357871,"sourceSize":871,"sourcePath":"알고리즘/[백준 7576] 토마토.md","exportPath":"알고리즘/[백준-7576]-토마토.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준-9251]-lcs.html":{"title":"[백준 9251] LCS","icon":"","description":"\n해를 분석해서 부문제로 분할하기 부문제의 해로 큰 문제의 해를 표현(점화식)\n부문제들의 해를 가지고 있는 dp table을 채우기 table에서 해를 계산하여 알고리즘의 correctness 검증\nstringA : ACAYKP\nstringB: CAPCAKAn과 Bm의 최장길이 공통 부문자열의 길이를 구해야 함\n이를 어떻게 작은 문제들로 쪼갤 수 있을까?\nLCS(i,j) =&gt; Ai과 Bj의 LCS 길이\nAi와 Bj가 서로 같다면 최장길이 공통 문자열에 추가된다.\n이는 곧 이 두 문자열을 비교했을 때, 두 문자열이 서로 같다면 길이가 1 증가한다는 뜻이다.\n나머지는 A1,A2,...Ai-1\nB1,B2,...Bj-1\n로 나뉘어 질 수 있다.\n그렇다면 이 문자열들에 대해서도 계속 공통 문자열을 비교하면서 나아가면 되지 않을까?\n마지막 두 문자열이 같을 때 : LCS(i,j) = LCS(i-1,j-1) + 1\n라고 볼 수 있다. 하지만 마지막 두 문자열이 다를 때는 간단하게 LCS(i,j) = LCS(i-1,j-1)라고만 생각하면 안된다. 왜냐면 나중에 A의 마지막 문자열이 포함되어 있지만 B의 마지막 문자열은 포함되어 있지 않을 수 있고, B의 마지막 문자열이 포함되어 있지만 A의 마지막 문자열을 포함되어 있지 않을 수 있기 때문이다. (여기서 A,B문자열이 모두 같은 경우는 이미 아니기 때문에 제외한다)\n그렇기 때문에 우리가 원하는 LCS는 LCS(i,j-1) 과 LCS(i-1,j) 중 더 길이가 긴 것으로 선택해야 한다.\n그렇다면 이 LCS(i,j-1)과 LCS(i-1,j)를 미리 구해놔야 한단 소리기 때문에 dp 테이블을 만들어서 이에 대한 값을 메모이제이션 해놓으면 된다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-9251]-lcs.html","pathToRoot":"..","attachments":[],"createdTime":1734510487708,"modifiedTime":1734512061049,"sourceSize":2216,"sourcePath":"알고리즘/[백준 9251] LCS.md","exportPath":"알고리즘/[백준-9251]-lcs.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준-12865]-평범한-배낭.html":{"title":"[백준 12865] 평범한 배낭","icon":"","description":"<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/12865\" target=\"_self\">https://www.acmicpc.net/problem/12865</a>한 달 뒤 입대하는 준서를 위해서..준서가 여행에 필요하다고 생각하는 N개의 물건에 대해 가져갈 수 있는 조합의 총 가치를 구한 다음에 여기서 최고의 가치를 지니는 조합을 리턴하면 된다.N개의 물건과 최대 K의 무게라는 조건이 붙는다.내가 처음에 선택했던 방식은 완전탐색방식이었다. let input = require(\"fs\").readFileSync(\"/dev/stdin\").toString().split(\"\\n\"); const [N, K] = input[0].split(\" \"); const stuffs = input.slice(1); let result = []; function takeStuff(left, val, allStuffs, result) { allStuffs.forEach((stuff, idx) =&gt; { const [w, v] = stuff.split(\" \").map((t) =&gt; parseInt(t)); if (left - w &gt;= 0) takeStuff( left - w, val + v, allStuffs.filter((_, i) =&gt; i !== idx), result ); }); result.push(val); return;\n} takeStuff(K, 0, stuffs, result);\nconsole.log(Math.max(...result)); 해당 문제를 하위의 문제들로 나누어보면하나의 물건을 선택 -&gt; 총 무게에서 해당 무게를 뺀 무게에서 가능한 물건들을 모두 구하기해당 조건을 계속해서 반복해가면서, 바닥조건이 보일 때까지 반복하여 가치를 구해야 한다.\n이러한 조건을 만족하기 위해서는 기존 내가 선택한 물건들에 대해서 어떤 물건을 이미 선택했는지를 알아야 하고, 현재까지 누적된 가치 또한 알아야 하기 때문에 나는 재귀적인 방식을 통해서 가치를 누적하면서도 모든 경우의 수에 대해서 배열에 넣어 해당 배열의 최댓값을 구하면 된다고 생각했다.하지만 이러한 완전탐색은 답은 맞지만 시간이 오래걸린다는 단점이 있다.따라서 해당 문제를 다이나믹 프로그래밍으로 다시금 접근해야 한다.let input = require(\"fs\").readFileSync(\"/dev/stdin\").toString().split(\"\\n\"); const [N, K] = input[0].split(\" \").map(Number);\nconst stuffs = input.slice(1).map((line) =&gt; line.split(\" \").map(Number)); const dp = Array(K + 1).fill(0); for (let i = 0; i &lt; N; i++) { const [w, v] = stuffs[i]; for (let j = K; j &gt;= w; j--) { dp[j] = Math.max(dp[j], dp[j - w] + v); }\n} console.log(dp[K]);\n해당 방식은 dp 테이블을 만들고 해당 테이블을 활용하는 방식이다.최대 K의 무게를 지닐 수 있을 때 가질 수 있는 최대의 가치를 dp[n] 에 기록해놓는다.\n이후 만들어진 dp 테이블에 대해서 모든 물건들에 대해서 반복을 돌게 되는데, 하지만 이러한 물건에 대해서 그대로 dp 테이블을 도는 것이 아닌, 거꾸로 dp 테이블의 끝에서부터 해당하는 물건의 무게까지 dp 테이블을 돈다.\n거꾸로 dp 테이블을 도는 이유는, 0부터 dp 테이블을 돌게 된다면 애초에 dp테이블의 w 이전 값들에 대한 값들은 전부 0이 될 수밖에 없다. n의 무게에서 최대로 가질 수 있는 가치를 기록해놓는 테이블이기 때문에 n 이전의 무게는 w가 더 무겁기 때문에 가치가 갱신될 것이 없다.테이블을 도는 과정에서 dp[n]에 있는 수는 Math.max를 통해 최댓값을 기존 dp에 있는 값과의 비교를 통해 가치가 현재가 더 크다면 업데이트를, 더 크지 않다면 기존 값을 선택해서 dp테이블의 값을 갱신시킨다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-12865]-평범한-배낭.html","pathToRoot":"..","attachments":[],"createdTime":1726984293710,"modifiedTime":1727006936776,"sourceSize":3466,"sourcePath":"알고리즘/[백준 12865] 평범한 배낭.md","exportPath":"알고리즘/[백준-12865]-평범한-배낭.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준-17123]-배열-놀이.html":{"title":"[백준 17123] 배열 놀이","icon":"","description":"<img src=\"https://i.imgur.com/XDa3R5Q.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">N x N의 행렬에서 [r1,c1] - [r2,c2]로 이루어진 사각형에 v를 더하면 된다\n각 대각선으로 된 꼭짓점의 좌표이므로\n[r1,c1] - [r1,c2] - [r2,c1] - [r2,c2] 가 각 꼭짓점인 사각형의 값들에 대해서 전부 v씩 더하면 된다.특정한 알고리즘이 딱히 필요한 것 같지는 않다const INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst inputs = require(\"fs\") .readFileSync(INPUT_FILE) .toString() .trim() .split(\"\\n\"); const t = +inputs[0]; for (let i = 1; i &lt; inputs.length; i++) { const [n, m] = inputs[i].split(\" \").map(Number); const map = inputs .slice(i + 1, i + n + 1) .map((row) =&gt; row.split(\" \").map(Number)); const tests = inputs .slice(i + n + 1, i + n + m + 1) .map((test) =&gt; test.split(\" \").map(Number)); for (const [r1, c1, r2, c2, v] of tests) { for (let k = r1 - 1; k &lt;= r2 - 1; k++) { for (let j = c1 - 1; j &lt;= c2 - 1; j++) { map[k][j] += v; } } } const resultRow = map.map((row) =&gt; row.reduce((acc, curr) =&gt; acc + curr, 0)); const resultCol = Array(n).fill(0); //열 for (let l = 0; l &lt; n; l++) { let acc = 0; for (let h = 0; h &lt; n; h++) { acc += map[h][l]; } resultCol[l] = acc; } console.log(resultRow.join(\" \")); console.log(resultCol.join(\" \")); i += n + m;\n} 그래서 그냥 했다\n근데 시간 초과가 떴다","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-17123]-배열-놀이.html","pathToRoot":"..","attachments":[],"createdTime":1738291207126,"modifiedTime":1738293283718,"sourceSize":1474,"sourcePath":"알고리즘/[백준 17123] 배열 놀이.md","exportPath":"알고리즘/[백준-17123]-배열-놀이.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준11631]-ascii-addition.html":{"title":"[백준11631] ASCII Addition","icon":"","description":"아.. 이거 전에 모 코테에서 본 문제와 비슷한 문제\n그 때 제대로 풀지 못해서 멘붕 왔었는데 이번엔 제대로 풀어본다.<img src=\"https://i.imgur.com/xQr9x8I.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">아스키 아트는 칠해지는 부분이 x로 되어 있고, 총 7개의 row와 5개의 column으로 되어 있다.\na+b의 형태로 아스키 아트가 주어지면 이를 인식하고 이에 대한 두 수의 합을 다시 아스키 코드로 나타내야 한다.const fs = require(\"fs\"); const INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst input = fs.readFileSync(INPUT_FILE).toString().trim().split(\"\\n\"); const asciiPatterns = [ `xxxxx\\nx...x\\nx...x\\nx...x\\nx...x\\nx...x\\nxxxxx`, `....x\\n....x\\n....x\\n....x\\n....x\\n....x\\n....x`, `xxxxx\\n....x\\n....x\\nxxxxx\\nx....\\nx....\\nxxxxx`, `xxxxx\\n....x\\n....x\\nxxxxx\\n....x\\n....x\\nxxxxx`, `x...x\\nx...x\\nx...x\\nxxxxx\\n....x\\n....x\\n....x`, `xxxxx\\nx....\\nx....\\nxxxxx\\n....x\\n....x\\nxxxxx`, `xxxxx\\nx....\\nx....\\nxxxxx\\nx...x\\nx...x\\nxxxxx`, `xxxxx\\n....x\\n....x\\n....x\\n....x\\n....x\\n....x`, `xxxxx\\nx...x\\nx...x\\nxxxxx\\nx...x\\nx...x\\nxxxxx`, `xxxxx\\nx...x\\nx...x\\nxxxxx\\n....x\\n....x\\nxxxxx`, `.....\\n..x..\\n..x..\\nxxxxx\\n..x..\\n..x..\\n.....`,\n]; const asciiToCharMap = {};\nasciiPatterns.forEach((pattern, index) =&gt; { asciiToCharMap[pattern] = index === 10 ? \"+\" : index.toString();\n}); const ROWS = 7;\nconst COLS = 5; const splitInput = [];\nfor (let i = 0; i &lt; input[0].length; i += COLS + 1) { const block = []; for (let j = 0; j &lt; ROWS; j++) { block.push(input[j].slice(i, i + COLS)); } splitInput.push(block.join(\"\\n\"));\n} const expression = splitInput.map((block) =&gt; asciiToCharMap[block]).join(\"\");\nconst [a, b] = expression.split(\"+\").map(BigInt); const result = (a + b).toString(); const charToAsciiMap = Object.fromEntries( asciiPatterns.map((pattern, index) =&gt; [ index === 10 ? \"+\" : index.toString(), pattern, ])\n); const resultAscii = Array(ROWS).fill(\"\");\nfor (const char of result) { const asciiBlock = charToAsciiMap[char].split(\"\\n\"); for (let i = 0; i &lt; ROWS; i++) { resultAscii[i] += (resultAscii[i] ? \".\" : \"\") + asciiBlock[i]; }\n} console.log(resultAscii.join(\"\\n\")); 응 다 노가다로 아스키 맵 만들면 그만이야~\n이딴 문제 만들지좀 마라","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준11631]-ascii-addition.html","pathToRoot":"..","attachments":[],"createdTime":1738044174859,"modifiedTime":1738047399812,"sourceSize":2346,"sourcePath":"알고리즘/[백준11631] ASCII Addition.md","exportPath":"알고리즘/[백준11631]-ascii-addition.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준14596]-quilting(smaill).html":{"title":"[백준14596] Quilting(smaill)","icon":"","description":"두 패턴의 이미지를 포개면서, 가장 최적의 동선을 통해 부자연스러움의 정도가 가장 낮은 경계를 골라 해당 동선의 부자연스러움의 정도를 출력해야 한다.<img src=\"https://i.imgur.com/aR713da.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/jU8rnI2.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n문제 드럽게 기네;일단 여기서 주의해야 할 점은\n아래 같은 인덱스거나 +-1 의 경계까지만 움직일 수 있으므로 여기서 가장 주의를 해야한다그렇다면 맨 위에서부터 가장 최적의 동선을 골라야 할텐데, 이게 어디서 시작하느냐에 따라서도 최적의 경계가 바뀔 수도 있다. 그러므로 해당 문제는 가장 위쪽 모든 인덱스에서 출발하면서 최적의 동선을 가지는 쪽으로 움직여야 하기 때문에 dp로 풀어야 함을 알 수 있다.그렇다면 시작점을 기준으로 배열을 만든 다음, 해당 시작점에서 가지는 최소의 부자연스러움을 각각 구한다음에 그 중 최소인 부자연스러움 정도를 가지고 오면 된다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준14596]-quilting(smaill).html","pathToRoot":"..","attachments":[],"createdTime":1738160420595,"modifiedTime":1738160689116,"sourceSize":1062,"sourcePath":"알고리즘/[백준14596] Quilting(smaill).md","exportPath":"알고리즘/[백준14596]-quilting(smaill).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준31784]-포닉스의-문단속.html":{"title":"[백준31784] 포닉스의 문단속","icon":"","description":"<img src=\"https://i.imgur.com/p4MrRmQ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nN개의 다이얼이 연결된 자물쇠를 돌려서 풀어야 하는데 다이얼 중 하나를 골라 1번 돌리는 작업을 해야 하는데, K번을 돌려서 나올 수 있는 단어 중에 가장 사전순으로 앞인 단어를 찾으면 된다.내가 가진 정보는 자물쇠의 길이 N과 작업의 횟수 K\n그리고 다음 줄에는 문자열 S가 주어진다\n해당 문자열에서 돌려서 가장 사전순으로 작은 문자열을 만들면 된다.<br><img src=\"https://i.imgur.com/zSYDvvb.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n예제를 보자.4 3\nABCD\n의 경우, 3번을 돌려 나올 수 있는 사전순으로 가장 작은 단어는 ABCG이다.\nABC는 어차피 사전순으로 가장 앞이므로 D를 세번 돌려 D -&gt; E -&gt; F -&gt; G를 만들었다.4 5\nXYZW\n해당 문자열은 XYZW가 AAZW로 변했다.\nX -&gt; Y -&gt; Z -&gt; A\nY -&gt; Z -&gt; A\n로 총 5번을 돌렸다.이를 통해 가장 앞인 문자부터 검사해서 돌려서 만약 알파벳 앞 순위의 숫자로 변환할 수 있다면 변환하는 것을 알 수 있다.\n그리디 알고리즘이 이에 대해 가장 잘 맞는 알고리즘같다.\n앞문자열부터 하나씩 검사\n알파벳의 아스키코드를 더했을 때 이전보다 사전순으로 앞인 알파벳이 나오면 더한다.\n없으면 뒤로 돌린다\n마지막에 남은 횟수를 다 돌린다.\n정도로 생각할 수 있다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준31784]-포닉스의-문단속.html","pathToRoot":"..","attachments":[],"createdTime":1738377260567,"modifiedTime":1738377938599,"sourceSize":1422,"sourcePath":"알고리즘/[백준31784] 포닉스의 문단속.md","exportPath":"알고리즘/[백준31784]-포닉스의-문단속.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html":{"title":"[프로그래머스] 두 원 사이의 정수 쌍","icon":"","description":"r1과 r2가 주어지면, r1에 해당하는 원과 r2에 해당하는 원 사이의 공간에 x좌표와 y좌표가 모두 정수인 점의 개수를 리턴하는 문제일단 r1 &lt; r2의 관계이기 떄문에 R1과 r2사이의 정수 좌표는 8개를 디폴트로 하고 시작한다\n상하좌우 x좌표와 y좌표에 걸쳐있는 쪽은 무조건 사이에 있으면서도 반지름이 정수이기 때문에 x좌표와 y좌표 모두 걸쳐져 있는 좌표가 정수로 되어있기 때문이다\n그렇다면 그 사이에 있는 것들이 문제인데..<img src=\"https://i.imgur.com/LZDU4AA.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n요렇게 생긴 두 원의 사이에서 해당 원은 무조건 원점을 기준으로 하는 원이기 때문에 4가지의 영역 모두 사이에 있는 정수 x, y좌표가 서로의 부호만 다를 뿐이지 사실상 절대값으로 따지면 모두 같은 위치이다.<br><img src=\"https://i.imgur.com/5oOg924.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n따라서 굳이 하나하나 다 구하기 보다는, 한쪽을 구해놓고 x4를 하는 편이 합리적으로 보인다.\n그럼 이제 남은 문제는 이 사이의 값을 어떻게 구할 것이냐인데,,\n더 큰 원을 지나는 x좌표와 y좌표를 모두 구한다? 1,000,000까지 반지름의 길이가 될 수 있는데 이걸 모두 구하는 것은 비합리적이라고 생각해서 일단 보류 큰 원 안의 정수 좌표들에서 작은 원의 조건을 뺀 다음 거리를 계산해서 원 세기 작은 쪽의 원의 반지름만큼의 길이를 가진 정사각형부터 시작한다면, 조건의 수를 확실히 줄일 수 있다 2번 방식대로 풀 경우,\n작은 원의 반지름을 구해서 정사각형의 각 변부터 시작 (큰 원의 반지름 - 작은 원의 반지름)\nx좌표와 y좌표를 하나씩 올려가면서 큰 원 안에 들어오는지 확인 큰 원 안에 들어오는 경우는 피타고라스의 정리를 이용하여 구한 대각선이 큰 원의 반지름보다 작아야 함 a^2 + b^2 = r^2\nr^2 -a^2 = b^2","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html","pathToRoot":"..","attachments":[],"createdTime":1726655676046,"modifiedTime":1726660140350,"sourceSize":2014,"sourcePath":"알고리즘/[프로그래머스] 두 원 사이의 정수 쌍.md","exportPath":"알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[프로그래머스]-방금그곡.html":{"title":"[프로그래머스] 방금그곡","icon":"","description":"자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악 찾기반복 재생 -&gt; 끝과 처음이 이어서 재생된 멜로디일 수도 있음\n중간에 음악을 끊을 경우 곡이 다를 수도 있음\n=&gt; 기억한 멜로디를 재생 시간과 제공된 악보를 보면서 비교\n음악제목, 재생되고 끝난시간, 악보\n음 -&gt; C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개\n악보의 총 음 개수를 구한다\n시 -&gt; 분으로 바꾼 뒤, 얼마만큼 재생이 되었는지 분단위로 파악한다\n분단위로 파악한 뒤에는 기존 음악의 멜로디에 반복된 수만큼 악보 또한 반복해준 악보를 배열에 저장한다\n배열을 돌면서 해당 문자열이 포함되어 있는지 검색한다\n이 과정에서 #이 포함된 음정이 있을경우 이를 어떻게 포함해서 문자열에 만드느냐?","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[프로그래머스]-방금그곡.html","pathToRoot":"..","attachments":[],"createdTime":1726564996692,"modifiedTime":1726566729916,"sourceSize":886,"sourcePath":"알고리즘/[프로그래머스] 방금그곡.md","exportPath":"알고리즘/[프로그래머스]-방금그곡.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[프로그래머스]-석유-시추.html":{"title":"[프로그래머스] 석유 시추","icon":"","description":"<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/250136\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/250136</a>한 열을 수직으로 뚫는 시추관에서 한 번 뚫었을 때 가장 많이 받을 수 있는 석유의 양을 계산하는 문제\n맨 처음에는 그냥 루프 돌아서 석유만 골라내면 되는거 아닌가 생각했지만,, 석유가 이어져 있을 경우 이어져있는 석유가 모두 들어오기 때문에 이에 대해서도 계산이 필요함DFS로 석유의 양을 계산한다고 하면 지나간 길을 표시해야 하는데, 이걸 얕은 복사로 해버리면 다음 열에서 시추를 할 때 지나간 길이 표시된 석유의 경우 판단하기 어렵다\n그렇다고 깊은 복사로 해버리면, 열을 도는 과정에서 function solution(land) { const oilMap = new Map(); land.forEach((rowArr,row) =&gt; { rowArr.forEach((colArr, col) =&gt; { const oilRoad = []; const drilled = drilling(oilMap, land, row, col, oilRoad); oilRoad.forEach((oiledCol) =&gt; { if(oilMap.has(oiledCol)) oilMap.set(oiledCol,oilMap.get(oiledCol) + drilled); else oilMap.set(oiledCol, drilled); }) }) }) let max = 0; for (let val of oilMap.values()){ if(max&lt;val) max = val; } return max;\n} function drilling(oilMap,land,row,col,road){ if(!land[row][col]) return 0; if(!road.includes(col)) road.push(col); land[row][col] = 0; let oils = 1; // dfs if(row &gt; 0) oils += drilling(oilMap,land, row-1, col, road); if(row&lt;land.length-1) oils += drilling(oilMap, land, row+1, col, road); if(col &gt; 0) oils += drilling(oilMap,land, row, col-1, road); if(col&lt;land[0].length-1) oils += drilling(oilMap, land, row, col+1, road); return oils;\n}\n이런 식으로 dfs 탐색을 하면서 지나간 자리를 0으로 만들고, 지나갔던 열에 대해서 모두 배열에 넣은 뒤에 map에서 col의 키값에 해당 석유 덩이의 크기만큼을 더해주는 방식으로 순회를 돌고, 마지막에는 만들어진 map에 대해서 최댓값을 찾도록 했다.<br><img src=\"https://i.imgur.com/OAVtMef.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n정확성 테스트는 모두 통과했으나, 효율성 테스트에서는 2개가 런타임 에러가 떴다.\n다른 사람들이 질문한 것을 보았을 때, 아마 재귀가 깊어지면서 나오는 에러때문이 아닐까 싶었다.function solution(land) { const oilMap = new Map(); for (let row = 0; row &lt; land.length; row++) { for (let col = 0; col &lt; land[row].length; col++) { if (land[row][col]) { const oilRoad = []; const drilled = drilling(oilMap, land, row, col, oilRoad); oilRoad.forEach((oiledCol) =&gt; { if (oilMap.has(oiledCol)) { oilMap.set(oiledCol, oilMap.get(oiledCol) + drilled); } else { oilMap.set(oiledCol, drilled); } }); } } } let max = 0; for (let val of oilMap.values()) { if (max &lt; val) max = val; } return max;\n} function drilling(oilMap, land, startRow, startCol, road) { const queue = [[startRow, startCol]]; let oils = 0; while (queue.length &gt; 0) { const [row, col] = queue.shift(); if (land[row][col] === 0) continue; oils++; land[row][col] = 0; if (!road.includes(col)) road.push(col); if (row &gt; 0 &amp;&amp; land[row - 1][col]) queue.push([row - 1, col]); if (row &lt; land.length - 1 &amp;&amp; land[row + 1][col]) queue.push([row + 1, col]); if (col &gt; 0 &amp;&amp; land[row][col - 1]) queue.push([row, col - 1]); if (col &lt; land[0].length - 1 &amp;&amp; land[row][col + 1]) queue.push([row, col + 1]); } return oils;\n}\n이번에는 BFS를 활용하여 문제를 풀었을 때 모두 정답이 떴다.\nBFS의 경우에는 재귀를 이용하지 않고 큐를 이용하기 때문에, 런타임 에러가 발생하지 않아 정답이 뜬 것으로 보인다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"시도 1. 루프를 돌다가 석유를 만다면 DFS로 석유의 양을 계산하여 열별로 최댓값 계산","level":3,"id":"시도_1._루프를_돌다가_석유를_만다면_DFS로_석유의_양을_계산하여_열별로_최댓값_계산_0"},{"heading":"시도2. DFS로 모두 탐색한 다음, 해당하는 열에 대해서 정보를 기록","level":3,"id":"시도2._DFS로_모두_탐색한_다음,_해당하는_열에_대해서_정보를_기록_0"},{"heading":"시도 3. BFS로 탐색한 후에 해당하는 열에 대해서 기록","level":3,"id":"시도_3._BFS로_탐색한_후에_해당하는_열에_대해서_기록_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[프로그래머스]-석유-시추.html","pathToRoot":"..","attachments":[],"createdTime":1729849354618,"modifiedTime":1729855082389,"sourceSize":4403,"sourcePath":"알고리즘/[프로그래머스] 석유 시추.md","exportPath":"알고리즘/[프로그래머스]-석유-시추.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[프로그래머스]-요격-시스템.html":{"title":"[프로그래머스] 요격 시스템","icon":"","description":"<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/181188\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/181188</a>A 나라와 B 나라 간에 전쟁중에 A는 x축에 평행한 미사일을 발사하고, B 나라는 이를 수직으로 요격한다.\n조건은 미사일의 양 끝에서는 요격을 할 수 없다는 조건만 붙어있고, 미사일의 개구간 (s,e) 사이의 값이라면 어느 곳이든 가능하다.아무튼 A 나라에서 미사일을 여러발 쏠 때, 이를 요격할 수 있는 최소한의 미사일 수를 구하는 문제이다.<br>\n<img src=\"https://i.imgur.com/UzM9He1.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n이런 식으로 B가 최대한 많은 미사일을 요격할 수 있는 x좌표를 구하고, 이를 위해 최소 몇 개의 미사일이 필요한 지에 대해서 구해야 한다.맨 처음에는 2차원 배열로 기록한 다음에 열마다 확인하려고 했는데, 이 경우에는 targets의 길이가 500,000의 길이까지 커질 수 있고, 개구간 (s,e)는 100,000,000까지 갈 수 있으므로 배열로 풀기에는 너무 많은 메모리와 시간이 소모되어 불가능 할 것 같다. 최대한 많은 미사일을 한 번에 요격할 수 있어야 한다.\n그렇다면 최대한 많은 미사일들이 지나가는 x좌표를 그때마다 선택하게 된다면 최소한으로 필요한 요격 미사일을 구할 수 있을 것 같다.\n그렇다면 가장 많은 곳을 지나는 미사일 구간을 어떻게 찾느냐가 문제인데,,, 여전히 1억개의 구성 요소를 지닌 배열을 만들기에는 부담이 있다. 이를 배열이 아닌 다른 방식으로 풀 수 있는 방법이 있을까?\n라는 생각에 그냥 처음에 sort로 s를 기준으로 한 오름차순 정렬을 한 뒤에 순차적으로 가면서 최대한 많이 미사일을 요격할 수 있는 방법으로 범위를 조정하면 되지 않을까? 생각했다.function solution(targets) { let missile = 0; let start = 0; let end = 0; targets.sort((a,b) =&gt; a[0] - b[0]) targets.forEach((target) =&gt; { if(end &lt;= target[0]) { missile++; start = target[0]; end = target [1]; } else{ if(start &lt; target[0]) start = target[0]; if(end &gt; target[1]) end = target[1]; } }) return missile\n}\n그래서 forEach로 요소들을 돌면서 미사일이 최대한 많이 요격할 수 있도록 미사일이 쏠 수 있는 범위를 start, end 따로 선언하여 미사일을 돌 때마다 조정했으며, 조정할 수 있는 범위를 넘겼을 경우에는 필요한 미사일이 하나 더 추가된다고 판단하여 이 때 미사일의 개수를 올려주었다.<br><img src=\"https://i.imgur.com/JLxRO1M.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n요격성공","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"문제 설명","level":2,"id":"문제_설명_0"},{"heading":"문제 해결 과정","level":2,"id":"문제_해결_과정_0"},{"heading":"시도 1. 각 미사일과 길이를 2차원 배열에 기록하기","level":3,"id":"시도_1._각_미사일과_길이를_2차원_배열에_기록하기_0"},{"heading":"시도 2. 그리디 알고리즘","level":3,"id":"시도_2._그리디_알고리즘_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[프로그래머스]-요격-시스템.html","pathToRoot":"..","attachments":[],"createdTime":1729934294728,"modifiedTime":1729937918072,"sourceSize":2876,"sourcePath":"알고리즘/[프로그래머스] 요격 시스템.md","exportPath":"알고리즘/[프로그래머스]-요격-시스템.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[프로그래머스]-주차-요금-계산.html":{"title":"[프로그래머스] 주차 요금 계산","icon":"","description":"입차와 출차요금표입차된 후 출차 x -&gt; 23:59\n00:00 ~ 23:59 입출차 내역을 바탕으로 차량별 누적 주차 시간 계산 및 요금 일괄 정산누적 주차 시간\n기본 시간 이하 -&gt; 기본 요금\n기본 시관 초과 -&gt; 기본 요금 + 초과한 시간에 대해서 단위 시간마다 단위 요금 시간 나눈 값에 올림 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[프로그래머스]-주차-요금-계산.html","pathToRoot":"..","attachments":[],"createdTime":1726816871041,"modifiedTime":1726817496974,"sourceSize":504,"sourcePath":"알고리즘/[프로그래머스] 주차 요금 계산.md","exportPath":"알고리즘/[프로그래머스]-주차-요금-계산.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[프로그래머스]-행렬-테두리-회전하기.html":{"title":"[프로그래머스] 행렬 테두리 회전하기","icon":"","description":"rows x columns 크기의 행렬\n한 줄씩 순서대로 적혀있는 숫자들\n이 행렬에서 직사각형 모양의 범위를 선택해 테두리 부분만 시계 방향으로 회전(x1,y1,x2,y2) -&gt; x1행 y1열부터 x2행 y2열까지의 직사각형에서 테두리 숫자들을 한칸씩 시계방향으로 회전\n움직이는 것들(테두리에 있는 수들) x1, x2행의 y1~y2까지 모든 수들 x1~x2행의 y1과 y2들\n어떻게 회전시킬 것이냐? y1, y2의 위치일 경우 y1, y2, 오른쪽 상단 -&gt; x1행의 y2일 경우 -&gt; x1 + 1행의 y2위치 오른쪽 하단 -&gt; x2-1행의 y2일 경우 -&gt; x2행의 y2위치로 순서대로 x,y의 배열 만들어놓기\nqueries forEach로 받기 save에 이동시킬 수 저장해놓기 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[프로그래머스]-행렬-테두리-회전하기.html","pathToRoot":"..","attachments":[],"createdTime":1726713381890,"modifiedTime":1726714453401,"sourceSize":779,"sourcePath":"알고리즘/[프로그래머스] 행렬 테두리 회전하기.md","exportPath":"알고리즘/[프로그래머스]-행렬-테두리-회전하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/알고리즘.html":{"title":"알고리즘","icon":"","description":"<a data-href=\"[백준 1004] 어린왕자\" href=\"https://alsgud8311.github.io/알고리즘/[백준-1004]-어린왕자.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 1004] 어린왕자</a><br>\n<a data-href=\"[프로그래머스] 방금그곡\" href=\"https://alsgud8311.github.io/알고리즘/[프로그래머스]-방금그곡.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[프로그래머스] 방금그곡</a><br>\n<a data-href=\"[프로그래머스] 두 원 사이의 정수 쌍\" href=\"https://alsgud8311.github.io/알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[프로그래머스] 두 원 사이의 정수 쌍</a><br>\n<a data-href=\"[프로그래머스] 행렬 테두리 회전하기\" href=\"https://alsgud8311.github.io/알고리즘/[프로그래머스]-행렬-테두리-회전하기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[프로그래머스] 행렬 테두리 회전하기</a><br>\n<a data-href=\"[프로그래머스] 주차 요금 계산\" href=\"https://alsgud8311.github.io/알고리즘/[프로그래머스]-주차-요금-계산.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[프로그래머스] 주차 요금 계산</a><br>\n<a data-href=\"[백준 12865] 평범한 배낭\" href=\"https://alsgud8311.github.io/알고리즘/[백준-12865]-평범한-배낭.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 12865] 평범한 배낭</a><br>\n<a data-href=\"[백준 7576] 토마토\" href=\"https://alsgud8311.github.io/알고리즘/[백준-7576]-토마토.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 7576] 토마토</a><br>\n<a data-href=\"[프로그래머스] 석유 시추\" href=\"https://alsgud8311.github.io/알고리즘/[프로그래머스]-석유-시추.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[프로그래머스] 석유 시추</a><br>\n<a data-href=\"[프로그래머스] 요격 시스템\" href=\"https://alsgud8311.github.io/알고리즘/[프로그래머스]-요격-시스템.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[프로그래머스] 요격 시스템</a><br>\n<a data-href=\"[백준 9251] LCS\" href=\"https://alsgud8311.github.io/알고리즘/[백준-9251]-lcs.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 9251] LCS</a><br>\n<a data-href=\"[백준 1912] 연속합\" href=\"https://alsgud8311.github.io/알고리즘/[백준-1912]-연속합.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 1912] 연속합</a><br>\n<a data-href=\"[백준11631] ASCII Addition\" href=\"https://alsgud8311.github.io/알고리즘/[백준11631]-ascii-addition.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준11631] ASCII Addition</a><br>\n<a data-href=\"[백준14596] Quilting(smaill)\" href=\"https://alsgud8311.github.io/알고리즘/[백준14596]-quilting(smaill).html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준14596] Quilting(smaill)</a><br>\n<a data-href=\"[백준 17123] 배열 놀이\" href=\"https://alsgud8311.github.io/알고리즘/[백준-17123]-배열-놀이.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 17123] 배열 놀이</a><br>\n<a data-href=\"[백준31784] 포닉스의 문단속\" href=\"https://alsgud8311.github.io/알고리즘/[백준31784]-포닉스의-문단속.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준31784] 포닉스의 문단속</a><br>\n<a data-href=\"[백준 6064] 카잉 달력\" href=\"https://alsgud8311.github.io/알고리즘/[백준-6064]-카잉-달력.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 6064] 카잉 달력</a><br>\n<a data-href=\"[백준 10597] 순열장난\" href=\"https://alsgud8311.github.io/알고리즘/[백준-10597]-순열장난.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 10597] 순열장난</a><br>\n<a data-href=\"[백준 31836] 피보나치 기념품\" href=\"https://alsgud8311.github.io/알고리즘/[백준-31836]-피보나치-기념품.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 31836] 피보나치 기념품</a> - 미완성<br>\n<a data-href=\"[백준26091] 현대모비스 소프트웨어 아카데미\" href=\"https://alsgud8311.github.io/알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준26091] 현대모비스 소프트웨어 아카데미</a><br>\n<a data-href=\"[백준 23307] 드디어 시작한 화석 발굴 이벤트\" href=\"https://alsgud8311.github.io/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 23307] 드디어 시작한 화석 발굴 이벤트</a><br>\n<a data-href=\"[백준 12891] DNA 비밀번호\" href=\"https://alsgud8311.github.io/알고리즘/[백준-12891]-dna-비밀번호.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">[백준 12891] DNA 비밀번호</a><br>\n<a data-href=\"백준 18113 그르다 김가놈\" href=\"https://alsgud8311.github.io/백준-18113-그르다-김가놈.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">백준 18113 그르다 김가놈</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["알고리즘/[백준-1004]-어린왕자.html#_0","알고리즘/[프로그래머스]-방금그곡.html#_0","알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html#_0","알고리즘/[프로그래머스]-행렬-테두리-회전하기.html#_0","알고리즘/[프로그래머스]-주차-요금-계산.html#_0","알고리즘/[백준-12865]-평범한-배낭.html#_0","알고리즘/[백준-7576]-토마토.html#_0","알고리즘/[프로그래머스]-석유-시추.html#_0","알고리즘/[프로그래머스]-요격-시스템.html#_0","알고리즘/[백준-9251]-lcs.html#_0","알고리즘/[백준-1912]-연속합.html#_0","알고리즘/[백준11631]-ascii-addition.html#_0","알고리즘/[백준14596]-quilting(smaill).html#_0","알고리즘/[백준-17123]-배열-놀이.html#_0","알고리즘/[백준31784]-포닉스의-문단속.html#_0","알고리즘/[백준-6064]-카잉-달력.html#_0","알고리즘/[백준-10597]-순열장난.html#_0","알고리즘/[백준-31836]-피보나치-기념품.html#_0","알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html#_0","[백준-23307]-드디어-시작한-화석-발굴-이벤트.html","알고리즘/[백준-12891]-dna-비밀번호.html#_0","백준-18113-그르다-김가놈.html"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/알고리즘.html","pathToRoot":"..","attachments":[],"createdTime":1725254058383,"modifiedTime":1739028697967,"sourceSize":881,"sourcePath":"알고리즘/알고리즘.md","exportPath":"알고리즘/알고리즘.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"index.html":{"title":"HELLO👋","icon":"","description":"안녕하세요. 프론트엔드 개발자로 열심히 공부중인 조민형입니다.<img height=\"400/\" src=\"https://i.imgur.com/4YbV9wp.jpeg\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 300px; max-width: 100%;\">어떤 기술이든지 노력이면 해낼 수 있다는 믿음 하에 일단 도전하는 것을 좋아합니다.&nbsp;&nbsp;UX를 고려한 서비스 제작, 추상화를 활용한 컴포넌트와 프로젝트 설계에 관심이 있습니다.합리적이고 논리적인 근거를 가진 코드를 작성하기 위해 노력중입니다 💪<br><img alt=\"React Native\" src=\"https://img.shields.io/badge/React%20Native-61DAFB?style=for-the-badge&amp;logo=react&amp;logoColor=white\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> <img alt=\"React\" src=\"https://img.shields.io/badge/React-61DAFB?style=for-the-badge&amp;logo=react&amp;logoColor=white\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> <img alt=\"Next.js\" src=\"https://img.shields.io/badge/Next.js-000000?style=for-the-badge&amp;logo=next.js&amp;logoColor=white\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img alt=\"Tailwind CSS\" src=\"https://img.shields.io/badge/Tailwind%20CSS-38B2AC?style=for-the-badge&amp;logo=tailwind-css&amp;logoColor=white\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> <img alt=\"styled-components\" src=\"https://img.shields.io/badge/styled--components-DB7093?style=for-the-badge&amp;logo=styled-components&amp;logoColor=white\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img alt=\"JavaScript\" src=\"https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&amp;logo=javascript&amp;logoColor=black\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> <img alt=\"TypeScript\" src=\"https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&amp;logo=typescript&amp;logoColor=white\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img alt=\"Zustand\" src=\"https://img.shields.io/badge/Zustand-FF8800?style=for-the-badge&amp;logo=zustand&amp;logoColor=white\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n한국외국어대학교 영미문학문화학과/ai융합전공(sw&amp;ai) - 재학중 멋쟁이사자처럼 한국외국어대학교(2023~2024)\n네이버 부스트캠프 웹모바일 9기(2024.7 ~ 2024.12) 멋쟁이사자처럼 연합해커톤 간지톤 최우수상\n리눅스마스터 2급 <br><a data-href=\"알고리즘\" href=\"https://alsgud8311.github.io/알고리즘/알고리즘.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">알고리즘</a>\n<br><a data-href=\"학습 정리\" href=\"https://alsgud8311.github.io/학습-정리/학습-정리.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">학습 정리</a> <br>adhd인을 위한 서비스 - <a data-href=\"forA\" href=\"https://alsgud8311.github.io/프로젝트/fora/fora.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">forA</a>\n<br>생성형 ai로 나만의 웹소설 만들기 - <a data-href=\"Neo\" href=\"https://alsgud8311.github.io/프로젝트/neo/neo.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Neo</a>\n<br>ai가 도와주는 마인드맵 저작도구 - <a data-href=\"Boomap\" href=\"https://alsgud8311.github.io/프로젝트/boomap/boomap.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Boomap</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Welcome to Minhyung's Dev Log","level":1,"id":"Welcome_to_Minhyung's_Dev_Log_0"},{"heading":"Tech skill","level":3,"id":"Tech_skill_0"},{"heading":"Education","level":3,"id":"Education_0"},{"heading":"Activity","level":3,"id":"Activity_0"},{"heading":"Awards &amp; Certificate","level":3,"id":"Awards_&_Certificate_0"},{"heading":"바로 가기","level":2,"id":"바로_가기_0"},{"heading":"프로젝트","level":2,"id":"프로젝트_0"}],"links":["알고리즘/알고리즘.html#_0","학습-정리/학습-정리.html#_0","프로젝트/fora/fora.html#_0","프로젝트/neo/neo.html#_0","프로젝트/boomap/boomap.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/index.html","pathToRoot":".","attachments":[],"createdTime":1738506132180,"modifiedTime":1738943532312,"sourceSize":2071,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/자바스크립트-알고리즘-강의/스택(stack)과-큐(queue).html":{"title":"스택(Stack)과 큐(Queue)","icon":"","description":"<img src=\"https://i.imgur.com/OrNBkYQ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">후입선출(LIFO, Last In First Out)의 구조를 가진 자료구조이다.\n스택 자료구조는\n함수 호출(call stack)을 다루는 상황에서 사용\nUndo(되돌리기)/Redo(다시실행)\n인터넷의 방문기록(히스토리 관리)\n등에서 주로 활용된다.\n// 배열을 이용한 방식 1\nvar stack = [];\nstack.push(\"stack1\");\nstack.push(\"stack2\");\nstack.push(\"stack3\");\nstack.pop();\nstack.pop();\nstack.pop(); // 배열을 이용한 방식 2 =&gt; 방향만 바뀜.\n// 앞에서 제거 및 추가하는 경우 인덱스를 계속 밀고 당겨야 하기 때문에 효율적이지 않음\nstack.unshift(\"stack1\");\nstack.unshift(\"stack2\");\nstack.unshift(\"stack3\");\nstack.shift();\nstack.shift();\nstack.shift();\n구현이라고 하기도 민망하네\n그냥 빌트인 메서드 쓰면 된다\n배열을 이용한 스택 말고도 단일 연결 리스트를 이용해서도 구현할 수 있다. 물론 양방향도 가능하지만 살짝 투머치//연결 리스트를 이용한 방식\nclass Node { constructor(val) { this.val = val; this.next = null; }\n} class Stack { constructor() { this.first = null; this.last = null; this.size = 0; } // 앞에서 값을 넣는 push 메서드 push(val) { var newNode = new Node(val); if (!this.first) { this.first = newNode; this.last = newNode; } else { var temp = this.first; this.first = newNode; this.first.next = temp; } return ++this.size; } // 앞에서 값을 하나씩 빼는 pop 메서드 pop() { if (!this.head) return null; var temp = this.first; if (this.first === this.last) this.last = null; this.first = this.first.next; this.size--; return temp.value; }\n} 여기서 push와 pop 메서드를 앞에서 추가하고 삭제하는 메서드로 만든 이유는 단일 연결리스트의 경우 pop이 상수시간이 나오지 않기 때문이다.단일연결리스트로 pop을 구현하려면 마지막 노드를 그 전 노드로 만들어야 하는데, 그 전 노드를 구하는 과정의 시간복잡도가 이 걸리기 때문이다. 따라서 앞에서 추가하고 빼내는 것이 보다 효율적이다.또한 단일 연결 리스트를 이용해서 만들게 되면 데이터의 양이 매우 많아졌을 때 그냥 배열을 이용했을 때보다 낫다. 중요한 것은 삽입과 삭제가 상수시간이 걸리는 자료구조라는 것이다. 탐색이나 접근이 필요한 것들이 필요한 작업이라면 다른 자료구조를 이용하는 것이 낫다.하지만 삽입과 삭제는 전체를 순회할 이유가 없기 때문에 상수시간이 걸려 삽입과 삭제만 필요한 부분에서는 효율적인 자료구조이다.<br><img src=\"https://i.imgur.com/8HCpTOI.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">큐는 스택과 비슷한 데이터 구조로 데이터의 추가와 삭제를 위한 자료구조이다.\n스택과의 차이점이라고 한다면 순서인데, 큐는 선입선출(FIFO, First In First Out) 구조를 가지고 있다.큐와 같은 선입선출 구조는 많은 곳에서 사용되는 구조이다. 줄을 서서 기다리는 것도 그렇고 프로그래밍 측면에서는\n게임 대기열\n백그라운드 작업\n어떤 파일을 업로드할 때\n프린트 대기열\n등이 있다.\n큐 또한 스택처럼 배열을 이용하여 구현할 수도 있고, 연결 리스트를 이용한 클래스를 만들어 사용할 수도 있다.// 배열을 이용한 방식 1\nvar queue = [];\nqueue.push(\"first\");\nqueue.push(\"second\");\nqueue.push(\"third\");\nqueue.shift(); //first\nqueue.shift(); //second\nqueue.shift(); //third // 배열을 이용한 방식 2\nqueue.unshift(\"first\");\nqueue.unshift(\"second\");\nqueue.unshift(\"third\");\nqueue.pop();\nqueue.pop();\nqueue.pop();\n배열을 사용할 때는 어떤 방향에서든지 삽입이나 삭제에서 의 시간이 걸리는 작업이 있을 수밖에 없으므로 직접 클래스를 구현하는 것이 보다 효율적이다.//단일 연결 리스트를 이용한 구현\nclass Node { constructor(val) { this.val = val; this.next = null; }\n}\nclass Queue { constructor(val) { this.first = null; this.last = null; this.size = 0; } // 뒤에 값을 추가하는 enqueue 메서드 enqueue(val) { var newNode = new Node(val); if (!this.first) { // 아무것도 없을 경우 새로 헤드와 테일 설정 this.first = newNode; this.last = newNode; } else { // 포인터 옮기기 this.last.next = newNode; this.last = newNode; } } // 앞의 값들을 하나씩 빼는 dequeue 메서드 dequeue() { if (!this.first) return null; var temp = this.first; if (this.first === this.last) { this.last = null; } this.first = this.first.next; this.size--; return temp.val; }\n}\n배열을 사용했을 때는 이 한 방향에서 발생했으나 연결리스트를 이용하여 구현했을 때에는 상수시간이 걸리는 것을 알 수 있다. 이를 통해 큐 또한 삽입과 삭제에 효율적인 자료구조임을 알 수 있다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"스택(Stack)","level":1,"id":"스택(Stack)_0"},{"heading":"스택(Stack)이란?","level":2,"id":"스택(Stack)이란?_0"},{"heading":"배열을 이용한 스택 구현","level":2,"id":"배열을_이용한_스택_구현_0"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_0"},{"heading":"큐(Queue)","level":1,"id":"큐(Queue)_0"},{"heading":"큐(Queue)란?","level":2,"id":"큐(Queue)란?_0"},{"heading":"구현","level":2,"id":"구현_0"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_1"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/자바스크립트-알고리즘-강의/스택(stack)과-큐(queue).html","pathToRoot":"../..","attachments":[],"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":5644,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/스택(Stack)과 큐(Queue).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/스택(stack)과-큐(queue).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/자바스크립트-알고리즘-강의/이진-탐색-트리(binary-search-tree).html":{"title":"이진 탐색 트리(Binary Search Tree)","icon":"","description":"이진 탐색 트리(Binary Search Tree)는 이진 트리 기반의 탐색을 위한 자료구조이다.\n이진탐색트리는 자식 노드가 2개 이하 여야만 함\n모든 원소의 키가 유일한 키\n왼쪽 서브 트리 키들은 루트 키보다 작음\n오른쪽 서브 트리의 키들은 루트의 키보다 큼\n왼쪽, 오른쪽 서브 트리의 하위 트리도 이진 탐색 트리이다\n의 조건을 지닌다.\n작은 것들은 왼쪽에 두고 큰 것들을 항상 오른쪽에 두어 정렬하는 방식의 트리는 선형적이지 않고 탐색이 매우 빠르게 이루어질 수 있다.class Node { constructor(val) { //해당 노드의 값 this.val = val; // 왼쪽 트리를 가르키는 포인터 this.left = null; // 오른쪽 트리를 가르키는 포인터 this.right = null; }\n}\nclass BinarySearchTree { constructor() { this.root = null; } // 루트에서부터 내려가면서 새로운 노드가 들어갈 자리를 찾고 삽입하는 insert 메서드 insert(val) { //새로운 노드 생성 var newNode = new Node(val); //루트가 없을 때(아무 노드도 없을 떄) -&gt; 새로 들어온 값을 루트로 설정 if (!this.root) { this.root = newNode; return this; } // 그렇지 않은 경우 -&gt; 값이 들어갈 적절한 자리를 찾아 탐색 else { // 시작점에서부터 나아가는 방향을 나타내는 current 변수 var current = this.root; while (true) { // 무한루프에 빠지지 않기 위해 탈출조건 명시 if (val === current.val) return undefined; // 들어오는 값이 현재 값보다 작을 때 -&gt; 왼쪽으로 이동 if (val &lt; current.val) { // 왼쪽 자식 노드가 더이상 없을 경우 들어갈 자리까지 탐색이 완료된 경우이므로 해당 값을 삽입 if (current.left === null) { current.left = newNode; return this; } // 그렇지 않을 경우(노드가 있을 경우) else { current = current.left; } //value값이 현재 가리키고 있는 노드의 val보다 클 경우 -&gt; 오른쪽으로 이동 } else if (val &gt; current.val) { // 오른쪽 자식 노드가 더이상 없을 경우 들어갈 자리까지 탐색이 완료된 경우이므로 해당 값을 삽입 if (current.right === null) { current.right = newNode; return this; } else { current = current.right; } } } } } // val값에 해당하는 노드를 트리에서 찾는 contains 메서드 contains(val) { // 트리에 노드가 아무것도 없을 경우 false 리턴 if (!this.root) return false; // 루트에서부터 노드를 옮겨가면서 탐색할 current 변수를 만들고 루트를 가리키도록 함 var current = this.root, // found 변수의 경우 루프문에서 빠져나오기 위한 조건 found = false; // 더 갈 수 있는 노드가 있고 아직 값을 찾지 못했을 동안 반복 while (current &amp;&amp; !found) { // 찾는 값이 현재 값보다 작을 경우 왼쪽 트리로 이동 if (val &lt; current.val) { current = current.left; } // 찾는 값이 현재 값보다 클 경우 오른쪽 트리로 이동 else if (val &gt; current.val) { current = current.right; } // 나머지 경우는 val === current.val일 경우기 때문에 찾은 경우라 true를 리턴 else { return true; } } // 못 찾았을 경우 false 리턴 return false; }\n} 최고와 평균적인 경우 모두 의 시간이 걸린다.\n이진 트리의 노드의 개수는 아래의 트리로 내려갈 수록 2배씩 거듭제곱으로 증가한다. 1,2,4,8,16... 이렇게 기하급수적으로 늘어나는 개의 노드와는 반대로 트리의 높이는 하나씩만 깊어진다.\n여기서 탐색 혹은 연산을 할 때 우리는 루트에서부터 밑으로 내려가면서 작을 경우/클 경우 두 경우로만 나뉘어 밑으로 내려가기 때문에 비교가 쉬우면서도 2의 거듭제곱인 노드의 수에 비해서 트리의 높이인 만큼만 비교하면 되므로 시간복잡도가 매우 빠르다.하지만 최악의 경우를 다룰 경우에는 반드시 을 가지지 않을 수도 있다. 어떤 이진 탐색 트리의 구성을 가지냐에 따라서도 시간이 달라질 수 있기 때문이다.<img src=\"https://i.imgur.com/BI6TOmc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이러한 이진 트리는 이진 트리의 성격을 갖추면서도 일자로 뻗어나가는 형태를 지니고 있기 때문에 탐색/삽입이 선형적인 시간만큼 걸릴 수밖에 없다.\n따라서 이진 탐색 트리라고 하더라도 구성에 따라 시간복잡도가 달라질 수 있으므로 주의해야 한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"이진 탐색 트리(BST, Binary Search Tree)","level":1,"id":"이진_탐색_트리(BST,_Binary_Search_Tree)_0"},{"heading":"이진 탐색 트리란?","level":1,"id":"이진_탐색_트리란?_0"},{"heading":"구현","level":2,"id":"구현_0"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/자바스크립트-알고리즘-강의/이진-탐색-트리(binary-search-tree).html","pathToRoot":"../..","attachments":[],"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":5220,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/이진 탐색 트리(Binary Search Tree).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/이진-탐색-트리(binary-search-tree).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/자바스크립트-알고리즘-강의/정렬-기수정렬(radix-sort).html":{"title":"정렬 - 기수정렬(Radix Sort)","icon":"","description":"이제까지 쓴 버블, 삽입, 선택, 합병, 퀵 정렬의 경우 모두 비교 정렬 알고리즘에 속한다. 본질적으로 주어진 시점에서 두 개의 항목을 비교하여 정렬을 이루어낸다는 것이다. 그렇게 만들어진 정렬 중에 가장 나았던 정렬은 퀵, 합병 정렬로 시간복잡도가 이었다. 하지만 여기에서 더 빠른 정렬 알고리즘이 있을까?답은 '있다'. 하지만 이건 비교를 통해 정렬을 이루어내는 방식이 아니다. 수학적으로 비교 정렬의 평균 시간 하한선은 이기 때문에 더 아래로 내려가는 것은 수학적인 제약이 있다.그렇지만 비교가 아닌 다른 방식으로 정렬을 해서 이보다 더 줄일 수 있다! 대신 특정한 경우에 한정해서만 가능하긴 하지만 그런 빠른 정렬 알고리즘 중 하나가 기수정렬(Radix Sort) 이다. 기수 정렬은 우리가 저장하는 데이터가 이진 형식으로 되어있다는 점을 이용했다.\n숫자 크기에 대한 정보를 자릿수대로 인코딩할 수 있다는 사실을 이용하여 자릿수 비교를 하는 방식이다.[1556, 4, 3556, 593, 408, 4386, 902, 7, 8157, 86, 9637, 29]라는 배열이 있다고 해보자. 각 수는 한자리 수부터 4자리 수까지 있다.여기에 우리는 0부터 9까지 각 수를 나타내는 10개의 버킷을 만든다.\n각 요소는 제일 오른쪽 숫자를 기준으로 각각의 버킷에 들어간다.<img src=\"https://i.imgur.com/qzvzSBZ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">마지막 일의자리 수로 버킷에 마구잡이로 넣어주었다.\n이렇게 넣어놓은 버킷을 기준으로 0부터 9까지, 아래서부터 하나씩 빼가면서 다시금 배열에 저장한다.\n정렬이 한번 되면 아래와 같이 숫자들의 일의자리 오름차순으로 정렬이 된다.\n[902, 593, 4, 1556, 3556, 4386, 86, 7, 8157, 9637, 408, 29]\n이렇게 한 뒤 마지막 오른쪽에서부터 왼쪽으로 하나씩 자릿수를 높여가면서 다시금 정렬한다. 즉, 이번에는 십의자리 숫자대로 정렬하는 것이다.<br><img src=\"https://i.imgur.com/o2SNXna.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">십의 자리 순서대로 넣어주었다. 여기서 다음 자리수의 값이 없는 값들은 0으로 들어간다.\n[902, 4, 7, 408, 29, 9637, 1556, 3556, 8157, 4386, 86, 593] 다음으로 만들어진 정렬은 이와 같다.\n계속해서 다음 백의자리 숫자, 다음은 천의자리 숫자.. 이렇게 늘려가면서 다음 자릿수의 수가 모두 없을 때까지 반복한다.<br><img src=\"https://i.imgur.com/f8pjilQ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n백의 자리 숫자로 다시급 정렬했다. 점점 정렬이 되어가는 것들을 볼 수 있다.\n[4, 7, 29, 86, 8157, 4386, 408, 1556, 3556, 593, 9637, 902] 백의 자리 숫자로 정렬했을 때의 결과는 이와 같다. 다시한번 돌려보자 <br><img src=\"https://i.imgur.com/kQNqDpj.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">천의자리로 정렬을 다시 하면 [4, 7, 29, 86, 408, 593, 902, 1556, 3556, 4386, 8157, 9637]의 순서대로 오게 된다.\n제일 큰 수의 마지막 자리수까지 오게 되면 각 자리수 순서대로 아래서부터 뺐을 때 순서대로 정렬이 되어있는 것을 볼 수 있다.이렇게 작동시키기 위해서는 각 요소의 수에서 해당 위치의 숫자를 알 수 있어야 한다. 구현 과정에서 필요한 과정을 함수로 나누어 각각 구현해보았다.각 자릿수를 알아낼 수 있는 함수이다. 수와 위치를 가져온 다음 그 위치의 숫자를 반환할 수 있어야 한다.function getDigit(num, place) { return Math.floor(Math.abs(num) / Math.pow(10, place)) % 10;\n}\n한 요소의 자릿수가 얼마인지 확인하는 함수function digitCount(num) { if (num === 0) return 1; //들어오는 값에 대해 10의 제곱근을 구하고 1을 더함 return Math.floor(Math.log10(Math.abs(num))) + 1;\n}\n각 요소중에서 자리수의 최대값을 리턴function mostDigits(arr){ let maxDigits = 0; for(let i=0;i&lt;arr.length;i++){ maxDigits= Math.max(maxDigits,digitCount(arr[i])) } return maxDigits\n}\nfunction radixSort(arr) { let maxLoop = mostDigits(arr); for (let i = 0; i &lt; maxLoop; i++) { let bucket = Array.from({ length: 10 }, () =&gt; []); for (let j = 0; j &lt; arr.length; j++) { let place = getDigit(arr[j], i); bucket[place].push(arr[j]); } arr = [].concat(...bucket); }\n}\nn의 경우 정렬할 항목 수나 정수의 수이고, k의 경우에는 이러한 수의 길이이다. 각 숫자의 자릿수를 의미한다.\n평균과 베스트, 워스트 케이스가 모두 로 같아 비교정렬보다 비슷하거나 빠르다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"이전까지의 정렬..","level":1,"id":"이전까지의_정렬.._0"},{"heading":"기수 정렬이란?","level":1,"id":"기수_정렬이란?_0"},{"heading":"구현","level":2,"id":"구현_0"},{"heading":"getDigit","level":3,"id":"getDigit_0"},{"heading":"digitCount","level":3,"id":"digitCount_0"},{"heading":"mostDigits","level":3,"id":"mostDigits_0"},{"heading":"정렬","level":3,"id":"정렬_0"},{"heading":"시간복잡도","level":3,"id":"시간복잡도_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/자바스크립트-알고리즘-강의/정렬-기수정렬(radix-sort).html","pathToRoot":"../..","attachments":[],"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":5027,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/정렬 - 기수정렬(Radix Sort).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/정렬-기수정렬(radix-sort).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/자바스크립트-알고리즘-강의/정렬-버블,-삽입,-선택정렬.html":{"title":"정렬 - 버블, 삽입, 선택정렬","icon":"","description":"버블정렬은 배열을 오름차순으로 정렬을 한다고 할 때, 더 큰 숫자가 한번에 하나씩 뒤로 이동을 하는 방식이다.\n루프를 돌면서 각 항목을 다음 항목과 비교해서 해당 숫자가 비교 대상보다 더 큰지 확인하고, 만약 더 크다면 교환한다. 자바스크립트에서 교환 방법은 대표적으로 두 가지가 있다.//ES5 =&gt; temp라는 변수에 따로 idx1의 값을 저장해두고 바꾸는 방식\nfunction swap(arr, idx1, idx2) { var temp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = temp;\n} //ES6 =&gt; syntax를 통해 서로의 값을 교환하는 방법\nconst swap = (arr, idx1, idx2) =&gt; { [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\n}; 이 루프는 처음 수부터 마지막 수까지 계속 움직이면서 교환하지만, 바로 뒤의 숫자밖에 교환할 수 없기 때문에 앞의 숫자는 관여할 수 없다. 그렇기 때문에 이러한 루프는 마지막에서부터 1개씩만 정렬이 100% 보장되기 때문에 n-1개씩 계속해서 루프를 돌려야 한다.function bubbleSort(arr) { // 맨 뒤는 하나씩 무조건 정렬되기 때문에 정렬 횟수를 줄이기 for (let i = arr.length; i &gt; 0; i--) { //i-1까지 반복시키면서 불필요한 초과정렬연산 막기 for (let j = 0; j &lt; i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { //ES5방식의 swap let temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr;\n} console.log(bubbleSort([37, 45, 29, 8, 12, 88, -3])); function bubbleSort(arr) { const swap = (arr, idx1, idx2) =&gt; { [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]; }; // 맨 뒤는 하나씩 무조건 정렬되기 때문에 정렬 횟수를 줄이기 for (let i = arr.length; i &gt; 0; i--) { //i-1까지 반복시키면서 불필요한 초과정렬연산 막기 for (let j = 0; j &lt; i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { //ES6방식의 swap swap(arr, j, j + 1); } } } return arr;\n} console.log(bubbleSort([37, 45, 29, 8, 12, 88, -3])); 만약 데이터가 거의 정렬이 된 상태거나, 이미 정렬이 완료된 상태라면 버블 성렬을 할 필요가 없어진다.\n기본적인 버블 정렬 알고리즘은 해당 데이터를 다르게 처리하지 않고 여전히 항목 하나하나를 정렬하려고 하기 때문에 정렬 과정에서 필요없는 비교가 너무 많아지게 된다.function bubbleSort(arr) { const swap = (arr, idx1, idx2) =&gt; { [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]; }; // 맨 뒤는 하나씩 무조건 정렬되기 때문에 정렬 횟수를 줄이기 for (let i = arr.length; i &gt; 0; i--) { //i-1까지 반복시키면서 불필요한 초과정렬연산 막기 for (let j = 0; j &lt; i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { //ES6방식의 swap swap(arr, j, j + 1); } } } return arr;\n}\n// 정렬이 돼 있음에도 7!의 비교를 수행한다\nconsole.log(bubbleSort([8, 1, 2, 3, 4, 5, 6, 7]));\n그렇기 때문에 버블 정렬을 최적화하는 방법은, 해당 루프가 마지막으로 실행됐을 때 교환을 하지 않았다면 정렬이 완료된 상태임을 알고 정렬이 된 부분을 생략하는 것이다. let noSwaps; // 맨 뒤는 하나씩 무조건 정렬되기 때문에 정렬 횟수를 줄이기 for (let i = arr.length; i &gt; 0; i--) { noSwaps = true; //i-1까지 반복시키면서 불필요한 초과정렬연산 막기 for (let j = 0; j &lt; i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { //ES5방식의 swap let temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; //swap이 이루어졌으므로 false로 바꾸기 noSwaps = false; } } //한 번도 교환이 없었다 = 더이상 정렬할 것이 없음 //한 번도 교환이 이루어지지 않았으면 true값으로 유지되기 때문에 바로 break를 통해 빠져나감 if (noSwaps) break; } return arr;\n} console.log(bubbleSort([-8, 1, 2, 3, 4, 5, 6, 7])); Average: 배열을 반복해서 돌면서 각 항목마다 n번의 비교를 해야 하기 때문Best Case: 0데이터가 거의 정렬됐거나 이미 정렬이 끝난 상태에서 noSwaps 변수가 있는 최적화 버전을 사용했을 때 Worst Case: <img src=\"https://i.imgur.com/StSGWKf.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n버블정렬과 비슷하지만, 큰 값을 배열의 끝에 위치시키는 대신 작은 값을 한 번에 하나씩 위치에 배열하는 방식\n버블정렬과 같이 처음부터 끝까지 움직이지만, 실제 정렬된 데이터는 처음부터 누적됨\n배열을 돌며 최소값을 찾아 맨 앞에서 하나씩 증가하는 인덱스와 바꾸어 정렬하는 방식\n이러한 방식으로 정렬을 하면 맨 앞부터 하나씩 정렬이 될 것이고, 최솟값을 찾는 것도 앞에서 하나씩 뒤로 당기면서 최솟값을 찾는 범위를 줄여가면 됨\nfunction selectionSort(arr) {\n// 두 요소의 위치 바꾸는 함수 const swap = (arr, idx1, idx2) =&gt; { [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]; }; // 바깥쪽 루프문 =&gt; 돌 범위 for (let i = 0; i &lt; arr.length; i++) { let min = i; // 안쪽 루프문 =&gt; 최솟값 비교 for (let j = i + 1; j &lt; arr.length; j++) { if (arr[min] &gt; arr[j]) { min = j; } } // 굳이 바꿀 필요가 없는 경우에 바꾸지 않도록 조건 명시 if (i !== min) swap(arr, i, min); } return arr;\n} selectionSort([34, 22, 10, 19, 17]);\n\bAverage: Best Case: Worst Case: <br><img src=\"https://i.imgur.com/y5hY6AV.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">버블정렬이나 선택정렬같이 한 번에 가장 큰 요소를 찾거나 한 번에 가장 작은 요소를 찾는 대신 앞에서부터 순서대로 각 요소를 취하여 정렬되어 있는 요소들 속에 위치를 찾고 배치하면서 점진적으로 정렬을 구축한다.function insertionSort(arr) { // 바깥쪽 루프문 -&gt; 정렬할 숫자 고르기 for (var i = 1; i &lt; arr.length; i++) { var currentVal = arr[i]; // 안쪽 루프문 -&gt; 정렬할 숫자 왼쪽에 있는 요소들이 정렬되어 있기 때문에 해당 배열 범위 안을 거꾸로 돌며 위치 찾기 for (var j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; currentVal; j--) { // 새로 들어오는 수의 공간을 만들기 위해 오른쪽으로 하나씩 밀어내기 arr[j + 1] = arr[j]; } arr[j + 1] = currentVal; } return arr;\n}\ninsertionSort([2, 1, 9, 76, 4]); Average: Best Case: O(n)\n온라인 알고리즘 데이터의 경우 실시간으로 최신 데이터가 들어올 때마다 필요한 자리에 정렬시킬 수 있음(정렬된 부분을 유지하고 적절한 위치에 항목을 삽입하기 때문)Worst Case: 배열의 길이가 늘어날 수록 비교 횟수를 기본적으로 n제곱해야 함\n특히 가장 최악인 케이스는 역순으로 정렬(내림차순)되어있을 때 가장 느림 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"버블정렬","level":1,"id":"버블정렬_0"},{"heading":"버블정렬이란?","level":2,"id":"버블정렬이란?_0"},{"heading":"<strong>📚여기서 교환(swap)이란?</strong>","level":3,"id":"**📚여기서_교환(swap)이란?**_0"},{"heading":"구현","level":2,"id":"구현_0"},{"heading":"ES5 방식의 교환으로 구현","level":3,"id":"ES5_방식의_교환으로_구현_0"},{"heading":"ES6방식으로 구현","level":3,"id":"ES6방식으로_구현_0"},{"heading":"최적화","level":2,"id":"최적화_0"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_0"},{"heading":"선택정렬","level":1,"id":"선택정렬_0"},{"heading":"선택정렬이란?","level":2,"id":"선택정렬이란?_0"},{"heading":"구현","level":2,"id":"구현_1"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_1"},{"heading":"삽입정렬","level":1,"id":"삽입정렬_0"},{"heading":"삽입정렬이란?","level":2,"id":"삽입정렬이란?_0"},{"heading":"구현","level":2,"id":"구현_2"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_2"},{"heading":"정렬 알고리즘 비교","level":1,"id":"정렬_알고리즘_비교_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/자바스크립트-알고리즘-강의/정렬-버블,-삽입,-선택정렬.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058383,"modifiedTime":1725254058384,"sourceSize":7975,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/정렬 - 버블, 삽입, 선택정렬.md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/정렬-버블,-삽입,-선택정렬.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/자바스크립트-알고리즘-강의/정렬-퀵정렬(quick-sort).html":{"title":"정렬 - 퀵정렬(Quick Sort)","icon":"","description":"개인적으로 모든 알고리즘 중에 가장 골아프게 하는 알고리즘..\n진짜 이거 만든 사람은 무슨 생각하다가 만든걸까?합병정렬과 같은 가정으로 작동하는 정렬 알고리즘\n재귀를 통해 해결하기 쉬운(?) 방식 중 하나이다.배열에 0개 or 1개의 항목이 남을 때까지 분할한 뒤에 개별적으로 정렬하는 방식이다\n정렬하는 과정에서 피벗 포인트라고 부르는 단일 요소를 선택하여 수행하는데, 한 요소를 선택하면 해당 값보다 작은 숫자를 모두 왼쪽으로 옮기고, 큰 값은 오른쪽으로 옮긴다.[5, 2, 1, 8, 4, 7, 6, 3]의 숫자가 있다고 생각해보자\n처음에 5를 피벗이라고 생각하면 5보다 작은 숫자는 1,2,3,4 4개가 있다.\n그렇다면 1.2,3,4를 왼쪽으로 옮기고 5의 인덱스를 피벗보다 작은 수의 끝 바로 오른쪽으로 옮긴다. 이 과정에서 옮기는 과정은 자기보다 작은 수들을 일단 바로 오른쪽으로 옮기면서 자기보다 큰 수는 좀 떨어져 있게 하고 옆으로 한칸씩 밀어서 옮긴다. 다 옮긴 후에는 자신보다 더 작은 수의 끝 인덱스와 자신을 옮기면서 마무리된다\n그렇게 되면 [3, 2, 1, 4, 5, 7, 6, 8]의 순서대로 값들이 옮겨간다. 이 과정이 끝났으면 이러한 과정을 5을 중심으로 왼쪽과 오른쪽에서 재귀적으로 반복한다. 왼쪽과 오른쪽에서 어떤 요소를 사용하든 상관은 없다.\n왼쪽부터 가장 첫 요소 3을 피벗으로 사용한다고 하면 위와 같은 과정을 반복했을 때 나오는 결과는 [1, 2, 3, 4, 5, 7, 6, 8]이다.\n다시 3을 기준으로 했으니 왼쪽의 1을 피벗으로 잡고 돌리면 따로 변환 없이 그대로 나오게 되고, 이는 곧 왼쪽이 모두 분할되어 1개 이하의 요소들로만 남게 되었으므로 정렬이 완성되었음을 의미한다\n오른쪽 또한 정렬이 필요하기 때문에 여기도 첫번째 요소 7을 피벗으로 잡고 이동시킨다. 7을 피벗으로 값들을 이동시키면[1, 2, 3, 4, 5, 6, 7, 8]이 되고, 나머지 요소들이 단일 요소가 되었으므로 정렬이 끝난다.\n퀵정렬의 시간은 어떤 피벗을 선택하느냐에 따라 속도가 달라질 수 있다.데이터 집합의 중간값이 되도록 선택하는 것이 이상적이다. 하지만 데이터가 무엇인지, 순서가 어떻게 되어 있는지 알지 못한다면 이를 고려하여 피벗 또한 선택하는 것이 쉽지 않다.그래서 다른 전략으로 첫번째, 마지막, 중간, 랜덤한 요소 등을 선택하는데, 여기서는 첫 번째 요소를 피벗으로 선택하려 한다. //배열이 주어지면 요소를 피벗 포인트로 지정하여 배열 속 요소를 재배치하는 함수\nfunction pivot(arr, sidx = 0, eidx = arr.length + 1) { // 배열의 두 위치를 바꾸기 위한 함수 const swap = (arr, idx1, idx2) =&gt; { [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]; }; let pivot = arr[sidx]; let swapIdx = sidx; for (let i = sidx + 1; i &lt; arr.length; i++) { if (pivot &gt; arr[i]) { // 스왑할 공간을 만들어주기 위해 옆으로 밀기 swapIdx++; // 만든 공간에 있는 값과 i에 있는 값을 교환 swap(arr, swapIdx, i); } } //스왑 인덱스와 피벗의 위치를 교환하여 피벗의 왼쪽에 작은수, 오른쪽에 큰 수만 오도록 만듦 swap(arr, sidx, swapIdx); //스왑 인덱스를 리턴하여 나중에 왼쪽과 오른쪽을 어떤 인덱스 기준으로 구분할 지 알 수 있음 return swapIdx;\n}\n//배열이 주어지면 요소를 피벗 포인트로 지정하여 배열 속 요소를 재배치하는 함수\nfunction pivot(arr, sidx = 0, eidx = arr.length + 1) { // 배열의 두 위치를 바꾸기 위한 함수 const swap = (arr, idx1, idx2) =&gt; { [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]; }; let pivot = arr[sidx]; let swapIdx = sidx; for (let i = sidx + 1; i &lt; arr.length; i++) { if (pivot &gt; arr[i]) { // 스왑할 공간을 만들어주기 위해 옆으로 밀기 swapIdx++; // 만든 공간에 있는 값과 i에 있는 값을 교환 swap(arr, swapIdx, i); } } //스왑 인덱스와 피벗의 위치를 교환하여 피벗의 왼쪽에 작은수, 오른쪽에 큰 수만 오도록 만듦 swap(arr, sidx, swapIdx); //스왑 인덱스를 리턴하여 나중에 왼쪽과 오른쪽을 어떤 인덱스 기준으로 구분할 지 알 수 있음 return swapIdx;\n} function quickSort(arr, left = 0, right = arr.length - 1) { //하위배열이 작아질수록 왼쪽과 오른쪽은 가까워지고 하나의 요소만 남으면 왼쪽과 오른쪽이 같아지는 원리는 이용하여 바닥조건 설정 if (left &lt; right) { let pivotIndex = pivot(arr, left, right); //왼쪽 quickSort(arr, left, pivotIndex - 1); //오른쪽 quickSort(arr, pivotIndex + 1, right); } console.log(arr); return arr;\n} // [1, 2, 3, 4, 5, 6, 7, 8];\nquickSort([4, 8, 2, 1, 5, 7, 6, 3]); 베스트 케이스와 평균이 모두 합병 정렬과 같지만 워스트 케이스의 경우는 이 걸리니 조심하자!여기서 워스트 케이스를 개선하는 방법은 무조건 첫 번째 요소를 피벗으로 정하는 것이 아닌 무작위로 하나의 요소를 골라 피벗으로 정하여 분해하면 시간이 개선될 수 있다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"퀵 정렬","level":1,"id":"퀵_정렬_0"},{"heading":"퀵 정렬이란?","level":2,"id":"퀵_정렬이란?_0"},{"heading":"피벗 선택하기","level":2,"id":"피벗_선택하기_0"},{"heading":"구현","level":2,"id":"구현_0"},{"heading":"피벗 교환 알고리즘","level":3,"id":"피벗_교환_알고리즘_0"},{"heading":"퀵 정렬(전체)","level":3,"id":"퀵_정렬(전체)_0"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/자바스크립트-알고리즘-강의/정렬-퀵정렬(quick-sort).html","pathToRoot":"../..","attachments":[],"createdTime":1725254058384,"modifiedTime":1725254058384,"sourceSize":6653,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/정렬 - 퀵정렬(Quick Sort).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/정렬-퀵정렬(quick-sort).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/자바스크립트-알고리즘-강의/정렬-합병정렬(merge-sort).html":{"title":"정렬 - 합병정렬(Merge Sort)","icon":"","description":"버블, 선택, 삽입 정렬의 치명적인 단점은 느리다는 것이다. 평균적인 정렬 시간 복잡도가 이면 다른 이 걸리는 정렬들보다 시간이 제곱된다는 것을 의미하고, 이는 점점 정렬할 데이터의 수가 많아지면 많아질수록 훨씬 큰 차이가 나게 된다. <img src=\"https://i.imgur.com/w8KHjDC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그래프에서도 볼 수 있듯이 과 의 차이가 가면 갈수록 더욱 크게 나는 것을 볼 수 있다.이를 통해 우리는 보다 많은 데이터를 빠르게 처리하기 위해 시간 복잡도를 줄일 필요가 있다.비교 기반 정렬 알고리즘으로, 폰 노이만이 1945년도에 개발한 분할 정복 알고리즘 중 하나이다. 이를 뒷받침하는 개념은 분할, 합병, 정렬이라는 시 가지 조합으로 이루어져 있다.\n합병 정렬은 0개요소, 1개 요소 배열이 이미 정렬되어 있다는 점을 활용하여 배열을 더 작은 배열로 나눈다(그래서 분할 정복 알고리즘이다). 그리고 0이나 1개 요소 배열이 될 때까지 계속 분할하다가 다시 병합(merge)시키는 방식이다.<br><img src=\"https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">위의 gif를 보면 6,5,3,1,8,7,2,4의 수들이 있다.처음에는 이를 두개로 나누어 6,5,3,1과 8,7,2,4의 배열로 분할되고, 이를 다시 분할하여 6,5 / 3,1 / 8,7 / 2,4로 나뉜다. 아직도 각 분할된 요소들이 정렬되지 않은 상태이므로 다시 6/5/3/1/8/7/2/4로 분할된다.분할된 요소들은 다시 역행하여 병합하게 되는데, 이 병합하는 과정에서 2개, 4개, 8개씩 다시 병합하게 되고, 이 병합하는 과정에서 정렬이 되도록 각 요소가 알맞은 자리에 들어가게 짜는 알고리즘이다.function merge(arr1, arr2) { let results = []; // 두 개의 배열로 나뉜 것들을 합병하기 때문에 포인터를 각각 한 개씩 둠 let i = 0; let j = 0; // 두 배열을 보면서 각 위치에서 비교하고 더 작은 수를 찾아 순서대로 넣는 방식 while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) { if (arr2[j] &gt; arr1[i]) { results.push(arr1[i]); i++; } else { results.push(arr2[j]); j++; } } // 첫번째 루프문이 끝나고 남은 배열이 남았을 때 남은 배열들은 정렬이 되어있기 때문에 그대로 하나씩 뺴서 넣음 while (i &lt; arr1.length) { results.push(arr1[i]); i++; } while (j &lt; arr2.length) { results.push(arr2[j]); j++; } return results;\n}\n//[1, 2, 10, 14, 50, 99, 100]\nmerge([1, 10, 50], [2, 14, 99, 100]); function mergeSort(arr) { // base Case if (arr.length &lt;= 1) return arr; let mid = Math.floor(arr.length / 2); // 재귀적으로 호출하여 1개, 0개 요소만 남을 때까지 계속 분할 let left = mergeSort(arr.slice(0, mid)); let right = mergeSort(arr.slice(mid)); // merge 함수를 통해 쪼갠 것들을 리턴하도록 하면 재귀적으로 계속 합병된 배열들이 리턴되어 마지막엔 모두 정렬된 배열이 완성 return merge(left, right);\n} function merge(arr1, arr2) { let results = []; // 두 개의 배열로 나뉜 것들을 합병하기 때문에 포인터를 각각 한 개씩 둠 let i = 0; let j = 0; // 두 배열을 보면서 각 위치에서 비교하고 더 작은 수를 찾아 순서대로 넣는 방식 while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) { if (arr2[j] &gt; arr1[i]) { results.push(arr1[i]); i++; } else { results.push(arr2[j]); j++; } } // 첫번째 루프문이 끝나고 남은 배열이 남았을 때 남은 배열들은 정렬이 되어있기 때문에 그대로 하나씩 뺴서 넣음 while (i &lt; arr1.length) { results.push(arr1[i]); i++; } while (j &lt; arr2.length) { results.push(arr2[j]); j++; } return results;\n}\n//[1, 2, 10, 14, 50, 99, 100]\nmergeSort([1, 10, 50, 2, 14, 99, 100]);\nAverage: Best Case: Worst Case: Space Complexity: 배열이 클 수록 합병 정렬에서는 메모리에 더 많은 배열을 저장해야 할 수박에 없다. 버블 정렬 등 보다는 많은 공간을 사용한다모든 케이스가 으로 같다. 보다 빠르지만 선형()보다는 살짝 오래 걸린다.이 걸린 이유는 재귀를 통해 한 가지 이하의 요소가 남는 배열이 될 때까지 계속해서 두 배열로 분할하기 때문에 분할하는 과정에서 의 시간이 걸린다. 여기에 합병할 때는 하나씩 배열의 요소를 보면서 순서대로 새로운 배열에 넣어야 하기 때문에 의 시간이 걸린다.따라서 이 된다.선형시간 O(n)만큼 좋지는 않지만 데이터에 구애받지 않는 정렬 알고리즘 중에서는 최선이라고 할 수 있다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"버블, 선택, 삽입 정렬의 한계","level":1,"id":"버블,_선택,_삽입_정렬의_한계_0"},{"heading":"합병 정렬(Merge Sort)","level":1,"id":"합병_정렬(Merge_Sort)_0"},{"heading":"합병정렬이란?","level":2,"id":"합병정렬이란?_0"},{"heading":"구현","level":2,"id":"구현_0"},{"heading":"합병(Merge)","level":3,"id":"합병(Merge)_0"},{"heading":"합병 정렬","level":3,"id":"합병_정렬_0"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/자바스크립트-알고리즘-강의/정렬-합병정렬(merge-sort).html","pathToRoot":"../..","attachments":[],"createdTime":1725254058384,"modifiedTime":1725254058384,"sourceSize":5217,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/정렬 - 합병정렬(Merge Sort).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/정렬-합병정렬(merge-sort).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/자바스크립트-알고리즘-강의/트리-순회(tree-traversal).html":{"title":"트리 순회(Tree Traversal)","icon":"","description":"트리 순회는 어떤 트리에서든 사용 가능한 개념이다. 트리 내의 모든 노드를 한 번씩 방문할 수 있도록 하는 알고리즘이다. 이러한 트리를 한 번씩 돌 수 있는 방법에는 네 가지 방법이 있다. <img src=\"https://i.imgur.com/lWbri1U.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 루트 노드부터 시작해서 아래로 내려가면서 같은 레벨에 있는 모든 노드들을 가로질러서 거쳐가는 방식이다. // 기존 BST에서 탐색하는 BFS이므로 BST 클래스의 메서드로 추가 BFS() { // 탐색하면서 움직이는 점 node var node = this.root, // 탐색 경로를 저장하는 data 배열 data = [], // 앞으로 탐색할 곳을 담아놓는 queue 배열 queue = []; queue.push(this.root); // queue 배열이 빌 때까지 계속 반복해서 탐색 // 빈 배열은 참의 값을 가지므로 length가 0일 때 falthy값을 가지는 것을 이용 while (queue.length) { node = queue.shift(); data.push(node.val); // 왼쪽과 오른쪽에 탐색할 수 있는 노드가 있으면 모두 queue에 넣음 if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } return data; }\n깊이우선 탐색은 내가 처음 탐색하는 노드에서부터 계속 끝까지, 즉 수직으로 트리의 끝까지 들어갔다가 더 이상 탐색할 노드가 없다면 나오고, 탐색할 노드가 있다면 다시 돌아가 똑같이 탐색을 계속 안으로 파고들며 재귀적으로 탐색하는 알고리즘이다. 수평으로 탐색을 하는 너비 우선 탐색(BFS)와는 탐색 방식 자체가 다르다.깊이우선 탐색에는 탐색 순서에 따라 세 가지로 나뉠 수 있다. 탐색 순서의 이름은 가운데, 즉 루트 노드의 위치가 어떤 순서에 오는지에 따라 전위순회, 후위순회, 중위순회로 나뉘어진다.전위 탐색은 가장 처음 노드에 접근한 이후에 왼쪽 서브트리를 재귀적으로 전위순회하고 오른쪽 서브트리를 재귀적으로 전위순회하는 식으로 탐색한다. DFSPreOrder() { // 방문한 노드를 저장하는 배열인 visited var visited = []; function traverse(node) { //방문한 노드에 해당 노드의 값을 추가 visited.push(node.val); // 왼쪽 -&gt; 오른쪽 순서대로 탐색이므로 왼쪽부터 재귀적으로 호출 if (node.left) traverse(node.left); if (node.right) traverse(right); } // 루트노드부터 탐색을 시작하여 재귀적으로 파고들며 탐색 traverse(this.root); return visited; }\n후위 탐색은 가장 왼쪽 서브트리를 재귀적으로 후위순회하고 오른쪽 서브트리를 재귀적으로 후위순회한 뒤 마지막으로 루트 노드를 후위탐색하는 순으로 탐색한다. DFSPostOrder() { // 방문한 노드를 저장하는 배열인 visited var visited = []; function traverse(node) { // 왼쪽 -&gt; 오른쪽 순서대로 탐색이므로 왼쪽부터 재귀적으로 호출 if (node.left) traverse(node.left); if (node.right) traverse(right); //후위순위는 마지막에 루트 노드를 추가 visited.push(node.val); } // 루트노드부터 탐색을 시작하여 재귀적으로 파고들며 탐색 traverse(this.root); return visited; }\n중위 탐색은 왼쪽 서브트리를 재귀적으로 중위순회한 뒤에 루트 노드를 거쳐 오른쪽 서브트리로 간 뒤 오른쪽 서브트리를 재귀적으로 중위순회하는 식으로 탐색한다. DFSInOrder() { // 방문한 노드를 저장하는 배열인 visited var visited = []; function traverse(node) { // 왼쪽 -&gt; 오른쪽 순서대로 탐색이므로 왼쪽부터 재귀적으로 호출 // 다른 문법을 사용했을 뿐 if문과 작동 방식은 같음 node.left &amp;&amp; traverse(node.left); // 중위순위는 중간에 루트 노드의 값을 추가한 뒤에 오른쪽 서브트리로 이동하여 재귀적으로 탐색 visited.push(node.val); node.right &amp;&amp; traverse(right); } // 루트노드부터 탐색을 시작하여 재귀적으로 파고들며 탐색 traverse(this.root); return visited; }\n결론부터 말하자면 상황에 따라 다르다. 즉, 트리의 형태에 따라 사용하는 알고리즘의 효율적인 면에서 차이가 발생하게 되는 것이다.사실 시간복잡도적인 측면에서는 같을 수밖에 없다. 트리 순회라는게 어찌 됐든간에 모든 노드를 방문해야 순회이기 때문에 결국 방문하는데 드는 시간 복잡도는 같지만 공간복잡도적인 측면에서 효율성이 갈릴 수 있다.<br><img src=\"https://i.imgur.com/KhcNeP1.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n위와 같은 그림을 보면 노드의 수는 2배만큼 계속 증가한다. 지금은 얼마 없지만 2의 거듭제곱은 기하급수적으로 증가하기 때문에 레벨이 깊어질수록 노드의 수는 매우 많아진다.만약 이런 트리 구조에 모든 노드가 꽉 차있는 형태가 된다면 BFS로 탐색을 할 때 모든 바로 아래 모든 노드를 배열에 저장한 뒤 하나씩 빼가면서 찾게 되는데, 여기서 쓰이는 공간복잡도 또한 기하급수적으로 늘어나게 된다. 따라서 공간복잡도적인 측면에서 이러한 형태의 트리는 BFS가 효율적이지 못하다.<br><img src=\"https://i.imgur.com/BI6TOmc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">DFS의 경우에는 전에 말했던 노답 이진트리처럼 한 줄로 이어져있는 이진트리가 효율적이지 못하다. 여기서는 깊이 우선 탐색을 하게 될 경우 무조건 계속 끝 레벨까지 재귀적으로 호출하면서 그 전 레벨까지는 모두 메모리에 저장되어 있어야 하기 때문에 공간복잡도적인 측면에서 효율성이 떨어진다. 이러한 트리에 BFS 탐색을 할 경우엔 계속해서 하나의 노드만 배열에 들어가고 탐색을 진행하기 때문에 메모리에서 사용되는 공간이 거의 없어 공간복잡도적인 측면에서 효율적이다. 사실 여기에도 명확한 답은 없다. 상황에 따라 다를 뿐이다중위순회의 경우 트리의 값들을 오름차순으로 정렬할 때 유용하게 쓰인다.\nDFS는 이진탐색트리, 즉 BST 트리에 쓰이는 탐색 방법이므로 탐색을 할 때 왼쪽-중앙-오른쪽 순이 곧 오름차순이기 때문이다. 전위순회의 경우 트리를 복사하거나 평탄화해서 파일이나 데이터베이스 등에 저장하는 경우에 유용하게 사용될 수 있다. 순서대로 자식을 똑같은 전위순회 식으로 넣어주면 다시금 트리를 구성하기 용이해진다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"트리 순회란?","level":1,"id":"트리_순회란?_0"},{"heading":"1. 너비우선탐색 BFS(Breadth First Search)","level":2,"id":"1._너비우선탐색_BFS(Breadth_First_Search)_0"},{"heading":"구현","level":3,"id":"구현_0"},{"heading":"2. 깊이우선탐색 DFS(Depth First Search)","level":2,"id":"2._깊이우선탐색_DFS(Depth_First_Search)_0"},{"heading":"2-1. 전위 탐색(PreOrder)","level":3,"id":"2-1._전위_탐색(PreOrder)_0"},{"heading":"구현","level":4,"id":"구현_1"},{"heading":"2-2. 후위 탐색(PostOrder)","level":3,"id":"2-2._후위_탐색(PostOrder)_0"},{"heading":"구현","level":4,"id":"구현_2"},{"heading":"2-3. 중위 탐색(InOrder)","level":3,"id":"2-3._중위_탐색(InOrder)_0"},{"heading":"구현","level":4,"id":"구현_3"},{"heading":"BFS와 DFS중 무엇이 더 나은 알고리즘인가?","level":2,"id":"BFS와_DFS중_무엇이_더_나은_알고리즘인가?_0"},{"heading":"BFS의 경우","level":3,"id":"BFS의_경우_0"},{"heading":"DFS의 경우","level":3,"id":"DFS의_경우_0"},{"heading":"DFS에서 서로 다른 종류의 탐색을 언제 시행해야 하는가?","level":2,"id":"DFS에서_서로_다른_종류의_탐색을_언제_시행해야_하는가?_0"},{"heading":"중위순회(Inorder)의 경우","level":3,"id":"중위순회(Inorder)의_경우_0"},{"heading":"전위순회(Preorder)의 경우","level":3,"id":"전위순회(Preorder)의_경우_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/자바스크립트-알고리즘-강의/트리-순회(tree-traversal).html","pathToRoot":"../..","attachments":[],"createdTime":1725254058384,"modifiedTime":1725254058384,"sourceSize":7387,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/트리 순회(Tree Traversal).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/트리-순회(tree-traversal).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/자바스크립트-알고리즘-강의/udemy_자바스크립트-알고리즘.html":{"title":"udemy_자바스크립트 알고리즘","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<a data-href=\"정렬 - 버블, 삽입, 선택정렬\" href=\"정렬 - 버블, 삽입, 선택정렬\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">정렬 - 버블, 삽입, 선택정렬</a>","level":4,"id":"[[정렬_-_버블,_삽입,_선택정렬]]_0"},{"heading":"<a data-href=\"정렬 - 합병정렬(Merge Sort)\" href=\"정렬 - 합병정렬(Merge Sort)\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">정렬 - 합병정렬(Merge Sort)</a>","level":4,"id":"[[정렬_-_합병정렬(Merge_Sort)]]_0"},{"heading":"<a data-href=\"정렬 - 퀵정렬(Quick Sort)\" href=\"정렬 - 퀵정렬(Quick Sort)\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">정렬 - 퀵정렬(Quick Sort)</a>","level":4,"id":"[[정렬_-_퀵정렬(Quick_Sort)]]_0"},{"heading":"<a data-href=\"정렬 - 기수정렬(Radix Sort)\" href=\"정렬 - 기수정렬(Radix Sort)\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">정렬 - 기수정렬(Radix Sort)</a>","level":4,"id":"[[정렬_-_기수정렬(Radix_Sort)]]_0"},{"heading":"<a data-href=\"연결 리스트- 단일 연결 리스트(Singly Linked Lists)\" href=\"연결 리스트- 단일 연결 리스트(Singly Linked Lists)\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">연결 리스트- 단일 연결 리스트(Singly Linked Lists)</a>","level":4,"id":"[[연결_리스트-_단일_연결_리스트(Singly_Linked_Lists)]]_0"},{"heading":"<a data-href=\"연결 리스트 - 이중 연결 리스트(Doubly Linked List)\" href=\"연결 리스트 - 이중 연결 리스트(Doubly Linked List)\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">연결 리스트 - 이중 연결 리스트(Doubly Linked List)</a>","level":4,"id":"[[연결_리스트_-_이중_연결_리스트(Doubly_Linked_List)]]_0"},{"heading":"<a data-href=\"스택(Stack)과 큐(Queue)\" href=\"스택(Stack)과 큐(Queue)\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">스택(Stack)과 큐(Queue)</a>","level":4,"id":"[[스택(Stack)과_큐(Queue)]]_0"},{"heading":"<a data-href=\"이진 탐색 트리(Binary Search Tree)\" href=\"이진 탐색 트리(Binary Search Tree)\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">이진 탐색 트리(Binary Search Tree)</a>","level":4,"id":"[[이진_탐색_트리(Binary_Search_Tree)]]_0"},{"heading":"<a data-href=\"트리 순회(Tree Traversal)\" href=\"트리 순회(Tree Traversal)\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">트리 순회(Tree Traversal)</a>","level":4,"id":"[[트리_순회(Tree_Traversal)]]_0"}],"links":["알고리즘/자바스크립트-알고리즘-강의/정렬-버블,-삽입,-선택정렬.html#_0","알고리즘/자바스크립트-알고리즘-강의/정렬-합병정렬(merge-sort).html#_0","알고리즘/자바스크립트-알고리즘-강의/정렬-퀵정렬(quick-sort).html#_0","알고리즘/자바스크립트-알고리즘-강의/정렬-기수정렬(radix-sort).html#_0","학습-정리/computer-science/운영체제/연결-리스트-단일-연결-리스트(singly-linked-lists).html#_0","학습-정리/computer-science/운영체제/연결-리스트-이중-연결-리스트(doubly-linked-list).html#_0","알고리즘/자바스크립트-알고리즘-강의/스택(stack)과-큐(queue).html#_0","알고리즘/자바스크립트-알고리즘-강의/이진-탐색-트리(binary-search-tree).html#_0","알고리즘/자바스크립트-알고리즘-강의/트리-순회(tree-traversal).html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/자바스크립트-알고리즘-강의/udemy_자바스크립트-알고리즘.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":444,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/udemy_자바스크립트 알고리즘.md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/udemy_자바스크립트-알고리즘.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/boomap/boomap.html":{"title":"Boomap","icon":"","description":"<a data-href=\"react-konva를 이용하여 원 사이 라인 그리기\" href=\"https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">react-konva를 이용하여 원 사이 라인 그리기</a><br>\n<a data-href=\"react-konva를 이용하여 노드 추가기능 구현하기\" href=\"https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">react-konva를 이용하여 노드 추가기능 구현하기</a><br>\n<a data-href=\"react-konva를 이용하여 원 사이 충돌 방지 시키기\" href=\"https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">react-konva를 이용하여 원 사이 충돌 방지 시키기</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제 해결 과정","level":3,"id":"문제_해결_과정_0"}],"links":["프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html#_0","프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html#_0","프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/boomap/boomap.html","pathToRoot":"../..","attachments":[],"createdTime":1738514304296,"modifiedTime":1738514343654,"sourceSize":217,"sourcePath":"프로젝트/Boomap/Boomap.md","exportPath":"프로젝트/boomap/boomap.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html":{"title":"react-konva를 이용하여 노드 추가기능 구현하기","icon":"","description":"\nfunction averageLocation(children: number[], data: NodeData, parentNode?: Node) { if (!children.length) { return parentNode ? { x: parentNode.location.x + 30, y: parentNode.location.y + 30 } : { x: 0, y: 0 }; } const x = children.reduce((acc, curr) =&gt; data[curr.toString()].location.x + acc, 0) / children.length; const y = children.reduce((acc, curr) =&gt; data[curr.toString()].location.y + acc, 0) / children.length; return { x, y };\n}\n만약 x,y값을 기준으로 좌표를 평균내어 추가하게 된다면, 처음엔 문제 없이 children들의 평균값을 내거나, 만약 children이 없을 경우에는 자식이 생길 예정인 부모 노드의 x,y좌표에서 30씩 떨어져서 생성될 수 있도록 했다.하지만 해당 코드의 문제점은 만약 2개의 노드 사이에서 평균 x,y좌표를 구한 노드 1개가 생성된다고 할 때, 위치를 하나도 변경하지 않고 그대로 다시 추가를 누르면 평균값으로 나온 노드와 함께 평균을 다시 구하게 되므로 사실상 똑같은 평균 x,y좌표가 나올 수밖에 없다.더 큰 문제는 내가 데이터를 상태로 다루고 있는데, 이 상태가 업데이트 될 때마다 데이터를 dependency array에 두고 useEffect로 충돌 방지를 실행시키고 있다는 사실이었다.useEffect(() =&gt; { checkCollision(layer, updateNode); }, [data]);\n내 충돌 방지의 로직의 허점은 두 노드가 완벽하게 포개질 때, 서로 무한대로 x +축을 향해 움직인다는 점이었다.//vector.ts\nexport function verticalVector(a: Location, b: Location) { return { x: a.y - b.y, y: b.x - a.x };\n} export function unitVector(a: Location, b: Location) { const v = verticalVector(a, b); const vectorLength = Math.sqrt(v.x ** 2 + v.y ** 2); return { x: v.x / vectorLength, y: v.y / vectorLength };\n} //addNode.ts\nfunction getNewNodePosition(children: number[], data: NodeData, parentNode: Node) { if (!children.length) { return parentNode ? { x: parentNode.location.x + 30, y: parentNode.location.y + 30 } : { x: 0, y: 0 }; } const lastChildren = data[children[children.length - 1]]; const uv = unitVector(parentNode.location, lastChildren.location); return { x: lastChildren.location.x + uv.x * 50, y: lastChildren.location.y + uv.y * 50, };\n}\n요소에서 수직벡터를 구하는 공식은 기존 벡터를 구하는 공식에서 반대로 해서 x,y좌표를두 점 와 가 있을 때, 벡터 는 의 공식으로 구할 수 있다.하지만 우리가 구하는 것은 벡터에 대해 수작으로 그어지는 수직벡터를 구해 수직벡터 방향에서 내가 원하는 정도만큼 떨어진 거리를 만들어내는 것이므로, 수직벡터의 공식을 활용하여 구해야 한다.벡터 의 수직 벡터는 두 가지 방향으로 구할 수 있는데, 시계방향으로의 수직벡터와 반시계방향으로의 수직벡터이다. 시계 방향의 경우 로 계산할 수 있으며, 반시계방향의 경우는 의 공식으로 계산이 가능하다.\n하지만 우리 프로젝트의 경우 처음 초기 데이터 생성 과정에서 만약에 ai를 통해 회의록을 업로드하고 여기서 키워드를 뽑아내어 마인드맵을 만든다고 할 때, 생성되는 키워드 노드들은 각각 시계방향으로 돌아가면서 생성되는 규칙을 가지고 있기 때문에 새롭게 만드는 하위 생성 노드의 경우도 시계방향으로 구하기로 했다.\n// 두 점 사이의 벡터 구하기\nexport function vector(a: Location, b: Location) { return { x: b.x - a.x, y: b.y - a.y };\n} // 벡터의 수직 벡터 구하기\nexport function perpendicularVector(v: { x: number; y: number }, clockwise: boolean = true) { return clockwise ? { x: -v.y, y: v.x } : { x: v.y, y: -v.x };\n} vector 함수는 두 점 a와 b 사이의 벡터를 반환합니다.\nperpendicularVector 함수는 주어진 벡터 v에 대해 clockwise 파라미터에 따라 시계 방향 또는 반시계 방향으로 회전된 수직 벡터를 반환합니다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"생성위치 알고리즘 정하기","level":3,"id":"생성위치_알고리즘_정하기_0"},{"heading":"노드들의 평균 x,y값을 기준으로 계산하여 추가하기","level":4,"id":"노드들의_평균_x,y값을_기준으로_계산하여_추가하기_0"},{"heading":"마지막 요소에서 수직벡터 구하기","level":4,"id":"마지막_요소에서_수직벡터_구하기_0"},{"heading":"JavaScript/TypeScript 코드 예시","level":3,"id":"JavaScript/TypeScript_코드_예시_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html","pathToRoot":"../..","attachments":[],"createdTime":1731426244112,"modifiedTime":1731460224141,"sourceSize":4523,"sourcePath":"프로젝트/Boomap/react-konva를 이용하여 노드 추가기능 구현하기.md","exportPath":"프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html":{"title":"react-konva를 이용하여 원 사이 라인 그리기","icon":"","description":"import { Node } from \"@/types/Node\";\nimport { useEffect, useState } from \"react\";\nimport { Circle, Group, Layer, Line, Stage, Text } from \"react-konva\"; type NodeProps = { x: number; y: number; depth: number; text: string; setNodeLocation?: any;\n}; function NodeComponent({ x, y, depth, text, setNodeLocation }: NodeProps) { return ( &lt;Group&gt; &lt;Circle draggable x={x} y={y} fill={\"white\"} radius={50 - depth * 5} stroke=\"black\" strokeWidth={3} onDragMove={(e) =&gt; { setNodeLocation({ x: e.target.x(), y: e.target.y(), }); }} onDragEnd={(e) =&gt; setNodeLocation({ x: e.target.x(), y: e.target.y(), }) } /&gt; &lt;Text text={text} x={x - 20} y={y - 10} /&gt; &lt;/Group&gt; );\n} type DrawNodeProps = { root: Node; x: number; y: number; depth?: number; parentPosition?: any; update?: () =&gt; void;\n}; export function DrawNodefromData({ root, x, y, depth = 0, parentPosition, update }: DrawNodeProps) { const [nodeLocation, setNodeLocation] = useState(root.location); const nodeSpacing = 150; useEffect(() =&gt; { console.log(nodeLocation); }, [nodeLocation]); return ( &lt;&gt; {parentPosition &amp;&amp; ( &lt;Line points={[parentPosition.x, parentPosition.y, nodeLocation.x, nodeLocation.y]} stroke=\"gray\" strokeWidth={2} /&gt; )} &lt;NodeComponent x={nodeLocation.x} y={nodeLocation.y} text={root.content} depth={depth} setNodeLocation={setNodeLocation} /&gt; {root.children?.map((childNode, index) =&gt; ( &lt;DrawNodefromData key={childNode.id} root={childNode} x={nodeLocation.x + (index - root.children!.length / 2) * nodeSpacing} y={nodeLocation.y + nodeSpacing} depth={depth + 1} parentPosition={nodeLocation} update={update} /&gt; ))} &lt;/&gt; );\n} Line 함수형 컴포넌트는 points에 배열을 인자로 받음인자에는 [시작점x,시작점y, 끝점x, 끝점y] 가 들어감. 그럼 그대로 그 두 요소의 x,y 좌표 사이에 선을 그어줌state로 관리하고 있는 노드를 해당 인자의 값에 넣어주어 상태가 변할 때, 즉 x,y 좌표가 움직일 때 setter함수가 실행되는데 그 때마다 렌더링이 이루어지기 때문에 선은 이 x,y좌표에 따라 움직이게 됨<img src=\"https://i.imgur.com/c5Bekmc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">하지만 끝점, 만약 대분류-중분류-소분류로 이루어져 있는 마인드 맵에서 선을 이을 때, 끝점이 가르키는 x,y 좌표의 경우에는 원이 위로 가서 선이 보이지 않는 형태가 되지만 시작하는 점의 x,y좌표에서는 앞으로 와서 원의 중심저메에서 뻗어나가는 형태가 되어버림z-index를 주고 노드가 위로 올라가게 할 수도 있지만, 이는 정상적인 해결 방식이 아닌 임시 방편에 불과하다고 생각한다.따라서 다른 방식으로 노드를 이어보려고 하는데, 문제는 원 안에 있는 노드를 어떻게 잘라내느냐였다.현재 내가 알고 있는 정보는 시작점으로 되어 있는 점과 끝점이다. 이 점 사이의 거리를 이용하여 시작점에서 끝점으로 이어지는 선이 그어졌다고 가정했을 때, 이어져 있는 두 노드 간의 선에서 시작점의 선이 노드를 빠져나올 때의 가장자리가 가지는 x,y 값을 알 수 있을 것 같았다. 벡터 구하기:\n시작 점의 좌표가 xc, yc이고, 이를 이어주려는 끝점의 좌표가 xp,yp라고 하자. 먼저, 원의 중심으로 향하는 방향을 나타내는 벡터를 구할 수 있다. 이 벡터는 임의의 점과 원의 중심 사이의 차이로 계산할 수 있다 벡터의 길이 구하기: 이제 이 벡터의 길이를 구해 방향을 정규화한다. 여기까지는 피타고라스의 정리를 통해 쉽게 구할 수 있다. 단위 벡터 구하기\n벡터를 단위 벡터로 정규화하여 방향만 남기고 크기를 1로 만듭니다. 단위 벡터를 구하려면 원래 벡터의 각 성분을 벡터의 길이로 나눈다 가장자리 좌표 구하기\n단위 벡터 방향으로 반지름만큼 이동하면, 원의 가장자리 좌표를 구할 수 있습니다. 원의 중심점에 단위 벡터의 성분을 각각 반지름 r만큼 곱해서 더하면 된다. // from 원의 중점에서 to 원의 중점으로 이어지는 선에서 from 선의 위치를 원의 중점이 아닌 가장자리의 위치 구하는 함수\nfunction getCircleEdgePoint(from: Location, to: Location, r: number) { const dx = to.x - from.x; const dy = to.y - from.y; const vector = Math.sqrt(dx * dx + dy * dy); const xEdgePoint = Math.ceil(from.x + (r * dx) / vector); const yEdgePoint = Math.ceil(from.y + (r * dy) / vector); return { xEdgePoint, yEdgePoint, };\n}\n해당 함수를 통해 벡터 길이를 구하고, 반지름에 단위 벡터를 곱하여 가장자리가 어떤 좌표인지 x,y 각각의 좌표에 더해주어 곱했다.// Point의 인자로 만들어주는 함수\n// 각각의 원에 대해서 가장자리 쪽으로 갈 수 있게끔 해줌\nfunction getLinePoints(from: Location, to: Location, r: number) { const fromCircleEdgePoint = getCircleEdgePoint(from, to, r); const toCircleEdgePoint = getCircleEdgePoint(to, from, r); return [ fromCircleEdgePoint.xEdgePoint, fromCircleEdgePoint.yEdgePoint, toCircleEdgePoint.xEdgePoint, toCircleEdgePoint.yEdgePoint, ];\n} type ConnectedLineProps = { from: Location; to: Location; radius: number;\n}; export function ConnectedLine({ from, to, radius }: ConnectedLineProps) { return &lt;Line points={getLinePoints(from, to, radius)} stroke=\"gray\" strokeWidth={2} /&gt;;\n}\n기존의 Line을 계속 활용하면서도 여기서 이어지는 선에 대해 원의 중점이 아닌, 각 원에서 뻗어나온 가장자리의 좌표로 선을 잇는 것이 이상적이기 때문에 이를 함수화했다.points 인자에 들어갈 값은 from과 to의 원 가장자리 좌표를 구해야 하는데, getCircleEdgePoint는 단일책임원칙을 지키기 위해 함수를 분리하여 한 원의 가장자리 좌표를 구하는 함수로 만들었다. 따라서 getLinePoints라는 함수를 따로 만들어 인자로 그대로 넣을 수 있는 함수로 활용할 수 있도록 하였다.<br><img src=\"https://i.imgur.com/Ymf6Gep.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n어딘가 미묘하게 두 선이 어느정도 띄워져있는지가 다른 것 같다..// from 원의 중점에서 to 원의 중점으로 이어지는 선에서 from 선의 위치를 원의 중점이 아닌 가장자리의 위치 구하는 함수\nfunction getCircleEdgePoint(from: Location, to: Location, r: number) { const dx = to.x - from.x; const dy = to.y - from.y; const vector = Math.sqrt(dx * dx + dy * dy); const xEdgePoint = Math.ceil(from.x + (r * dx) / vector); const yEdgePoint = Math.ceil(from.y + (r * dy) / vector); return { xEdgePoint, yEdgePoint, };\n}\n코드를 살펴보며 생각해보니 나는 현재 분류에 따라서 하위 요소의 경우 depth를 조금씩 줄이고 있었는데, 더 작아지거나 커지는 선의 경우에는 사실상 from의 반지름을 가지고 계산했기 때문에 더 커졌던 문제를 가져온 것으로 보인다.// Point의 인자로 만들어주는 함수\n// 각각의 원에 대해서 가장자리 쪽으로 갈 수 있게끔 해줌\nexport function getLinePoints(from: Location, to: Location, r: number) { const fromCircleEdgePoint = getCircleEdgePoint(from, to, r); const toCircleEdgePoint = getCircleEdgePoint(to, from, r); return [ fromCircleEdgePoint.xEdgePoint, fromCircleEdgePoint.yEdgePoint, toCircleEdgePoint.xEdgePoint, toCircleEdgePoint.yEdgePoint, ];\n}\n그러므로 고쳐야 할 것은 여기였던 것이다. from의 원이 가지는 원의 반지름과 to 원이 가지는 원의 반지름을 모두 받아야 했다.//depth가 70 - depth * 10 이라고 할 때\n&lt;ConnectedLine from={parentPosition} to={nodeLocation} fromRadius={70 - (depth - 1) * 10 + 10} toRadius={70 - depth * 10 + 10} /&gt;\n그렇게 되면 이런 식으로 두 원의 반지름을 모두 받고export function getLinePoints(from: Location, to: Location, fromRadius: number, toRadius: number) { const fromCircleEdgePoint = getCircleEdgePoint(from, to, fromRadius); const toCircleEdgePoint = getCircleEdgePoint(to, from, toRadius); return [ fromCircleEdgePoint.xEdgePoint, fromCircleEdgePoint.yEdgePoint, toCircleEdgePoint.xEdgePoint, toCircleEdgePoint.yEdgePoint, ];\n}\n계산 과정에서 각각의 반지름을 넣어주어 각각의 원에서 가장자리 좌표를 구할 수 있도록 해 주었다.<br><img src=\"https://i.imgur.com/aYk7867.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n어어... 그만..<br><img src=\"https://i.imgur.com/Y2MWzT2.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">넘어가버리기~내가 기대한 것은 선이 서로에게 어느정도 가까이 닿거나 교집합이 생기기 시작하면 둘을 잇는 선이 생기지 않는 것이었다.하지만 이를 고려하지 않고 둘의 좌표를 무조건 계산하여 선을 그리다 보니 원이 근접했을 대에 원이 안쪽으로 파고드는 문제를 가지게 되었다.\n나중에 충돌 방지를 넣는다면 이러한 문제는 어느정도 해소될 수 있지만, 나중에 예상치 못한 오류를 낳을 수도 있기 때문에 이러한 점도 고려하여 선을 그려야겠다 싶었다.// from 원의 중점에서 to 원의 중점으로 이어지는 선에서 from 선의 위치를 원의 중점이 아닌 가장자리의 위치 구하는 함수\nexport function getCircleEdgePoint(from: Location, to: Location, fromRadius: number, toRadius: number) { const dx = to.x - from.x; const dy = to.y - from.y; const vector = Math.sqrt(dx * dx + dy * dy); if (fromRadius + toRadius - vector &gt; 0) { return { xEdgePoint: 0, yEdgePoint: 0, }; } const xEdgePoint = Math.ceil(from.x + (fromRadius * dx) / vector); const yEdgePoint = Math.ceil(from.y + (fromRadius * dy) / vector); return { xEdgePoint, yEdgePoint, };\n}\n기존에 가장자리 구하는 함수에서도 그냥 fromRadius와 toRadius 를 둘 다 받은 다음에, 만약 두 원의 반지름을 더한 것이 벡터보다 커지게 된다면 이는 최대한 근접해있다는 사실을 알 수 있기 때문에 이런 경우 x좌표와 y좌표를 모두 0으로 줌으로써 라인이 생성되지 않도록 했다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제1 : 원 안의 선","level":3,"id":"문제1_원_안의_선_0"},{"heading":"함수화 하기","level":3,"id":"함수화_하기_0"},{"heading":"문제2: 선 사이 띄워진 거리가 다르다","level":3,"id":"문제2_선_사이_띄워진_거리가_다르다_0"},{"heading":"문제3: 사회적 거리두기","level":3,"id":"문제3_사회적_거리두기_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html","pathToRoot":"../..","attachments":[],"createdTime":1731133332983,"modifiedTime":1731137120877,"sourceSize":11518,"sourcePath":"프로젝트/Boomap/react-konva를 이용하여 원 사이 라인 그리기.md","exportPath":"프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html":{"title":"react-konva를 이용하여 원 사이 충돌 방지 시키기","icon":"","description":"이번에 마인드맵을 react-konva로 구현하는 과정을 거치면서 마인드맵의 각 노드 간에 충돌을 방지시키지 않으면 여러 요소들이 겹쳐져 있는 상태가 나올 것이기 때문에, 이러한 충돌을 방지하고자 이에 관련되어 로직을 보강하기로 했다.type NodeProps = { parentNode?: Node; node: Node; depth: number; text: string; updateNode: (id: number, updatedNode: Node) =&gt; void;\n}; function NodeComponent({ parentNode, node, depth, text, updateNode }: NodeProps) { return ( &lt;&gt; &lt;Circle id={node.id.toString()} onDragMove={(e) =&gt; { updateNode(node.id, { ...node, location: { x: e.target.x(), y: e.target.y(), }, }); }} onDragEnd={(e) =&gt; updateNode(node.id, { ...node, location: { x: e.target.x(), y: e.target.y(), }, }) } draggable x={node.location.x} y={node.location.y} fill={\"white\"} width={100} height={100} radius={70 - depth * 10} stroke=\"black\" strokeWidth={3} /&gt; &lt;Text name=\"text\" text={text} x={node.location.x - 20} y={node.location.y - 10} /&gt; {parentNode &amp;&amp; ( &lt;ConnectedLine from={parentNode.location} to={node.location} fromRadius={70 - (depth - 1) * 10 + 10} toRadius={70 - depth * 10 + 10} /&gt; )} &lt;/&gt; );\n}\n기본적인 노드의 정보는 이러하다. 만약 노드 간에 부모-자식 관계가 있다면 이런 식으로 react-konva의 Line을 커스텀한 ConnectedLine이라는 컴포넌트를 추가적으로 렌더링 하도록 했다.추가적으로 각 노드에는 dragmove와 dragend 이벤트를 달아서 해당 요소를 드래그 앤 드롭 시에 계속해서 상태를 바꾸면서 노드의 위치를 갱신할 수 있도록 했다.export type Node = { id: number; keyword: string; depth: number; location: Location; children: number[] | [];\n}; type DrawNodeProps = { data: Node[]; root: Node; depth?: number; parentNode?: any; update?: (id: number, node: Node) =&gt; void;\n}; export function DrawNodefromData({ data, root, depth = 0, parentNode, update }: DrawNodeProps) { return ( &lt;&gt; {/* from */} &lt;NodeComponent text={root.keyword} depth={depth} parentNode={parentNode} node={root} updateNode={update} /&gt; {/* to */} {root.children?.map((childNode, index) =&gt; ( &lt;DrawNodefromData data={data} key={index} root={data[childNode - 1]} depth={depth + 1} parentNode={root} update={update} /&gt; ))} &lt;/&gt; );\n}\n노드의 부모-자식을 렌더링하는 방식은 위와 같다. 모든 노드는 직렬화 되어있는 상태이고, children에는 노드의 id만을 가지고 있다.\n노드의 id는 index를 1부터 시작하여 만들었기 때문에 계속해서 서브트리의 루트로 가게 될 때에는 root를 id값에서 1을 빼어 인덱스로 접근할 수 있도록 하였다.그렇다면 이 노드 사이에서 어떻게 충돌할 때의 문제를 해결할 수 있을까?\n내가 생각했을 때 가장 기본적인 해결 방식은 '충돌이 됐을 때, 충돌당한 노드를 겹치지 않도록 밀어낸다' 였다. 그렇기 때문에, 나는 충돌한 각도를 어느정도 알고 있고, 밀어낼 때마다 각 원이 가져야 하는 최소 사이의 길이만 정한다면 이를 통해 리렌더링 과정에서 노드들을 피하게 할 수 있을 것 같았다.//...\nconst layer = useRef(null); useEffect(() =&gt; { layer.current.on(\"dragmove\", (event) =&gt; checkCollision(layer, event, updateNodeList)); }, []);\n가장 먼저 필요한 것은 layer에 이벤트를 다는 일이다. react-konva에서는 useRef를 layer에 달게 되면 layer 안의 모든 요소들이 jsx와 같은 요소처럼 접근할 수 있기 때문에, children에도 접근할 수 있다. 가장 처음에 생각한 방식은 무조건 맨 처음에 어떤 요소를 드래그해서 옮기기 시작하면 옮기는 이벤트가 발동될 때마다 layer 안에 있는 children들에 대해 모두 collision을 확인하고, 드래그하고 있는 요소들과 충돌하는 노드가 있는지 확인을 해야 했다.export function checkCollision(layer, event, update) { const dragTarget = event.target; const dragTargetRect = event.target.getClientRect(); layer.current.children.forEach((child) =&gt; { if ( !(child.attrs.name === \"text\") &amp;&amp; !(child.attrs.name === \"line\") &amp;&amp; isCollided(child, dragTarget, dragTargetRect) ) { const newPosition = moveOnCollision(child, dragTarget); update(parseInt(child.attrs.id), { location: newPosition }); } });\n}\ndragmove 이벤트가 발동될 때마다 해당 checkCollision 함수가 실행된다. 이벤트가 발동되면서 해당 함수에 이벤트 객체를 그대로 넘겨주어 이 함수에서 확인할 수 있도록 해주었다.\ndragTarget의 경우, 현재 드래그 하고 있는 Target의 객체를 넘겨준다.\nevent 객체의 target property에서 getClientRect 메서드는 해당 요소가 가지고 있는 크기범위를 직사각형 형태로 나타내준다.<img src=\"https://i.imgur.com/6luPbOC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n요런 식으로 각도가 있는 요소들도 전부 직사각형의 범위로 측정한 값을 보내준다. 대부분 충돌 감지를 할 때는 위와 같이 충돌이라고 할 수 있는 범위를 직사각형 형태로 측정하여 감지하는 것으로 보았기 때문에 나 또한 이를 기준으로 측정했다. getClientRect()를 실행한 값을 dragTargetRect에 할당하였다.layer.current.children.forEach((child) =&gt; { if ( !(child.attrs.name === \"text\") &amp;&amp; !(child.attrs.name === \"line\") &amp;&amp; isCollided(child, dragTarget, dragTargetRect)\n다음으로는 layer의 children에 접근하여 각각의 요소에 대해서 모두 해당 요소가 현재 드래그하고 있는 요소와 충돌되는지를 검사하도록 했다.여기서 !(child.attrs.name === \"text\") &amp;&amp; !(child.attrs.name === \"line\")가 들어간 이유는 layer의 children 안에는 비단 Circle 객체만 있는 것이 아닌, 같은 depth에 text와 line을 두었기 때문이다. 그렇게 되면 text와 line에 대해서도 충돌 감지를 하기 때문에 예상치 못한 부수효과를 가져올 수 있어 원에 대해서만 충돌 감지를 할 수 있도록 했다.export function isCollided(node, target, targetRect) { if (node === target) return false; return haveIntersection(node.getClientRect(), targetRect);\n} function haveIntersection(r1, r2) { return !(r2.x &gt; r1.x + r1.width || r2.x + r2.width &lt; r1.x || r2.y &gt; r1.y + r1.height || r2.y + r2.height &lt; r1.y);\n}\n충돌을 감지하는 로직은 생각보다 어렵지 않다. 드래그 하고 있는 요소를 제외시키기만 하고, 나머지는 x,y 좌표가 서로 겹치는지만 검사하면 된다.\n두 개의 원 r1,r2가 있다고 할 때, 각각의 요소에 대해서 x,y 좌표를 모두 충돌되어 있는지 검사하는 조건문을 넣었다.만약 충돌 검사 조건문에서 충돌이 되었다고 판단이 되면, 조건문 블록으로 넘어가 노드를 이동시키는 로직을 실행한다. const newPosition = moveOnCollision(child, dragTarget); update(parseInt(child.attrs.id), { location: newPosition });\nmoveOnCollision은 충돌된 요소가 가야 할 x,y좌표를 계산하는 함수이다. 이 함수의 결과를 newPosition에 할당하고 해당 좌표를 상태 업데이트 시켜주어 리렌더링이 바로 일어나면서 위치가 업데이트된다.function moveOnCollision(targetNode, draggedNode) { const dx = targetNode.attrs.x - draggedNode.attrs.x; const dy = targetNode.attrs.y - draggedNode.attrs.y; const angle = Math.atan2(dy, dx); const minDistance = 5; const moveX = Math.cos(angle) * minDistance; const moveY = Math.sin(angle) * minDistance; return { x: targetNode.attrs.x + moveX, y: targetNode.attrs.y + moveY, };\n}\nmoveOnCollision은 충돌이 된targetNode와 충돌을 시킨draggedNode를 인자로 받는다. 각 객체에는 내가 attribute로 넘겼던 x,y,radius 등의 정보가 attrs에 담겨 있으므로 여기에 접근하여 값을 계산한다.dx,dy는 두 점 사이의 거리를 x,y좌표로 계산한 값이다. 먼저 두 점을 잇는 선을 빗변으로 직각삼각형을 그린 뒤, 역탄젠트를 통해서 각도를 구해야 하기 때문이다. Math.atan2는 아크탄젠트, 즉 역탄젠트를 구하는 Math 모듈의 함수이다.<br>\n<a data-tooltip-position=\"top\" aria-label=\"https://ko.khanacademy.org/math/geometry/hs-geo-trig/hs-geo-solve-for-an-angle/a/inverse-trig-functions-intro\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.khanacademy.org/math/geometry/hs-geo-trig/hs-geo-solve-for-an-angle/a/inverse-trig-functions-intro\" target=\"_self\">역탄젠트 알아보기</a> 아크탄젠트를 구했다면 해당 각도가 곧 충돌했을 때의 방향을 나타내는 각도이며, 라디안 값으로 나타난다.\n이 각도에 x축의 경우 Math.cos, y축의 경우 Math.sin을 이용하여 각도 값을 x,y축 성분으로 변환하여 해당 방향으로 minDistance만큼 가도록 했다. 이 부분의 계산은 sin(angle) = a/c, cos(angle) = b/c 인 것을 생각했을 때, minDistance가 c로 간다고 생각했더니 이해가 나름 편했다(사실 아직도 잘 모름) 아무튼 여기서 minDistance는 두 원 사이에 어느 정도의 거리가 있어야 하는지를 나타내는 변수이며, 이를 각 사인(아크탄젠트값), 코사인(아크탄젠트값)에 곱해주면 x,y 축을 어느정도 옮겨야 하는지 알 수 있다.\n마지막에는 기존 요소의 x,y 좌표에 이동해야 할 x,y의 값만큼을 더해주었다.그렇게 moveOnCollistion은 충돌이 일어난 요소들에 대해서 피할 수 있는 좌표 값을 주고, 이를 update(parseInt(child.attrs.id), { location: newPosition });를 통해서 업데이트 함으로서 노드의 상태를 다시금 업데이트하고 리렌더링이 일어나면서 캔버스에 반영된다.내가 생각했던 로직의 경우 이벤트가 일어난 타겟, 즉 해당 노드에서 다른 모든 노드들을 검색하고 현재 드래그 하고 있는 노드 객체와 충돌되는 다른 노드들에 대해서 충돌을 방지할 수 있도록 했다.\n하지만 그럴 경우, 해당 노드와 충돌하는 경우만을 검색하기 때문에 사실상 충돌로 인해 움직인 노드가 움직이게 된다면, 사실상 움직인 노드가 다른 요소들과 충돌할 경우에 대해서는 고려하지 않았기 때문에 이 경우 움직인 노드가 다른 노드와 충돌하는 예외가 생기게 된다. 이런 식으로 충돌된 요소들끼리의 충돌은 적용하지 않는다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"기본적인 Node의 정보","level":2,"id":"기본적인_Node의_정보_0"},{"heading":"충돌 해결하기","level":2,"id":"충돌_해결하기_0"},{"heading":"Layer에 이벤트 달기","level":3,"id":"Layer에_이벤트_달기_0"},{"heading":"충돌 검사하기","level":3,"id":"충돌_검사하기_0"},{"heading":"충돌된 노드 이동시키기","level":3,"id":"충돌된_노드_이동시키기_0"},{"heading":"문제","level":2,"id":"문제_0"},{"heading":"타겟과 충돌한 노드에만 충돌방지 적용","level":3,"id":"타겟과_충돌한_노드에만_충돌방지_적용_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html","pathToRoot":"../..","attachments":["부스트캠프/멤버십/8주차/화면-기록-2024-11-10-오후-11.20.13.mov"],"createdTime":1731238556042,"modifiedTime":1731248483936,"sourceSize":11332,"sourcePath":"프로젝트/Boomap/react-konva를 이용하여 원 사이 충돌 방지 시키기.md","exportPath":"프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/fora/fora.html":{"title":"forA","icon":"","description":"<a data-href=\"forA_트러블슈팅\" href=\"https://alsgud8311.github.io/프로젝트/fora/fora_트러블슈팅.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">forA_트러블슈팅</a><br>\n<a data-href=\"forA_리팩토링_Navigation 추상화하기\" href=\"https://alsgud8311.github.io/fora_리팩토링_navigation-추상화하기.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">forA_리팩토링_Navigation 추상화하기</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["프로젝트/fora/fora_트러블슈팅.html#_0","fora_리팩토링_navigation-추상화하기.html"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/fora/fora.html","pathToRoot":"../..","attachments":[],"createdTime":1737689866280,"modifiedTime":1738942701396,"sourceSize":247,"sourcePath":"프로젝트/forA/forA.md","exportPath":"프로젝트/fora/fora.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/fora/fora_트러블슈팅.html":{"title":"forA_트러블슈팅","icon":"","description":"<img src=\"https://i.imgur.com/DJXqyXM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n유효성 검사가 제대로 이루어지지 않아 6글자일 때 인증번호가 제대로 된 인증번호인지 띄워줘야 하는데 다짜고짜 인증번호를 다시 확인해달라고 나온다. 인증 확인 버튼을 누른 상태도 아니었다.\n```tsx\nuseEffect(() =&gt; { const intervalId = setInterval(() =&gt; { if (timer &gt; 0) { setTimer(timer - 1) } }, 1000) return () =&gt; clearInterval(intervalId)\n}, [timer])\n타이머에서 유효성 검증 상태 안바꿀거면 장식용으로 둔건가 ```tsx const gotoBeforeScreen = () =&gt; { navigation.navigate('EmailDuplicateCheck' as never) } const gotoNextScreen = () =&gt; { navigation.navigate('SetPassword' as never) }\nnavigate의 타입제네릭을 써주지 않아서 never로 타입","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 이메일 인증","level":3,"id":"1._이메일_인증_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/fora/fora_트러블슈팅.html","pathToRoot":"../..","attachments":[],"createdTime":1737689882069,"modifiedTime":1738942717136,"sourceSize":1121,"sourcePath":"프로젝트/forA/forA_트러블슈팅.md","exportPath":"프로젝트/fora/fora_트러블슈팅.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/neo/반응형을-자바스크립트로-해보기.html":{"title":"반응형을 자바스크립트로 해보기","icon":"","description":"이제는 어느 사이트를 가든 반응형 페이지가 디폴트로 되어 있다. 항상 고정적인 레이아웃을 가지게 되면 모바일 디바이스부터 데스크톱까지 다양한 환경이 있음에도 불구하고 같은 화면을 보게 되는 거니 사용자 경험상으로 좋지 않다. 그렇기에 서비스를 디자인 할 때는 반응형으로 많이 신경쓰는 편이다.웹 페이지의 디자인과 레이아웃이 모든 화면 크기에 자동으로 맞춰지는 디자인이다. 데스크탑에서 페이지를 늘렸다 줄였다 하면 이에 맞춰서 화면의 디자인이 바뀌는게 반응형 디자인이다.다른 방식의 유연한 웹 디자인 기술로는 적응형 디자인이 있다.\n적응형 디자인의 경우 웹 페이지에서 감지된 기기를 기반으로 미리 만드레어진 정적인 레이아웃을 불러오는 것으로 각 화면 크기마다 이에 맞는 레이아웃을 따로 디자인을 해야 한다. 이 방식은 각각 저마다의 장단점을 지닌다.import * as React from \"react\" const MOBILE_BREAKPOINT = 768 export function useIsMobile() { const [isMobile, setIsMobile] = React.useState&lt;boolean | undefined&gt;(undefined) React.useEffect(() =&gt; { const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`) const onChange = () =&gt; { setIsMobile(window.innerWidth &lt; MOBILE_BREAKPOINT) } mql.addEventListener(\"change\", onChange) setIsMobile(window.innerWidth &lt; MOBILE_BREAKPOINT) return () =&gt; mql.removeEventListener(\"change\", onChange) }, []) return !!isMobile\n} 나는 여기서 모바일과 데스크톱 환경 정도만 구분한 뒤에, 데스크톱의 경우에는 따로 미디어 쿼리를 추가하는 방식으로 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"반응형 디자인이란?","level":2,"id":"반응형_디자인이란?_0"},{"heading":"모바일과 데스크톱 구분하기","level":2,"id":"모바일과_데스크톱_구분하기_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/neo/반응형을-자바스크립트로-해보기.html","pathToRoot":"../..","attachments":[],"createdTime":1738321920477,"modifiedTime":1738322702790,"sourceSize":2757,"sourcePath":"프로젝트/Neo/반응형을 자바스크립트로 해보기.md","exportPath":"프로젝트/neo/반응형을-자바스크립트로-해보기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/neo/axios를-떠나보내기.html":{"title":"axios를 떠나보내기","icon":"","description":"이제까지 리액트 프로젝트를 하면서 가장 고정적으로 쓰였던 리액트 외의 라이브러리라고 한다면 단언컨데 axios일 것이다.axios는 &nbsp;XMLHttpRequest를 기반으로 만들어진 라이브러리로, 우리가 이제까지 귀찮게 http요청을 보내면서 하던 인터셉터, timeout 등의 설정을 간단하게 구현할 수 있기 때문에 확실히 개발비용을 줄여주던 라이브러리이다.하지만 이번에 Nextjs 프로젝트를 시작하면서 예상치 못하게 axios의 필요성에 대해서 다시금 생각해보았다.\nXMLHttpRequest의 경우 매우 오래된 http 요청이기 때문에 상대적으로 최근에 나온 fetch api의 성능이 좋아 굳이 XMLHttpRequest를 써야 하나?에 대한 의문을 가지는 사람이 많아졌다.\n서버 컴포넌트에서 window 객체 참조 문제\nNext.js의 자체 캐싱 시스템과의 충돌\nJavaScript가 비활성화된 환경에서 무한 로딩 이슈\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/neo/axios를-떠나보내기.html","pathToRoot":"../..","attachments":[],"createdTime":1738053627742,"modifiedTime":1738054189820,"sourceSize":2124,"sourcePath":"프로젝트/Neo/axios를 떠나보내기.md","exportPath":"프로젝트/neo/axios를-떠나보내기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/neo/neo.html":{"title":"Neo","icon":"","description":"Neo는 생성형 ai를 활용한 개인별 웹소설 창작 서비스입니다.\nNeo를 통해서는\n개인별 생성형 ai를 통한 맞춤 소설 제작\nNeo에 존재하는 웹소설을 내 마음대로 다시쓰기\n등의 서비스를 제공합니다.\n<a data-href=\"axios를 떠나보내기\" href=\"https://alsgud8311.github.io/프로젝트/neo/axios를-떠나보내기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">axios를 떠나보내기</a><br>\n<a data-href=\"반응형을 자바스크립트로 해보기\" href=\"https://alsgud8311.github.io/프로젝트/neo/반응형을-자바스크립트로-해보기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">반응형을 자바스크립트로 해보기</a><br>\n<a data-href=\"구현의 상세 추상화\" href=\"https://alsgud8311.github.io/프로젝트/neo/구현의-상세-추상화.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">구현의 상세 추상화</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Neo에서 가졌던 고민들","level":3,"id":"Neo에서_가졌던_고민들_0"}],"links":["프로젝트/neo/axios를-떠나보내기.html#_0","프로젝트/neo/반응형을-자바스크립트로-해보기.html#_0","프로젝트/neo/구현의-상세-추상화.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/neo/neo.html","pathToRoot":"../..","attachments":[],"createdTime":1738053593062,"modifiedTime":1738596273053,"sourceSize":405,"sourcePath":"프로젝트/Neo/Neo.md","exportPath":"프로젝트/neo/neo.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/backend/트랜잭션과-비즈니스-로직.html":{"title":"트랜잭션과 비즈니스 로직","icon":"","description":"컴퓨터 과학에서의 트랜잭션은 더 이상 분할이 불가능한 업무 처리의 단위를 의미하며 데이터베이스에서 트랜잭션은 데이터베이스의 상태를 바꾸는 일종의 작업 단위이다. 데이터베이스를 예로 들어보면 이해가 쉽다. 은행에서 돈을 인출/입금하는 행위의 경우\n돈을 인출 -&gt; 기존의 잔고에서 인출한 만큼의 금액 차감\n돈을 입금 -&gt; 입금 계좌의 잔고가 입금한 금액만큼 증가\n와 같은 순서로 업무 처리가 이루어지는데, 만약 이 과정중에 하나라도 결여가 생겨 입금이 되었는데 돈이 들어오지 않았다든지, 인출했지만 돈이 빠져나가지 않았다면 치명적인 결과를 초래한다.\n그렇기에 해당 인출/입금은 두 개의 작업을 따로 나누는 것이 아니라, 하나로 처리해야 할 필요성이 있다. 즉, 둘 다 실패하거나 성공하거나 둘 중 하나여야 한다는 것이다.\n이렇듯 더이상 분해할 수 없는 업무 처리의 단위를 트랜잭션이라고 한다.\n위에서 데이터베이스에서 트랜잭션은 데이터베이스의 상태를 바꾸는 일종의 작업 단위라고 했다.\n따라서 데이터베이스의 관점에서 트랜잭션이랑 모든 쿼리 명령어들이라고 생각할 수 있다.\nSQL 명령문을 실행하면 해당 명령문에 따라 데이터의 상태를 바꾸게 되는데, MySQL의 경우 데이터의 상태가 바뀔 때마다 내부적으로 자동적으로 데이터베이스에 영구적으로 반영(commit)하게 된다.<img src=\"https://i.imgur.com/PHoRCIr.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">따라서 새로운 명령문이 들어오면 명령에 대해서 실행하고 데이터베이스에 반영하는 과정 자체가 하나의 트랜잭션으로 분류되며, 이 과정 중 하나라도 문제가 생기게 되면 그대로 폐기한다위와 같은 사진은 트랜잭션 상태를 나타낸 것으로, 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 흐름이다.\n보면 부분완료(Partially Committed)가 된 상태라고 해도 여기서 트랜잭션이 비정상적으로 종료된다면 Rollback연산을 통해 기존의 작업을 철회(Abort)하는 것을 볼 수 있다. 따라서 트랜잭션은 committed될 때까지 끝이 아닌 것이다.\nRollback\n트랜잭션의 처리 과정에서 발생한 변경 사항을 취소\n트랜잭션이 시작되기 이전 상태로 돌아감\n트랜잭션의 특징은 대표적으로 4가지의 특징이 있다. START TRANSACTION; -- 트랜잭션 시작 select * from members; -- 초기 상태 보여줌\ninsert into members values(1, '쿠', '크다스', '크라운제과' '?', '대한민국'); -- 데이터 수정\nselect * from members; -- 수정 상태 보여줌 COMMIT -- 트랜잭션을 DB에 적용 select * from members; -- 적용된 결과 조회\nSTART TRANSACTION; -- 트랜잭션 시작 insert into members values(5, '쿠', '크다스 동생', '크라운제과', '?', '대한민국'); -- 데이터 수정\nselect * from members; -- 수정 상태 보여줌 ROLLBACK -- 트랜잭션을 취소하고 START TRANSACTION 실행 전 상태로 롤백함 select * from members; -- 조회\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC\" target=\"_self\">https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%9D%B4%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"트랜잭션","level":1,"id":"트랜잭션_0"},{"heading":"MySQL에서의 트랜잭션","level":3,"id":"MySQL에서의_트랜잭션_0"},{"heading":"트랜잭션의 특징","level":3,"id":"트랜잭션의_특징_0"},{"heading":"MySQL에서 트랜잭션하기","level":3,"id":"MySQL에서_트랜잭션하기_0"},{"heading":"MySQL에서 Rollback하기","level":4,"id":"MySQL에서_Rollback하기_0"},{"heading":"참조","level":2,"id":"참조_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/backend/트랜잭션과-비즈니스-로직.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058408,"modifiedTime":1725254058408,"sourceSize":4400,"sourcePath":"학습 정리/Backend/트랜잭션과 비즈니스 로직.md","exportPath":"학습-정리/backend/트랜잭션과-비즈니스-로직.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/backend/backend.html":{"title":"Backend","icon":"","description":"\n<a data-href=\"트랜잭션과 비즈니스 로직\" href=\"https://alsgud8311.github.io/학습-정리/backend/트랜잭션과-비즈니스-로직.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">트랜잭션과 비즈니스 로직</a>\n<br><a data-href=\"express+pug로 templating해서 SSR + CSR 구현하기\" href=\"https://alsgud8311.github.io/학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">express+pug로 templating해서 SSR + CSR 구현하기</a>\n<br><a data-href=\"mysql Join\" href=\"https://alsgud8311.github.io/학습-정리/backend/mysql-join.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">mysql Join</a>\n<br><a data-href=\"Node.js Libuv에 대한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/backend/node.js-libuv에-대한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Node.js Libuv에 대한 고찰</a>\n<br><a data-href=\"Passport의 로컬 인증전략\" href=\"https://alsgud8311.github.io/학습-정리/backend/passport의-로컬-인증전략.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Passport의 로컬 인증전략</a>\n<br><a data-href=\"REST API\" href=\"https://alsgud8311.github.io/학습-정리/backend/rest-api.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">REST API</a>\n<br><a data-href=\"sql 트리거\" href=\"https://alsgud8311.github.io/학습-정리/backend/sql-트리거.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">sql 트리거</a>\n<br><a data-href=\"sql 기본문법\" href=\"https://alsgud8311.github.io/학습-정리/backend/sql-기본문법.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">sql 기본문법</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["학습-정리/backend/트랜잭션과-비즈니스-로직.html#_0","학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html#_0","학습-정리/backend/mysql-join.html#_0","학습-정리/backend/node.js-libuv에-대한-고찰.html#_0","학습-정리/backend/passport의-로컬-인증전략.html#_0","학습-정리/backend/rest-api.html#_0","학습-정리/backend/sql-트리거.html#_0","학습-정리/backend/sql-기본문법.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/backend/backend.html","pathToRoot":"../..","attachments":[],"createdTime":1738514692840,"modifiedTime":1738514706253,"sourceSize":252,"sourcePath":"학습 정리/Backend/Backend.md","exportPath":"학습-정리/backend/backend.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html":{"title":"express+pug로 templating해서 SSR + CSR 구현하기","icon":"","description":"express로 처음 서버를 구동해보면서 이를 html+css+js와 섞는다면 SSR 뿐만 아니라 CSR 또한 내 마음대로 입맛따라 고를 수 있을 것 같았다. 그렇게 된다면 next.js와 비슷한 느낌이지 않을까도 싶다.아무튼 맨 처음에 express를 시작했을 때는 전체적인 html 템플릿을 그대로 출력시켜 열었던 로컬호스트 주소로 접속하면 통채로 웹사이트를 렌더링하여 보내주는 SSR 방식으로 시작했지만, pug라는 템플릿 엔진이 생각보다 여러가지 쓸만한 구석이 많아 이를 좀 더 활용해서 CSR을 만들기 보다 쉽지 않을까 생각해서 시도해보았다.pug를 처음 맛보기로 써봤는데, 생각보다 장점이 많았다.\n그 중에서도 이번 templating에 사용하려는 pug의 api는 클라이언트 사이드 렌더링을 하기에 최적화된 api라고 생각했다.const pug = require('pug'); // Compile the source code\nconst compiledFunction = pug.compileFile('template.pug'); // Render a set of data\nconsole.log(compiledFunction({ name: 'Timothy'\n}));\n// \"&lt;p&gt;Timothy's Pug source code!&lt;/p&gt;\" // Render another set of data\nconsole.log(compiledFunction({ name: 'Forbes'\n}));\n// \"&lt;p&gt;Forbes's Pug source code!&lt;/p&gt;\"\ncompileFile은 파일을 읽어들여 해당 템플릿을 통해 templating을 하는 함수를 반환한다.\n이 외에도 각종 메서드들은 컴파일에 필요한 여러가지 상황을 상정하여 다양한 방식으로 컴파일한 후 렌더링 할 수 있는 방법을 제시한다.\ncompile(source : string,?options : ?options) : function() 함수를 반환하고, 반환한 함수를 실행시키면 렌더링 시킬 수 있다 compileFile(source : string,?options : ?options) : function() pug 파일을 읽어들여, templating 하는 함수를 반환 compileClient(source : string,?options : ?options) : function() \b문자열을 넣고 클라이언트 사이드에서 렌더링 compileClientWithDependenciesTracked(source, ?options): function() 의존성을 가진 template 클라이언트 사이드에서 렌더링 compileFileClient(path:string, ?options: ?options): function()\n- 클라이언트 사이드에서 쓰일 수 있는 문자열로 templating\n렌더링 관련 메서드\nrender(source: string, ?options: ?options): string 문자열을 넣고 html 문자열로 리턴 renderFile(source: string, ?options: ?options, ?callback: ?callback) : string html 문자열로 리턴 해당 경우는 어떠한 요소를 추가했을 때 가져오는 기능이라고 생각해보자app.post(\"/api\", (req, res) =&gt; { const { title, detail, section } = req.body; const data = JSON.parse(readFileSync(`${DATAPATH}`, \"utf-8\")); const data2 = JSON.parse( readFileSync(`${DATAPATH}`, \"utf-8\") ); // 서버 데이터에 추가하는 코드 //JSON으로 컴파일한 html 문자열 stringify const template = JSON.stringify({ data: pug.compileFile( path.join( __dirname, 내 경로들 ), { basedir: path.join(__dirname, \"views\"), } )({argument : value}), }); res.type(\"Content-Type\", \"application/json\"); res.json(template);\n});\n서버에서는\n데이터를 갱신\n갱신한 데이터를 다시 가져오거나 받은 데이터에서 직접적으로 추가(이건 보내는 용도로)\ntemplating할 pug 파일을 pug의 compileFile을 통해 함수를 받기\n갱신한 데이터를 compileFile의 리턴값으로 온 함수에 넣기\n리턴값으로 온 string을 json 형식으로 만들어 클라이언트의 응답 body에 넣어 보내기\n의 과정을 거쳐 새롭게 갱신된 데이터의 컴포넌트 html을 다시금 클라이언트로 보낼 수 있다.\nfunction handler(sectionId) {\n... submitButton.addEventListener(\"click\", async () =&gt; { const title = targetSection.getElementsByClassName(\"form__input--title\")[0].value; const detail = targetSection.getElementsByClassName( \"form__textarea--cardDetail\" )[0].value; const section = targetSection.id; const response = await fetch(\"/api/todo/new\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\", }, body: JSON.stringify({ title: title, detail: detail, section: section, }), }); let data = await response.json(); data = JSON.parse(data); document.getElementById(\"sections\").innerHTML = data.data; });\n}\n사실상 서버에서 html 파일을 통채로 보내서 렌더링 시키는 서버 사이드 렌더링 방식인 만큼 클라이언트라고 불리는게 맞을까 싶다. 그냥 view라고 볼 수 있지만 편의를 위해 클라이언트라고 칭하겠다.클라이언트에서는 이벤트 위임 방식을 통해 이벤트들을 등록하기 때문에 기존의 html을 제외한 정적 파일들은 모두 남아있는 것들을 활용할 수 있다고 생각했다.\n<img src=\"https://i.imgur.com/AlMIpF9.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\ninnerHTML을 통해서 html을 교체하기 전에 기존의 js script로 들어간 js 파일을 개발자도구로 열어 script에 console.log하는 코드를 실행했는데 새롭게 렌더링이 이루어졌음에도 불구하고 스크립트 파일은 여전히 기존 파일을 유지하는 것을 볼 수 있다. 이러한 점은 새롭게 렌더링하는 과정에서 불필요한 정적 파일들을 불러오지 않는다는 이점을 가진다고 생각했다.여러 컴포넌트로 복사된 html들에 이벤트 등록을 하는 방법은 이벤트 위임 뿐만이 아닌, querySelectorAll을 통해 해당하는 각각의 컴포넌트에 forEach를 돌면서 하나하나 이벤트 등록을 해줘야 하는 방식도 존재하지만 이러한 방식은 성능 상에 이슈가 있을 뿐만 아니라 새롭게 렌더링된 Html에는 이벤트 등록을 해주지 않은 상태에서 스크립트는 변하지 않았기 때문에 이벤트가 제대로 등록되지 않아 동작하지 않을 가능성이 있다. You should not have pug tags with multiple attributes.\n사실 이건 해당 templating의 문제가 아닌 내 코드 문제였다<br>\n<img src=\"https://i.imgur.com/b7reY7N.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">form(action=\"post\").editform(hidden)\n나도 모르게 그냥 여러 개의 attribute를 콤마로 구분하지 않고 써놔서 warning이 떴다. 정상적으로 인식은 되지만 주의하자이 문제에 대해서는 stackoverflow를 뒤져보고 했는데 결국 제대로 된 느낌의 답변을 찾지 못했다.<br>\n<img src=\"https://i.imgur.com/hWYkzlh.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n내 나름대로 생각한 점으로는 내가 이제까지 pug 파일을 컴파일 했던 때 사용했던 파일이 mixin형태로 arguments들을 받는 방식으로 될까 싶어서 했던건데, 다른 사용 예시들을 보니 mixin을 활용한 예시가 없었다.\n아마도 html 컴파일 과정에서 mixin을 지원하지 않는건가 싶어서 일반 html으로 바로 컴파일이 가능한 pug 코드를 쓰니 정상작동되었다.\n아무래도 mixin은 해당 템플릿 엔진에서 자체적으로 컴포넌트를 만드는 방식이나보니 compileFile에서는 아직 지원하지 않는 것이라 생각했다.사실 서버 자체에서 렌더링을 하고 있지는 않지만, html 템플릿을 기존에 있는 정적 파일들을 그대로 활용하면서 Html 파일만 교체했음에도 정상적으로 모두 작동한다는 점은 큰 이점을 가진다고 생각한다. ssr과 pug를 공부하면서, 'pug를 통해서 보다 컴포넌트 단위로 나누는 것이 쉬워졌는데, 이러한 방식으로 페이지 전체를 새로고침하지 않아도 문제없을 정도로 계속 사용 가능한 html만 바꿀 수 있지 않을까?'라는 생각에서부터 시작한 실험이었는데 생각보다 이벤트 위임 방식과 시너지를 잘 이루어 나름 야매(?) 클라이언트 사이드 렌더링 방식을 구현했다는 점이 의의가 있는 것 같다. 이번 시도를 통해 CSR과 SSR의 차이도 공부하고, 조금 더 잘 파악할 수 있는 기회가 되었다고 생각한다.하지만 CSR임에도 불구하고 문제가 남아있었으니,,\n기존의 placeholder 안에서 모든 html을 통채로 갈아치우다 보니 SSR처럼 모든 화면이 깜빡이지는 않더라도, 컴포넌트의 placeHolder의 일부분이 깜빡이는 부분은 조금 킹받는 부분이 있다.\n이를 위해서라면, 컴포넌트에 있는 DOM 노드들을 검사해서 변동사항이 있는 부분만 갱신하는 식으로 해도 될 것 같은데, 이거는 조금 더 깊게 파고 들어가야하기 때문에 조금 더 설계해보려고 한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"개요","level":1,"id":"개요_0"},{"heading":"서버와 클라이언트 처리","level":1,"id":"서버와_클라이언트_처리_0"},{"heading":"서버: 컴파일한 다음 문자열로 보내기","level":2,"id":"서버_컴파일한_다음_문자열로_보내기_0"},{"heading":"클라이언트: api 요청하고 받은 값을 기준으로 해당하는 Html 교체","level":2,"id":"클라이언트_api_요청하고_받은_값을_기준으로_해당하는_Html_교체_0"},{"heading":"TroubleShooting","level":1,"id":"TroubleShooting_0"},{"heading":"1. 다중 attribute 문제","level":2,"id":"1._다중_attribute_문제_0"},{"heading":"2. mixin 컴파일링 불가능","level":3,"id":"2._mixin_컴파일링_불가능_0"},{"heading":"과연 CSR이라고 할 수 있을까?","level":2,"id":"과연_CSR이라고_할_수_있을까?_0"},{"heading":"정리","level":1,"id":"정리_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058386,"modifiedTime":1725254058386,"sourceSize":9084,"sourcePath":"학습 정리/Backend/express+pug로 templating해서 SSR + CSR 구현하기.md","exportPath":"학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/backend/mysql-join.html":{"title":"mysql Join","icon":"","description":"JOIN은 데이터베이스 내의 여러 테이블에서 가져온 레코드를 조합하여 하나의 테이블이나 결과 집합으로 표현해 준다.\n관계형 데이터베이스에서는 가장 많이 쓰이는 기능으로, 집합의 개념으로 이해하고 보면 쉽다<img src=\"https://i.imgur.com/ubMaryV.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://i.imgur.com/T8Vp6Vh.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n조인하는 테이블의 ON절의 조건이 일치하는 결과만 출력한다.\n교집합이라고 생각하면 편하다\nmysql에서는 JOIN, INNER JOIN, CROSS JOIN이 같은 의미로 사용 된다\nselect a.userid, name\nfrom users as a inner join history as b\non a.userid = b.userid\nwhere a.userid = \"1\"\n두 개의 테이블을 비교할 때는 각 테이블을 식별하는 변수? 를 as로 지정한 뒤에 조인을 할 때 접근자를 통해서 각 테이블을 식별할 수 있도록 한다!select a.userid, name\nfrom users a, history b\nwhere a.userid = b.userid and a.userid =\"1\"\n<br><img src=\"https://i.imgur.com/yq2y9Eg.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/rX0UgX8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n두 테이블이 합쳐질 때 왼쪽/오른쪽을 기준으로 방향을 정하고, 정한 방향의 컬럼은 모두 가져온다\n한마디로 on 조건에서 설정한 조건에서 한 방향의 데이터를 다 가져온다는 소리다\nOUTER JOIN은 LEFT/RIGHT OUTER JOIN, FULL OUTER JOIN이 있다.\n대부분 LEFT OUTER JOIN을 많이 사용하는데, 왼쪽을 방향으로 잡는 이유는 데이터를 읽는 구조 등의 연관이 있다.처음에 조인할 때 쓸 테이블을 왼쪽에 두고 LEFT JOIN하는 방식으로 하게 되면 데이터 또한 왼쪽 -&gt; 오른쪽으로 엑세스하기 때문에 일반적으로 우리가 글을 읽는 방식처럼 위 -&gt; 아래의 순서대로 데이터를 읽게 된다. 그렇기 때문에 보다 일반적인 방식으로 LEFT JOIN을 사용하여 가장 많은 열을 가져와야 할 테이블을 왼쪽에 우선적으로 적어준다-- 예) 1학년 학생의 이름과 지도교수명을 출력하라. 단, 지도교수가 지정되지 않은 학생도 출력되게 하라. SELECT STUDENT.NAME, PROFESSOR.NAME FROM STUDENT LEFT OUTER JOIN PROFESSOR -- STUDENT를 기준으로 왼쪽 조인\nON STUDENT.PID = PROFESSOR.ID WHERE GRADE = 1\n-- 예) 1학년 학생의 이름과 지도교수명을 출력하라. 단, 지도교수가 지정되지 않은 학생도 출력되게 하라. SELECT STUDENT.NAME, PROFESSOR.NAME FROM STUDENT RIGHT OUTER JOIN PROFESSOR -- PROFESSOR를 기준으로 오른쪽 조인\nON STUDENT.PID = PROFESSOR.ID WHERE GRADE = 1\n3개의 테이블을 조합해야 할 때는 outer join을 연속으로 3번 사용하면 된다.-- 3개의 테이블을 join하고 한국에대한 정보만 뷰로 생성해라 create view allView as ( select A.Name, A.CountryCode from city A left join country B on A.countrycode = B.code -- 테이블 2개 조인 완료 left join countrylanguage C on B.code = C.countrycode -- 테이블 3개 조인 완료 where A.countrycode in ('KOR'); )\n<br><img src=\"https://i.imgur.com/KsP0LXn.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">full outer join은 두 테이블의 합집합이다.\n하지만 full outer join같은 경우 대부분 db가 지원하지 않기 때문에 Union을 활용하여 간접적으로 구현한다.-- full outer join\nselect * from topic FULL OUTER JOIN autor on topic.auther_id = authoer.id -- 같은구문\n(select * from topic LEFT JOIN autor on topic.auther_id = authoer.id)) UNION (select * from topic RIGHT JOIN autor on topic.auther_id = authoer.id))\nUNION은 여러 개의 SELECT문의 결과를 하나의 테이블이나 결과 집합으로 표현할 때 사용한다.\n⚠️ 이 때 각각의 SELECT문으로 선택된 필드의 개수와 타입은 모두 같아야 하며, 필드의 순서 또한 같아야 한다.\n⚠️ 기본 집합 쿼리에는 중복 제거가 자동 포함되어 있다.\nSELECT 필드이름 FROM 테이블이름\nUNION\nSELECT 필드이름 FROM 테이블이름\nUNION은 DISTINCT 자동 포함이라 중복되는 레코드를 제거하기 때문에, 중복되는 레코드까지 모두 출력하고 싶다면 ALL 키워드를 붙이면 된다.SELECT 필드이름 FROM 테이블이름\nUNION ALL\nSELECT 필드이름 FROM 테이블이름\n<br><img src=\"https://i.imgur.com/xtQFPFY.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">EXCLUSIVE LEFT JOIN은 A의 여집합과 같은 느낌이다.\n조건에 해당하는 것을 제외하고 특정 테이블에 있는 레코드만 가져온다.\nEXCLUSIVE JOIN도 LEFT/RIGHT가 나뉘어져 있는데, 방향에 따라 한쪽의 데이터만 가져온다SELECT * FROM table1 A LEFT JOIN table2 B\nON A.ID_SEQ = B.ID_SEQ WHERE B.ID_SEQ IS NULL -- 조인한 B 테이블의 값이 null만 출력하라는 말은, 조인이 안된 A 레코드 나머지값만 출력하라는 말\n자체 조인(SELF JOIN)은 테이블 자기 자신을 조인하는 것이다.<br>\n<img src=\"https://i.imgur.com/usk4Gfy.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">SELECT E.NAME as Name, M.NAME as Secret_Santa\nFROM Santa E, Santa M -- inner join\nWHERE E.Santa_Color = M.Color; JOIN시 먼저 엑세스돼서 ACCESS PATH를 주도하는 테이블\n어디의 데이터부터 출발해서 값을 찾느냐에 따라 성능을 좌지우지한다. 대표적인 예로\n(조건을 만족하는)5000만건의 데이터 A 테이블 (조건을 만족하는)1000건의 데이터 B 테이블 이 두개가 있을 때 조인 과정에서 A테이블에 먼저 엑세스하면 5000만번을 탐색하고\nB테이블에 엑세스하면 1000번의 엑세스만으로 탐색이 완료된다는 차이를 든다.\n따라서 우리는 조인을 할 때 보다 적은 데이터의 양이 들어갈 확률이 높은 테이블에 대해서 드라이빙 테이블로 설정해야 할 필요성이 있다.(물론 관계도 고려해야겠지만)규칙 기반 옵티마이저(Rule-Based Optimizer)에서는 연산자, 인덱스 유무, 조건절 형태 등 정해진 규칙의 우선순위에 따라 실행 계획을 생성한다. 인덱스를 이용한 액세스 방식이 전체 테이블 액세스 방식보다 우선순위가 높음 조인 칼럼에 대한 인덱스가 양쪽 테이블에 모두 존재할 때, 우선순위가 높은 테이블을 선택 조인 칼럼에만 인덱스가 존재하는 경우에는 인덱스가 없는 테이블을 먼저 선택하여 조인 수행 만약 조인 테이블의 우선순위가 동일하지않다면, FROM 절에 나열된 테이블의 역순으로 수행\n하지만 최근에는 비용기반 옵티마이저(Cost-Based Optimizer)를 채택한다.\n비용기반 옵티마이저는 쿼리를 수행하는데 소욕되는 예상 비용을 바탕으로 실행 계획을 생성한다.실행 계획은 인덱스를 기준으로 나뉜다.\n인덱스가 있을 경우 인덱스가 있는 테이블은 데이터 조회 시 풀 스캔이 일어나지 않기 때문에 인덱스가 있는 테이블을 DRIVEN TABLE로 두면 드라이빙 테이블이 드리븐 테이블에 대해서 반복적으로 풀 스캔을 하지 않아 더 빠르기 때문이다.\n따라서 인덱스의 유무를 기준으로 결정 규칙을 나눠보면\n두 칼럼 모두 각각 인덱스가 있을 경우 레코드 건수에 따라 적은 레코드 수를 가진 테이블을 드라이빙 테이블로 한 칼럼에만 인덱스가 있는 경우 인덱스가 없는 테이블의 반복된 풀 스캔을 막기 위해 인덱스가 없는 테이블을 드라이빙 테이블로 선택 두 칼럼 모두 인덱스가 없을 경우 스캔되는 레코드 수에 따라 적절한 드라이빙 테이블 선택\n드리븐 테이블을 풀스캔 으로 동작하게 된다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-JOIN-%EC%A1%B0%EC%9D%B8-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EA%B8%B0%EC%89%BD%EA%B2%8C-%EC%A0%95%EB%A6%AC\" target=\"_self\">https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-JOIN-%EC%A1%B0%EC%9D%B8-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EA%B8%B0%EC%89%BD%EA%B2%8C-%EC%A0%95%EB%A6%AC</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://devuna.tistory.com/36\" target=\"_self\">https://devuna.tistory.com/36</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Join이란?","level":1,"id":"Join이란?_0"},{"heading":"INNER JOIN","level":2,"id":"INNER_JOIN_0"},{"heading":"기본 구문","level":3,"id":"기본_구문_0"},{"heading":"함축 구문","level":3,"id":"함축_구문_0"},{"heading":"LEFT/RIGHT OUTER JOIN","level":2,"id":"LEFT/RIGHT_OUTER_JOIN_0"},{"heading":"\b기본 구문(LEFT JOIN)","level":3,"id":"\b기본_구문(LEFT_JOIN)_0"},{"heading":"기본 구문(RIGHT JOIN)","level":3,"id":"기본_구문(RIGHT_JOIN)_0"},{"heading":"3중 조인","level":3,"id":"3중_조인_0"},{"heading":"FULL OUTER JOIN","level":2,"id":"FULL_OUTER_JOIN_0"},{"heading":"UNION","level":2,"id":"UNION_0"},{"heading":"UNION ALL","level":2,"id":"UNION_ALL_0"},{"heading":"EXCLUSIVE JOIN","level":2,"id":"EXCLUSIVE_JOIN_0"},{"heading":"SELF JOIN","level":2,"id":"SELF_JOIN_0"},{"heading":"DRIVING TABLE","level":2,"id":"DRIVING_TABLE_0"},{"heading":"DRIVING TABLE의 결정 규칙","level":3,"id":"DRIVING_TABLE의_결정_규칙_0"},{"heading":"참조","level":2,"id":"참조_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/backend/mysql-join.html","pathToRoot":"../..","attachments":[],"createdTime":1725787203633,"modifiedTime":1725797402548,"sourceSize":8273,"sourcePath":"학습 정리/Backend/mysql Join.md","exportPath":"학습-정리/backend/mysql-join.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/backend/node.js-libuv에-대한-고찰.html":{"title":"Node.js Libuv에 대한 고찰","icon":"","description":"Libuv는 비동기 입출력 및 이벤트 기반에 초점을 둔 라이브러리이다.\n주요 기능으로는 논블로킹 IO처리, 비동기 파일 시스템 접근 등이 있다.\n우리가 알고 있는 Node.js의 핵심적인 로직인 이벤트 루프를 가지고 있는 라이브러리이기도 하다.고전적으로는 기존 IO 처리의 경우 요청마다 스레드를 할당하여 처리하는 구조를 가지고 있다.\n기존에는 이 동시성을 위해 멀티스레드를 열고 작업이 완료될 때까지 스레드의 실행을 차단하는 방법을 사용했다. 하지만 여기에선 쓰레드를 열었음에도 idle time, 즉 유효한 시간이 각각의 쓰레드에게 발생하기 때문에 이는 곧 자원의 낭비로 이어진다.이어 나온 방식은 논블로킹의 이벤트 디멀티플렉싱메커니즘이다.\n<img src=\"https://i.imgur.com/o1TK327.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">멀티플렉서가 요청들을 하나로 묶고 디멀티플렉서가 요청을 싱글 스레드에 나눔으로써 모든 요청들을 관리하고 요청이 완료되기 전까지 블로킹, 완료가 된 후에는 이벤트큐에 푸시하는 방법 또한 사용했다.\n이러한 메커니즘에 특화된 디자인 패턴으로는 리액터 패턴이 있다.<br><img src=\"https://i.imgur.com/uQBTe8v.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">리액터 패턴은 이벤트 디멀티플렉서에서 I/O 요청이 완료되었을 때, 이벤트와 이벤트에 해당하는 핸들러를 이벤트 큐에 넣고 이벤트 루프를 통해 이러한 핸들러를 실행시키는 방식으로 작동한다.\n여기서 이벤트 루프가 존재를 드러내기 시작한다. 이러한 이벤트 루프의 기본적인 작동 방식이 현재 우리가 알고 있는 Node.js libuv 라이브러리의 이벤트 루프의 기반이 되었다.<br><img src=\"https://i.imgur.com/V1c7vQl.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nLibuv의 공식문서를 보면 Libuv는 이벤트루프를 통해 Handle과 Request 두 가지를 다룬다고 나와있다.\nHandle의 경우 작동 과정에서 다루는 콜백, TCP 서버 연결 콜백 등의 IO를 다루게 되고, Request는 Handle이 작동하는 과정에서 필요한 작업들을 요청하는 단기간 작업들을 다룬다.while there are still events to process: e = get the next event if there is a callback associated with e: call the callback\n이벤트 루프는 반복적으로 이러한 작업들에 대해서 단일 스레드인 nodejs와 연결하고 이를 비동기적으로 수행한다.\n비동기적으로 IO작업을 수행하기 위해서는 여타 단일 스레드 비동기 I/O접근방식과 같이 논블로킹 소켓에서 사용되며, 이 과정에서 필요한 polling은 각 OS에서 사용 가능한 최적의 메커니즘을 통해 작동한다. 해당 메커니즘의 경우 Windows의 경우 IOCP, Linux의 경우 Epoll 등이 있다.\n대표적인 IO polling 메커니즘인 Linux의 Epoll에 대해서도 짚고가자.Epoll은 리눅스에서 개발된 I/O 통지 모델이다. 멀티플렉싱 기법으로 동작하는 select 함수의 단점(느린 멀티플렉싱 등)을 보완하기 위해 나온 OS 레벨에서 지원하는 멀티플렉싱 함수이다.\n파일 디스크럽터를 커널이 관리하면서 CPU에서 파일 디스크럽터의 상태 변화를 감시하고, 비동기 I/O 이벤트를 처리하는데 사용된다.\n파일 디스크립터(File Descriptor)\n유닉스 계열 시스템에서 프로세스가 특정 파일에 접근할 때 사용하는 추상적인 값\n프로세스가 실행 중에 파일을 Open하면 커널은 해당 프로세스의 파일 디스크립터 숫자 중 사용하지 않는 가장 작은 값을 할당해준다. 그 다음 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.\n표준입력 0 / 표준출력 1 / 표준에러 2는 고정임\nint epfd = epoll_create1(0); 새로운 epoll 인스턴스를 생성하고 파일 디스크립터(fd)를 반환\n매개변수 size 플래그를 전달 struct epoll_event event;\nevent.events = EPOLLIN;\nevent.data.fd = socket_fd;\nepoll_ctl(epfd, EPOLL_CTL_ADD, socket_fd, &amp;event); epoll 인스턴스에 파일 디스크립터를 추가, 수정 또는 삭제\n매개변수 epfd : epoll 인스턴스의 파일 디스크립터\nop: 수행할 작업 EPOLL_CTL_ADD: 새 파일 디스크립터를 epoll 인스턴스에 추가\nEPOLL_CTL_MOD: 기존 파일 디스크립터를 수정\nEPOLL_CTL_DEL: 파일 디스크립터를 삭제 fd: 감시할 파일 디스크립터\nstruct epoll_event *event: 감시할 이벤트와 데이터를 설정하는 구조체로 관찰 대상의 관찰 이벤트 유형 EPOLLIN : 수신할 데이터가 있음\nEPOLLOUT : 송신 가능함\nEPOLLPRI : 중요 데이터 발생\nEPOLLRDHUD : 연결 종료 또는 Half-close 발생\nEPOLLERR : 에러 발생\nEPOLLET : 엣지 트리거 방식으로 설정(디폴트는 레벨 트리거) 엣지 트리거 : 특정 상태가 변화하는 시점에서 감지\n레벨 트리거 : 특정 상태가 유지되는 동안 감지 EPOLLONESHOT : 한번만 이벤트 받기 struct epoll_event events[MAX_EVENTS];\nint nfds = epoll_wait(epfd, events, MAX_EVENTS, -1); epoll 인스턴스에 등록된 파일 디스크립터들 중 이벤트가 발생한 것을 기다림\n매개변수 epfd: epoll 인스턴스의 파일 디스크립터\nevents: 발생한 이벤트들이 저장된 배열\nmaxevents: 감시할 수 있는 최대 이벤트 수\ntimeout: 이벤트가 발생할 때까지 대기하는 시간(밀리초). -1로 설정하면 무한 대기 <br><img src=\"https://i.imgur.com/p0BTiqc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n아무튼 이렇게 IO polling을 통해 이벤트를 감시하고, IO 이벤트에 대해서 처리를 커널단에서 해주는데, 파일 I/O나 DNS 함수(getaddrinfo, getnameinfo) 같은 경우는 커널단에서 지원해주지 않는다. 그렇기 때문에 Libuv는 워커 스레드 풀을 두고, 워커 스레드를 할당하여 해당 작업을 처리하도록 한다. 해당 작업은 스레드 풀에서 블로킹 방식으로 접근 및 작업을 처리한다.결국 모든 작업은 이벤트루프 를 중심으로 내외적으로 이루어지는 것이다.\n이벤트 루프 안에서 비동기 작업이 일어나는 경우 I/O Polling의 작업이나 워커스레드가 할 수 있는 비동기 작업 등에 대해서는 함수를 실행한 뒤 바로 리턴받는다. 이후에 각 비동기 작업이 끝난 후 받는 callback을 각 이벤트에 맞는 queue에 넣어주고 이벤트 루프가 돌다가 이 큐에 콜백이 들어온 것을 감지하고 실행시키는 것이다.<br><img src=\"https://i.imgur.com/U5C6EN6.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n전체적인 구조가 잘 도식화되어있는 것 같아서 사진을 가져왔다. 이런 식으로 이벤트 루프는 싱글 스레드로 동작하지만 비동기 작업에서는 IO Polling을 커널에서, 파일 IO와 같은 작업은 별도의 워커스레드를 통해 구현하여 싱글스레드인데도 비동기적으로 동작시키기 때문에 블로킹I/O보다 좋은 효율을 내게 된다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://sjh836.tistory.com/149\" target=\"_self\">https://sjh836.tistory.com/149</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://rammuking.tistory.com/entry/Epoll%EC%9D%98-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95\" target=\"_self\">https://rammuking.tistory.com/entry/Epoll%EC%9D%98-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Libuv란?","level":2,"id":"Libuv란?_0"},{"heading":"기존의 IO 처리와 Libuv의 등장","level":2,"id":"기존의_IO_처리와_Libuv의_등장_0"},{"heading":"Libuv의 구조","level":2,"id":"Libuv의_구조_0"},{"heading":"Epoll","level":3,"id":"Epoll_0"},{"heading":"Epoll 주요 함수와 매개변수","level":4,"id":"Epoll_주요_함수와_매개변수_0"},{"heading":"epoll_create()","level":4,"id":"epoll_create()_0"},{"heading":"epoll_ctl()","level":4,"id":"epoll_ctl()_0"},{"heading":"epoll_wait()","level":4,"id":"epoll_wait()_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/backend/node.js-libuv에-대한-고찰.html","pathToRoot":"../..","attachments":[],"createdTime":1727007369417,"modifiedTime":1727014265529,"sourceSize":7709,"sourcePath":"학습 정리/Backend/Node.js Libuv에 대한 고찰.md","exportPath":"학습-정리/backend/node.js-libuv에-대한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/backend/passport의-로컬-인증전략.html":{"title":"Passport의 로컬 인증전략","icon":"","description":"passport 모듈을 사용하여 로컬에서 인증을 관리하는 로직을 구현해보자.\nPassport 모듈을 사용한 로그인 인증 전략은 로컬과 각종 소셜 로그인 등으로 구성되어 있다.\n해당 글은 Inpa님의 글을 참고하면서 제가 구현했던 로그인 인증 전략에 대해서 정리하는 글입니다\nrouter.post(\"/login\", isNotLoggedIn, (req, res, next) =&gt; { passport.authenticate(\"local\", (authError, user, info) =&gt; { if (authError) { console.error(authError); return next(authError); } if (!user) { // 해당하는 인증 정보를 찾기 못했을 경우 401 에러 반환 return res.status(401).json(info); } //req의 login 두번째 인자 -&gt; 에러 핸들링 return req.login(user, (loginError) =&gt; { if (loginError) { console.error(loginError); return next(loginError); } // 로그인 성공시 200 응답하기 return res.status(200).json({ message: \"successfully login\" }); }); })(req, res, next);\n});\n로그인 요청은 가장 먼저 설정한 라우터를 통해 들어오게 된다. 여기서 두 번째로 설정해둔 미들웨어는 isNotLoggedIn으로 해당 유저가 로그인한 상태를 확인하는 미들웨어이다.export const isNotLoggedIn = (req, res, next) =&gt; { if (!req.isAuthenticated()) { next(); } else { const message = encodeURIComponent(\"로그인한 상태\"); res.redirect(`/?error=${message}`); }\n};\n이렇게 로그인이 된 경우에는 헤더에 로그인 정보가 함께 오기 때문에 req 객체의 isAuthenticated 함수를 통해 로그인 여부를 체크할 수 있다.\n해당 함수는 boolean 값을 반환하기 때문에 if else문으로 로그인하지 않은 경우는 next()를 통해 다음 미들웨어를 호출할 수 있게 해 주었고, else의 경우네는 로그인한 상태이기 때문에 redirect를 시켜주었다.해당 미들웨어를 거친 뒤에 예외처리에서 걸러지지 않았다면 next()를 통해 다음 미들웨어로 이동하도록 한다.\n다음 미들웨어가 실행되면 다시 위의 코드 다음으로 올라와서 router.post 안의 콜백 함수를 실행시키게 되는게, 가장 먼저 콜백함수 한에는passport.authenticate()가 있다. 여기서 authenticate() 메소드를 실행하게 되는데, passport/localStrategy.js 파일에 내가 따로 설정해놓은 passport 미들웨어가 있다.function localStrategy() { passport.use( new LocalStrategy( { usernameField: \"username\", passwordField: \"password\", }, async (username, password, done) =&gt; { try { const user = await transaction(User.findOne, username); if (user) { const result = await bcrypt.compare(password, user.passwd); if (result) { done(null, user); } else { done(null, false, { message: \"비밀번호가 일치하지 않음\" }); } } else { done(null, false, { message: \"해당하는 유저 정보가 없습니다.\" }); } } catch (error) { console.error(error); done(error); } } ) );\n} export default localStrategy; LocalStrategy는 passport.use를 통해 미들웨어를 설정한 것을 볼 수 이싿.\n미들웨어 안에는 LocalStrategy 객체를 생성하고, 들어오는 로그인 정보를 검증하는 과정을 거친다.\n여기서 transaction은 내가 mysql connection과 release를 하나로 묶어놓은 함수이다. 해당 함수에 내가 써놓은 쿼리를 실행하는 함수와 필요한 정보를 인자로 넣으면 transaction은 mysql과 연결한 뒤 해당 쿼리문을 수행한다.\n로그인 비밀번호는 해시값으로 암호화 되어있기 때문에 bcrypt.compare을 통해서 가져온 db의 비밀번호와 비교한다.비밀번호를 비교한 뒤 해당하는 유저가 맞거나 틀리거나의 여부에 상관없이 done 함수를 호출한다.\ndone()이 실행되면 해당 미들웨어가 끝나고 다시 이전에 진행하던 함수로 돌아가는데, 돌아가는 함수는 아까 authenticate 함수 내의 다음 미들웨어를 실행한다.done의 인자로 주었던 세 가지의 값들은 이 콜백 함수의 세 가지 인자에 들어가게 된다. (authError, user, info) =&gt; { if (authError) { console.error(authError); return next(authError); } if (!user) { // 해당하는 인증 정보를 찾기 못했을 경우 401 에러 반환 return res.status(401).json(info); } //req의 login 두번째 인자 -&gt; 에러 핸들링 return req.login(user, (loginError) =&gt; { if (loginError) { console.error(loginError); return next(loginError); } // 로그인 성공시 200 응답하기 return res.status(200).json({ message: \"successfully login\" }); }); }\n해당 미들웨어는 만약 여기서 유저를 찾지 못했다거나 로그인이 됐을 경우를 처리해준다.\n해당 함수는 콜백 함수를 리턴하게 되는데, 이 과정에서 방금 받았던 로그인 정보에 대해서 에러가 있었을 시 처리를 하고 req의 login 메소드를 호출하면, passport는 설정해놨던 passport.serializeUser()를 호출시킨다.export default function () { passport.serializeUser((user, done) =&gt; { done(null, user.username); }); passport.deserializeUser(async (username, done) =&gt; { try { const user = await transaction(User.findOne, username); done(null, user); } catch (error) { done(error); } }); local();\n}\nSerialize(직렬화)란?\n데이터 스트림으로 만들어진 객체로, 객체 자체를 영속적으로 보관할 떄 사용하는 파일형태로 작성되어 네트워크를 통해 전송한다.\n간단하게 직렬하는 바이트 형태로 바꾸는 작업이다.\n자매품으로 Deserialize는 이렇게 데이터 스트림으로 만들어진 객체를 반대로 다시금 해석하고, 원래의 형태로 되돌리는 역할을 한다\n\bserialzieUser를 통해 로컬에 PK로 두고 로그인을 식별 가능한 최소한의 값(메모리 최적화)만을 가지고 있도록 한다. done()함수의 두번째 인자로 넣으면 된다.\nserializeUser가 끝난 후에는 밑으로 가서 바로 deserializeUser를 실행하낟. 해당 미들웨어에는 알아서 유저가 들어가게 되기 때문에 나는 거기서 유저를 다시금 db에서 찾아서 done의 두번째 인자로 user를 넣어줌으로써 req 객체에 user 객체를 등록시킬 수 있다.로그인 성공/실패의 여부와는 별개로 desrializeUser에서 실행하는 done은 같은 req.login미들웨어로 다시 돌아오고 해당 결과는 return req.login(user, (loginError) =&gt; { if (loginError) { console.error(loginError); return next(loginError); }\n요 부분의 loginError로 들어가게 된다.\n여기서 done의 인자가 로그인 성공시 두개인데 왜 여기서 받는 인자는 하나냐면 두 번째 인자의 경우에는 req 객체에 user 객체만 등록하는 것일 뿐 돌아오면서 해당 콜백의 인자로 넣어주는게 아니기 때문에 첫 번째 인자만 넘어오게 된다. 그래서 로그인 성공시 done의 첫번쨰 인자가 null이고, 실패 시에는 첫번째 인자가 error인 것이다.이렇게 로그인이 완료된 후에 응답을 보낼 때는 // app.js\npassportConfig();\napp.use( session({ resave: false, saveUninitialized: false, secret: process.env.SECRET_KEY || crypto.randomBytes(32).toString(\"hex\"), cookie: { httpOnly: true, secure: false, }, })\n);\napp.use(passport.initialize());\napp.use(passport.session()); 해당 미들웨어들을 순서대로 실행시켜준다.\n여기서 passportConfig는 아까 serialize, deserialize가 있는 함수이다!\n로그인이 완료되면 응답을 보낼 때 여기서 session에 cookie 설정을 하고 보내면(set-cookie를 해준다) 알아서 클라이언트의 쿠키에 세션 정보가 저장되고, 클라이언트에서 요청을 보낼 때 알아서 머리에 쿠키를 담아 보낸다\nhttpOnly Cookie\n자바스크립트를 통해 쿠키에 접근할 수 없게 되어 악성 스크립트를 통해 쿠키값에 접근하는 것을 막아준다. secure Cookie\n네트워크 감청을 막기 위한 쿠키 세팅이다. 암호화된 쿠키를 넘겨준다\n하지만 https가 아닌 http에서는 사용할 수 없다\n그렇다면 머리에 쿠키를 담고 보내는 클라이언트 녀석은 나중에 api를 요청할 때 어떤 방식으로 유저임을 확인할까?로그인 이후에는 클라이언트가 머리에 쿠키를 달고 api를 요청하면서 등장하면 서버는 이 쿠키를 떼어 해당 세션 아이디에 해당하는 유저네임을 뽑고, 그 유저네임을 통해 db에 해당 유저가 여전히 존재하는지를 확인한다. 이 과정에서 모든 요청에 passport.session 미들웨어가 passport.deserializeUser 메서드를 항상 실행하면서 벌어지는 일인데, 아까 봤던 대로 deserializeUser는 db에서 사용자를 조회하고 조회된 사용자 전체 정보를 req 객체에 등록하는 역할을 한다.그래서 항상 로그인한 뒤에는 알아서 db에서 유저 정보 뽑아서 req 객체로 넣어주니, 우리는 라우터에서 이 req 객체의 user 객체를 통해서 접근하고 유저 정보에 맞는 정보만을 뽑아서 줄 수 있다!","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"passport의 초기 로그인","level":2,"id":"passport의_초기_로그인_0"},{"heading":"로그인 자체의 과정","level":3,"id":"로그인_자체의_과정_0"},{"heading":"로그인 요청이 라우터를 통해 들어옴","level":4,"id":"로그인_요청이_라우터를_통해_들어옴_0"},{"heading":"로그인 이후 세션 아이디로 인증","level":2,"id":"로그인_이후_세션_아이디로_인증_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/backend/passport의-로컬-인증전략.html","pathToRoot":"../..","attachments":[],"createdTime":1725373005731,"modifiedTime":1725541410582,"sourceSize":9931,"sourcePath":"학습 정리/Backend/Passport의 로컬 인증전략.md","exportPath":"학습-정리/backend/passport의-로컬-인증전략.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/backend/rest-api.html":{"title":"REST API","icon":"","description":"Representational State Transfer API의 약자로, 로이 필딩의 논문에서 소개되었다.REST API는\n자원(Resource) - URI\n행위(Verb) - HTTP METHOD\n표현(Representations)\n로 구성된다.\nURI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일REST는 무상태성 성격을 갖는다.\n작업을 위한 상태 정보를 저장하고 관리하지 않기 때문에 세션 정보나 쿠키 정보를 별도로 저장하고 관리하지 않아 들어오는 요청만을 단순히 처리한다.\n세션이나 쿠키를 관리하지 않음으로써 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해진다.HTTP의 웹표준을 그대로 사용하기 때문에 기존 인프라를 그대로 사용하는 캐싱 기능 등을 적용 가능하다. REST API 메시지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조로 되어 있다.REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션이나 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 구분되어 의존성이 줄어들 뿐만 아니라 클라/서버가 개발해야 할 내용이 명확해진다REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 한다.REST API 설계에 있어서 고려해야 할 중요 항목들은 몇 가지가 있다.GET /members/delete/1 리소스 명은 동사보다 명사 사용\n자원을 표현하는데 집중\nDELETE /members/1\nGET /members\nPOST /members\nPUT /members\n<img src=\"https://i.imgur.com/brCZvOz.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">위와 같이 uri에 delete를 명시하는 것이 아닌 HTTP Method를 통해 이러한 자원에 대해 어떠한 행위, 즉 어떠한 조작을 할 것인지를 명시할 수 있도록 한다.http://restapi.example.com/animals/mammals/whales\n왼쪽에서 오른쪽으로 갈수록 하위 계층을 나타내도록 해야 한다.\n추가적으로\n마지막 문자에 슬래시 포함하지 않음\n하이픈을 통해 Url 가독성 높이기\n언더바(_) 사용하지 않기\nURI 경로에는 소문자 사용\n파일 확장자는 URI에 포함 X (헤더를 통해 나타내기)\n등이 있다.\nREST 리소스 간에 연관 관계가 있을 경우 /리소스명/리소스ID/관계가 있는 다른 리소스명 의 순서대로 표현할 수 있도록 한다.GET: /users/{userid}/phone\nGET: /users/{userid}/favorite/phone\n이와 같이 관계명이 복잡할 경우에는 서브 리소스에 추가적으로 명시도 가능하다Collection은 복수, Document는 단수로 사용한다.\nCollection vs. Document\nCollection은 여러 개의 리소스를 모아 놓은 집합이고, Document는 이러한 Collection 내의 개별 리소스를 나타낸다.\nex) sports(Collection) - Soccer(Document)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"REST API란?","level":1,"id":"REST_API란?_0"},{"heading":"구성","level":2,"id":"구성_0"},{"heading":"특징","level":2,"id":"특징_0"},{"heading":"Uniform(유니폼 인터페이스)","level":3,"id":"Uniform(유니폼_인터페이스)_0"},{"heading":"Stateless(무상태성)","level":3,"id":"Stateless(무상태성)_0"},{"heading":"Cacheable(캐시 가능)","level":3,"id":"Cacheable(캐시_가능)_0"},{"heading":"Self-descriptiveness(자체 표현 구조)","level":3,"id":"Self-descriptiveness(자체_표현_구조)_0"},{"heading":"Client - Server구조","level":3,"id":"Client_-_Server구조_0"},{"heading":"계층형 구조","level":3,"id":"계층형_구조_0"},{"heading":"디자인 가이드","level":2,"id":"디자인_가이드_0"},{"heading":"URI는 정보의 자원을 표현해야 함","level":3,"id":"URI는_정보의_자원을_표현해야_함_0"},{"heading":"자원에 대한 행위는 HTTP METHOD로 표현","level":3,"id":"자원에_대한_행위는_HTTP_METHOD로_표현_0"},{"heading":"슬래시를 통해 계층 관계 나타내기","level":3,"id":"슬래시를_통해_계층_관계_나타내기_0"},{"heading":"관계 표현","level":3,"id":"관계_표현_0"},{"heading":"Collection과 Document의 자원 표현","level":3,"id":"Collection과_Document의_자원_표현_0"},{"heading":"응답 코드","level":2,"id":"응답_코드_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/backend/rest-api.html","pathToRoot":"../..","attachments":[],"createdTime":1726067961664,"modifiedTime":1726072273414,"sourceSize":4877,"sourcePath":"학습 정리/Backend/REST API.md","exportPath":"학습-정리/backend/rest-api.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/backend/sql-기본문법.html":{"title":"sql 기본문법","icon":"","description":"SQL(Structured Query Language) 는 관계형 데이터베이스에 정보 저장 및 처리에 용이한 프로그래밍 언어이다.\n관계형 데이터베이스는 정보를 표 형태로 저장하며, 행과 열을 통해 데이터 속성과 데이터 값 간의 다양한 관계를 나타낸다.데이터베이스를 데이터의 집합이라고 한다면, DBMS(데이터베이스 관리 시스템)은 이러한 데이터베이스를 관리하고 운영할 수 있는 소프트웨어이다. 정보에 대해서\n다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합\n사용자 또는 다른 프로그램의 요구를 처리하고 적절히 응답하여 데이터를 사용할 수 있도록 해준다.\n자료의 통합성 증진\n데이터의 접근성 용이\n데이터 통제 강화\n애플리케이션 프로그램 개발 및 관리 용이\n보안 강화 계층형(Hierarchical)<img src=\"https://i.imgur.com/F0m6agz.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 트리 형태를 갖는 계층형 구조\n현재는 사용 X <br>망형(Network)<img src=\"https://i.imgur.com/tZMMoSx.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 하위에 있는 구성원끼리도 연결된 구조\n현재는 사용 X <br>관계형(Relational) <img src=\"https://i.imgur.com/3ETG6Gc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 테이블(table)이라는 최소 단위로 구성\n테이블은 하나 이상의 열과 행으로 이루어짐 객체지향형(Object-Oriented)\n객체관계형(Object-Relational) MYSQL Oracle에서 제공하는 오픈 소스 관계형 데이터베이스 관리 시스템 NOSQL 테이블을 사용하여 데이터를 저장하지 않는 비관계형 데이터베이스\n수평 확장(NOSQL 소프트웨어를 실행하는 컴퓨터의 추가)이 가능하여 최신 애플리케이션에 많이 사용됨 Microsoft SQL Server SQL로 데이터를 조작하는 마이크로소프트의 관계형 데이터베이스 관리 시스템 PostgreSQL\nDB2\nACCESS\nSQLite\n-- USE '스키마명'\nUSE mh_db\n-- SELECT '컬럼명' FROM '테이블명'\nSELECT member_id, name FROM member; -- SELECT 와 FROM 사이에 *를 적으면 테이블의 모든 컬럼을 조회한다.\nSELECT * FROM member; -- 두 SQL은 동일한 기능\nSELECT * FROM market_db.member;\nSELECT * FROM member;; -- 논리연산자 사용 가능\nSELECT TRUE OR FALSE AND FALSE; // 1 SELECT (TRUE OR FALSE) AND FALSE; // 0\n-- between을 통한 범위 표현\nSELECT * FROM member WHERE height between 160 and 165\n-- mem_name 컬럼 값이 '블'로 시작하는 4글자 글자 데이터 조회\nSELECT * FROM member WHERE mem_name LIKE '블___'; -- mem_name 컬럼 값이 '블'로 시작하는 모든 데이터 조회\nSELECT * FROM member WHERE mem_name LIKE '블%'; -- mem_name 컬럼 값에 '블'이 들어가는 모든 데이터 조회\nSELECT * FROM member WHERE mem_name LIKE '%블%'; 글자_ -&gt; 글자로 시작, 언더바의 수에 따라 글자 지정\n글자% -&gt; 해당 글자로 시작하는 모든 데이터 조회\n%글자% -&gt; 값에 해당 글자가 들어가는 모든 데이터 조회\n-- member 테이블에서 mem_number 컬럼 값이 5이상인 데이터 조회\nSELECT * FROM member WHERE mem_number &gt;= 5;\n-- addr 컬럼값이 경기, 전남, 경남인 데이터 조회\nSELECT * FROM member WHERE addr IN('경기', '전남', '경남'); SELECT * FROM member WHERE addr = '경기' OR addr = '전남' OR addr = '경남';\nSELECT mem_name, height FROM member WHERE height &gt; (select height from member where mem_name LIKE '에이핑크');\n2개의 SQL문을 하나로 만들기-- debut_date 값을 기준으로 정렬 (기본 ASC)\nSELECT * FROM member ORDER BY debut_date; ASC -&gt; 오름차순(기본값)\nDESC -&gt; 내립차순\n-- height 컬럼 값이 164 이상인 데이터를 조회하여 -- height 값 기준 내림차순 정렬하고 동일한 값이라면 debut_date 값 기준 오름차순 정렬\nSELECT * FROM member WHERE height &gt;= 164 ORDER BY height DESC, debut_date;\nSELECT * FROM member LIMIT 3; -- 상위 3건만 조회 SELECT * FROM member LIMIT 3, 2; -- 3번째 데이터부터 2건만 조회 LIMIT 2 OFFSET 3; -- 위와 동일 LIMIT 시작, 개수\n처음부터 N까지의 데이터만 가져옴\nLIMIT와 OFFSET 조합으로도 출력 개수 제한 가능\n-- addr 의 모든 컬럼 값을 중복을 제거하여 조회\nSELECT DISTINCT addr FROM member;\nDISTINCT를 열 이름 앞에 붙이면 중복된 값은 1개만 출력-- mem_id가 같은 데이터를 그룹으로 묶음\n-- 그룹핑된 데이터에서 mem_id와 amount의 합계를 구함\nSELECT mem_id, SUM(amount) AS \"합계\" FROM buy GROUP BY mem_id ORDER BY mem_id; SUM() 컬럼의 합계\nAVG() 컬럼의 평균\nMIN() 컬럼의 최소값 반환\nMAX() 컬럼의 최대값을 반환\nCOUNT() 행의 개수(NULL 값 포함)\nCOUNT(DISTINCT) : 행의 개수 (중복 제외, NULL값 비포함)\nSTDEV() 표준 편차\nVARIANCE() 분산\n-- 집계 함수 안에서 연산도 가능\nSELECT mem_id, SUM(amount*price) AS \"총 금액\" FROM buy GROUP BY mem_id ORDER BY mem_id;\n-- mem_id 를 기준으로 그룹화\n-- 그룹화된 데이터를 기준으로 amount*price 합계가 1000 이상인 그룹만 남김\n-- 조건에 걸러진 그룹에서 amount*price 의 합계를 조회\nSELECT SUM(amount*price) AS \"총 금액\" FROM buy GROUP BY mem_id HAVING SUM(amount*price) &gt;= 1000; 집계 함수에 대해서 조건 제한하는 편리한 개념\n반드시 GROUP BY절 다음에 나와야 함 총합 또는 중간합계가 필요할 때 사용\nGROUP BY절과 함께 WITH ROLLUP문 사용 여러 테이블에서 가져온 레코드를 조합하여 하나의 테이블이나 결과 집합으로 표현\n그냥 합치는게 아니라, ON을 통해서 조건을 걸어주기 LENGTH() 문자열 길이\nCONCAT() 전달받은 문자열을 모두 결합하여 하나의 문자열로 반환 전달받은 문자열 줄 하나라도 NULL이 존재하면 NULL 반환 LOCATE() 문자열 내에서 찾는 문자열이 처음으로 나타나는 위치 찾는 문자열이 문자열 내에 없으면 0 반환\nMYSQL은 시작 인덱스가 1부터임 LEFT() 문자열 왼쪽부터 지정한 개수만큼의 문자를 반환\nRIGHT() 문자열 오른쪽부터 지정한 개수만큼의 문자를 반환\nLOWER() 소문자로\nUPPER() 대문자로\nREPLACE() 문자열에서 특정 문자열을 대체 문자열로 교체\nTRIM() 문자열 앞뒤 or 양쪽에 모두 있는 특정 문자를 제거 BOTH 양 끝에 존재하는 특정 문자 제거\nLEADING 전달 받은 문자열 앞에 존재하는 특정 문자 제거\nTRAILING 전달 받은 문자열 뒤에 존재하는 특정 문자 제거\n지정자 명시 안하면 BOTH로 됨\n제거할 문자 명시 없으면 공백 제거 SELECT TRIM(LEADING \"@@@\" FROM \"@@@wrwr@@@\")\n-- wrwr FORMAT() 숫자 타입의 데이터를 세 자리마다 쉼표를 사용하는 형식으로 변환 문자열로 반환됨\n두번째 인수는 반올림할 소수 부분의 자릿수 FLOOR() 내림\nCEIL() 올림\nROUND() 반올림\nSQRT() 양의 제곱근\nPOW() 밑수와 지수를 전달하여 거듭제곱\nEXP() 인수로 지수를 전달받아 e의 거듭제곱 계산\nLOG() 자연로그 값을 계산\nSIN() 사인값\nCOS() 코사인값\nTAN() 탄젠트값\nABS() 절대값\nRAND() 0.0보다 크거나 같고 1.0보다 작은 하나의 실수를 무작위 생성\nNOW() 현재 날짜와 시간 반환 'YYYY-MM-DD HH:MM:SS' 또는 YYYYMMDDHHMMSS형태로 반환 CURDATE() 현재 날짜 반환 'YYYY-MM-DD' 또는 YYYYMMDD형태로 반환 CURTIME() 현재 시각 반환 'HH:MM:SS' 또는 HHMMSS형태로 반환 DATE() 전달받은 값에 날짜 정보 반환\nMONTH() 월\nDAY() 일\nHOUR() 시간\nMINUTE() 분\nSECOND() 초\nMONTHNAME() 월에 해당하는 이름\nDAYNAME() 요일\nDAYOFWEEK() 해당 주에서 몇번째 날인지 반환 1-7사이 일요일 = 1, 토요일 = 7 DAYOFMONTH() 해당 월에서 몇 번쨰 날인지 반환 0부터 31 사이\nDAYOFYEAR() 해당 \u001f연도에서 몇번째 날인지 반환 1-366사이\nDATE_FORMAT() 전달받은 형식에 맞춰 날짜와 시간 정보 문자열로 반환\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"SQL이란?","level":1,"id":"SQL이란?_0"},{"heading":"DBMS란?","level":2,"id":"DBMS란?_0"},{"heading":"장점","level":3,"id":"장점_0"},{"heading":"DBMS의 분류","level":3,"id":"DBMS의_분류_0"},{"heading":"사용되는 DBMS들","level":3,"id":"사용되는_DBMS들_0"},{"heading":"sql 기본 문법","level":1,"id":"sql_기본_문법_0"},{"heading":"USE - 스키마(데이터베이스) 선택","level":2,"id":"USE_-_스키마(데이터베이스)_선택_0"},{"heading":"SELECT - 조회할 데이터(column) 지정","level":2,"id":"SELECT_-_조회할_데이터(column)_지정_0"},{"heading":"논리연산자 사용","level":3,"id":"논리연산자_사용_0"},{"heading":"between 범위표현","level":3,"id":"between_범위표현_0"},{"heading":"LIKE 문자열의 일부 글자 검색","level":3,"id":"LIKE_문자열의_일부_글자_검색_0"},{"heading":"WHERE - 특정 조건 조회","level":2,"id":"WHERE_-_특정_조건_조회_0"},{"heading":"IN() - 여러 값 매칭","level":2,"id":"IN()_-_여러_값_매칭_0"},{"heading":"서브 쿼리","level":2,"id":"서브_쿼리_0"},{"heading":"ORDER BY 조회 데이터 정렬","level":2,"id":"ORDER_BY_조회_데이터_정렬_0"},{"heading":"LIMIT 출력 개수 제한","level":2,"id":"LIMIT_출력_개수_제한_0"},{"heading":"DISTINCT 중복 데이터 제거","level":2,"id":"DISTINCT_중복_데이터_제거_0"},{"heading":"GROUP BY 그룹화","level":2,"id":"GROUP_BY_그룹화_0"},{"heading":"집계 함수","level":2,"id":"집계_함수_0"},{"heading":"HAVING 그룹 조건","level":2,"id":"HAVING_그룹_조건_0"},{"heading":"ROLLUP","level":2,"id":"ROLLUP_0"},{"heading":"JOIN","level":2,"id":"JOIN_0"},{"heading":"내장함수","level":2,"id":"내장함수_0"},{"heading":"문자열 함수","level":3,"id":"문자열_함수_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/backend/sql-기본문법.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058395,"modifiedTime":1739035385494,"sourceSize":9054,"sourcePath":"학습 정리/Backend/sql 기본문법.md","exportPath":"학습-정리/backend/sql-기본문법.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/backend/sql-트리거.html":{"title":"sql 트리거","icon":"","description":"트리거(Trigger)는 테이블에서 어떤 이벤트가 발생했을 때 자동으로 실행되는 함수와 같은 존재다.자바스크립트의 이벤트 리스너처럼 어떤 테이블에서 특정한 이벤트가 발생했을 때 실행시키고자 하는 추가 쿼리 작업들을 자동으로 수행할 수 있게끔 트리거를 미리 설정해주는 것이다.정말 간략하게 예를 들어보자면, A 테이블에 1이라는 숫자가 입력됐을 때, 자동으로 B 테이블에도 1을 복사해주고 싶을 때 트리거를 이용해 설정해 놓았다면 자동으로 B에도 1이라는 숫자가 입력되게 할 수 있습니다.<img src=\"https://velog.velcdn.com/images/odh0112/post/8dbbda7b-059a-4cab-ac75-51494f665cdf/image.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nINSERT, UPDATE, DELETE 문에 대해&nbsp;한 번만&nbsp;실행\nAFTER 트리거 : 쿼리 이벤트 작동한 후\nBEFORE 트리거 : 쿼리 이벤트가 작동하기 전 -&gt; 미리 데이터를 확인 가능할 때\n<br><img src=\"https://velog.velcdn.com/images/odh0112/post/64e5363f-9df4-48f0-bb0b-b6aae6236ef1/image.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n테이블 안의 영향을 받은 행 각각에 대해 실행\n변경 전 or 변경 후의 행은 각각&nbsp;OLD, NEW라는 가상 줄 변수를 사용하여 읽어옴 OLD : 기존 데이터, delete로 삭제 된 데이터 또는 update로 바뀌기 전의 데이터 NEW : 새로운 데이터, insert로 삽입된 데이터 또는 update로 바뀐 후의 데이터 INSERT - 새롭게 데이터가 추가되는 것이므로 이전 데이터는 존재하지 않아 OLD X, NEW O 입니다.\nUPDATE - 기존에 있던 데이터를 새로운 데이터로 변경하는 작업이기 때문에 OLD O, NEW O 입니다.\nDELETE - 기존에 있던 데이터를 지우는 작업이므로 OLD O, NEW X 입니다. DELIMITER $$ CREATE TRIGGER before_to_after -- before_to_after라는 Trigger 이름\nAFTER INSERT ON before_num -- {BEFORE | AFTER} {INSERT | UPDATE | DELETE}중 언제 어떤 작업을 할 지 정해줍니다.\nFOR EACH ROW -- 아래 나올 조건에 해당하는 모든 row에 적용한다는 의미 BEGIN -- Trigger가 실행되는 코드 IF NEW.number THEN -- 새로운 number가 입력됐을 때, INSERT INTO after_num(id, number) VALUES(NEW.id, NEW.number); -- `VALUES(NEW.id, NEW.number)`의 데이터를 after_num의 id, number에 삽입 END IF;\nEND $$ BEGIN ~ END 사이에 조건문과 실행문을 작성\ndelimiter(구문 문자, 문법의 끝) 명시(대부분 $$를 많이 씀)\nTrigger before_to_after는&nbsp;AFTER INSERT ON before_num가 실행되면 자동으로 트리거가 작동하는 구조이기 때문에, before_num 테이블에 새로운 데이터를 삽입해주면 됩니다.INSERT INTO before_num(number) VALUES(1); 앞서 만들었던 Trigger 이름과 명령 등 정보들을 확인\nSHOW triggers;\n<br><img src=\"https://velog.velcdn.com/images/odh0112/post/a62e280a-9aab-4f78-8eca-6d74ee2f7bc6/image.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">-- 전부 삭제\nDELETE TRIGGERS; -- 하나만 삭제\nDROP TRIGGET 트리거이름; 변수 선언은&nbsp;DECLARE&nbsp;명령을 이용해 사용\nBEGIN ~ END 사이에 작성\n-- DECLARE 선언 방법 BEGIN DECLARE 변수 타입 {디폴트값} . . .\nEND\nIF (조건) THEN\nELSEIF (조건) THEN\nELSE\nENDIF\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Trigger","level":1,"id":"Trigger_0"},{"heading":"Trigger 종류","level":2,"id":"Trigger_종류_0"},{"heading":"문장 트리거","level":2,"id":"문장_트리거_0"},{"heading":"행 트리거","level":2,"id":"행_트리거_0"},{"heading":"Trigger 사용법","level":2,"id":"Trigger_사용법_0"},{"heading":"트리거 생성","level":3,"id":"트리거_생성_0"},{"heading":"트리거 실행","level":3,"id":"트리거_실행_0"},{"heading":"트리거 확인","level":3,"id":"트리거_확인_0"},{"heading":"트리거 삭제","level":3,"id":"트리거_삭제_0"},{"heading":"변수 생성","level":3,"id":"변수_생성_0"},{"heading":"조건문","level":3,"id":"조건문_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/backend/sql-트리거.html","pathToRoot":"../..","attachments":[],"createdTime":1725340456332,"modifiedTime":1725357605970,"sourceSize":3684,"sourcePath":"학습 정리/Backend/sql 트리거.md","exportPath":"학습-정리/backend/sql-트리거.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/연결-리스트-이중-연결-리스트(doubly-linked-list).html":{"title":"연결 리스트 - 이중 연결 리스트(Doubly Linked List)","icon":"","description":"<img src=\"https://i.imgur.com/yBv7gns.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">저번에는 단방향으로 자신의 노드 다음 노드만 갈 수 있는 단방향의 연결 리스트가 있었다면 이중 연결 리스트는 해당 노드의 뒤로도 갈 수 있는 포인터가 하나 더 추가된 형태의 연결 리스트이다.작은 차이 같지만 실제 구조에서는 메서드를 작성할 때마다 추가적인 부분이 필요하다. 양쪽의 연결을 계속해서 인지한 채로 노드의 연결을 조정해줘야 한다.작동 방식도 거의 단일 연결 리스트와 같다. 노드가 많이 있지만 인덱스는 없고 헤드와 테일이 있다. class Node { constructor(val) { this.val = val; this.next = null; this.prev = null; }\n} class DoublyLinkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } // 맨 뒤에 새로운 노드 추가하고 뒤의 노드와 서로 연결하는 push 메서드 push(val) { var newNode = new Node(val); // 연결 리스트에 아무것도 없으면 헤드와 테일 모두 newNode가 됨 if (this.length === 0) { this.head = newNode; this.tail = newNode; } else { // next와 prev를 전부 연결해 주어야 함 this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; } this.length++; return this; } // 연결리스트의 마지막 요소 뺴기 pop() { // 바닥조건 if (!this.head) return undefined; // 빼낼 노드를 미리 받아오기 var poppedNode = this.tail; // 연결리스트에 노드가 하나밖에 없었을 떄 if (this.length === 1) { this.head = null; this.tail = null; } // tail을 업데이트하고, 기존의 tail.next값을 nulㅣ로 업데이트 // 빼낸 노드에 존재하는 연결도 끊음 else { this.tail = poppedNode.prev; this.tail.next = null; poppedNode.prev = null; } this.length--; return poppedNode; } // 연결리스트의 맨 앞에서 노드를 제거하는 shift shift() { if (this.length === 0) return undefined; var oldHead = this.head; if (this.length === 1) { this.head = null; this.tail = null; } else { // 헤드를 oldHead 노드 다음 노드로 this.head = oldHead.next; // oldHead의 연결 끊기 oldHead.next = null; // 새로운 헤드의 앞 노드 연결 끊기 this.head.prev = null; } this.length--; return oldHead; } // 연결리스트의 맨 앞에 노드를 추가하는 unshift 메서드 unshift(val) { var newNode = new Node(val); //노드가 하나도 없을 경우 헤드와 테일 모두 newNode로 설정 if (this.length === 0) { this.head = newNode; this.tail = newNode; } else { // 헤드의 앞에 새로운 노드 추가 this.head.prev = newNode; // 새로운 노드의 다음 노드를 현재 헤드에 있는 노드에 연결 newNode.next = this.head; // 새로운 노드를 헤드로 설정 this.head = newNode; } this.length++; return this; } // 연결리스트에서 해당 인덱스에 있는 노드의 값을 찾는 get메서드 get(idx) { // 인덱스가 0보다 작거나 해당 길이보다 같거나 클 경우 해당하는 값이 없으므로 null 리턴 if (idx &lt; 0 || idx &gt;= this.length) return null; var count, current; // 인덱스가 길이의 반보다 같거나 작을 경우 =&gt; 헤드에서부터 시작해서 찾아가는게 유리함 if (idx &lt;= this.length / 2) { count = 0; current = this.head; // 해당 인덱스만큼 옆으로 이동해서 해당 인덱스의 값 찾기 while (count != idx) { current = current.next; count++; } return current; } // 아닐 경우 =&gt; 테일에서부터 하나씩 찾아가는게 유리함 else { count = this.length - 1; current = this.tail; // 한개씩 연결리스트 뒤로 문워크 하면서 인덱스에 있는 값까지 가기 while (count !== idx) { current = current.prev; count--; } return current; } } // 해당하는 인덱스의 연결 리스트 값을 업데이트하는 set 메서드 set(idx, val) { var foundNode = this.get(idx); if (foundNode) { foundNode.val = val; return true; } return false; } // 해당하는 인덱스에 val 값을 가진 노드를 삽입하는 insert 메서드 insert(idx, val) { // 인덱스가 유효하지 않을 경우 false 리턴 if (idx &lt; 0 || idx &gt; this.length) return false; // 인덱스가 0일 경우 unshift 메서드 사용 if (idx === 0) return !!this.unshift(val); // 인덱스가 연결리스트의 길이와 같을 경우 push 메서드 사용 if (idx === this.length) return !!this.push(val); var newNode = new Node(val); var prevNode = this.get(idx - 1); var afterNode = prevNode.next; prevNode.next = newNode; newNode.prev = prevNode; newNode.next = afterNode; afterNode.prev = newNode; this.length++; return true; } // 해당 인덱스의 노드를 삭제하는 remove 메서드 remove(idx) { // 유효허지 않은 인덱스일 경우 undefined 리턴 if (idx &lt; 0 || idx &gt;= this.length) return undefined; // 인덱스가 0일 경우 shift 메서드 사용 if (idx === 0) this.shift(); // 인덱스가 연결리스트의 길이일 경우 pop 메서드 사용 if (idx === this.length - 1) this.pop(); var removedNode = this.get(idx); // 연결 업데이트 removedNode.prev.next = removedNode.next; removedNode.next.prev = removedNode.prev; // 저장된 연결 지우기 removedNode.next = null; removedNode.prev = null; this.length--; return removedNode; }\n} 이중 연결 리스트의 형태는 거의 단일 연결리스트와 비슷하지만 추가적인 포인터가 있다!(이전의 노드를 가리키는 포인터)\n이중 연결 리스트는 탐색에서 절반의 시간이 걸리기 때문에 단일 연결 리스트보다 더 나은 성능을 기대할 수 있다.\n단일 연결 리스트보다 이전의 노드를 가리키는 포인터를 만들면서 메모리를 더 소모하기 때문에 이러한 점을 고려해야 한다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"이중 연결 리스트란?","level":1,"id":"이중_연결_리스트란?_0"},{"heading":"구현","level":2,"id":"구현_0"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_0"},{"heading":"기억해야 할 것들","level":2,"id":"기억해야_할_것들_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/연결-리스트-이중-연결-리스트(doubly-linked-list).html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058366,"modifiedTime":1725254058366,"sourceSize":6886,"sourcePath":"학습 정리/Computer Science/운영체제/연결 리스트 - 이중 연결 리스트(Doubly Linked List).md","exportPath":"학습-정리/computer-science/운영체제/연결-리스트-이중-연결-리스트(doubly-linked-list).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/연결-리스트-단일-연결-리스트(singly-linked-lists).html":{"title":"연결 리스트- 단일 연결 리스트(Singly Linked Lists)","icon":"","description":"단일연결리스트는 원하는 데이터를 저장하는 자료구조 중 하나로, 배열처럼 순서에 따라 다수의 데이터를 저장한다. 하지만 배열과의 차이점이 있다.배열의 경우 각 데이터 Elements는 번호에 의해 인덱스가 부여된다. 새로운 데이터를 추가할 때도 그 위치에 따른 인덱스가 주어진다.반면 연결 리스트들은 다음 데이터 Element를 가리키는 인덱스 없이 그냥 다수의 데이터 Element들로 구성된다. 마치 객차들이 연속으로 연결되어 있는 기차와 같은 형태로 꼬리에 꼬리를 물면서 계속 옆으로 이어지는 형태이다. 하지만 여기서 데이터에 접근하기 위해 사용할 인덱스는 없다는 점이 특징이다. Head 노드부터 옆으로 계속 이어서 옮겨가면서 값을 찾는다.<img src=\"https://i.imgur.com/rcJcYfh.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">class Node { constructor(val) { // 해당 노드의 값 this.val = val; // 다음 노드를 가리킬 공간 this.next = null; }\n} class SinglyLinkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } //push 메서드 =&gt; 새로운 노드 추가 push(val) { var newNode = new Node(val); // 헤드에 아무것도 없을 경우 노드가 아무것도 없다는 뜻 // 새로운 노드를 헤드와 테일 모두에 업데이트 if (!this.head) { this.head = newNode; this.tail = this.head; } // 연결 리스트에 노드가 있을 경우 // 끝에서 다음 노드를 새로운 노드로 하고 마지막 노드를 새로운 노드로 업데이트 else { this.tail.next = newNode; this.tail = newNode; } this.length++; return this; } pop() { if (!this.head) return undefined; // current -&gt; 현재 옆으로 옮기면서 가리키고 있는 노드를 나타냄 var current = this.head; // newTail -&gt; current 이전의 노드를 가리키면서 계속 끌려감 var newTail = current; // 반복문을 통해 노드를 끝까지 옮기기 while (current.next) { newTail = current; current = current.next; } // 테일을 마지막 노드 이전의 노드로 설정 this.tail = newTail; // newTail의 next에 붙어 있던 마지막 노드를 없애기 newTail.next = null; // 연결 리스트의 길이 하나 줄이기 this.length--; // 연결 리스트가 하나도 없을 경우 -&gt; 헤드와 테일을 null로 재설정 if (this.length === 0) { this.head = null; this.tail = null; } return current; } // shift -&gt; 연결리스트의 앞에서 노드를 제거 shift() { if (!this.head) return undefined; var currHead = this.head; this.head = currHead.next; // 연결 리스트 길이 줄이기 this.length--; // next가 남는 문제 해결 if (this.length === 0) { this.head = null; this.tail = null; } return currHead; } // unshift =&gt; 맨 앞에 부분에 노드를 붙여넣기 unshift(val) { // 새로운 노드 생성 var newNode = new Node(val); // 아무 노드도 없을 경우 // 헤드를 들어오는 노드로 만들고 테일도 똑같이 만듦 if (!this.head) { this.head = newNode; this.tail = this.head; } // 노드가 있을 경우 // 현재 헤드를 새로운 노드 다음으로 밀고 헤드를 새로운 노드로 설정 else { newNode.next = this.head; this.head = newNode; } this.length++; return this; } // 받은 인덱스값에 해당하는 연결 리스트의 값을 리턴 get(idx) { // 해당하는 인덱스 값이 없는 경우(범위초과) null 리턴 if ((idx &lt; 0 &amp;&amp; idx) || !this.length) return null; var counter = 0; var current = this.head; // 인덱스만큼 연결리스트를 따라 옮겨감 while (counter !== idx) { current = current.next; counter++; } return current; } // 인덱스와 값을 받고 해당하는 인덱스의 값을 받은 값으로 업데이트 set(idx, val) { // 만들어둔 get 메서드를 통해 해당하는 인덱스의 노드를 가져옴 var foundNode = this.get(idx); // 해당하는 노드가 있다면 if (foundNode) { // 노드의 값 업데이트 foundNode.val = val; // true 반환 return true; } // 없다면 false 반환 return false; } //인덱스와 값을 받아들여 해당하는 인덱스 위치에 받은 값을 삽입 insert(idx, val) { // 범위에 벗어나는 인덱스일 경우 false 리턴 if (idx &lt; 0 || idx &gt; this.length) return false; // 연결리스트의 길이와 인덱스가 같으면 맨 오른쪽에 요소 삽입 =&gt; push 메서드 사용 if (idx === this.length) { this.push(val); return true; } // 인덱스가 0일 경우 가장 앞에 삽입 =&gt; unshift 메서드 + 반환값에 !!를 붙여 불리언으로 바꾸기 if (idx === 0) !!this.unshift(val); // 삽입할 노드 만들기 var newNode = new Node(val); // 해당 인덱스 이전의 노드를 찾아오기 =&gt; get 메서드 var prev = this.get(idx - 1); // 노드를 보존하면서 넣기 위해 스왑용 변수 만들기 var temp = prev.next; // 이전 노드의 다음 노드를 새로운 노드를 가리키도록 변경 prev.next = newNode; // 이전 노드의 다음 노드를 새로운 노드의 다음 노드로 변경 newNode.next = temp; // 길이 추가 this.length++; return true; } remove(idx) { // 인덱스가 0보다 작거나 길이보다 클 경우 undefined 리턴 if (idx &lt; 0 || idx &gt; this.length) return undefined; // 인덱스가 길이와 같을 경우 가장 오른쪽에 있으므로 pop 메서드 사용 if (idx === this.length) this.pop(); // 인덱스가 0일 경우 가장 왼쪽에 있으므로 shift 메서드 사용 if (idx === 0) this.shift(); // 이전 노드의 다음 노드를 설정하기 위해 이전 노드 접근 var prev = this.get(idx - 1); var removed = prev.next; // 이전 노드의 다음 노드의 다음 노드를 이전 노드의 다음 노드로 변경해서 바로 다음이었던 노드를 삭제 prev.next = removed.next; // 길이가 하나 줄어들기 떄문에 하나 빼기 this.length--; return prev.mext; } // 단순 출력하여 연결 리스트 파악용 메서드 print() { var arr = []; var current = this.head; while (current) { arr.push(current.val); current = current.next; } console.log(arr); } // 연결리스트를 돌면서 처음부터 연결 리스트의 방향을 바꾸는 메서드 reverse() { // 미리 헤드와 테일을 바꿔놓는 작업 var node = this.head; this.head = this.tail; this.tail = node; var next; // prev가 null이 되어야 하는 이유는 tail의 next가 null이기 때문 var prev = null; for (var i = 0; i &lt; this.length; i++) { next = node.next; node.next = prev; // 반대방향으로 가면서 이전 노드는 곧 현재 노드가 됨 prev = node; // 현재의 노드는 next 노드로 재설정 node = next; } return this; }\n}\n단방향 연결 리스트는 삽입과 삭제에 있어서 의 시간을 가지기 때문에 배열에 비해 우수한 성능을 가지고 있다. 따라서\n삽입/삭제 작업을 주로 해야 할 때\n임의 접근 작업이 필요없을 때\n주어진 순서대로 데이터를 접근/관리할 필요가 있을 때\n중간의 노드를 접근할 필요가 없을 때\n와 같은 상황에서 단방향 연결 리스트가 보다 성능이 좋다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"단일 연결 리스트란?","level":1,"id":"단일_연결_리스트란?_0"},{"heading":"용어정리","level":2,"id":"용어정리_0"},{"heading":"구현","level":2,"id":"구현_0"},{"heading":"시간복잡도","level":2,"id":"시간복잡도_0"},{"heading":"결론","level":2,"id":"결론_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/연결-리스트-단일-연결-리스트(singly-linked-lists).html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058366,"modifiedTime":1725254058366,"sourceSize":9519,"sourcePath":"학습 정리/Computer Science/운영체제/연결 리스트- 단일 연결 리스트(Singly Linked Lists).md","exportPath":"학습-정리/computer-science/운영체제/연결-리스트-단일-연결-리스트(singly-linked-lists).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제.html":{"title":"운영체제","icon":"","description":" <a data-href=\"운영체제_1주차_기본 구성요소, 명령어 수행, 인터럽트\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_1주차_기본 구성요소, 명령어 수행, 인터럽트</a><br>\n<a data-href=\"운영체제_메모리 계층 구조, 캐시 메모리, IO연산 기법, 멀티프로세서와 멀티코어\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_메모리 계층 구조, 캐시 메모리, IO연산 기법, 멀티프로세서와 멀티코어</a><br>\n<a data-href=\"운영체제_운영체제의 목적 및 기능\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_운영체제의 목적 및 기능</a><br>\n<a data-href=\"운영체제_운영체제 개요_최근 운영체제로의 발전\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_운영체제 개요_최근 운영체제로의 발전</a><br>\n<a data-href=\"운영체제_운영체제 개요_결함 허용\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_운영체제 개요_결함 허용</a><br>\n<a data-href=\"운영체제_운영체제 개요_멀티프로세서와 멀티코어를 위한 운영체제 설계 사항\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_운영체제 개요_멀티프로세서와 멀티코어를 위한 운영체제 설계 사항</a><br>\n<a data-href=\"운영체제_프로세스 기술과 제어_프로세스란?,프로세스 상태\" href=\"https://alsgud8311.github.io/.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_프로세스 기술과 제어_프로세스란?,프로세스 상태</a><br>\n<a data-href=\"운영체제_프로세스 기술과 제어_프로세스 기술\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_프로세스 기술과 제어_프로세스 기술</a><br>\n<a data-href=\"운영체제_프로세스 기술과 제어_프로세스 제어\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_프로세스 기술과 제어_프로세스 제어</a><br>\n<a data-href=\"운영체제_프로세스 기술과 제어_운영체제의 수행\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_프로세스 기술과 제어_운영체제의 수행</a><br>\n<a data-href=\"운영체제_스레드_프로세스와 스레드\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_스레드_프로세스와 스레드</a><br>\n<a data-href=\"운영체제_스레드_스레드의 유형\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_스레드_스레드의 유형</a><br>\n<a data-href=\"운영체제_스레드_멀티코어와 멀티스레딩\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_스레드_멀티코어와 멀티스레딩</a><br>\n<a data-href=\"운영체제_병행성_병행성의 원리\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_병행성_병행성의 원리</a><br>\n<a data-href=\"운영체제_병행성_상호 배제-하드웨어 지원\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_병행성_상호 배제-하드웨어 지원</a><br>\n<a data-href=\"운영체제_병행성_세마포어\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_병행성_세마포어</a><br>\n<a data-href=\"운영체제_병행성_모니터\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_병행성_모니터</a><br>\n<a data-href=\"운영체제_병행성_교착상태와 기아상태_교착상태의 원리\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_병행성_교착상태와 기아상태_교착상태의 원리</a><br>\n<a data-href=\"운영체제_병행성_교착상태와 기아상태_교착상태 예방,회피,발견\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_병행성_교착상태와 기아상태_교착상태 예방,회피,발견</a><br>\n<a data-href=\"운영체제_병행성_교착상태와 기아상태_교착상태 발견\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_병행성_교착상태와 기아상태_교착상태 발견</a><br>\n<a data-href=\"운영체제_병행성_교착상태와 기아상태_식사하는 철학자 문제\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_병행성_교착상태와 기아상태_식사하는 철학자 문제</a><br><a data-href=\"운영체제_메모리 관리_메모리 관리 요구조건\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_메모리 관리_메모리 관리 요구조건</a><br>\n<a data-href=\"운영체제_메모리 관리_메모리 분할(memory partitioning)\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_메모리 관리_메모리 분할(memory partitioning)</a><br>\n<a data-href=\"운영체제_메모리 관리_페이징\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_메모리 관리_페이징</a><br>\n<a data-href=\"운영체제_메모리 관리_세그먼테이션\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_메모리 관리_세그먼테이션</a><br>\n<a data-href=\"운영체제_가상 메모리_하드웨어와 제어구조\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_가상 메모리_하드웨어와 제어구조</a><br>\n<a data-href=\"운영체제_가상메모리_운영체제 소프트웨어\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_가상메모리_운영체제 소프트웨어</a><br>\n<a data-href=\"운영체제_가상메모리_Linux, Windows의 가상 메모리\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_가상메모리_Linux, Windows의 가상 메모리</a><br>\n<a data-href=\"운영체제_단일처리기 스케줄링_처리기 스케줄링의 유형\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_단일처리기 스케줄링_처리기 스케줄링의 유형</a><br>\n<a data-href=\"운영체제_단일처리기 스케줄링_스케줄링 알고리즘\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_단일처리기 스케줄링_스케줄링 알고리즘</a><br>\n<a data-href=\"운영체제_입출력 관리와 디스크 스케줄링_입출력 장치, 입출력 기능 구성\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_입출력 관리와 디스크 스케줄링_입출력 장치, 입출력 기능 구성</a><br>\n<a data-href=\"운영체제_입출력 관리와 디스크 스케줄링_운영체제 설계 이슈\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_입출력 관리와 디스크 스케줄링_운영체제 설계 이슈</a><br>\n<a data-href=\"운영체제_입출력 관리와 디스크 스케줄링_입출력 버퍼링\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_입출력 관리와 디스크 스케줄링_입출력 버퍼링</a><br><a data-href=\"운영체제_입출력 관리와 디스크 스케줄링_디스크 스케줄링\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_입출력 관리와 디스크 스케줄링_디스크 스케줄링</a><br>\n<a data-href=\"운영체제_입출력 관리와 디스크 스케줄링_RAID\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_입출력 관리와 디스크 스케줄링_RAID</a><br>\n<a data-href=\"운영체제_입출력 관리와 디스크 스케줄링_디스크 캐시\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_입출력 관리와 디스크 스케줄링_디스크 캐시</a><br>\n<a data-href=\"운영체제_입출력 관리와 디스크 스케줄링_UNIX SVR4의 입출력\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_입출력 관리와 디스크 스케줄링_UNIX SVR4의 입출력</a><br>\n<a data-href=\"운영체제_파일 관리_개요\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_파일 관리_개요</a><br>\n<a data-href=\"운영체제_파일 관리_파일 구성과 접근\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_파일 관리_파일 구성과 접근</a><br>\n<a data-href=\"운영체제_파일 관리_B-트리, 파일 디렉토리\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_파일 관리_B-트리, 파일 디렉토리</a><br>\n<a data-href=\"운영체제_파일관리_파일 공유와 레코드 블로킹\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_파일관리_파일 공유와 레코드 블로킹</a><br>\n<a data-href=\"운영체제_파일관리_보조 저장공간 관리\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_파일관리_보조 저장공간 관리</a><br>\n<a data-href=\"운영체제_파일 관리_UNIX의 파일 관리\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_파일 관리_UNIX의 파일 관리</a><br>\n<a data-href=\"운영체제_파일 관리_Linux의 가상파일시스템과 windows 파일 시스템\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제_파일 관리_Linux의 가상파일시스템과 windows 파일 시스템</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html#_0","학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html#_0","학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html#_0","학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html#_0","학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html#_0","학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html#_0",".html","학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html#_0","학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html#_0","학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html#_0","학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html#_0","학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html#_0","학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html#_0","학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html#_0","학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html#_0","학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html#_0","학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html#_0","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html#_0","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html#_0","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html#_0","학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html#_0","학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html#_0","학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html#_0","학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html#_0","학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html#_0","학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html#_0","학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html#_0","학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html#_0","학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html#_0","학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html#_0","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html#_0","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html#_0","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html#_0","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html#_0","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html#_0","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html#_0","학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html#_0","학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html#_0","학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html#_0","학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html#_0","학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html#_0","학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html#_0","학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html#_0","학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058366,"modifiedTime":1738514203775,"sourceSize":3017,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제.md","exportPath":"학습-정리/computer-science/운영체제/운영체제.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html":{"title":"운영체제_1주차_기본 구성요소, 명령어 수행, 인터럽트","icon":"","description":"컴퓨터는 4가지 기본 구성요소로 이루어진다.\n처리기(프로세서 Processor) 컴퓨터의 동작 제어 및 데이터 처리. 중앙처리장치(CPU)로 불림 주기억장치(main memory) 데이터와 프로그램 저장\n휘발성(volatile)을 가짐\n실기억장치(real memory) 또는 주메모리(primary memory)로도 불림 입출력 모듈(I/O module) 컴퓨터와 외부환경 간의 데이터 이동 담당.\n외부 환경은 보조기억장치, 통신장비, 단말기 등 다양한 외부 장치로 구성 시스템 버스(System bus) 처리기, 주기억장치, 그리고 입출력 모듈 간의 통신 제공<img src=\"https://i.imgur.com/2kDGX4t.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> CPU의 기능인 메모리와 데이터의 교환 기능\n메모리 주소 레지스터(Memory Address Register) 다음에 Read/Write할 메모리의 주소를 기록\n이후 메모리 버퍼 레지스터(Memory Buffer Register) 로는 메모리에 기록되거나 메모리부터 읽힐 데이터를 저장 입출력 주소 레지스터와 입출력 버퍼 레지스터도 동일한 방식으로 입출력 모듈과 처리기 간의 데이터 교환을 위해 사용된다. 프로그램은 처리기에 의해 수행되고 메모리에 저장된 명령어들의 집합으로 구성\n단일 명령어 수행에서 필요한 처리 과정은 명령어 사이클(instruction cycle)<br>\n<img src=\"https://i.imgur.com/5YN41zb.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 각 명령어 사이클이 시작될 때 처리기가 메모리로부터 명령어를 가져옴 프로그램 카운터(PC)가 다음에 가져올 명령어의 주소를 가지고 있어서 얘가 가져옴 각 명령어를 반입한 후 PC를 증가시켜 순서대로 다음 명령어가 순차적으로 가져와짐\n반입된 명령어는 처리기 내의 명령어 레지스터(IR: Instruction Register)로 적재됨\n처리기가 명령어를 해석하고 요구된 작업 수행 처리기-메모리 데이터는 처리기로부터 메모리로 / 메모리로부터 처리기로 전송될 수 있음 처리기-입출력 처리기와 입출력 모듈 간의 전송을 통해 주변장치로 또는 주변장치로부터 데이터 전송될 수 있음 데이터 처리 처리기는 데이터에 대해 산술 또는 논리 연산을 수행 가능 제어\n- 명령어는 수행 순서 변경 명시 가능. 다음 실행할 명령어의 메모리 주소를 다른 것들로 반입시킴.<br>\n<img src=\"https://i.imgur.com/XrtwU5m.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n명령어 형식에서 연산 코드는 4비트를 차지하고, 나머지 12비트는 주소\n해당 명령어 형식은 처리기마다 다르며, 기기에 맞는 기계 명령어로 컴파일해줌\n아래 정수 형식의 경우에는 값(data)를 저장 맨 앞은 부호를 의미하며, 옆 절대값은 +, - 값이 있는 만큼 2의 보수로 기록 연산코드의 경우\n0001(1) = 메모리에 저장된 값을 AC에 적재\n0010(2) = AC에 저장된 값을 메모리에 저장\n0101(5) = 메모리에 저장된 값을 AC에 더함\n세 가지가 있다.\n<br><img src=\"https://i.imgur.com/OVNJKFN.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n해당 프로그램 수행의 예시를 통해 보자.\n현재 프로그램 카운터(PC)는 300을 가리킴. 메모리의 300번지의 경우 1940을 명령어 레지스터(IR)로 보냄. 프로그램 카운터(PC)는 1 증가\n명령어 레지스터의 1940에서 앞 1은 메모리에 저장된 값을 AC에 적재하는 연산코드이므로 뒤 940의 메모리 주소를 가진 값을 AC에 저장. 따라서 940 번지의 0003이라는 값이 AC에 적재됨.\n301번지의 명령어 5941을 반입. 연산 코드 5의 경우 메모리에 저장된 값을 AC에 더하는 연산코드. PC 증가\n메모리 주소인 941에 있는 값 0002를 가져와 AC에 있는 0003과 합하여 5를 저장. 메모리 주소 302에서 다음 명령어 2941이 반입. 연산코드 2의 경우 AC에 저장된 값을 메모리에 저장\n명시되어있는 941 메모리 주소에 더한 단계1~4까지 수행된 후 AC의 값 0005를 저장.\n의 과정을 거친다.모든 컴퓨터는 처리기의 일반적 처리에 다른 모듈들(입출력, 메모리)이 인터럽트를 걸 수 있도록 허용한다. 일반적인 인터럽트 부류는 아래와 같다\n인터럽트는 처리기의 처리율 향상을 위해 제공\n여러 입출력 장치들이 있을 때 각 입출력 장치들은 명령어 사이클 기법을 사용하여 데이터를 전송\n하지만 문제는 이런 매번 쓰기/읽기 연산 이후 처리기는 수행을 일시 중지하고 입출력장치가 동작을 완료할 때까지 유휴상태가 되는데, 이러한 유휴 상태의 시간이 매우 길어 그 시간동안 수백, 수천개의 명령어 사이클을 동작할 수 있음에도 낭비하는 상황 발생\n그러한 처리기의 낭비를 막기 위해 도입된 것이 인터럽트\n<br><img src=\"https://i.imgur.com/8b8pQOa.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n위 사진에서 1번은 사용자 프로그램을 실행했을 경우\n사용자 프로그램은 실행 도중에 중간중간 2번의 WRITE 호출\nWRITE 호출은 시스템 유틸리티인 입출력 루틴이며, 실제 입출력 연산을 수행\n입출력 프로그램은 세 단계로 구성 4번처럼 실제 입출력 연산을 준비하는 명령어가 출력될 데이터를 특별한 버퍼에 복사하고 장치 명령을 위한 매개변수를 준비\n2번과 같이 명령을 내리고 나면 프로그램은 입출력 장치가 요청된 기능을 수행하도록 기다림. 이 과정에서 인터럽트가 없으면 그저 기다리거나 단순히 테스트 연산을 반복 수행하면서 대기한다\n5번과 같이 연산을 완료하기 위한 일련의 명령어를 실행하여 연산의 성공 또는 실패 여부를 나타내는 플래그를 설정하는 등의 동작을 수행한다 a와 같이 인터럽트가 없는 경우 첫 번째 WRITE 명령어를 만나면 인터럽트가 걸리고 I/O 프로그램으로 실행이 계속되며 입출력 연산을 완료할 때까지 기다려야 하는 시간동안 처리기는 수행이 정지되어 낭비\n<br><img src=\"https://i.imgur.com/17omgB3.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n하지만 b와 같은 경우 WRITE 형태의 시스템 호출을 하는 지점에서 입출력 프로그램은 준비 코드와 실제 입출력 명령어를 수행하고 제어가 다시 사용자 프로그램으로 리턴되지만 외부 장치는 해당 기능을 수행하고 있음 외부 장치가 만약에 다 끝난 후 다시 서비스할 준비가 되면 처리기로부터 더 받을 수 있다고 인터럽트 요청 신호를 처리기로 보냄\n그럼 처리기는 수행중이던 프로그램의 작업을 보류하고, 해당 입출력 장치를 인터럽트 처리기라는 프로그램으로 분기하며 장치에 대한 서비스 후에 보류했던 프로그램의 수행을 재개한다.\nWRITE 연산 후 2a와 2b로 나누어진 이유가 이 때문 X로 표기되어 있는 부분에서 인터럽트 요청이 일어나며, 정상적인 프로그램의 수행되다가 잠깐 중지시킨 다음 인터럽트부터 처리 후 원래 프로그램의 수행이 재개됨\n이러한 수행의 중지와 재개는 처리기와 운영체제에서 관리 <br><img src=\"https://i.imgur.com/UMFXA8F.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n명령어 사이클에 인터럽트 단계(interrupt stage)가 추가된 버전 인터럽트 단계에서 처리기는 인터럽트의 발생 여부(인터럽트 신호 존재 여부)를 검사\n처리할 인터럽트가 없을 경우 : 처리기는 반입 단계로 진행하고 현재 프로그램의 다음 명령어 가져옴\n처리할 인터럽트가 있을 경우: 프로그램의 수행을 중지시키고 인터럽트 처리기 루틴 수행\n인터럽트 처리기 루틴이 완료되면 처리기는 인터럽트가 발생한 지점에서 사용자 프로그램의 수행 재개\n=&gt; 중간의 대기 시간을 효율적으로 사용 위와 같은 단계는 사용자 프로그램에서 쓰기 연산 간의 명령어 수행을 완료하는데 요구되는 시간보다 입출력 연산에 필요한 시간이 더 짧을 때를 가정하고 동작 과정을 설명\n하지만 프린트와 같이 입출력 연산 시간이 일련의 사용자 명령어를 수행하는 시간보다 훨씬 더 오래 걸리는 경우도 고려해야 함\n<br><img src=\"https://i.imgur.com/SXMhaJo.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n긴 입출력 대기의 경우에도 사용자 프로그램은 첫 번째 호출에 의한 입출력 연산이 완료되기 전에 두 번째 WRITE 호출에 이르게 되고, 결과적으로는 여기서 멈춤\n그러다가 이 입출력 연산이 완료되면 그 때 새로운 WRITE 호출이 진행되어 새로운 입출력 연산이 시작됨\n이렇게 된다면 2번의 사용자 프로그램은 대기 시간 없이 바로 실행된 이후에 대기시간을 가지는 것이기 때문에 입출력 작업 시간의 일부가 사용자 명령어 수행 시간과 겹치는 부분이 있어 효율적 측면에서 이득임을 알 수 있다. 인터럽트가 발생하면 처리기 하드웨어와 소프트웨어에서 많은 이벤트가 발생한다.\n해당 이벤트의 과정 📚📚📚<br>\n<img src=\"https://i.imgur.com/tlJfV4k.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 장치가 인터럽트 시그널을 처리기로 보냄\n인터럽트에 응답하기 전에 처리기는 현재 수행중인 명령어를 완료\n처리기는 대기중인 인터럽트 요청이 있는지 검사하여 알게 되고, 인터럽트를 발생시킨 장치에게 수신 확인 신호를 전송. 확인 후 해당 장치가 인터럽트 신호를 제거할 수 있음\n처리기가 제어를 인터럽트 루틴으로 넘기기 위해 준비. 먼저 인터럽트가 발생한 지점에서 현재 진행중인 프로그램을 인터럽트가 끝난 시점에 다시 재개해야 하기 때문에 저장해야 할 필요성을 가짐. 최소한의 정보는 프로그램 상태 워드(PSW)이며, 프로그램 카운터 안에 있는 내용 등이 들어가 있음. 이러한 정보는 시스템 제어 스택에 저장됨.\n처리기는 인터럽트에 응답할 인터럽트 처리 루틴의 진입 위치를 프로그램 카운터에 적재. 컴퓨터 구조와 운영체제마다 인터럽트 처리 루틴은 다른데, 만약 한 개 이상의 인터럽트 처리 루틴이 제공되면 여기서 처리기는 어느 루틴을 호출할 지 결정해야 함. 인터럽트 신호 안에 있기도 하지만 인터럽트 발생 입출력 장치에게 요청할 수도 있음.\n프로그램 카운터 적재 후 처리기가 다음 명령어 사이클의 명령어 반입부터 진행하여 다음 처리기의 제어가 인터럽트 처리기 프로그램으로 넘어감(기존 실행중이었던 프로그램 카운터와 PSW는 제어 스택에 보관)\n이 시점에서 처리기 레지스터의 내용들은 기존에 작업하던 내용들을 담고 있고 재개할때 필요하므로 인터럽트 처리기가 모든 레지스터의 내용을 스택에 저장. 저장하는 과정은 아래와 같이 N번지 명령어 이후 인터럽트가 발생했을 때의 예제를 다루고 있는데, 이 때 모든 레지스터의 내용과 다음 명령어의 주소(N+1), 전체적으로 M개의 워드가 제어 스택에 들어감. 스택 포인터는 새로 설정된 스택의 최상단을 가리키고 프로그램 카운터는 인터럽트 서비스 루틴의 시작을 가리키도록 갱신.<br>\n<img src=\"https://i.imgur.com/dSGSemu.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n인터럽트 처리기가 인터럽트를 처리한다. 입출력과 관련된 상태 정보에 대한 조사 작업 과정에서 입출력 장치로 추가적인 명령이나 확인을 보낼 수 있다.\n인터럽트 처리가 완료되면, 저장된 레지스터 값을 검색하여 레지스터에 다시 저장한다.\n다시 기존에 진행중인 프로그램을 재개해야 하므로 스택으로부터 PSW와 프로그램 카운터 값을 인터럽트 발생 이전으로 복원한다. 이후에는 수행될 다음 명령어가 인터럽트 당한 프로그램으로부터 나온다. 하나의 인터럽트만 발생하는 경우도 있겠지만, 하나 이상의 인터럽트가 발생하는 경우도 있음. 예를 들어 데이터를 하나씩 전송받아 인쇄하는 경우 하나의 프린트 연산이 완료될 때마다 인터럽트가 생성됨\n이런 경우에 프린터 인터럽트 처리 동안 통신 인터럽트가 발생할 가능성도 있음 이런 경우 중첩 인터럽트를 처리해야 하는데, 처리 방법에는 두 가지가 있음 <br>하나의 인터럽트를 처리하는 동안 다른 인터럽트 금지<img src=\"https://i.imgur.com/vwrGhZc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 처리기가 인터럽트 처리 동안 오는 인터럽트 요구 신호를 무시하고 남겨놨다가 처리기가 인터럽트 발생을 허용한 후에 처리된다. 이런 방식은 순차적으로 인터럽트가 실행되기 때문에 순차적 인터럽트 처리라고도 불린다. <br>인터럽트 간의 우선순위를 정의하고 높은 우선순위 인터럽트가 낮은 순위 인터럽트를 인터럽트할 수 있도록 허용<img src=\"https://i.imgur.com/4g9wXBm.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 만약에 계층 구조가 있는 인터럽트가 있다면 계층의 순서대로 인터럽트를 중첩시켜 순서대로 상태를 스택에 저장하면서 중첩시켜 문제를 없애면서도 인터럽트 중첩으로 처리기를 조금 더 활용 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제1주차기본 구성요소, 명령어 수행, 인터럽트","level":1,"id":"운영체제1주차기본_구성요소,_명령어_수행,_인터럽트_0"},{"heading":"기본 구성유소","level":3,"id":"기본_구성유소_0"},{"heading":"명령어 수행","level":3,"id":"명령어_수행_0"},{"heading":"명령어 사이클 순서","level":4,"id":"명령어_사이클_순서_0"},{"heading":"명령어 사이클의 범주 분류","level":4,"id":"명령어_사이클의_범주_분류_0"},{"heading":"인터럽트","level":3,"id":"인터럽트_0"},{"heading":"인터럽트 처리","level":3,"id":"인터럽트_처리_0"},{"heading":"중첩 인터럽트","level":3,"id":"중첩_인터럽트_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058366,"modifiedTime":1725254058366,"sourceSize":14863,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_1주차_기본 구성요소, 명령어 수행, 인터럽트.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html":{"title":"운영체제_가상 메모리_하드웨어와 제어구조","icon":"","description":"\n프로세스의 모든 메모리 참조는 논리주소이며, 프로세스 수행 시간에 동적으로 물리주소로 변환\n=&gt; 한 프로세스가 스와핑으로 주기억장치에 적재할 때 다른 위치에 적재 가능함을 의미\n한 프로세스의 주소공간은 여러 블록으로 분할될 수 있고, 프로세스 수행 중 이 블록들은 주기억장치의 연속된 영역에 위치할 필요가 없음\n=&gt; 프로세스가 수행될 때 페이지(혹은 세그먼트) 테이블을 활용해 동적으로 주소를 변환함으로써 가능케됨\n=&gt; 수행 시간에 프로세스의 모든 페이지(혹은 세그먼트)가 주기억장치에 적재될 필요가 없음(적재집합) 적재집합(resident set)\n프로세스의 코드나 데이터 중 임의 시점에 주기억장치에 적재되어 있는 부분\n주기억장치에 적재되지 않은 논리주소가 참조(적재집합에 없는 메모리 참조)되었을 경우\n-&gt; 처리기는 메모리 접근 오류(memory access fault)를 의미하는 인터럽트 발생\n-&gt; 인터럽트 당한 프로세스를 블록 상태에 두고 제어를 넘겨받음\n-&gt; 디스크 입출력 요청\n-&gt; 다른 프로세스에게 CPU를 넘겨 디스크 입출력이 진행되는 동안 수행\n-&gt; 운영체제가 제어를 돌려받고 이전에 메모리 접근 오류를 발생시켜 블록 되었던 프로세스를 준비 상태로 전환시킴위 새로운 기법의 장점\n보다 많은 프로세스를 주기억장치에 유지 가능 각 프로세스에 대해 일부 블록들만 적재 주기억장치보다 큰 프로세스 수행 가능 프로그래밍에 있어 가장 근본적 제약점 중 하나 제거 페이징과 세그먼테이션에 가상메모리를 적용했을 때와 적용하지 않았을 때가상 메모리(Virtual memory)\n프로그래머나 사용자가 가지는 디스크 상에 할당된 훨씬 큰 잠재적 메모리\n효과적인 멀티프로그래밍을 허용하면서도 주기억장치를 사용할 때의 엄격한 제약을 해소시켜 줌 긴 프로그램과 다수의 데이터 배열로 구성된 큰 프로세스의 경우 모두 적재 시 비경제적\n=&gt; 각 프로세스는 메모리 상에 몇 개의 블록만 가지게 되고, 이를 통해 보다 많은 프로세스를 메모리에 유지할 수 있음 쓰레싱(thrashing) 과도한 스와핑으로 인한 블록 이동\n=&gt; 지역성의 원리(프로세스 내의 명령어 및 데이터에 대한 참조가 가지는 군집화 경향) 에 기초하여 해결 가상 메모리를 실용적이고 효과적으로 사용하기 위해 필요한 요소 하드웨어(페이징,세그멘테이션) + 소프트웨어(블록 이동) 프로세스마다 고유의 페이지 테이블을 가짐 프로세스의 페이지들이 적재될 때 주기억장치에 설정\n각 페이지테이블 항목에는 해당 페이지가 적재된 페이지프레임의 번호와 패리티비트(존재비트) P와 함께 저장\n해당 페이지가 메모리에 적재된 후 그 내용이 변경되었는지 여부를 나타내는 변경비트 M를 가짐 페이징의 장점 투명한 페이징으로 외부단편화를 없애 주기억장치를 효율적으로 사용\n블록들이 고정 크기이기 때문에 프로그램의 행태\u001e에 부합되는 정교한 메모리 관리 알고리즘 개발 가능 <img src=\"https://i.imgur.com/wYVNpPL.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/9XSR7RV.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 메모리에서 한 워드를 읽을 때마다 페이지 번호와 오프셋으로 구성된 가상 주소가 물리 주소(프레임번호+오프셋)로 변환 페이지 테이블 시작 주소 특정 레지스터에 저장 일반적으로 페이지 번호 필드가 프레임 번호 필드보다 긺(n&gt;m) 프로세스당 하나의 페이지 테이블 설정으로 메모리가 큼<br>\n=&gt; 큰 페이지테이블을 구성하기 위해 2단계 구조 사용<img src=\"https://i.imgur.com/nWSB8qD.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 32비트 주소체계의 경우 4KB()의 페이지\n=&gt; 4GB() 크기의 가상주소공간 설정\n=&gt; 페이지 각각이 4바이트\n=&gt; 개의 PTE(Page Table Entry)로 구성된 4MB(1MB*4) 크기의 페이지테이블을 만들 수 있음\n=&gt; 개의 페이지를 차지하는 페이지테이블이 개의 PTE를 가지는 4KB의 루트 페이지 테이블에 사상되어 가상메모리 상에 유지 루트 페이지는 주기억장치에 상주<br>\n<img src=\"https://i.imgur.com/1cGinwb.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 가상 주소의 처음 10비트는 루트 페이지에 대한 인덱스로 쓰이며 사용자 페이지테이블이 저장된 페이지를 위한 PTE를 찾아줌 그 페이지가 주기억장치에 없다면 페이지폴트 발생 주기억장치에 있다면 다음 10비트가 사용자 페이지테이블에 대한 인덱스로 쓰여 실제 페이지를 위한 PTE를 찾음 페이지테이블의 단점 크기가 가상주소공간 크기에 비례\n=&gt; 역페이지테이블의 사용 <br>역페이지테이블<img src=\"https://i.imgur.com/efzVDYb.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 페이지번호 부분이 해시함수를 통해 특정 해시값으로 매핑\n페이지테이블 항목의 개수가 실기억장치의 페이지프레임당 하나씩 설정\n동일 해시 값에 의해 오버플로우 체인 필요 역페이지 테이블 제어비트 유효(valid)\n참조(reference)\n변경(modify)\n보호(pretection)\n잠금(locking) <br><img src=\"https://i.imgur.com/viqCk2r.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n모든 가상메모리 참조 -&gt; 2번의 물리메모리 참조 페이지테이블 항목 참조\n요구된 데이터 접근\n=&gt; 두 배의 메모리 접근 시간\n=&gt; 페이지테이블 항목들에 대한 특수 고속 캐시 사용(TLB) 가장 최근에 참조된 페이지테이블 항목들을 유지\n페이지테이블 항목의 존재비트가 0일 경우 페이지폴트(page fault) 발생\n<br><img src=\"https://i.imgur.com/CfznrlT.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n가장 처음 TLB에 페이지테이블 항목이 있는지 확인 있을 경우(TLB hit) -&gt; 바로 프레임 번호 추출되어 실주소 구성\n없을 경우(TLB miss) -&gt; 페이지 번호로 페이지테이블을 인덱싱하여 페이지테이블 항목 참조 요구된 페이지가 주기억장치에 없을 때 페이지폴트 처리 루틴(인터럽트) 호출\n지역성의 원리에 의해 대부분의 가상주소 참조는 최근에 사용된 페이지들 내의 위치들로 한정 -&gt; 대부분의 참조는 캐시 안에 있는 페이지테이블 항목과 연계\n<br><img src=\"https://i.imgur.com/1miFOpe.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n페이지 번호가 곧 페이지 테이블 내에서 인덱싱하여 직접적으로 접근할 수 있게끔 사용됨 TLB는 페이지테이블의 일부 항목들만 포함. 대신 항목들은 페이지 번호도 포함해야 함\n처리기에 특정 페이지 번호와 일치하는 TLB 항목이 있는지 조사하는 하드웨어 장착\n<br><img src=\"https://i.imgur.com/efhuQCq.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n메모리 시스템은 일치하는 페이지테이블 항목이 TLB 상에 존재하는지 조사 존재 -&gt; 프레임 번호와 오프셋이 결합된 실주소 생성\n비존재 -&gt;페이지테이블 상의 해당 항목 접근 실주소 생성\n해당 워드를 포함한 블록이 캐시 상에 존재하는지 조사 존재 -&gt; 캐시 상의 해당 워드가 CPU에게 보내짐\n비존재 -&gt; 해당 워드는 주기억장치로부터 읽힘 <br><img src=\"https://i.imgur.com/10eIbdw.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n내부 단편화 페이지가 작을수록 적어짐 페이지가 작을 경우 큰 페이지테이블 필요\n두 번의 페이지폴트 가능성(페이지테이블 + 프로세스페이지)\n페이지의 개수가 많아져 페이지폴트 빈도 감소 페이지가 클 경우 개별 페이지들이 최근의 참조로부터 보다 멀리 떨어진 위치를 포함하여 지역성의 원리에 따른 효과 감소\n-&gt; 페이지폴트 발생률 증가\n페이지 크기가 프로세스 전체 크기일 경우 페이지폴트 발생 X 한 프로세스에 할당된 프레임 개수도 페이지폴트 발생률에 영향 페이지 크기가 고정 + 주기억장치에 유지되는 페이지 개수가 증가하면 프레임이 많아지면서 폴트 발생률이 떨어짐 <br><img src=\"https://i.imgur.com/920a1Cp.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\nTLB 크기가 고정되어있다고 할 때 프로세스의 메모리 크기가 커지며 지역성이 줄어들면서 TLB의 적중률 또한 감소\n커지는 메모리에 비해 상대적으로 용량 증가가 어려운 TLB로 인한 병목지점 가능성 다른 대안 페이지의 크기 키우기 -&gt; 성능이 떨어질 가능성\n다수의 페이지 크기를 지원하여 유연성 증가 -&gt; 복잡하여 현실적으로 어려움 메모리를 다수의 주소공간들(or 세그먼트)의 조합으로 볼 수 있음 세그먼트의 크기는 동적 설정, 메모리 참조는 (세그먼트 번호, 오프셋)의 주소 형식으로 이루어짐 점진적으로 커져가는 자료구조 처리의 단순화 필요에 따라 운영체제가 동적인 세그먼트의 크기에 맞춰 확장 및 축소 가능 프로그램 전체에 대한 재연결(relink)이나 재적재(reloading) 없이, 세그먼트 각각을 변경하거나 재컴파일이 가능\n프로세스들이 세그먼트 공유 가능\n세그먼트 보호 가능 프로그래머나 시스템 관리자가 자신에게 용이한 방식으로 접근 권한 부여 가능 <br><img src=\"https://i.imgur.com/YJZ3wrR.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n프로세스마다 고유의 세그먼트테이블이 설정\n프로세스의 세그먼트들이 적재될 때 주기억장치에 설정되며 각 세그먼트테이블 항목에는 그에 대응된 세그먼트가 적재된 메모리 영역의 시작주소와 길이가 저장\n<br><img src=\"https://i.imgur.com/o7InBgn.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n동일한 장치로서 세그먼트테이블 필요하지만 추가 비트가 있음 존재 비트 P 테이블 항목에서 주기억장치에 적재되어 있는지를 나타냄 변경 비트 M 해당 세그먼트가 적재된 이후 그 내용이 변경되었는지를 나타냄\n세그먼트 교체 시 변경된 세그먼트만 구별하여 디스크에 기록할 수 있게 해줌 세그먼트 + 오프셋으로 구성된 가상 주소를 물리 주소로 변환\n세그먼트테이블이 프로세스의 크기에 따라 가변 길이를 가져 주기억장치의 참조 가능 영역에 세그먼트테이블을 유지해야 함\n가상 주소의 세그먼트 번호를 세그먼트테이블의 인덱스로 사용하여 적재된 세그먼트의 시작 위치에 해당하는 주기억장치의 주소 + 가상주소의 오프셋 = 실주소 값(real address)\n페이징 고유의 장점 + 세그먼테이션 고유의 장점을 결합시키기 위해 두 기법 모두 제공되는 시스템도 있음<br><img src=\"https://i.imgur.com/Ezxg5ge.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/WG2nLS8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n세그먼트의 논리적 구조와 페이징의 물리적 메모리 관리의 장점을 합한 버전\n사용자의 주소 공간이 몇 개의 세그먼트로 나뉘어지고, 이는 다시 주기억장치의 프레임 크기와 동일한 고정 크기의 페이지들로 분할됨\n한 세그먼트의 크기가 한 페이지 크기보다 작을 경우, 하나의 페이지만 차지\n프로그래머 관점에서 논리주소는 여전히 세그먼트 번호와 세그먼트 오프셋으로 구성 시스템 관점에서 세그먼트 오프셋은 해당 세그먼트 내의 한 페이지에 대한 페이지 번호와 페이지 오프셋으로 보임 페이지 테이블의 다른 제어비트의 경우 공유나 보호등을 위해 사용\n페이지 테이블의 변경 비트는 해당 페이지프레임에 다른 페이지를 적재하려 할 때, 기존 페이지의 내용을 디스크에 기록할 필요가 있는지 나타냄\n<br><img src=\"https://i.imgur.com/qNzM3Ws.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n세그먼테이션이 보호와 공유 정책을 구현하기에 적합\n각 항목에 시작 주소와 길이가 포함되어 있어 프로그램은 세그먼트 범위 밖의 주기억장치 영역에 접근 불가능\n공유를 위해 다수의 세그먼트테이블이 특정 세그먼트를 참조하게 할 수 있음 페이징은 프로그램과 데이터의 페이지 구조가 투명하기 때문에 보호나 공유의 요건을 명확히 표현하기 어려움 보다 정교한 기법들로도 가능 -&gt; 링-보호(ring-protection)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제가상 메모리하드웨어와 제어구조","level":1,"id":"운영체제가상_메모리하드웨어와_제어구조_0"},{"heading":"하드웨어와 제어구조","level":1,"id":"하드웨어와_제어구조_0"},{"heading":"페이징과 세그먼테이션의 특성","level":2,"id":"페이징과_세그먼테이션의_특성_0"},{"heading":"가상 메모리 페이징/세그먼테이션","level":2,"id":"가상_메모리_페이징/세그먼테이션_0"},{"heading":"지역성(Locality)과 가상메모리","level":2,"id":"지역성(Locality)과_가상메모리_0"},{"heading":"페이징","level":2,"id":"페이징_0"},{"heading":"페이지 테이블 구조","level":3,"id":"페이지_테이블_구조_0"},{"heading":"역페이지테이블(Inverted Page Table)","level":3,"id":"역페이지테이블(Inverted_Page_Table)_0"},{"heading":"TLB(Translation Lookaside Buffer)","level":3,"id":"TLB(Translation_Lookaside_Buffer)_0"},{"heading":"작동순서","level":4,"id":"작동순서_0"},{"heading":"TLB와 캐시","level":3,"id":"TLB와_캐시_0"},{"heading":"직접사상","level":4,"id":"직접사상_0"},{"heading":"연관사상","level":4,"id":"연관사상_0"},{"heading":"TLB와 캐시의 동작","level":4,"id":"TLB와_캐시의_동작_0"},{"heading":"페이지 크기와 페이지 폴트의 관계","level":3,"id":"페이지_크기와_페이지_폴트의_관계_0"},{"heading":"세그먼테이션","level":2,"id":"세그먼테이션_0"},{"heading":"가상메모리의 유익","level":3,"id":"가상메모리의_유익_0"},{"heading":"세그먼테이션 구성","level":3,"id":"세그먼테이션_구성_0"},{"heading":"단순 세그먼테이션의 경우","level":4,"id":"단순_세그먼테이션의_경우_0"},{"heading":"가상 메모리 세그먼테이션의 경우","level":4,"id":"가상_메모리_세그먼테이션의_경우_0"},{"heading":"페이징과 세그먼테이션의 결합","level":2,"id":"페이징과_세그먼테이션의_결합_0"},{"heading":"보호와 공유","level":2,"id":"보호와_공유_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058366,"modifiedTime":1725254058366,"sourceSize":16586,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_가상 메모리_하드웨어와 제어구조.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html":{"title":"운영체제_가상메모리_운영체제 소프트웨어","icon":"","description":"\n가상메모리 기술 사용 여부\n페이징, 세그멘테이션, 세그멘테이션/페이징 결합의 사용 메모리 관리와 관련된 알고리즘 페이징에서의 페이지폴트 발생을 최소화 하기 위한 노력 페이지폴트가 초래하는 소프트웨어 오버헤드가 매우 크기 때문\n어떤 페이지를 교체 / 페이지 내보내기 및 들여오기 입출력 등이 오버헤드로 작용 입출력 진행동안 수행될 다른 프로세스 스케줄 과정에서 프로세스 문맥 교환이 수반됨 각 페이지를 언제 주기억장치로 적재할지 결정\n요구페이징(demand Paging) 해당 페이지의 일부가 참조될 때 선페이징(PrePaging) 페이지폴트에 의해 요구된 페이지들 이외의 페이지들도 반입 적재될 블록이 주기억장치의 어디에 위치할 것인지 결정\n최적적합, 최초적합 등\n고려 대상 페이지들 중에 어떤 페이지를 교체 대상으로 선택할 것인가 결정\n교체 정책은 교체되는 페이지가 가까운 미래에 참조될 가능성이 가장 적은 페이지여야 함. 운영체제는 일부 페이지 프레임을 잠가두어 해당 프레임에 적재된 페이지가 교체되지 않도록 표시해둠 <img src=\"https://i.imgur.com/g0yo9Fz.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n최적(Optimal) 미래에 참조될 때까지의 시간이 가장 긴 페이지를 교체\n운영체제가 미래에 일어날 사건들에 대해 완벽하게 알 수 없기 때문에 정책의 구현이 현실적으로 불가능 LRU(Least Recently Used) 가장 오랜 동안 참조되지 않은 주기억장치 상의 페이지를 교체\n지역성의 원리에 따르면 가까운 미래에 참조될 가능성이 가장 적을 것으로 예상됨\n정책의 구현이 어려움 가능한 구현 방법: 각 페이지에 대한 최종 참조 시간을 해당 페이지의 태그로 설정\n매번 참조될 때마다 갱신되어야 해서 오버헤드가 큼 FIFO(First-In-First-Out) 프로세스에 할당된 페이지프레임들은 순환버퍼처럼 다루어, 라운드로빈(Round-Robin)스타일로 프레임 상의 페이지들을 제거\n가장 쉽게 구현 가능\n프로그램 수행 과정 내내 집중적으로 이용되는 코드나 데이터 영역이 제거될 가능성이 높음 <br>클록(Clock) <img src=\"https://i.imgur.com/WsGfE4l.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 각 프레임에 대해 사용비트(use bit)라 불리는 한 비트를 연계\n페이지 폴트로 인해 어떤 페이지가 메모리 프레임에 처음 반입될 때, 그 프레임의 사용 비트를 1로 설정\n해당 페이지가 참조될 때마다 사용비트는 1로 설정\n사용비트가 0인 프레임을 찾아 교체, 1인 경우 0으로 바꾸고 다음 프레임으로 진행 <br><img src=\"https://i.imgur.com/Bwr2bAL.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">페이징 성능을 향상시키는 동시에 단순한 페이지 교체 정책을 허용하는 전략\n단순 FIFO 정책을 적용해 교체 대상을 선정하지만 선정된 페이지를 바로 교체하지 않고 그 페이지가 변경되지 않은 페이지인 경우 가용페이지 리스트에, 변경된 페이지인 경우 변경페이지 리스트에 연결시켜 관리\n페이지버퍼링과 유사한 전략을 사용하는 시스템에서 페이지 교체정책을 페이지 버퍼 상에 페이지 배치정책으로 보완함으로써 캐시 성능을 개선프로세스에게 얼마나 많은 주기억장치를 할당할지 결정\n고려사항\n한 프로세스에게 할당된 메모리 양이 적을수록, 임의 시점에 주기억장치에 존재 가능한 프로세스가 많아짐\n주기억장치 상에 적재된 한 프로세스의 페이지 수가 상대적으로 작으면 페이지폴트 발생률이 더 높아짐\n적재된 페이지 수가 어느 정도 이상이 되면, 해당 프로세스에 대해 주기억장치를 추가 할당 하더라도 지역성의 원리에 의해 그 프로세스의 페이지폴트 발생률에 큰 영향이 없음\n이러한 고려사항들을 반영한 두 종류의 정책\n고정할당(fixed-allocation) 각 프로세스에게 고정 개수의 페이지프레임을 주고 수행\n초기 적재 시점에 결정(프로세스의 타입이나 지침 등)\n프로세스 수행 중에 페이지폴트가 발생할 경우 그 프로세스에 할당된 페이지 중 하나가 새로운 페이지로 교체됨 가변할당(variable-allocation) 프로세스 생존 기간 동안 각 프로세스에 할당된 페이지프레임 수의 변경을 허용 교체 전략의 범위는 전역과 지역으로 분류","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제가상메모리운영체제 소프트웨어","level":1,"id":"운영체제가상메모리운영체제_소프트웨어_0"},{"heading":"운영체제 소프트웨어","level":1,"id":"운영체제_소프트웨어_0"},{"heading":"운영체제 메모리관리 설계 시 의존하는 영역","level":2,"id":"운영체제_메모리관리_설계_시_의존하는_영역_0"},{"heading":"하드웨어 플랫폼에 의존(지원 필요)","level":3,"id":"하드웨어_플랫폼에_의존(지원_필요)_0"},{"heading":"딱히 의존하지 않는 경우","level":3,"id":"딱히_의존하지_않는_경우_0"},{"heading":"성능면에서의 이슈","level":2,"id":"성능면에서의_이슈_0"},{"heading":"가상메모리를 위한 운영체제 정책","level":2,"id":"가상메모리를_위한_운영체제_정책_0"},{"heading":"반입정책","level":3,"id":"반입정책_0"},{"heading":"배치정책","level":3,"id":"배치정책_0"},{"heading":"교체정책","level":3,"id":"교체정책_0"},{"heading":"프레임 잠금(Frame Locking)","level":4,"id":"프레임_잠금(Frame_Locking)_0"},{"heading":"기본 알고리즘","level":3,"id":"기본_알고리즘_0"},{"heading":"교체 알고리즘의 성능 비교","level":3,"id":"교체_알고리즘의_성능_비교_0"},{"heading":"페이지 버퍼링(Page Buffering)","level":3,"id":"페이지_버퍼링(Page_Buffering)_0"},{"heading":"교체정책과 캐시 크기","level":3,"id":"교체정책과_캐시_크기_0"},{"heading":"적재집합 관리","level":2,"id":"적재집합_관리_0"},{"heading":"적재집합의 크기","level":3,"id":"적재집합의_크기_0"},{"heading":"교체범위","level":3,"id":"교체범위_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":7619,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_가상메모리_운영체제 소프트웨어.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html":{"title":"운영체제_가상메모리_Linux, Windows의 가상 메모리","icon":"","description":"3단계 페이지테이블 구조의 사용\n<img src=\"https://i.imgur.com/77G9ybl.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n페이지 디렉토리(page directory) 각 프로세스는 페이지 크기의 페이지 디렉토리 하나를 가짐\n페이지 디렉토리의 각 항목은 페이지 중간 디렉토리 중 한 페이지를 가리킴 페이지 중간 디렉토리(page middle directory) 다수의 페이지로 구성될 수 있음\n중간 디렉토리의 각 항목은 페이지테이블 중 한 페이지를 가리킴 페이지테이블(Page table) 다수의 페이지로 구성될 수 있음\n각 항목은 프로세스의 가상페이지 하나를 참조 Linux 가상 주소 : 4개의 필드로 구성\n첫 번째 필드 -&gt; 페이지 디렉토리의 인덱스\n두 번째 필드 -&gt; 페이지 중간 디렉토리에 대한 인덱스\n세 번째 필드 -&gt; 페이지테이블의 인덱스\n네 번째 필드 -&gt; 선택된 메모리 페이지 내의 오프셋 값\n<br><img src=\"https://i.imgur.com/TBzoS9i.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n- 사용자 프로세스 -&gt; 각각 독립된 32비트 주소공간(4GB)의 메모리 사용 가능\n- 메모리의 절반(2GB)은 운영체제용, 절반은 사용자가 독자적으로 사용할 수 있는 가상주소공간의 크기(2GB)\n프로세스 생성 시 2GB(32비트의 경우)에 가까운 사용자 공간 전체를 사용 가능\n윈도우즈는 페이지들을 64KB 경계에 맞추어 할당된 연속 영역으로 관리 가용(available) 프로세스에 의해 현재 사용되지 않는 주소영역 예약(reserved) 가상메모리 관리자가 다른 용도로 할당될 수 없도록 프로세스를 위해 마련해 둔 주소영역 위탁(committed) 프로세스가 가상메모리 페이지들을 접근할 때 사용할 수 있도록 초기화된 주소영역\n페이지는 디스크 혹은 주기억장치 상에 위치\n디스크 상에 있는 페이지들은 파일 내에 유지되거나 페이지 파일 상에 위치 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Linux의 메모리 관리","level":1,"id":"Linux의_메모리_관리_0"},{"heading":"Linux 가상 메모리","level":2,"id":"Linux_가상_메모리_0"},{"heading":"Windows의 메모리 관리","level":1,"id":"Windows의_메모리_관리_0"},{"heading":"Windows 가상주소 맵(Virtual Address Map)","level":2,"id":"Windows_가상주소_맵(Virtual_Address_Map)_0"},{"heading":"Windows의 디폴트 32비트 가상주소공간","level":3,"id":"Windows의_디폴트_32비트_가상주소공간_0"},{"heading":"Windows 페이징","level":2,"id":"Windows_페이징_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058366,"modifiedTime":1725254058367,"sourceSize":2193,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_가상메모리_Linux, Windows의 가상 메모리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html":{"title":"운영체제_단일처리기 스케줄링_스케줄링 알고리즘","icon":"","description":"단기 스케줄링의 주된 목적\n-&gt; 시스템의 전체 성능을 높이기 위해 처리기 시간을 프로세스들에게 효율적으로 분배\n사용자 중심의 관점/시스템 중심의 관점에서 평가\n성능 중심의 관점에서/성능과 관련 없는 다른 척도로 평가\n개별 사용자/프로세스의 입장에서 긍정적으로 영향을 미치는 스케줄러인지 평가\n반환 시간(turnaround time) 프로세스가 시스템으로 진입한 후부터 종료할 때까지 걸린 시간\n실제 실행 시간 뿐만 아니라 CPU나 다른 자원들을 사용하기 위해 대기한 시간까지 모두 포함 응답시간(response time) 대화형 프로세스가 시스템에 요구를 한 후 이에 대한 시스템으로부터의 첫 번째 응답이 올 때까지의 시간 완료 기한(deadline) 프로세스가 완료되어야 하는 시점에 기한이 있다면, 스케줄러는 다른 평가척도가 희생당하더라도 완료 기한을 만족시킬 수 있는 프로세스의 수를 최대화해야함 예측 가능성(Predictability) 같은 작업이라면 실행될 때마다 동일한 기간 동안 실행되어야 하고, 시스템의 부하 정도에 상관없이 동일한 비용으로 실행되어야 함\n성능이 불안정한 경우 시스템 튜닝(tuning)을 통해 해소 스케줄러가 처리기를 얼마나 효율적이고도 효과적으로 활용했는지 평가\n처리량(throughout) 단위 시간 내에 완료될 수 있는 프로세스의 수를 최대화하는 정책 사용 처리기 이용률(processor utilization) 전체 시간 중에 처리기가 바쁘게 실행을 한 시간의 비율\n단일-사용자 시스템이나 실시간 시스템에서는 처리기 이용률이 중요한 성능 척도로 사용 X 공정성(fairness) 시스템이 어떤 특정 목적을 위해 미리 공표하지 않은 이상 어떤 프로세스도 스케줄러로부터 차별을 받아선 안됨\n차별이 심하면 기아(starvation) 상태 발생 가능 우선순위의 부여(enforcing priority) 프로세스들에게 우선순위가 부여되고 나면 스케줄러는 높은 우선순위의 프로세스를 우대 균형 있는 자원(balancing resources) 활용 스케줄러는 시스템 내의 자원들이 가능한 한 최대한 활용되도록 해야함\n중기/장기 스케줄러 차원에서 시행하는 것이 바람직함 모든 프로세스에 우선순위를 부여하고 스케줄러는 항상 우선순위가 가장 높은 프로세스를 다음번 프로세스로 선택<img src=\"https://i.imgur.com/LP0cI4g.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n우선순위[] &gt; 우선순위[] ()에 대해\n단점\n낮은 우선순위의 프로세스가 계속 실행되지 못함\n=&gt; 기아(starvation) 발생 가능성 = 지금까지 실행 또는 대기하면서 시스템 내에 머문 시간 = 지금까지 실행하는 데에 소요한 시간 = 를 포함하여 프로세스가 요구한 총 서비스 시간 선택 함수(selection function)\n다음번 실행을 위해 준비 큐에서 대기 중인 프로세스 중 하나를 고를 때 사용하는 알고리즘을 함수 형태로 표현한 것 결정 모드(decision mode)\n선택 함수가 호출되는 시점이 언제인가 하는 것\n결정 모드 - 비선점 모드(Nonpreemptive)\n프로세스가 일단 실행 상태(Running state)에 진입하면 종료되거나 자발적으로 CPU를 놓을 때까지는 CPU를 빼앗기지 않음\n결점 모드 - 선점 모드(Preemptive)\n현재 실행 중인 프로세스라 할지라도 운영체제에 의해 인터럽트가 걸려 비자발적으로 준비 큐로 이동될 수 있음\n🚨 선점 모드 스케줄링에서는 비선점 모드 스케줄링에 비해 프로세스 간 문맥 교환이 자주 발생하기 때문에 이로 인한 오버헤드가 큼\n🚨 하지만 한 프로세스가 처리기를 오랫동안 독점하는 현상을 방지하여 비선점 모드보다 나은 서비스 제공\n<br><img src=\"https://i.imgur.com/UxF3obC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n- 서비스 시간의 의미 - 프로세스들의 일괄 작업으로 가정 - 시작부터 종료까지 소요되는 총 실행 시간의 의미 - 이미 실행되고 있는 계산/입출력 교행 프로세스들로 가정 - 다음번 사이클 동안에 실행할 시간\n![](https://i.imgur.com/tjN44M9.jpeg)\n&gt;큐잉 분석 - 정규화된 반환 시간\n&gt;어떤 프로세스가 시스템에 진입한 후 대기하느라 실행이 지연된 시간의 비율\n&gt; $$\\frac{Tr}{Ts} = \\frac1{1-p}$$\n&gt;\n&gt; $r$ = 상주시간(residence Time)\n&gt; $Tr$ = 반환 시간 또는 시스템에 머문 시간; 시스템 내에 총 머문 시간(대기 시간 + 실행 시간)\n&gt; $Ts$ = 평균 서비스 시간; 실행 상태에 머물렀던 평균 시간\n&gt; $p$ = 처리기 이용률\n&gt; &gt;✔️ 정규화된 반환 시간이 1.0 =&gt; 시스템에 진입한 후 한 번도 대기한 적이 X\n&gt;✔️ 아무리 훌륭한 스케줄러라도 정규화된 반환 시간을 1.0 밑으로 떨어뜨릴 수는 없으며, 이 값의 크기와 스케줄링 서비스의 질은 반비례함 가장 단순한 형태의 스케줄링 정책으로 FIFO(First-In-First-Out)라고도 함\n큐잉 정책을 엄격하게 지키고 있는 형태\n실행 중인 프로세스가 종료되면 준비 큐에서 대기중이던 프로세스 중 가장 오랫동안 기다렸던 프로세스가 다음번 실행할 프로세스로 선정\n<br>짧은 프로세스보다는 긴 프로세스에 유리 (짧은 프로세스가 피해를 봄)<img src=\"https://i.imgur.com/c2lvo8m.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 짧은 Y프로세스가 순서대로 실행되면서 오래 기다려야 함(정규화된 반환시간이 긺)\nZ 프로세스 또한 짧은 프로세스에 비해 상대적으로 피해가 적을 뿐 피해는 있음 입출력 중심의 프로세스보다 처리기 중심 프로세스 우대 비선점으로 동작하므로 문맥 교환이 안 일어남 처리기 및 입출력장치 모두에게 비효율적인 스케줄링 정책\n시간할당량(time sclicing, 또는 quantum)기법을 통해 일정 시간이 지나면 클록(Clock) 인터럽트(타이머 인터럽트)를 실행시켜 CPU를 뺏음<br>\n<img src=\"https://i.imgur.com/QFDnOAH.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n시간 할당량이 짧으면 문맥교환 오버헤드 / 길면 FCFS와 같은 효과를 얻음\n=&gt; 시간 할당량의 길이 설계가 중요\n처리기 중심 프로세스가 입출력 중심 프로세스보다 CPU를 더 사용하게 됨\n<br><img src=\"https://i.imgur.com/pPsVUkG.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://i.imgur.com/P1CNyx4.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n단위시간이 짧은 프로세스가 혜택을 봄(E)\n공평성이 뛰어남 범용 시분할 시스템\n트랜잭션 처리 시스템에 효과적인 스케줄링 개선된 라운드 로빈 스케줄링 정책<br><img src=\"https://i.imgur.com/BchC8hU.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n기존 라운드 로빈의 경우 원하는 입출력이 완료된 프로세스는 준비 큐의 끝으로 이동 가상 라운드 로빈의 경우 입출력이 완료된 프로세스는 보조 큐라고 하는 별도의 FCFS 큐로 들어감.\n다음 프로세스를 고르는 시점에서 스케줄러는 보조 큐에서 대기 중인 프로세스를 준비 큐보다 먼저 실행 저번 실행 때 못 채우고 반납한 시간 할당량만큼만 실행 공평성의 측면에서 기존 라운드 로빈보다 우수 가장 짧은 프로세스를 먼저 실행시키는 정책<br><img src=\"https://i.imgur.com/kZ73WwC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/nQb3nHY.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n비선점 모드로 작동 종료 시까지 남아 있는 실행시간이 가장 짧은 프로세스를 다음 프로세스로 선택 응답시간의 개선\n문제점 각 프로세스가 요구하는 총 실행 시간을 미리 알거나 추측할 수 있어야 함 만약 실제 총 실행 시간이 프로그래머가 알려준 총 실행시간보다 현격히 초과하면 OS는 해당 프로세스를 강제로 종료 <br>각 프로세스가 CPU를 잡고 한 번의 시간할당량 중 얼마나 오랫동안 실행하는지에 대한 평균값<img src=\"https://i.imgur.com/E7ADkd5.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 모든 스케줄링 순번에서의 실행 시간에 동일한 가정치를 둠\n<br>과거의 데이터를 그 시간에 따라 다른 가중치를 두어 활용하는 방식(시계열 방식(time series) -&gt; 지수적 평균(Exponential averaging))<img src=\"https://i.imgur.com/4PvARw9.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 모든 과거 측정치들을 다 활용하면서도 현재로부터 먼 과거에 있는 측정치일수록 미래의 예측에 미치는 영향은 줄어듦\n<br>\u001e<img src=\"https://i.imgur.com/lGcUX7I.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 짧은 프로세스들이 지속적으로 시스템에 진입한다면 상대적으로 긴 프로세스가 기아 상태에 빠질 수 있음 비선점 모드로 작동하기 때문 SPN의 선점 모드 버전<br>\n<img src=\"https://i.imgur.com/B7LvlGQ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/AzDQKUM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n예상되는 남아 있는 실행시간이 가장 짧은 프로세스가 다음번 프로세스로 선택됨(SPN과 달리 예상되는 전체 실행 시간X)\n새로 도착한 프로세스의 예상되는 남아있는 실행 시간이 현재 실행중인 다른 모든 프로세스들보다 짧다면 실행 중인 프로세스를 선점하고 곧장 선택됨\n단점 매 스케줄링 때마다 프로세스들의 남아있는 실행시간을 평가해야 함\n긴 프로세스가 기아에 빠질 위험이 있음\n각 프로세스의 전체 서비스 요구 시간 중 지금까지 얼마나 서비스 받았는지 기억하고 있어야 하는 오버헤드 존재(남아있는 실행시간 계산용) 선점을 통해 반환시간이 SPN보다 월등히 우수함\n전체 프로세스들에 대해서 정규화된 반환시간의 평균값을 최소화하는 방향의 스케줄링 정책\n정규화된 반환시간 : 서비스 시간 대비 반환 시간의 비율\n정규화된 반환 시간을 일반화한 일종의 응답 비율을 계산할 때 사용할 수 있는 계산식 ✔️ R(response rate)의 값도 1.0 이하로는 내려갈 수 없음해당 응답시간을 활용한 스케줄링 정책\n=&gt; 스케줄러는 준비 큐에 있는 프로세스 중 R값이 가장 큰 프로세스를 다음번 프로세스로 선택\n프로세스가 시스템 내에서 머문 시간을 고려하고 있다는 점에서 매력적인 편\n하지만 s(예상되는 서비스 시간)을 알기 어려움(위의 지수평균) 과거의 서비스 시간 기록\n사용자가 직접 제공한 정보\n설정 파일 관리자 프로세스들의 예상되는 서비스 시간을 미리 알아낼 수 없는 경우\n=&gt; SPN, SRT, HRRN 모두 불가능다른 짧은 프로세스에 대한 선호도를 높일 수 있는 방법\n=&gt; 오랫동안 실행하고 있는 작업들이 단계적으로 불이익을 받도록 만듦시간 할당량이 있는 선점 모드로 운영하면서 동시에 동적인 우선순위 정책을 병행 사용\n새로 도착한 프로세스일수록, 짧은 프로세스일수록 오래된 프로세스나 긴 프로세스보다 우대받는 정책<br><img src=\"https://i.imgur.com/cMGnxsg.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n프로세스가 최초로 시스템에 진입하면 RQ0으로 진입\n첫 번째 선점점에 도달하면 다시 준비상태로 돌아가면서 RQ1로 들어감\n계속해서 선점점에 도달할 때마다 한 단계 낮은 우선순위위 준비 큐로 강등되어 진입\n각 큐 내에서는 가장 낮은 우선순위 큐만 제외하고 모두 FCFS 방식으로 다음번 프로세스 선택\n가장 낮은 우선순위까지 가면 다시 선점점에 도달해도 같은 큐의 맨 뒤로 들어감\n<br><img src=\"https://i.imgur.com/MGUX2pp.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/Z55YeED.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">다단계 피드백 스케줄링 정책의 변형\n모든 큐에서 시간할당량이 있는 FCFS 방식의 라운드 로빈 방식으로 만듦\n시간 할당량을 큐 별로 다르게 줌\n🚨 근데 잘못하다 기아 상태까지 갈 수 있음\n시스템의 상황에 따라 성능이 좌우됨\n프로세스 서비스 시간들의 확률 분포\n스케줄링 자체의 효율성\n문맥 교환 메커니즘\n입출력 요구 패턴\n입출력 서브시스템의 성능\n=&gt; 스케줄러의 성능을 명확하게 비교하는 것은 불가능하지만 일반론적인 결론을 위한 성능 비교 기법들을 통해 측정\n프로세스들의 도착률은 포아송(Poisson) 분포/서비스 시간은 지수적(exponential) 분포를 보인다고 가정 = 상주시간(residence Time) = 반환 시간 또는 시스템에 머문 시간; 시스템 내에 총 머문 시간(대기 시간 + 실행 시간) = 평균 서비스 시간; 실행 상태에 머물렀던 평균 시간 = 처리기 이용률\n<br><img src=\"https://i.imgur.com/WvLZXAS.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">예상되는 서비스 시간에 근거한 스케줄링 정책들을 세밀하게 관찰하기 불가능\n=&gt; 우선순위에 고려하는 여러 정책들의 성능을 그렇지 않은 정책과 비교함으로써 상대적인 선은 평가<br><img src=\"https://i.imgur.com/OyEbYBJ.jpeg\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n✔️ 짧은 작업을 우대함으로써 처리기 이용률이 높아짐에 따라 평균 정규화된 반환 시간을 개선시킬 수 있음\n✔️ 하지만 평균 정규화된 반환시간의 개선에도 불구하고 전체 성능의 차이가 확연하지 않음<br><img src=\"https://i.imgur.com/SZVvrGN.jpeg\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n✔️ 각 우선순위 등급을 따로 분리하여 생각하는 경우 큰 차이를 볼 수 있음\n✔️ 시스템이 빈선점 모드의 우선순위 기반 스케줄링 기법을 사용했을 때 짧은 프로세스들에 대해서 큰 성능 향상을 보임\n✔️ 긴 프로세스들에 대한 경우 우선순위를 사용한 경우 더 안좋은 성능을 보임\n큐잉 분석 기법의 경우 사용하기 까다롭지만 시뮬레이션 기법을 통해 다양한 스케줄링을 모델링 가능\n결과를 일반화시킬 수는 없지만 각 스케줄링 기법이 왜 그런 성능을 보이는지에 대한 직관을 높이기 좋음\n프로세스 도착률 = 0.8, 평균 서비스 시간() = 1 처리기 이용률(도착률 x 평균 서비스 시간) = 1 * 0.8 = 0.8\n100개의 그룹 -&gt; 서비스시간 1 요구 프로세스 500개, 서비스시간 2 요구 프로세스 500개.. 서비스시간 100 요구 프로세스 500개로 분류하여 시뮬레이션\n<br><img src=\"https://i.imgur.com/06cHRWF.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">대기 시간에 대한 시뮬레이션 결과의 경우\n✔️ FCFS -&gt; 전체 프로세스 수의 1/3 이상에서 자기 서비스 시간의 10배가 넘는 정규화된 반환 시간으로 피해가 크지만 대기시간은 서비스 시간에 관계없이 일정 -&gt; 서비스 시간을 고려하지 않아서 + 긴 프로세스 선호\n✔️ 라운드 로빈 -&gt; 시간 할당량이 1보다 작은 짧은 프로세스들을 제외하고 5정도로 균일한 성능\n✔️ SPN -&gt; 아주 짧은 프로세스들만 빼면 라운드 로빈보다 좋은 성능 + 짧은 프로세스 우대\n✔️ SRT -&gt; 서비스 시간이 긴 상위 7%정도를 제외하고 SPN보다 전반적으로 나은 성능\n✔️ HRRN -&gt; FCFS와 SPN 각각의 단점을 상호 보완하는 결과\n✔️ 피드백 -&gt; 짧은 프로세스들에 대해 꽤 좋은 성능프로세스 집합 단위의 스케줄링 방식\n다중사용자 시스템의 경우 사용자 응용프로그램이 여러 개의 프로세스들로 구성된 경우도 있음\n=&gt; 스케줄링의 단위를 개별 프로세스가 아닌 프로세스 집합 단위로 하는 것이 공정성 측면에서 더 유리함\n각 사용자에게 가중치 부여 -&gt; 시스템 전체 자원 중에 이 사용자가 사용할 수 있는 지분을 정하여 자원 사용율을 지분에 맞게 통제 우선순위에 기반한 스케줄링 프로세스별 우선순위 뿐만 아니라 최근 처리기 사용 시간이나 프로세스가 소속된 그룹이 최근 소비한 처리기 시간 등을 모두 고려한 복합 우선순위 <br>복합 우선순위를 구하는 공식<img src=\"https://i.imgur.com/5Z09G6x.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n각 프로세스는 처음에 기본 우선순위를 갖고 프로세스가 처리기를 사용할 때마다, 그 프로세스가 속한 그룹이 처리기를 사용할 때마다 프로세스의 우선순위는 점차 낮아짐(값은 커짐)\n그룹 사용률(GCPU)이 복합 우선순위에 반영될 때에는 해당 그룹의 가중치로 나누어져 정규화된 후 반영\n<br><img src=\"https://i.imgur.com/JYJwocU.jpeg\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제단일처리기 스케줄링스케줄링 알고리즘","level":1,"id":"운영체제단일처리기_스케줄링스케줄링_알고리즘_0"},{"heading":"스케줄링 알고리즘","level":1,"id":"스케줄링_알고리즘_0"},{"heading":"단기 스케줄링 평가 기준들","level":2,"id":"단기_스케줄링_평가_기준들_0"},{"heading":"사용자 중심의 성능 관련 평가척도","level":3,"id":"사용자_중심의_성능_관련_평가척도_0"},{"heading":"사용자 중심의 기타 평가척도","level":3,"id":"사용자_중심의_기타_평가척도_0"},{"heading":"시스템 중심의 성능 관련 평가척도","level":3,"id":"시스템_중심의_성능_관련_평가척도_0"},{"heading":"시스템 중심의 기타 평가척도","level":3,"id":"시스템_중심의_기타_평가척도_0"},{"heading":"우선순위-기반 스케줄링","level":2,"id":"우선순위-기반_스케줄링_0"},{"heading":"다양한 스케줄링 정책들","level":2,"id":"다양한_스케줄링_정책들_0"},{"heading":"스케줄링 예를 위한 프로세스 집합","level":3,"id":"스케줄링_예를_위한_프로세스_집합_0"},{"heading":"FCFS(First-Come-First-Served)","level":3,"id":"FCFS(First-Come-First-Served)_0"},{"heading":"Round-Robin","level":3,"id":"Round-Robin_0"},{"heading":"가상 라운드 로빈(Virtual Round Robin)","level":3,"id":"가상_라운드_로빈(Virtual_Round_Robin)_0"},{"heading":"Shortest Process Next(SPN)","level":3,"id":"Shortest_Process_Next(SPN)_0"},{"heading":"Shortest Remaining Time(SRT)","level":3,"id":"Shortest_Remaining_Time(SRT)_0"},{"heading":"Hightest Response Ration Next(HRRN)","level":3,"id":"Hightest_Response_Ration_Next(HRRN)_0"},{"heading":"피드백(Feedback)","level":3,"id":"피드백(Feedback)_0"},{"heading":"다단계 피드백 방식(multilevel feedback)","level":4,"id":"다단계_피드백_방식(multilevel_feedback)_0"},{"heading":"스케줄링 정책들의 성능 비교","level":2,"id":"스케줄링_정책들의_성능_비교_0"},{"heading":"큐잉 분석(Queuing Analysis)","level":2,"id":"큐잉_분석(Queuing_Analysis)_0"},{"heading":"시뮬레이션 모델링","level":3,"id":"시뮬레이션_모델링_0"},{"heading":"Fair-Share 스케줄링","level":2,"id":"Fair-Share_스케줄링_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":19838,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_단일처리기 스케줄링_스케줄링 알고리즘.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html":{"title":"운영체제_단일처리기 스케줄링_처리기 스케줄링의 유형","icon":"","description":"\n처리기 스케줄링의 목적\n응답시간이나 처리량, 효율성을 증대시키기 위해 처리기가 다음에 실행할 프로세스를 선택하는 것\n<img src=\"https://i.imgur.com/rdAOShp.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/42uZ8m1.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n디스패처(Dispatcher)라고도 불림\n장기, 중기 스케줄러보다 매우 자주 실행되면서 세밀한 기준으로 다음번에 실행시킬 프로세스 선정\n단기 스케줄러 호출 -&gt; 현재 실행중인 프로세스가 자발적으로 CPU를 놓거나 시간할당량이 소진되어 CPU를 뺏기는 경우 호출 클록(타이머) 인터럽트\n입출력 인터럽트\n운영체제 시스템 호출\n신호(signal) - 세마포어 등 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제단일처리기 스케줄링처리기 스케줄링의 유형","level":1,"id":"운영체제단일처리기_스케줄링처리기_스케줄링의_유형_0"},{"heading":"처리기 스케줄링의 유형","level":1,"id":"처리기_스케줄링의_유형_0"},{"heading":"단기 스케줄링++","level":2,"id":"단기_스케줄링++_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":1697,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_단일처리기 스케줄링_처리기 스케줄링의 유형.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html":{"title":"운영체제_메모리 계층 구조, 캐시 메모리, IO연산 기법, 멀티프로세서와 멀티코어","icon":"","description":"<img src=\"https://i.imgur.com/7usKIe9.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n메모리는 접근속도, 용량, 비용간에 상호 절충(tradeoff)관계가 있다. 접근 시간이 짧을수록 비트당 비용 높아짐\n용량이 클수록 비트당 비용 낮아짐\n용량이 클수록 접근 시간 길어짐 사실상 cpu와 가장 가까이에 있는 캐시 메모리로 모든 메모리를 대체하는 것이 이상적일지는 몰라도, 가격은 극악으로 치솟음\n딜레마를 해결하기 위해 단일 메모리 요소나 기술에 의존하지 않고 메모리 계층 구조를 채택\n위 사진은 a-d까지 내려감에 따라 성립되는 것들을 적어놓은 것. 서로가 서로를 보완하는 관계이다.\nCPU와 비슷한 속도인 캐시 메모리의 경우 너무 비싸기 때문에 캐시의 용량은 그리 크지 않은 캐시메모리를 사용하되, 주기억장치(RAM)의 경우에는 캐시보다 느리지만 가성비가 높아 캐시 메모리와 함께 사용하면 시너지 어떤 메모리의 한 지점을 엑세스할 때 메모리는 CPU로 직접 보내는 것이 아니라 1kb정도의 단위로 캐시 메모리에 보내고 캐시를 통해 CPU로 가기 때문에 CPU가 메모리를 직접 참조하는 경우는 없음.\n항상 캐시메모리에 요청을 하고 캐시 메모리에 해당 데이터가 있으면 hit, 없으면 miss\n여기서 만약 100번을 요청해서 90번의 hit와 10번의 miss가 일어났다면 90%의 적중률(hit ratio) 를 갖게 된다. 이러한 적중률은 1mb정도의 캐시 메모리만 갖고 있으면 거의 99%가 넘는 적중률을 가진다. 참조지역성(locality of reference) 📚📚📚\nd. 처리기에 의한 메모리 접근 회수 감소의 성립 근거.\n프로그램에서 메모리의 어떤 지점을 읽었으면 가까운 시간 내에 그 지점을 다시 읽을 가능성이 높고 비슷한 곳에 메모리가 몰리는 경향 Hit Ratio는 각 단계에서 메모리 접근 시간에 영향을 미침\n더 가까운 메모리의 접근 비율이 높아질수록 평균 총 접근시간은 더 가까운 메모리의 접근 시간에 가까워짐\n그렇기 때문에 적당한 수준의 캐시 메모리를 두고 그 다음 단계인 메모리(RAM)을 가성비를 위해 함께 두면 시너지를 발휘 자기디스크, CD-ROM, CD-RW, DVD-RW, DVD-RAM, Blu-Ray 등\n메모리보다 느리지만 저장 용량이 높음.\nCD와 DVD의 경우 레이저를 표면에 쏴 빛이 반사되는 경우와 반사되지 않는 경우를 구분하여 기록하는 방식\ncpu는 디스크에 있는 내용들을 읽을 때 나중에 다시 읽는 경우 계속해서 그때그때 새롭게 읽게 되면 속도가 느리므로 버퍼라는 곳에 메모리에서 읽은 내용을 일부 보관한다. 자기 테이프 등의 오프라인 저장장치\n데이터를 저장할 때 디스크와 같이 회전하면서 임의의 위치에 빠른 속도로 저장 녹음 테이프와 같은 원리 테이프는 얇은 비닐로 이루어져 있기 때문에 분해해보면 엄청 긴 테이프가 나옴\n해당 테이프에 데이터를 저장한다면 테이프가 긴 만큼 대용량의 데이터가 저장이 가능\n하지만 대용량의 데이터가 저장이 가능한 만큼 감겨져있는 테이프가 많기 때문에 데이터를 빠르게 읽을 수가 없기 때문에 보통 백업의 용도로 많이 사용\n<br><img src=\"https://i.imgur.com/CgKnPR9.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n블록과 같은 구조처럼 되어있는걸 볼 수 있는데 여기에 있는 칸마다 1kb 혹은 설계된 캐시메모리에 따라서 일정 단위가 블록에 들어오게 되고 블록 내에 있는 태크는 주소를 빠르게 검사하기 위한 목적으로 만들어짐\n캐시 메모리는 CPU만큼의 속도를 자랑하지만 그만큼 비싸다는게 단점\n따라서 각 캐시를 단계별로 나누어 속도에는 차이가 있지만 가성비로는 가장 최고의 효율을 낼 수 있도록 설계\n<br><img src=\"https://i.imgur.com/ykSPhVc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n단일 캐시의 경우 직접적으로 CPU와의 데이터 교환이 이루어지기 때문에 빠름\n또한 참조 지역성 때문에 어떤 메모리의 참조를 위해 하나의 데이터 블록을 캐시로 가져오게 되면, 그 이후의 참조는 그 블록 내에 있는 데이터가 될 확률이 높음\n=&gt; Hit Ratio가 높아짐\n삼단계 캐시 구조의 경우는 캐시가 3단계로 이루어져 있음\n단계 1의 L1 캐시는 CPU만큼 빠르고, L2는 그보다는 조금 더 느리며, L3는 L2보다는 조금 느림\n하지만 느린 만큼 단가는 떨어지기 때문에 해당 캐시를 하나 두는 것보다는 저렴하고 비슷한 효율을 낼 수 있도록 비슷한 수준으로 유지시킬 수 있음\n<br><img src=\"https://i.imgur.com/wWQq8e3.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n가장 먼저 캐시는 CPU로부터 입력, 즉 RA(Read Address)를 받음\n그러면 CPU는 캐시 메모리에서 RA를 포함한 블록이 있는지 확인\nRA를 포함한 블록이 있을 경우(hit)는 캐시에서 읽어들이면 되고, 아닐 경우(miss)에는 RA를 포함한 주기억장치에 있는 블록을 캐시에 갖다 쓰기 위해 캐시 슬롯을 할당 캐시 슬롯은 비어있을 수도 있지만 슬롯이 모두 차 있는 경우도 있다. 이런 경우에 미래에 참조될 가능성이 가장 낮은 캐시를 쫓아내는데, 이를 time locality, 즉 LRU(Least Recently Used)가 높은 캐시를 쫓아내게 되는데, 이러한 쫓겨나는 캐시 내의 블록을 victim이라고 한다. 해당 victim이 write 연산이 이루어져 실제 메모리와의 정보가 서로 다르다면, 이러한 블록을 dirty block이라고 한다. 이러한 경우에 flush 하여 메모리에 반영하는 과정이 필요하다.\n캐시슬롯을 할당 후 아래에 있는 블록을 주기억장치 블록을 캐시 슬롯에 적재\nCPU에 값 전달\n하는 과정을 동시에 진행한다. 메모리에 I/O 엑세스하는 방법 중 하나\nI/O장치는 키보드, 마우스, 모니터 등 다양하고 이러한 I/O장치에 각각의 명령어를 보내야 함\n각각의 I/O장치는 해당 장치 안에 CPU(장치 내의 CPU는 컨트롤러라고 한다)와 레지스터가 있음\n이러한 레지스터에 명령어를 쓰면 해당 명령어에 해당하는 동작을 해야 하는데 문제는 이러한 장치들이 명령어를 전달하는 방법이 다 다름\n그렇게 된다면 각각 다른 명령어에 대응해서 받는 로직은 너무 복잡해짐\n이를 해결하기 위해 메모리의 특정 부분을 각 레지스터마다 매핑(Mapping) 해당 메모리가 비어 있다가 엑세스하게 되면 운영체제에서 자동으로 해당 주소에다가 값을 넣을 수 있게끔 함\n각 I/O장치마다 특정 주소에 매핑되어 있기 때문에 각 I/O 장치의 주소만 알면 되고, 표준적인 방법을 가질 수 있음\n이러한 매핑의 경우는 운영체제가 알아서 핸들링을 해주는 것이 프로그램된 입출력(Programmed I/O) 하지만 프로세서에 대해 인터럽트를 포함한 더 이상의 어떤 처리도 행하지 않기 때문에 처리기가 I/O 연산이 언제 완료되는지 알지 못함 이를 위해 프로세서는 I/O 연산이 완료될 때까지 주기적으로 점검해야 하고, 이러한 상태를 I/O 데이터가 들어오기 전 대기 기간에도 계속 수행해야 하기 때문에 전체 시스템의 성능 수준이 현저히 떨어질 수 있다는 단점 존재 다른 대안으로 나온 기법이다. 앞서 말했던 인터럽트를 생각하면 됨\n프로세서가 모듈에게 I/O 명령을 보낸 후 다른 작업을 계속 수행\n프로세서는 데이터 전송 후 이전에 수행하던 작업을 재개하는 방식이다.\n하지만 이러한 방식은 데이터가 많을 경우에 문제가 됨 많은 데이터를 읽고 메모리에 저장하기까지의 과정을 계속해서 CPU가 관여하게 되는데, 두 가지의 문제점이 있다. I/O 전송률이 프로세서가 장치를 점검하고 서비스하는 속도에 제한을 받음\nI/O 전송마다 많은 명령어들이 수행됨 I/O 장치와 메모리를 직접 회로로 연결해놓고 DMA 모듈에 I/O 연산을 위임하는 방식이다.\n프로세서를 거치지 않고 그대로 메모리에 접근하기 때문에 CPU는 전송의 시작과 끝에 걸리는 인터럽트에만 관여\n해당 기능은 시스템 버스 상의 별도 모듈이 있거나 I/O 모듈에 포함된다.\nDMA 모듈에 입출력을 명령하는 정보는 다음과 같다. Read/Write 요청 여부\n관련 I/O 장치 주소\n읽거나 쓸 메모리 내 시작위치\n읽거나 쓸 워드의 개수 DMA 모듈은 데이터를 메모리로부터 또는 메모리로 전송하기 위하여 버스를 제어할 필요가 있음.\n프로세서는 한 번의 버스 사이클(버스를 통해 한 워드 전송하는데 걸리는 시간) 동안 일시정지하게 되고, 이 때문에 프로세서의 수행이 조금 느려지게 되는 단점이 있지만 다수의 I/O전송의 경우 DMA가 훨씬 효과적\n<br><img src=\"https://i.imgur.com/AAtvoPm.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 하나의 컴퓨터에 CPU를 여러개 붙여서 여러 개의 기계 명령어를 동시에 실행할 수 있음 두 개 이상 유사한 수행 능력을 갖는 프로세서로 구성\n버스나 내부 연결 방식에 의해 상호 연결된 주기억장치와 I/O 장치 공유\n동일한 장치에 이르는 경로들을 제공하는 채널이 동일하거나 달라도 모든 프로세서는 I/O 장치 접근 공유\n모든 처리기는 동일한 기능 수행\n시스템은 프로세서들과 작업, 태스크 파일, 그리고 데이터 요소 수준에서 프로그램들 간의 상호작용을 제공하는 하나의 통합된 운영체제에 의해 제어 멀티프로세서 구조를 가짐으로써 단일 프로세서에 비해 가질 수 있는 장점 성능 : 단일 처리기보다 동시에 처리하는 연산이 많으므로 성능 향상\n가용성: 모든 처리기들이 동일한 기능 수행 -&gt; 하나의 처리기가 고장나도 동작 가능\n점진적 확장: 성능 향상 -&gt; 처리기의 추가 설치 가능\n크기 조정(scaling) : 벤더들은 처리기의 수에 따라 가격과 성능이 다른 다양한 제품 공급 하지만 이러한 장점들을 살리기 위해서는 운영체제가 이러한 멀티프로세서의 활용성을 높여주는 도구와 기능을 제공해야 함 멀티프로세서에도 문제점이 있음 요즘 컴퓨터들은 한 단계 이상의 캐시 메모리를 가지고 있음\n각 지역 캐시들은 주기억장치 일부 이미지를 포함하고 있어 하나의 워드가 하나의 캐시에서 변경되면, 다른 캐시에 있는 워드를 무효화시킬 수 있는 문제가 발생할 수 있음\n이러한 현상을 방지하기 위해 다른 프로세서들은 갱신이 발생하면 변경되어야 하며 이는 일반적으로 하드웨어 분야에서 논의됨 <br><img src=\"https://i.imgur.com/dA4ersP.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n칩 멀티프로세서로 알려져 있으며 코어라고 불리는 두 개 이상의 프로세서가 다이(die)라고 불리는 단일 실리콘 조각에 결합되어 있는 형태\n쉽게 설명하면 연산들을 하는 회로들을 CPU 안에 여러개 복제해놓은 형태\n위의 그림에서는 코어가 6개가 있기 때문에 기계어 명령어를 6개까지 동시에 실행할 수 있다.\n하지만 만약에 이전 연산을 이용해서 연산을 하는 경우, 동시에 실행할 수 없는 경우가 생기기도 하는데, 이러한 경우를 잘 고르면서도 코어들을 효율적으로 상관할 수 있게 하려면 컴파일러를 통해 순서를 바꿔 상호 독립적인 작업을 수행할 수 있도록 만들어야 함\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"메모리 계층 구조","level":3,"id":"메모리_계층_구조_0"},{"heading":"보드내 메모리","level":4,"id":"보드내_메모리_0"},{"heading":"보드외 메모리","level":4,"id":"보드외_메모리_0"},{"heading":"오프라인 저장 장치","level":4,"id":"오프라인_저장_장치_0"},{"heading":"캐시 메모리 📚📚📚","level":3,"id":"캐시_메모리_📚📚📚_0"},{"heading":"구조","level":4,"id":"구조_0"},{"heading":"캐시 읽기 연산 과정","level":4,"id":"캐시_읽기_연산_과정_0"},{"heading":"I/O 연산의 기법","level":3,"id":"I/O_연산의_기법_0"},{"heading":"프로그램된 입출력(Programmed I/O)","level":4,"id":"프로그램된_입출력(Programmed_I/O)_0"},{"heading":"인터럽트 구동 입출력(Interrupt-driven I/O)","level":4,"id":"인터럽트_구동_입출력(Interrupt-driven_I/O)_0"},{"heading":"직접 메모리 접근(DMA)","level":4,"id":"직접_메모리_접근(DMA)_0"},{"heading":"멀티프로세서와 멀티코어 구조","level":3,"id":"멀티프로세서와_멀티코어_구조_0"},{"heading":"멀티프로세서","level":4,"id":"멀티프로세서_0"},{"heading":"멀티코어","level":4,"id":"멀티코어_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":12583,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 계층 구조, 캐시 메모리, IO연산 기법, 멀티프로세서와 멀티코어.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html":{"title":"운영체제_메모리 관리_메모리 관리 요구조건","icon":"","description":"\n재배치(relocation)\n보호(protection)\n공유(sharing)\n논리적 구성(logical organization)\n물리적 구성(physical organization) 주기억장치는 여러 프로세스에 의해 공유\n\bSwap in/Swap out 동일한 메모리 위치로 배치 보장 못함 =&gt; 재배치 <img src=\"https://i.imgur.com/JEOOAjb.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 프로세스의 이미지는 주기억장치의 연속된 영역이라 가정\nCPU 하드웨어 + 운영체제 소프트웨어 =&gt; 프로그램 코드의 메모리 참조 부분에서 실제 물리 주소로 변환 프로세스는 다른 프로세스에 의한 원치 않는 간섭(의도적 or 우연히 발생할 수 있는 간섭)으로부터 보호되어야 함\n=&gt; 다른 프로세스에 속한 프로그램들은 허가 없이 읽거나 쓰기를 위해 임의의 프로세스의 메모리 참조 금지\n재배치할 때 주기억장치 내의 프로그램 위치 예측 불가\n=&gt; 보호 요구 조건을 까다롭게 만듦\n=&gt; 보호를 위해 컴파일 시간에 확실한 주소를 아는 것이 불가능\n=&gt; 주소 검사는 실행 시간에 동적으로 주소 계산\n실행 시간에 다른 프로그램의 명령어로 분기 및 데이터 접근 불가능 이런 상황 발생 시 명령어를 중단시킬 수 있어야 함 메모리 보호는 운영체제(소프트웨어)가 아닌 프로세서(하드웨어)의 역할 운영체제가 예측이 가능하다고 하더라도 모든 메모리 참조를 예측할 수 없기 때문\n메모리 참조의 허용 여부 판정\n=&gt; 오로지 메모리 참조 명령의 실행 시에만 가능 보호 메커니즘은 주기억장치의 같은 부분을 접근하려는 여러 개의 프로세스들을 융통성있게 허용할 수 있어야 함\nex) 여러 개의 프로세스들이 동일한 프로그램 수행중일 때 각 프로세스들이 프로그램의 사본을 가지기 &lt; 프로그램 사본 하나를 모든 프로세스들이 참조 재배치를 허용해도 공유 기능을 지원해야 함 보호 기능을 침해하지 않는 범위에서 제한된 접근을 통해 메모리의 일부분 공유 운영체제와 컴퓨터 하드웨어가 몇몇 형태의 모듈로 구성된 사용자 프로그램과 데이터를 효과적으로 처리할 수 있을 때 얻는 이점\n각 모듈의 작성과 컴파일은 독립적으로 이루어질 수 있으며, 서로 다른 모듈 간에 이루어지는 참조는 수행시간에 시스템에 의해 해결됨\n비교적 적은 추가 비용(overhead)으로 각 모듈마다 서로 다른 보호 등급(읽기전용, 수행전용)을 적용 가능\n프로세스들 간에 모듈을 공유할 수 있는 기법 제공 가능 모듈 레벨의 공유 =&gt; 사용자가 문제를 보는 관점과 부합 + 그 결과 사용자가 자신이 원하는 대로 공유 명시 가능 이러한 요구들을 가장 쉽게 충족시키는 수단 =&gt; 세그먼테이션(segmentation)\n빠르고 느린 메모리들의 계층 간의 정보 흐름(주기억장치 &lt;-&gt; 보조기억장치)\n=&gt; 프로그래머 개인에게 전가하면 안되는 이유 오버레이 사용해야 함\n메모리를 고려한 모듈 구성을 프로그래머가 해야 함\n컴파일러가 오버레이 지원해도 인력 낭비 멀티프로그래밍 환경에서 프로그램 작성 시에 프로그래머는 사용가능한 공간의 양과 위치를 모름\n=&gt; 시스템이 메모리의 두 계층 사이의 정보의 흐름에 대한 책임을 가져야 함\n오버레이(overlay)\n컴퓨터의&nbsp;메인 메모리 기억 장치보다 큰 프로그램을 실행할 수 있게끔 하는&nbsp;방법\n메모리의 같은 영역을 차지하는 다양한 모듈들 중에서 프로그램에서 필요한 모듈만 골라 메모리에 적재하는 방식\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제메모리 관리메모리 관리 요구조건","level":1,"id":"운영체제메모리_관리메모리_관리_요구조건_0"},{"heading":"메모리 관리 요구조건","level":1,"id":"메모리_관리_요구조건_0"},{"heading":"메모리 관리 관련 용어","level":2,"id":"메모리_관리_관련_용어_0"},{"heading":"재배치(Relocation)","level":2,"id":"재배치(Relocation)_0"},{"heading":"보호(Protection)","level":2,"id":"보호(Protection)_0"},{"heading":"공유(Sharing)","level":2,"id":"공유(Sharing)_0"},{"heading":"논리적 구성","level":2,"id":"논리적_구성_0"},{"heading":"물리적 구성","level":2,"id":"물리적_구성_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":4660,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 관리_메모리 관리 요구조건.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html":{"title":"운영체제_메모리 관리_메모리 분할(memory partitioning)","icon":"","description":"\n메모리 관리 =&gt; 처리기에 의해 실행될 프로세스를 주기억장치로 가져오는 것\n가상 메모리 기법을 사용하는 세그먼테이션이나 페이징과는 다르게 가상메모리를 사용하지 않는 기법들 운영체제에서 주기억장치를 고정된 경계를 가지는 메모리 영역으로 구분\n<img src=\"https://i.imgur.com/AiDB0xA.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n한 프로세스의 크기가 분할의 크기보다 작거나 같음\n문제점 프로그램의 파티션보다 클 수 있음 =&gt; 오버레이의 사용 필요성\n주기억장치 이용이 매우 비효율적\n내부단편화 =&gt; 비균등 분할을 통해 영향 줄이기 내부단편화(internal fragmentation)\n적재되는 데이터가 파티션보다 작아 파티션 내부 공간의 낭비가 발생하는 현상 내부단편화의 영향을 줄일 수 있음 사용 가능 파티션이 존재하기만 하면 프로세스는 해당 파티션으로 적재가 가능\n=&gt; 모든 파티션들은 같은 크기이므로 어떤 파티션을 사용해도 차이 X\n준비 상태에 있지 않은 프로세스가 모든 파티션을 차지하고 있다면 새로운 프로세스를 위한 공간을 만들기 위해 프로세스들 중 하나 스왑 아웃\n<br><img src=\"https://i.imgur.com/dNZMMUE.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n각 프로세스의 용량에 맞는 파티션을 할당해주는 방법(파티션 당 하나의 프로세스 큐) 각 파티션에 할당 예정인 스왑아웃된 프로세스들을 유지하는 스케줄링 큐 필요\n장점 : 프로세스들이 항상 메모리의 낭비(내부 단편화)를 최소화시키는 파티션에 적재\n단점: 해당 메모리의 크기에 맞는 프로세스가 없을 경우 쓰이지 않은 채로 방치되는 파티션 발생 단일 큐 사용 프로세스를 메모리에 적재할 시점에 사용가능한 파티션 중에서 프로세스를 적재할 수 있는 가장 작은 크기의 파티션이 선택됨\n모든 파티션이 사용중일 경우 스와핑(스왑아웃) 비균등 분할의 단점 정해진 파티션 수에 의해 프로세스의 개수가 제한됨\n파티션 크기가 고정되므로 크기가 작은 작업들은 공간을 비효율적으로 사용 <br><img src=\"https://i.imgur.com/TItTdf4.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n- 고정분할 기법의 문제 해결을 위한 방법\n- 파티션의 크기와 개수가 가변적\n- 한 프로세스가 주기억장치로 적재될 때 정확히 요구된 크기만큼의 메모리만 할당\n- 단점 - 외부 단편화: **'구멍'** 이 존재하여 사이사이 사용할 수 있는 메모리가 있음에도 불구하고 이어져있지 않아 메모리 단편화의 심화와 메모리 이용률 감소 =&gt; **메모리 집약(Memory Compaction)** 을 통해 해소.\n메모리 집약(Memory Compaction)\n프로세스가 사용하는 파티션을 이동시켜 각 파티션이 연속적이 되도록 인접하게 만들고 메모리의 모든 빈 공간이 하나의 블록이 되도록 만듦\n<br><img src=\"https://i.imgur.com/KgCkHLa.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">최초적합 &lt;= 순환적합 &lt;= 최적적합\n최적적합(best-fit) 요청된 크기와 가장 근접한 크기의 메모리 선택 최초적합(first-fit) 메모리의 처음부터 검사해서 크기가 충분한 첫 번째 사용 가능한 메모리 블록 선택 순환적합(next-fit) 가장 최근에 배치되었던 메모리의 위치에서부터 검사를 시작해 크기가 충분한 다음 위치의 사용 가능한 메모리 블록을 선택 모든 프로세스가 대기 상태이고 메모리 집약 후에도 추가의 프로세스를 생성하기 위한 충분한 메모리가 없을 경우\n=&gt; 주기억장치에 있는 프로세스 중 하나를 스왑아웃시켜 준비상태의 새로운 프로세스나 준비-일시정지 상태의 프로세스가 들어올 공간을 만듦 고정 및 동적 분할 기법의 단점 활성 프로세스 수 제한\n프로세스와 파티션의 크기 차이가 크면 공간을 비효율적으로 사용\n=&gt; 절충안적인 버디(Buddy) 시스템의 등장 메모리 블록은 = 할당된 가장 작은 크기의 블록 = 할당된 가장 큰 크기의 블록, 보통 할당 가능한 전체 메모리의 크기와 같음\n요청된 크기 s가 이라면 전체 블록 할당. 그렇지 않은 경우 크기의 두 개의 버디로 분할 이라면 두 버디 중 하나를 할당. 그렇지 않은 경우 이 버디 중 하나를 다시 두 개로 나눔\ns 이상의 크기를 가진 가장 작은 버디가 만들어져 해당 요청에 할당이 이루어질 때까지 과정 반복 인 구멍들의 리스트 유지\n수정된 형태의 버디 시스템이 UNIX 커널 메모리 할당 방법으로 사용\n<br><img src=\"https://i.imgur.com/ZsaFbkr.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n위 그림과 같이 반씩 계속 메모리를 분할하고 적당한 크기까지 분할되면 해당 메모리에 할당하는 방식<br>\n<img src=\"https://i.imgur.com/dfYA2na.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n트리로 표현하면 이런 식으로 이진트리가 만들어진다.\n해당 트리는 B가 위의 예제에서 B가 해제되고 난 후의 상태인데, 보면 리프노드가 적어도 하나는 할당된 것을 볼 수 있다. 할당되지 않았을 경우 더 큰 블록으로 합쳐진다.\nvoid get_hole(int i)\n{ if (i == (U+1)) &lt;실패&gt;; if ( &lt;i_list가 비었음&gt; ) { get_hole(i+1); &lt;구멍을 두 개의 버디로 나눈다&gt; &lt;버디를 i_list에 포함시킨다&gt; } &lt;i_list의 첫 번쨰 구멍을 선택한다&gt;\n} 프로세스가 Swap in일 때 같은 주소에 배치하는 경우 고정 분할 기법 - 파티션 별 하나의 프로세스 큐 비균등 분할 프로세스가 적재되어질 때 코드 안에 있던 메모리 참조를 위한 상대적인 주소들은 적재된 프로세스의 시작 주소를 기준으로 결정되는 주기억장치 내의 절대 주소로 바뀜 프로세스가 Swap in일 때 다른 주소에 배치되는 경우 균등분할\n단일 큐를 쓰는 비균등 분할\n동적 분할 프로세스가 Swap out되었다가 다시 Swap in하는 경우 각각 다른 위치에 적재될 수 있어 주소를 유형별로 구분 논리주소 현재 데이터가 적재된 메모리와는 독립적인 메모리 위치에 대한 참조 상대주소 논리 주소의 특별한 예\n주로 처리기의 한 레지스터 값으로부터 상대적인 위치를 의미하는 주소 물리주소 주기억장치 내에서의 실제 위치 <br>프로세스는 베이스 레지스터와 경계 레지스터에 의해 격리<img src=\"https://i.imgur.com/IXSmHTf.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 베이스 레지스터 프로세스가 실행 상태가 되면 프로세서의 특정 레지스터에 프로그램이 적재되어 있는 주기억장치의 시작주소가 적재되는 레지스터 경계 레지스터 프로그램의 마지막 위치를 가리키는 레지스터 프로세스를 실행하는 동안 상대주소 사용 -&gt; 상대주소에 베이스 레지스터 값이 더해져 절대 주소로 변환 -&gt; 절대 주소가 경계 레지스터 값과 비교 -&gt; 주소가 경계범위 안에 있다면 명령 실행/그렇지 않다면 운영체제로 인터럽트 발생\n다른 프로세스의 원하지 않은 접근으로부터 안전하게 보호 가능 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제메모리 관리메모리 분할(memory partitioning)","level":1,"id":"운영체제메모리_관리메모리_분할(memory_partitioning)_0"},{"heading":"메모리 분할","level":1,"id":"메모리_분할_0"},{"heading":"고정분할","level":2,"id":"고정분할_0"},{"heading":"분할 크기","level":3,"id":"분할_크기_0"},{"heading":"균등분할","level":4,"id":"균등분할_0"},{"heading":"비균등 분할","level":4,"id":"비균등_분할_0"},{"heading":"고정 분할에서의 배치 알고리즘","level":3,"id":"고정_분할에서의_배치_알고리즘_0"},{"heading":"균등 분할의 경우","level":4,"id":"균등_분할의_경우_0"},{"heading":"비균등 분할의 경우","level":4,"id":"비균등_분할의_경우_0"},{"heading":"동적 분할","level":2,"id":"동적_분할_0"},{"heading":"배치 알고리즘","level":3,"id":"배치_알고리즘_0"},{"heading":"교체 알고리즘","level":3,"id":"교체_알고리즘_0"},{"heading":"버디(Buddy) 시스템","level":2,"id":"버디(Buddy)_시스템_0"},{"heading":"재배치","level":2,"id":"재배치_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":7847,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 관리_메모리 분할(memory partitioning).md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html":{"title":"운영체제_메모리 관리_세그먼테이션","icon":"","description":"<img src=\"https://i.imgur.com/mBsY10K.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n사용자 프로그램은 세그먼테이션 기법을 이용하여 프로그램과 그와 관련된 데이터들이 세그먼트로 나뉘어질 수 있음.\n프로그래머가 각 세그먼트를 지정 가능\n프로세스가 메모리로 적재될 경우 프로세스의 모든 세그먼트가 사용가능한 메모리 영역에 할당되어지고 그에 따라 세그먼트 테이블의 주소가 만들어짐\n세그먼트의 길이는 유동적이며 최대 길이는 제한이 있음. 유동적이기 때문에 동적 분할과 유사한 성격을 띰.\n하지만 주요한 차이점은 세그먼테이션의 경우 프로그램이 하나 이상의 파티션을 차지할 수 있고 이 파티션들이 연속적일 필요가 없다. 동적 할당 기법과 마찬가지로 외부단편화를 초래하지만 프로세스가 보다 작은 크기의 여러 조각으로 나누어지기 때문에 외부 단편화가 상대적으로 적음\n물리주소와 논리주소 간에 복잡한 관계가 존재 각 프로세스마다 세그먼트 테이블을 이용\n주기억장치의 사용 가능한 블록들의 리스트 유지 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제메모리 관리세그먼테이션","level":1,"id":"운영체제메모리_관리세그먼테이션_0"},{"heading":"세그먼테이션","level":1,"id":"세그먼테이션_0"},{"heading":"메모리 분할 방법 정리","level":1,"id":"메모리_분할_방법_정리_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":4731,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 관리_세그먼테이션.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html":{"title":"운영체제_메모리 관리_페이징","icon":"","description":"비균등 고정 분할 기법 -&gt; 내부 단편화의 문제 발생\n내부 단편화\n분할된 메모리 조각의 크기가 프로세스의&nbsp;크기보다&nbsp;커서 메모리가 남지만, 다른 프로세스가 들어가기엔 부족해서 사용할 수 없는 상태 가변크기 분할 기법 -&gt; 외부 단편화의 문제 발생\n외부 단편화\n남아있는 메모리의 크기가&nbsp;실행하고자 하는 프로세스보다 크지만, 연속적이지 않은 공간에 존재하여 실행하지 못하는 현상\n이를 보완하기 위한 방법 =&gt; 페이징\n<img src=\"https://i.imgur.com/mo1wiZV.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"><br>\n<img src=\"https://i.imgur.com/BCuL3Mq.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 주기억장치를 비교적 작은 고정 사이즈 파티션 (프레임) 으로 나누고 각 프로세스 또한 같은 크기의 고정 조각 (페이지) 으로 나눔 각 프로세스마다 하나의 페이지 테이블(page table) 유지 페이지 테이블은 프로세스의 각 페이지들에 해당하는 프레임의 위치 관리\n프로그램 안에서 각 논리 주소는 페이지 번호와 페이지 내의 오프셋으로 구성\n논리주소는 프로그램의 시작 위치로부터의 상대적인 값(페이지 번호 + 오프셋) 으로 처리기는 그 논리주소를 물리주소(프레임 숫자 + 오프셋)로 변환 외부단편화로 인한 메모리 낭비 X + 내부단편화로 인한 낭비도 마지막 페이지에서만 발생 프로세스별로 필요한 페이지만큼 빈 프레임에 적재하고 중간에 Swap out된다 하더라도 남은 프레임에 순서대로 채워넣기 논리주소로 되어있기 때문에 가능 한 프로그램이 하나 이상의 파티션을 차지할 수 있으며, 이 파티션들이 반드시 연속일 필요는 없다는 점이 중요 페이징 기법이 편리하게 사용되기 위한 방법 페이지/프레임 크기를 2의 거듭제곱으로 만듦<br>\n=&gt; 프로그램의 시작 위치로부터의 상대 주소와 페이지 번호와 오프셋으로 표현되는 논리 주소가 같음을 알 수 있음 <img src=\"https://i.imgur.com/ZjZioRj.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 10개 비트가 오프셋으로 사용되고 나머지 6비트가 페이지 번호\n<br>주소가 16비트, 페이지 크기가 1K(1024 바이트)라고 할 때 개의 1K 페이지로 구성될 수 있음.<img src=\"https://i.imgur.com/SfJ7aYQ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 2의 거듭제곱으로 만들 때 장점 논리 주소가 상대 주소와 동일해 프로그래머, 어셈블러, 링커에게 투명함\n수행 중에 동적 주소 변환을 담당할 하드웨어 기능 구현이 쉬움 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제메모리 관리페이징","level":1,"id":"운영체제메모리_관리페이징_0"},{"heading":"페이징","level":1,"id":"페이징_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":2685,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 관리_페이징.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html":{"title":"운영체제_병행성_교착상태와 기아상태_교착상태 발견","icon":"","description":"\n자원 할당이 요구될 때마다 매번 수행될 수도 있고\n주기적으로 가끔 수행될 수도 있음\n요청 행렬과 할당 행렬 필요 <img src=\"https://i.imgur.com/WaQxuqU.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> P는 프로세스, R은 자원\n자원 벡터: 각각의 자원에 대해 할당할 수 있는 자원의 개수\n가용 벡터: 자원 벡터에서 해당 자원의 값 - 할당 행렬의 열 전체 임시벡터 : 가용 벡터를 처음 복사 P3가 종료되고 난 후 자원 반환\nP1, P2는 자원 벡터에서 할당 행렬을 빼면 음수로 되기 때문에 종료하지 못하는 프로세스임 교착상태에 포함되어 있는 모든 프로세스 중지\n교착상태에 포함되어 있는 각 프로세스의 수행를 롤백시킴. 미리 정의한 체크포인트까지 되돌린 후 다시 수행\n교착상태가 없어질 때까지 교착상태에 포함되어 있는 프로세스들 하나씩 종료시킴\n교착상태가 없어질 때까지 교착상태에 포함되어 있는 자원을 하나씩 선점시킴 자원들을 유형에 따라 서로 다른 클래스로 구분\n자원 클래스들 간에는 할당 순서를 두어 환형 대기를 막음\n클래스 내부의 자원들 간에는 각 클래스에 적절한 교착상태 해결 방법을 사용 스왑 공간 보조 기억장치 상의 메모리 블록\n프로세스 스와핑용\n필요한 모든 자원을 한꺼번에 요청 프로세스 자원 테이프 드라이브나 파일 같은 할당 가능한 장치 자원\n프로세스가 이 클래스에 속한 자원의 예상 사용 시간을 미리 예측 가능 시간을 운영체제에 알려서 구현 가능 자원 할당 순서를 미리 결정하는 교착상태 예방 방법도 사용 가능 주 메모리 페이지나 세그먼트 등의 단위로 프로세스들에게 할당되는 자원\n선점을 허용하는 교착상태 예방 방법 내부 자원 입출력 채널 같은 지원\n자원 할당 순서를 미리 결정하는 교착상태 예방 방법 사용 가능 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제병행성교착상태와 기아상태_교착상태 발견","level":1,"id":"운영체제병행성교착상태와_기아상태_교착상태_발견_0"},{"heading":"교착상태 발견","level":1,"id":"교착상태_발견_0"},{"heading":"교착상태 발견 알고리즘","level":2,"id":"교착상태_발견_알고리즘_0"},{"heading":"교착상태 회복 알고리즘","level":2,"id":"교착상태_회복_알고리즘_0"},{"heading":"교착상태에 대한 통합적인 전략","level":2,"id":"교착상태에_대한_통합적인_전략_0"},{"heading":"전략","level":3,"id":"전략_0"},{"heading":"시스템 자원의 클래스","level":3,"id":"시스템_자원의_클래스_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":3053,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_교착상태 발견.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html":{"title":"운영체제_병행성_교착상태와 기아상태_교착상태 예방,회피,발견","icon":"","description":"\n교착상태를 예방하는 전략 운영체제를 설계할 때 교착상태가 발생할 가능성을 없애기 직접적인 방법 환형대기를 허용하지 않는 것 간접적인 방법 조건 1~3(상호 배제, 점유대기, 비선점 조건)중에 하나를 허용하지 않는 것 시스템 설계에서 상호 배제 조건을 없앨 수는 없지만 공유 자원의 일관성을 위해 반드시 필요함\n=&gt; 운영체제의 지원 필요\n다수의 읽기 접근은 허용되지만 쓰기 접근은 한 시점에 하나만 배타적으로 허용 프로세스는 자신이 사용할 모든 자원을 한 순간에 요청\n=&gt; 비효율적임 자원 흭득까지 오랜 시간 기다릴 수 있음\n나중에 사용하는 자원을 오랜 시간 점유 -&gt; 실제 수행이 끝날 때쯤에 사용될 수 있으므로\n프로세스가 미래에 사용될 모든 자원을 미리 알기 어려움 자원을 점유한 프로세스가 다른 자원 할당 불가 시 점유 자원 반납\n다른 프로세스가 점유한 자원을 강제로 반납시키고 점유 우선순위가 있을 때 적용 가능 Database transaction(원자적 연산) 중간에 끊겨도 온전히 실행되거나 모두 실행되지 않게 하여 정보의 유지 보장 자원들의 할당 순서를 정하면 없앨 수 있음\n실제로는 연산이 오래 걸려 쓸 수 없음\n운영체제의 자원 할당 순서에 위배되기 때문에 나타날 수 없음 교착상태 발생 조건 1~3(상호 배제, 점유대기, 비선점 조건) 허용 + 예방처럼 자원 할당 순서를 미리 정하지 않음\n자원을 할당할 때 교착 상태가 발견 가능한 상황으로 진행하지 않도록 교려\n=&gt; 병행성의 더 많은 제공\n할당 전에 이 할당이 교착 상태를 발생시킬 가능성이 있는지 동적 검사 교착상태 예방은 비효율적 현재 자원의 가용 개수와 프로세스 자원 요구량을 미리 알고 있어야 가능\n=&gt; 현실적으로 불가능 교착상태 회피 방법 프로세스가 시작하려 할 때 요구하는 자원 할당이 교착상태 발생의 가능성이 있을 경우 프로세스를 시작시키지 않음\n수행 중인 프로세스가 요구하는 추가적인 자원 할당의 교착상태의 발생 가능성이 있으면, 자원을 할당하지 않는다 벡터와 행렬을 정의한 뒤 이에 대해 회피 방법 논의\n<img src=\"https://i.imgur.com/JsDZe19.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n모든 프로세스들이 요구한 자원의 개수가 전체 자원 개수보다 적으면 교착상태가 발생하지 않음 = 현재 존재하는 모든 프로세스들이 요구하는 자원의 개수 = 새로 수행하려는 프로세스가 유행 모든 프로세스들이 동시에 최대 자원을 요구하여 사용함을 가정하고 있어 효율적이지 않음\n<br><img src=\"https://i.imgur.com/97i9bgE.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n- 은행원 알고리즘(banker's algorithm)\n- 상태(state)와 안전한 상태(safe state) - 상태 =&gt; 프로세스들이 자원을 요구하고 할당받은 관계 - 안전한 상태 =&gt; 교착상태가 발생하지 프로세스에게 자원을 할당할 수 있는 진행 경로가 존재함 - 불안전한 상태 =&gt; 그러한 진행 경로가 없는 상태\n#### (a) 초기상태<br><img src=\"https://i.imgur.com/VkcP2uN.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nP1의 경우 =&gt; R1 자원 부족(가용벡터 0개), R2 자원 부족(가용 벡터 1개), R3 자원 부족(가용 벡터 1개)\nP2의 경우 =&gt; R3만 1개의 자원이 필요한데 가용 벡터에도 R3가 하나 있기 떄문에 종료가 가능\nP3의 경우 =&gt; R1 자원 부족(가용벡터 0개), R3 자원 부족(가용 벡터 1개)\nP4의 경우 =&gt; R1 자원 부족(가용벡터 0개), R2 자원 부족(가용 벡터 1개)\n결과 P2 프로세스만 완료 수행이 가능한 상태 =&gt; P2 프로세스 완료 <br><img src=\"https://i.imgur.com/Exl4ryt.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nP2 프로세스가 차지하고 있던 자원이 완료되자 다시 반환됨\nP1, P3, P4 모두 수행 완료가 가능한 상태\n그 중에서 가장 가까운 P1이 수행 완료됨\nP1이 종료하는데 요구하는 자원의 양이 다 많기 때문에 P1 프로세스 완료\n<br><img src=\"https://i.imgur.com/UCLO5MO.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nP1이 수행 완료되고 다시 자원이 반환됨\nP1, P2는 모두 수행 완료되어 차지하고 있는 자원이 없는 상태\nP3이 종료하는데 필요한 조건을 만족하여 수행 완료\n<br><img src=\"https://i.imgur.com/G3umiAr.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nP1, P2, P3가 모두 종료하고 P4만 남은 경우\nP4만 남아서 조건을 체크 -&gt; 수행 완료가 가능한 조건을 가지고 있어 해당 프로세스 완료 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제병행성교착상태와 기아상태_교착상태 예방,회피,발견","level":1,"id":"운영체제병행성교착상태와_기아상태_교착상태_예방,회피,발견_0"},{"heading":"교착상태 예방","level":1,"id":"교착상태_예방_0"},{"heading":"간접적인 방법 - 조건별 방법","level":2,"id":"간접적인_방법_-_조건별_방법_0"},{"heading":"조건1. 상호 배제","level":3,"id":"조건1._상호_배제_0"},{"heading":"조건2. 점유대기","level":3,"id":"조건2._점유대기_0"},{"heading":"비선점","level":3,"id":"비선점_0"},{"heading":"환형대기 예방","level":3,"id":"환형대기_예방_0"},{"heading":"교착상태 회피","level":1,"id":"교착상태_회피_0"},{"heading":"교착상태 회피 - 프로세스 시작 거부","level":2,"id":"교착상태_회피_-_프로세스_시작_거부_0"},{"heading":"교착상태 회피 - 자원 할당 거부","level":2,"id":"교착상태_회피_-_자원_할당_거부_0"},{"heading":"(b) P2 수행 완료","level":4,"id":"(b)_P2_수행_완료_0"},{"heading":"(c) P1수행완료","level":4,"id":"(c)_P1수행완료_0"},{"heading":"(d) P3 수행 완료","level":4,"id":"(d)_P3_수행_완료_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":6488,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_교착상태 예방,회피,발견.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html":{"title":"운영체제_병행성_교착상태와 기아상태_교착상태의 원리","icon":"","description":"\n교착상태 프로세스들의 집합이 더 이상 진행을 못하고 영구적으로 블록되어 있는 상태 발생시기 시스템 자원에 대한 경쟁 도중\n프로세스 간 통신 도중 원인 기다리던 사건이 결코 발생하지 않기 때문 <img src=\"https://i.imgur.com/Yp7gBpc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n공유 자원인 교차로의 네 구역에서 서로의 차가 필요한 구역을 막고 있기 때문에 이러지도 저러지도 못 하는 상황 발생\n<br><img src=\"https://i.imgur.com/JCumAwM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\nGet 요청 -&gt; 자원을 요청\nRelease 요청 -&gt; 사용한 자원을 반환\n<br><img src=\"https://i.imgur.com/8stIQ7n.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nx축은 프로세스 P의 진행, y축은 프로세스 Q의 진행\nx축의 경우 getA와 getB사이 A에 대한 자원을 흭득한 상태\ny축의 경우 getB와 getA사이 B에 대한 자원을 흭득한 상태\n프로세스P의 경우 다음에 B를 가져와야 하지만 프로세스 Q가 가지고 있으므로 대기하고, 프로세스 Q의 경우 다음에 A를 가져와야 하지만 프로세스 P가 가지고 있으므로 서로 대기하다가 교착 상태 발생\n<br><img src=\"https://i.imgur.com/fA8qBEq.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n프로세스 P가 A,B 자원을 요청해서 쓰지만 그때그때 사용이 끝날 때마다 바로바로 자원을 반환하여 교착 상태가 일어나지 않음\nP의 getA -&gt; Q의 getB -&gt; P의 ReleaseA -&gt; Q의 getA -&gt; Q의 realeseB -&gt; P의 getB -&gt; P의 releaseB 의 순서대로 가면 교착상태가 일어나지 않음을 알 수 있음 (경로4)\n<br><img src=\"https://i.imgur.com/626oNsh.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n프로세스 사용에 의해 없어지지 않는 자원\n프로세스가 사용한 후 다른 프로세스가 다시 사용할 수 있도록 반납\n처리기, 입출력 채널, 주/보조 메모리, 장치, 파일이나 데이터베이스나 세마포어와 같은 자료구조 등\n<br><img src=\"https://i.imgur.com/1MuTfyM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n다른 프로세스에서 Lock을 걸어놓은 상태에서 서로가 Lock을 걸어놓은 자원에 Request를 하게 되면 교착 상태 발생\n<br><img src=\"https://i.imgur.com/69nhyG3.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n가용메모리가 200KB라고 가정할 경우 두 프로세서의 요청 모두의 메모리 요청을 처리하기는 어려움\n두 번째 요청에서 두 프로세서 모두 블록상태가 되고 교착상태 발생 생성되었다가 시간이 지나면 소멸되는 자원\n개수의 제한이 없음\n자원이 소비 프로세스에 의해 사용되면 사라짐\n인터럽트, 시그널, 메시지, I/O 버퍼 정보 등\n<br><img src=\"https://i.imgur.com/C876iRM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n각 프로세스는 상대 프로세스로부터 메시지 수신을 기다림\n메시지 수신 이후 상대 프로세스에게 새로운 메시지 전달\n수신을 먼저 수행 수신 프리미티브가 블록킹 타입(메시지가 올 때까지 대기)이면 교착 상태 발생\n발견하기 어려운 오류 프로세스와 자원 할당 관계를 표현하는데 사용 프로세스가 자원을 요청하는 경우 <br>\n<img src=\"https://i.imgur.com/rocXM9U.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 자원이 프로세스에게 할당된 경우 <br>\n<img src=\"https://i.imgur.com/uxOYzBV.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 환형 대기 두 개의 프로세스가 각자 서로 점유하고 있는 자원에 대해 서로 요구할 경우 환형 대기 발생 =&gt; 교착 상태로 이어짐 <br>\n<img src=\"https://i.imgur.com/lUW2M2F.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> <br>\n<img src=\"https://i.imgur.com/B3fEHic.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 결국 제자리로 돌아오게 되는 순환의 형태로 가게 되면 교착 상태 발생 교착상태가 아닌 경우 환형 대기와 비슷한 모양이지만 자원 안에 인스턴스가 여러 개가 있어 교착 상태를 방지\n<br>\n<img src=\"https://i.imgur.com/pDnPUs6.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 상호 배제(mutual exclusion) 조건 한 순간에 한 프로세스만이 자원을 사용 가능 점유대기(hold and wait) 조건 이미 자원을 보유한 프로세스가 다른 자원을 요청하며 기다림 비선점(no preemption) 조건 프로세스에 의해 점유된 자원을 다른 프로세스가 강제적으로 뺏을 수 없음 환형 대기(circular wait) 조건 프로세스들 간에 닫힌 연결(closed chain) 존재\n닫힌 연결에서 블록된 프로세스가 자원을 점유하고 있는데 이 자원을 체인 내부의 다른 프로세스가 원하며 대기하고 있음 =&gt; 교착상태를 해결하기 위해 다양한 접근 방법들이 제안","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제병행성교착상태와 기아상태_교착상태의 원리","level":1,"id":"운영체제병행성교착상태와_기아상태_교착상태의_원리_0"},{"heading":"교착상태의 원리 📚📚📚","level":1,"id":"교착상태의_원리_📚📚📚_0"},{"heading":"대표적 예: Traffic Deadlock","level":2,"id":"대표적_예_Traffic_Deadlock_0"},{"heading":"교착상태가 발생하는 예: 결합 진행 다이어그램(Joint Progress Diagram)","level":2,"id":"교착상태가_발생하는_예_결합_진행_다이어그램(Joint_Progress_Diagram)_0"},{"heading":"교착상태가 발생하지 않는 예","level":2,"id":"교착상태가_발생하지_않는_예_0"},{"heading":"재사용 가능한 자원과 소모성 자원","level":2,"id":"재사용_가능한_자원과_소모성_자원_0"},{"heading":"재사용 가능한 자원","level":3,"id":"재사용_가능한_자원_0"},{"heading":"재사용 가능한 자원을 위해 경쟁하는 두 프로세스 예","level":4,"id":"재사용_가능한_자원을_위해_경쟁하는_두_프로세스_예_0"},{"heading":"소모성 자원","level":3,"id":"소모성_자원_0"},{"heading":"소모성 자원에서 교착상태의 예","level":4,"id":"소모성_자원에서_교착상태의_예_0"},{"heading":"자원 할당 그래프","level":2,"id":"자원_할당_그래프_0"},{"heading":"교착 상태 조건 📚📚📚","level":2,"id":"교착_상태_조건_📚📚📚_0"},{"heading":"운영체제에서 교착상태 예방, 회피, 발견 기법 정리","level":2,"id":"운영체제에서_교착상태_예방,_회피,_발견_기법_정리_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":7340,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_교착상태의 원리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html":{"title":"운영체제_병행성_교착상태와 기아상태_식사하는 철학자 문제","icon":"","description":"<img src=\"https://i.imgur.com/DTnydkN.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n식탁에 5명의 철학자가 각각의 의자에 앉아있고, 가운데에는 스파게티가 있음\n각 철학자가 스파게티를 각각 자신의 접시에 가져다 놓고 식사\n스파게티 -&gt; 공유자원\n근데 철학자라서 우아하니까 동시에 집어가지 않고 한 번에 한 사람씩만 상호배제를 통해서 접근\n스파게티를 집을 때는 왼쪽과 오른쪽 포크을 이용해서 스파게티를 떠 가야 함 한 사람이 스파게티를 가져갈 때 양쪽 사람들의 사람들의 포크를 써서 그 동안은 사용 불가\n포크도 공유자원, 상호배제되는 자원 <br><img src=\"https://i.imgur.com/AvK04lC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n- 각 철학자 프로세스가 동시에 실행\n- fork 2개를 집어 eat 한 후에 fork를 다시 돌려놓음\n- 한 사람이 포크를 잡았을 때 포크로 스파게티를 먹으려는 옆 철학자는 기다려야 함 -&gt; 포크를 집고 있을 때는 옆 사람이 포크를 놓는 신호를 줄 때까지 대기 -&gt; 교착상태가 발생할 가능성\n- 모두가 기다리게 되면 모두 굶어 기아상태 발생<br><img src=\"https://i.imgur.com/BPuMIIc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n포크를 집고 음식을 먹는 행위가 원자적으로 이루어지게끔 구성\n테이블의 이용 권한을 흭득하고 운영권한을 넘겼다가 룸을 반납\n교착상태가 발생하지 않음\n<br><img src=\"https://i.imgur.com/dTdXnZi.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n5개의 프로세스 실행\n각각의 프로세스는 get_forks와 release_forks 수행\n두 개의 자원을 요청하는 코드를 모니터를 통해 얻음\n모니터는 자원 두 개를 흭득(get)하고 반환(release)하는 코드를 모니터 프로그램을 통해서 자원 관리 및 행위 개선\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제병행성교착상태와 기아상태_식사하는 철학자 문제","level":1,"id":"운영체제병행성교착상태와_기아상태_식사하는_철학자_문제_0"},{"heading":"식사하는 철학자 문제","level":1,"id":"식사하는_철학자_문제_0"},{"heading":"해결방법","level":2,"id":"해결방법_0"},{"heading":"세마포어를 이용한 해결","level":3,"id":"세마포어를_이용한_해결_0"},{"heading":"모니터를 이용한 해결","level":3,"id":"모니터를_이용한_해결_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":1894,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_식사하는 철학자 문제.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html":{"title":"운영체제_병행성_모니터","icon":"","description":"세마포어의 문제점\n올바른 프로그램 작성의 어려움\nsemWait, semSignal 연산이 프로그램 전체에 산재함\n=&gt; 어떠한 영향을 미치는지 파악이 어려움\n모니터를 이용한 병행 제어\nConcurrent Pascal, Pascal-Plus, Modula-2, Modula-3, Java\n언어 수준 혹은 라이브러리 수준에서 구현 java의 경우 -&gt; synchronized 키워드로 락 걸기 보호하려는 어떠한 객체에도 모니터 락(lock) 설정 가능 java의 경우 -&gt; 만든 객체에 락을 설정/해제가 가능. 연결 리스트 전체를 가리키는 객체를 만들고 설정하면 전체에 대해 락을 걸 수 있음 <img src=\"https://i.imgur.com/dP55EnC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n- 모니터에 진입하게 되면 락을 걸어야 하는지 확인/* 생산자 소비자 프로그램 */\nmonitor boundedbuffer; /* 데이터를 저장하고 꺼내가는 곳 */\nchar buffer (N); /* N개의 문자가 저장될 수 있는 버퍼 */\nint nextin, nextout; /* 버퍼 포인터 */\nint count; /* 버퍼 내부에 추가된 문자 개수 */\ncond notfull, notempty /* 동기화를 위한 조건 변수 */\nvoid append(char x)\n{ if (count == N) cwait(notfull); /* 버퍼에 문자가 가득 찬 경우, 오버플로우 감지 =&gt; 기다림 */ /* 생산자 코드 */ buffer(nextin) = x; nextin = (nextin + 1) % N; count++; /* 버퍼에 문자 하나를 추가 */ csignal(notempty); /* notempty 조건 변수에서 대기하고 있는 프로세스를 깨움*/\n}\nvoid take(char x)\n{ if (count == 0) cwait(notempty); /* 버퍼가 빈 경우, 언더플로우 방지*/ /* 데이터를 꺼내는 코드 */ x = buffer(nextout); nextout = (nextout + 1) % N; count--; /* 버퍼에서 문자 하나를 삭제 */ /* 데이터를 꺼내고 하나가 비면 다른 하나가 다시 차길 기다림 */ csignal(notfull); /* notfull 조건 변수에서 대기하고 있는 프로세스를 깨움 */\n}\n{ /* 모니터 몸체 */ nextin = 0; nextout = 0; count = 0; /* 버퍼 변수 초기화 */\n}\nvoid producer()\n{ char x; while (true) { produce(x); append(x); }\n}\nvoid consumer()\n{ char x; while (true) { take(x); consume(x); }\n}\nvoid main()\n{ parbegin(producer, consumer)\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제병행성모니터","level":1,"id":"운영체제병행성모니터_0"},{"heading":"모니터","level":1,"id":"모니터_0"},{"heading":"유한 버퍼에서 모니터를 이용한 생산자/소비자 문제 해결 방법","level":2,"id":"유한_버퍼에서_모니터를_이용한_생산자/소비자_문제_해결_방법_0"},{"heading":"produce와 take 함수","level":3,"id":"produce와_take_함수_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":2362,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_모니터.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html":{"title":"운영체제_병행성_병행성의 원리","icon":"","description":"운영체제 설계의 핵심 주제 -&gt; 프로세스와 스레드의 관리\n멀티프로그래밍(Multiprogramming) 단일처리기(프로세서) 시스템 상에서 다수의 프로세스 관리 멀티프로세싱(Multiprocessing) 멀티프로세서(다수의 프로세서) 시스템 상에서 다수의 프로세스 관리 분산처리(Distributed processing)\n- 다수의 분산된 컴퓨터들 상에서 수행되는 다수의 프로세스 관리\n=&gt; 병행성(concurrency)\n프로세스 간 통신\n자원에 대한 공유와 경쟁(메모리, 파일, I/O 등 모든 자원)\n프로세스 활동들의 동기화\n프로세스에 대한 처리기 시간 할당\n멀티프로세싱과 분산 시스템과 같이 다수의 처리기가 있는 시스템뿐만 아니라 단일처리기 멀티프로그래밍 시스템에서도 발생되는 이슈\n다수의 응용(application) 다수의 활동 중인 응용들 간에 처리 시간의 동적 공유를 위해 멀티프로그래밍 개발\nContext Switching 자체의 오버헤드 + 프로그램 수행의 점프로 인한 Hit ratio 하락으로 인한 부담 구조화된 응용 모듈화된 설계 원칙과 구조적 프로그래밍의 발전으로 일부 응용들은 병행 프로세스들의 집합으로 구현 운영체제 구조 운영체제는 다수의 프로세스와 스레드의 집합으로 구현 <img src=\"https://i.imgur.com/Z7bfSbT.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n서로가 서로의 임계 영역이 풀리길 기다리고 있는 상태이기 때문에 각 프로세스를 깨워 줄 조건이 없는 상태. 시스템에서 프로세스들은 인터리빙(interleaving), 여러 프로세스들이 서로 번갈아 수행 번갈아 수행하는게 빨라서 병렬처리되는 것처럼 보이지만 실제로 병렬처리되는 것은 아님\n시스템 처리 효율과 구조적인 프로그래밍에 장점 제공\n멀티프로세서 시스템에서는 프로세스들의 인터리빙뿐만 아니라 오버래핑(overlapping)도 지원 복습\n오버래핑(overlapping)\n두 개 이상의 프로세스들이 시간이 중첩되어 실제로 병행 수행\n인터리빙(interleaving)\n두 개 이상의 프로세스들이 서로 번갈아 수행 단일 처리기 환경에서 프로세스들의 수행의 상대 속도를 예측할 수 없음 프로세스들이 수행되는 상대 속도는 운영체제의 스케줄링 정책과 다른 프로세스 활동, 운영체제가 인터럽트를 처리하는 방법 등에 따라 동적으로 바뀌기 때문 전역 자원의 공유의 어려움 순서 따라 결과가 바뀔 수도 있기 때문에 전역 자원의 공유가 어려움 OS가 자원을 최적으로 할당하기 어려워짐 한 프로세스가 IO 특정 입출력 자원을 요청하여 운영체제에 할당받아놓고 일시중지되면 다른 프로세스들이 사용할 수 없음\n가용한 자원이 프로세스의 실행 순서에 따라 사용될 수 없는 상황\n=&gt; 시스템의 교착 상태 발생 프로그래밍 오류를 찾아내는 것이 어려워짐 특정 실행 순서에서 프로그래밍 오류가 나타나는데 순서가 바뀌고 오류가 안 뜨면 이후에도 디버깅이 어려움 함수 이미지가 하나만 존재할 경우, 같은 함수를 사용하는 과정에서 전역 변수에 접근하는 코드와 같은 부분에서 순서가 바뀔 수 있음\n한 함수에 한 프로세스만 진입이 가능하다면 다른 프로세스가 실행되던 이전 함수에서 똑같이 진입한다고 해도 막히기 때문에 공유 자원에 대한 접근을 제어 단일 처리의 경우 이러한 문제가 발생하는 경우는 위와 같이 같은 함수에 진입할 시에 전역변수가 공유되면서도 순서가 바뀌어 문제가 발생할 가능성이 있음\n멀티프로세서 또한 이러한 프로세서들이 함수에 서로 진입하는 과정에서 결과가 바뀌는 잠재적 문제가 생길 가능성이 있음\n=&gt; 단일 처리기/멀티프로세서 시스템 모두 같은 전역변수 접근 제어, 인터럽트의 비동기적인 발생으로 문제가 생길 가능성이 높음 P1, P2가 전역변수 a를 공유한다는 가정 하에\nP1은 a를 1로 수정, P2는 a를 2로 수정 =&gt; 서로 전역변수 a에 접근하기 위해 경쟁하고 있는 상태P3, P4가 있고, b=1, c=2로 초기화\nP3은 b = b+c 수행\nP4는 c = b+c 수행수행 결과는 각 프로세스의 수행 순서에 따라 달라질 가능성이 있음\nP3 -&gt; P4의 순서대로 했을 때 : b = 3, c = 5\nP4 -&gt; P3의 순서대로 했을 때: b = 4, c = 3\n모든 프로세스들의 상태와 수행 위치 추적 프로세스 제어블록(PCB: Process Control Block)으로 가능 자원 할당, 해제 처리기 시간\n메모리\n파일\nI/O 장치 다른 프로세스의 간섭으로부터 자원 및 데이터 보호\n프로세스의 기능과 수행 결과는 프로세스의 수행속도 및 동시에 수행되는 다른 프로세스들의 상대적인 수행 속도와 독립적이어야 함\n프로세스가 병렬적으로 수행될 때 병렬로 수행되는 다수의 프로세스가 서로에 대해 인식하는 정도와 이러한 프로세스들이 공유자원에 접근하여 발생할 수 있는 잠재적인 제어 문제가 상이함.\n두 개 이상의 프로세스들이 수행 중에 특정 자원을 사용하려 할 때, 각 프로세스는 다른 프로세스의 존재를 모름\n각 프로세스는 다른 프로세스의 수행 결과에 영향을 받지 않아야 함\n각 프로세스는 사용한 자원의 상태를 변화시켜서는 안됨\n경쟁 관계의 프로세스 간 정보 교환 없음\n<br><img src=\"https://i.imgur.com/2Vz8esh.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nRa - 임계자원 공유하는 자원 entercritical(RA) - 임계영역 진입 공유하고 있는 자원에 접근 할 때 사용하는 코드가 있는 영역에 진입 상호배제 임계 영역에 대해 한 순간에 하나의 프로세스만 진입하게 하는 명령어 exitcritical(Ra) 임계영역에 해당하는 코드를 사용하지 않는다고 운영체제에 알림 a = b라는 조건이 지켜지도록P1: a = a + 1; b = b + 1; P2: b = 2 b; a = 2 a;인터리빙될 경우\na = a + 1; =&gt; P1\nb = 2 * b; =&gt; P2\nb = b + 1; =&gt; P1\na = 2 * a; =&gt; P2\n서로를 알지 못 함 공유 변수, 공유 파일, 공유 데이터베이스에 대해서 서로가 데이터를 공유하고 이를 통해 협력 데이터의 무결성(integrity) 조건이 만족되지 못하는 것 =&gt; 무결성이 떨어짐 상호배제가 지켜져도 일관성을 상실할 수밖에 없음\n=&gt; 읽기모드와 쓰기모드를 구별하지 않아 상호 배제에서 쓰기 모드를 구분하지 않음\n=&gt; 데이터의 무결성이 깨어지게 됨\n강제되어야 함 동일한 자원이나 공유 객체에 대한 임계영역을 가진 모든 프로세스들 중에서 반드시 단 하나의 프로세스만이 임계영역에 진입 가능 임계 영역이 아닌 곳에서 수행이 멈춘 프로세스는 다른 프로세스의 수행을 간섭하면 안됨\n임계 영역에 접근하고자 하는 프로세스의 수행이 무한히 미루어져서는 안됨 교착상태나 기아상태가 일어날 확률이 없어야 함 임계영역이 비어 있을 때 진입하고자 하는 프로세스는 즉시 들어갈 수 있음\n프로세서의 개수나 상대적인 프로세스 수행 속도에 대한 가정이 없어야 함\n일단 임계영역에 들어간 프로세스는 일정한 시간 내에 임계영역에서 나와야만 한다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제병행성병행성의 원리","level":1,"id":"운영체제병행성병행성의_원리_0"},{"heading":"병행성의 개념","level":1,"id":"병행성의_개념_0"},{"heading":"병행성의 발생 이유","level":2,"id":"병행성의_발생_이유_0"},{"heading":"병행성과 관련 있는 주요 용어","level":2,"id":"병행성과_관련_있는_주요_용어_0"},{"heading":"deadlock 추가 설명","level":3,"id":"deadlock_추가_설명_0"},{"heading":"병행성의 원리","level":1,"id":"병행성의_원리_0"},{"heading":"단일처리기 시스템 상에서의 프로세스","level":2,"id":"단일처리기_시스템_상에서의_프로세스_0"},{"heading":"인터리빙과 오버래핑의 문제점","level":2,"id":"인터리빙과_오버래핑의_문제점_0"},{"heading":"문제에 대한 어려움","level":3,"id":"문제에_대한_어려움_0"},{"heading":"상호 배제의 필요성","level":4,"id":"상호_배제의_필요성_0"},{"heading":"단일 CPU와 멀티프로세스에서","level":3,"id":"단일_CPU와_멀티프로세스에서_0"},{"heading":"경쟁 상태","level":2,"id":"경쟁_상태_0"},{"heading":"예시 1","level":3,"id":"예시_1_0"},{"heading":"예시2","level":3,"id":"예시2_0"},{"heading":"운영체제의 고려 사항들","level":2,"id":"운영체제의_고려_사항들_0"},{"heading":"프로세스 간 상호작용","level":2,"id":"프로세스_간_상호작용_0"},{"heading":"프로세스 간 서로에 대해 인식의 정도와 이에 따른 상호 영향","level":3,"id":"프로세스_간_서로에_대해_인식의_정도와_이에_따른_상호_영향_0"},{"heading":"자원에 대한 프로세스 간 경쟁","level":2,"id":"자원에_대한_프로세스_간_경쟁_0"},{"heading":"공유를 이용한 프로세스 간 협력","level":2,"id":"공유를_이용한_프로세스_간_협력_0"},{"heading":"상호 배제 요구조건","level":2,"id":"상호_배제_요구조건_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":11583,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_병행성의 원리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html":{"title":"운영체제_병행성_상호 배제-하드웨어 지원","icon":"","description":"상호 배제를 하기 위해 하드웨어의 지원을 받는 경우\n인터리빙하게 수행될 때 인터럽트가 걸려 다른 프로세스의 내용이 수행\n단일 CPU의 경우 인터리빙\n인터럽트를 잠시 금지 -&gt; 인터리빙하게 수행되는 명령어들이 잠시 멈추게 됨\nwhile (true){\n/* 인터럽트 금지하는 기계어 명령어 */\n/* 임계영역 */\n/* 인터럽트 허용하는 기계어 명령어 */\n/* 임계영역 이후 코드 */\n} 부하가 큼\n외부 이벤트에 대한 처리, 다른 프로세스에 대한 스케줄링, 문맥교환 등 모든 기능 중지 -&gt; 시스템 수행 효율 매우 저하\n두 개 이상의 CPU에서는 안됨 멀티프로세스가 메모리를 공유할 경우\n동일 위치에 대해서 두 개의 프로세스가 동시에 접근하는 것은 허용하지 않는 것이 멀티프로세서 하드웨어의 기본적 특징\n=&gt; 동일 메모리 주소 접근은 동시 접근 요청 차단됨\n상호 배제를 위한 다음을 한번에 수행하는 새로운 명령어 고안\n- 같은 메모리 위치에 대한 읽기와 쓰기(읽기 + 쓰기)\n- 같은 메모리 위치에 대한 읽기와 테스트(읽기 + 테스트)\n=&gt; 같은 메모리 위치를 접근하려는 다른 명령어들은 블록됨\n/* 하나의 기계 명령어로 지원됨 -&gt; 원자적 수행 */\nint compare_and_swap (int *word, int testval, int newval)\n{ int oldval; /* word의 값을 대입복사 */ oldval = *word /* newval 값을 word의 위치에 set */ if (oldval == testval) *word = newval; return oldval;\n}\n/* 상호 배제 예제 프로그램 */\nconst int n = /* 프로세스 개수 */\n/* 공유하는 전역변수 -&gt; 0으로 초기화 */\n/* 전역변수가 0일 경우 임계 영역으로 진입 가능 */\nint bolt;\nvoid P(int i)\n{ while (true) ( /* compare_and_swap -&gt; 원자적 수행. bolt가 0이라면 1로 설정 */ /* bolt가 1일 동안 수행 -&gt; CPU를 계속 점유(busy waiting, spin waiting) */ while(compare_and_swap(bolt,0,1) == 1) /* 대기 */ /* 임계영역 */ /* 임계영역에서 빠져나올 경우 반드시 전역변수를 0으로 돌려놔야 함 */ bolt = 0 /* 임계영역 이후 코드 */ )\n}\nvoid main()\n{ bolt = 0; /* n개의 프로세스를 병렬적으로 수행시킴 */ parbegin(P(1),P(2), ... , P(n))\n} compare_and_swap 원자적으로 수행하는 명령어 지원 테스트 하려는 값(testval)\n메모리 위치에 저장된 값(*word)\n새로운 값(newval) 레지스터의 값과 메모리에 들어있는 값을 서로 교체\nIA-32(Pentium), IA-64(Itanium) XCHG 명령어 void exchange (int *register, int *memory)\n{ int temp; temp = *memory; *memory = *register; *register = temp;\n}\n/* 상호 배제 예제 프로그램 */\nint const n = /* 프로세스 개수 */\nint bolt;\nvoid P(int i)\n{ while (true) { /* 중간에 다른 스레드가 들어와 exchange를 실행해도 keyi와 바꾸어도 전역변수 bolt는 1인 상태이므로 변화가 없음 =&gt; bolt가 0이 될 때까지 무한루프 돌면서 임계영역 진입 대기*/ int keyi = 1; /* 임계영역 진입 전 setting */ /* keyi의 값은 0이 되고 bolt가 1이 됨 */ do exchange (&amp;keyi, &amp;bolt) while (keyi != 0); /* 임계영역 */ /* 임계영역을 벗어나는 setting */ bolt = 0; /* 임계영역 이후 코드 */ }\n} void main()\n{ /* bolt의 초기값 */ bolt = 0;\u001e /* n개의 프로세스 병렬 실행 */ parbegin(P(1), P(2), ... , P(n))\n} 단일처리기 CPU 뿐만 아니라 멀티프로세서 시스템에서도 사용 가능(공유 메모리를 사용하는 경우)\n간단하고 검증이 쉬움\n변수를 여러개 두어 여러 개의 임계영역을 두는 것이 가능 바쁜 대기(busy waiting, spin waiting) 사용 임계영역에 진입하고자 기다리고 있는 프로세스는 처리기를 계속 사용 기아 발생 가능성 프로세스가 임계영역에서 빠져 나왔을 때 대기하고 있던 프로세스가 여러개라면 하나의 프로세스만이 다시 진입 가능\n이 때 프로세스의 특성이나 기다린 대기시간 등을 고려하지 않으므로 무한정 기다리게 되는 프로세스가 생기면 기아 발생 교착 상태에 빠질 수 있음 프로세스 P1은 특별한 명령어(compare&amp;swap이나 exchange)를 수행한 후 임계영역 진입\nP1보다 높은 우선순위의 P2가 생성되고 OS가 P2 프로세스 스케줄\nP2가 P1과 같은 자원을 쓰려고 시도하면 상호 배제 조건에 의해 실패하고 바쁜 대기 수행\n우선순위가 높은 프로세스인 P2가 계속 바쁜 대기를 수행하면서 실행상태이므로 P1이 다시 스케줄링 될 수 없는 상태가 됨 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제병행성상호 배제-하드웨어 지원","level":1,"id":"운영체제병행성상호_배제-하드웨어_지원_0"},{"heading":"상호 배제: 하드웨어 지원","level":1,"id":"상호_배제_하드웨어_지원_0"},{"heading":"1. 인터럽트 금지","level":2,"id":"1._인터럽트_금지_0"},{"heading":"단점","level":3,"id":"단점_0"},{"heading":"2. 특별한 기계 명령어","level":2,"id":"2._특별한_기계_명령어_0"},{"heading":"Compare &amp; Swap 명령어","level":3,"id":"Compare_&_Swap_명령어_0"},{"heading":"Exchange 명령어","level":3,"id":"Exchange_명령어_0"},{"heading":"기계 명령어 접근 방법의 특성","level":3,"id":"기계_명령어_접근_방법의_특성_0"},{"heading":"장점","level":4,"id":"장점_0"},{"heading":"단점","level":4,"id":"단점_1"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":5132,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_상호 배제-하드웨어 지원.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html":{"title":"운영체제_병행성_세마포어","icon":"","description":"\n\b하드웨어의 문제 : 바쁜 대기(busy waiting, spin waiting)\n=&gt; 1965년 Dijkstra의 세마포어 제안\n두 개 이상의 프로세스들이 임계 영역에 대해 간단한 시그널을 통해서 협력하면서 진입할 수 있도록 하는 기법\n시그널을 통해 진입하기 때문에 임계 영역에 진입하지 못하게 되는 프로세스는 CPU 사용을 중단하고 블록 상태에서 임계영역의 자원이 반환되도록 대기\n=&gt; 바쁜 대기의 문제 해결\nstruct semaphore { int count; queueType queue;\n};\nvoid semWait (semaphore s)\n{ s.count--; if (s.count &lt; 0) { /* 요청한 프로세스를 s.queue에 연결 */ /* 요청한 프로세스를 블록 상태로 전이시킴 */ }\n}\nvoid semSignal (semaphore s)\n{ s.count++; if (s.count &lt;= 0) { /* s.queue에 연결되어 있는 프로세스를 큐에서 제거 */ /* 프로세스의 상태를 실행 가능으로 전이시키고 ready list에 연결 */ }\n} 세마포어 초기화 세마포어는 음이 아닌 값으로 초기화됨 semWait 연산 세마포어 값을 감소\n만일 값이 음수가 되면 semWait을 호출한 프로세스는 블록됨\n음수가 아니면 프로세스는 계속 수행될 수 있음 semSignal 연산 세마포어 값을 증가\n만약 값이 양수가 아니면(0이거나 음수면)semWait 연산에 의해 블록된 프로세스들을 깨움 일반적으로 프로세스가 세마포어를 감소시키기 전까지는 그 프로세스가 블록될지 아닐지 알 수 없음\n프로세스가 세마포어를 증가시키고 블록되어 있던 프로세스를 깨우면 이 두 프로세스 모두 수행 가능 상태가 됨 단일처리기 시스템에서 두 프로세스 중에 어떤 프로세스가 먼저 수행될 지 알 수 없음 세마포어에서 시그널을 보낼 때, 다른 프로세스가 대기 중인지 여부를 알 필요가 없음 블록되어 있는 프로세스의 개수는 0 또는 1일 수 있음 struct binary_semaphore { /* 0 아니면 1만의 값을 가짐 */ enum {zero, one} value; queueType queue;\n};\nvoid semWaitB(binary_semaphore s)\n{ if (s.value == one) /* s.value가 1이면 0으로 바꾸고 나옴 =&gt; 다음에 수행 */ s.value = zero; else{ /* s.value가 0일 때 수행 */ /* 요청한 프로세스를 s.queue에 연결 */ /* 요청한 프로세스를 블록 상태로 전이시킴 */ }\n}\nvoid semSignalB(semaphore s)\n{ if(s.queue is empty()) s.value = one; else { /* s.queue에서 프로세스 P를 제거 */ /* 프로세스 P의 상태를 실행 가능으로 전이시키고 ready list에 연결 */ }\n} 세마포어 초기화 이진 세마포어는 0이나 1로 초기화 semWaitB 연산 세마포어 값을 확인\n만약 값이 0이면 semWaitB를 호출한 프로세스는 블록\n만약 값이 1이면, 값을 0으로 변경시키고 프로세스는 계속 수행 semSignalB 연산 블록되어 있는 프로세스가 존재하는지 확인\n블록되어 있는 프로세스가 존재할 경우 그 프로세스 깨움\n블록되어 있는 프로세스가 존재하지 않을 경우 세마포어 값을 1로 설정 생산자(프로세스) : D\n소비자(프로세스) : A, B, C<img src=\"https://i.imgur.com/M9MydUl.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n1. s = 1에서부터 자원이 있다고 가정하고 시작\n2. A 프로세스가 자원 흭득을 위해 처음 실행\n3. A프로세스가 `semWait`을 호출하면 세마포어가 0으로 감소하고 A는 자원흭득 후 수행 <br><img src=\"https://i.imgur.com/7qLpaY2.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n4. A가 자원흭득 후 수행하다가 타임아웃 되어 다시 준비 큐로 이동\n5. 큐에서 B가 수행되면서 `semWait`을 호출 -&gt; 세마포어가 1 감소<br><img src=\"https://i.imgur.com/ir9YsT2.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n6. 감소된 세마포어는 -1로 바뀐 후 세마포어 값이 음수이기 때문에 B가 블록상태로 전이\n7. D가 준비 큐에서 실행되고 자원을 만듦. 이후 임계영역을 나갈 때 `semSignal`을 호출하여 s가 0이 됨\n<img src=\"https://i.imgur.com/CxxaHCK.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n8. s가 0이 되면서 잠자고 있던 B가 수행되고 다시 준비 큐로 들어감\n9. D는 시간이 지나서(timeout) 다시 준비 큐로 들어감\n<img src=\"https://i.imgur.com/evMKEn4.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n10. 다음에 C를 꺼내어 실행. 11. C가 `semWait` 호출하고 세마포어는 음수 값이 되어 C가 블록 큐로 들어감~ 중간 생략 ~<br><img src=\"https://i.imgur.com/VBHjMSI.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n12. A,B까지 블록 큐에 들어가게 되면 s=-4이 됨\n13. D가 들어오고 semSignal 호출<br><img src=\"https://i.imgur.com/93N3lMC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n14. C가 준비 큐에 들어가게 되고 s는 -2가 됨const int b = /* 프로세스 개수 */\nsemaphore s = 1;\nvoid P(int i)\n{ while (true) { semWait(s); /* 임계영역 */ semSignal(s); /* 임계영역 이후 코드 */ }\n}\nvoid main()\n{ parbegin (P(1), P(2), ... , P(n))\n} parbegin을 통해 n개의 프로세스 실행\nsemaphore s의 값은 1로 초기화하고 코드 실행\n무한 루프를 돌면서 임계 영역 전에서 대기하다 임계영역이 끝나면 semSignal 호출\n<br><img src=\"https://i.imgur.com/rhF47bx.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n- 세마포어 락의 값은 1로 시작 - 세마포어를 흭득한다 =&gt; 락을 건다\n- `semWait`을 통해 세마포어의 값 감소시키고 계속 수행\n- B는 처음 세마포어의 값이 0이기 때문에 수행시킬 수 없어 세마포어의 값을 1 내리고 락을 걺\n- C가 `semWait`하면 1 더 내리고 기다림\n- A가 락을 해제하는 `semSignal` 호출\n- B가 나와지고 세마포어 흭득 + 권한을 얻고 수행하다가 `semSignal`을 통해 락 해제\n- 잠자고 있던 C를 실행하고 C가 다시 락을 걺<br><img src=\"https://i.imgur.com/7eHaECC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n### 생산자생산자 : while(true){ /* 데이터 V를 생산 */ b[in] = V; in++;\n} 데이터에 대해서 값을 생성\n버퍼에 값을 기록하고 버퍼의 위치를 증가시킴\n소비자 :\nwhile(true){ while(in &lt;= out) /* 대기 */ w = b[out] out = ++; /* 데이터 w를 소비 */\n} 해당 데이터를 소비 데이터가 있으면 계속해서 꺼내면서 소비 /* 생산자 소비자 프로그램 */\nint n; /* 전역 변수 n =&gt; 전역변수의 비교를 통해 조정 */\nbinary_semaphore s = 1, delay = 0;\n/* 생산자의 경우 =&gt; 무한루프를 돌면서 데이터 생성 */\nvoid producer()\n{ while (true) { produce(); /* 데이터 생성 */ /* 버퍼의 임계 영역 설정 =&gt; s에 대해 LOCK을 만듦 */ semWaitB(s); /* 소비자의 버퍼 사용 방지 위해 버퍼 LOCK*/ append(); /* 버퍼 append */ n++; if (n==1) semSignalB(delay); /* 소비자에게 버퍼가 채워졌음을 알림 */ semSignalB(s); /* 버퍼 UNLOCK */ }\n}\n/* 소비자 프로세스의 경우 =&gt; */\nvoid consumer()\n{ semWaitB(delay); /* 생산자가 생성한 것을 기다림 */ while (true) { semWaitB(s); /* 생산자의 버퍼 사용 방지 위해 버퍼 LOCK */ take(); /* 버퍼에서 데이터 꺼내기 */ n--; semSignalB(s); /* 버퍼 UNLOCK */ consume(); if (n==0) semWaitB(delay); /* 생산자에게 버퍼가 비워졌음을 알림 =&gt; 기다리는 상태 */ }\n}\nvoid main()\n{ n = 0; parbegin (producer, consumer); /* 생산자와 소비자 두 프로세서 모두 실행*/\n}\n<br><img src=\"https://i.imgur.com/18UlsYl.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n실행되는 코드들의 나열\n5-6번 라인, 9-10번 라인, 13-14번 라인에서 문맥 교환이 이루어짐\n2-5번까지 LOCK s에 대해서 LOCK 표에서 흰색 영역은 세마포어에 의해 보호되는 임계영역을 나타냄\n11번 라인에서 n을 증가시키고 14번 라인에서 n이 0인지를 검사 -&gt; 임계영역의 코드가 아니기 때문에 n을 뒤에서 감소시킴 14번 라인에서 검사가 n을 증가시키고 검사하기 때문에 해당 코드가 실행하지 않아 -만 시키기 때문에 버퍼에 존재하지 않은 데이터를 소비하게 됨\n보호되지 않은 영역에서 n을 읽었기 때문 int n;\nbinary_semaphore s = 1, delay = 0;\nvoid producer()\n{ while (true) { produce(); semWaitB(s); append(); n++; if (n==1) semSignalB(delay); semSignalB(s); }\n}\nvoid consumer()\n{ int m; /* 지역변수 선언 */ semWaitB(delay); while (true) { semWaitB(s); /* 생산자의 버퍼 사용 방지 위해 버퍼 LOCK */ take(); /* 버퍼에서 데이터 꺼내기 */ n--; m = n; /* 소비자의 임계영역 내에 보조변수 m 사용 */ semSignalB(s); /* 버퍼 UNLOCK */ consume(); if (m==0) semWaitB(delay); /* 생산자에게 버퍼가 비워졌음을 알림 =&gt; 기다리는 상태 */ }\n}\nvoid main()\n{ n = 0; parbegin (producer, consumer); /* 생산자와 소비자 두 프로세서 모두 실행*/\n}\n\bsemaphore n = 0, s = 1,\nvoid producer()\n{ while (true) { produce(); /* 데이터 생성 */ semWaitB(s); /* s에 대해 락 걸기 */ append(); /* 큐에 넣기 */ semSignal(s) semSignal(n); /* 데이터가 있다는 사실을 알림 */ }\n}\nvoid consumer()\n{ while (true) { semWait(n); /* semWaitB(s)와 순서가 바뀌면 교착상태가 발생할 가능성이 있음 */ semWaitB(s); /* 데이터를 꺼내기 위한 버퍼 LOCK */ take(); /* 버퍼에서 데이터 꺼내기 */ semSignalB(s); /* 버퍼 UNLOCK */ consume(); }\n}\nvoid main()\n{ parbegin (producer, consumer); /* 생산자와 소비자 두 프로세서 모두 실행*/\n}\nproducer:\nwhile (true) { /* 데이터 V를 생산 */ while ((in + 1) % n == out) /* 대기 */ b[in] = V; in = (in + 1) % n;\n}\nconsumer:\nwhile (true) { while(in == out) /* 대기 */ w = b[out]; out = (out+1) % n /* 데이터 w를 생산 */\n}\n<br><img src=\"https://i.imgur.com/6vjT4iR.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n- 일반적인 원형 큐 자료구조와 같이 끝까지 들어가게 되면 다시 처음으로 돌아감\n- 큐의 개수가 정해져 있음 - **큐의 공간보다 넘치게 생산할 수 없음** - 큐의 **공간을 확인하는 세마포어** 필요/* 유한 버퍼를 사용하는 생산자 소비자 프로그램 */\nconst int sizeofbuffer = /* 버퍼 사이즈 */\nsemaphore s = 1, n = 0, e = sizeofbuffer; /* 큐에 넣을 수 있는 공간 확인용 */\nvoid producer()\n{ while (true){ produce(); semWait(e); /* e: 버퍼에서 빈 공간의 수 */ semWait(s); /* 버퍼에 대해서 LOCK */ append(); semSignal(s); semSignal(n); }\n}\nvoid consumer()\n{ while (true) { semWait(n); semWait(s); take(); semSignal(s); semSignal(e); /* 버퍼가 비기를 기다리는 생산자 깨워주는 코드 */ consume(); }\n}\nvoid main()\n{ parbegin(producer, consumer)\n}\nsemWait(s)\n{ /* 밑에 있는 코드들이 상호 배제를 확인하는 코드 */ while (compare_and_swap(s.flag, 0, 1) == 1) /* 대기 */ /* 임계 영역의 진입 */ a.count--; if (a.count &lt; 0) { /* 요청한 프로세스를 a.queue에 연결 */ /* 요청한 프로세스를 블록 상태로 전이시키고 s.flag를 0으로 설정 */ } /* 임계 영역 나옴 */ s.flag = 0;\n} semSignal(s)\n{ while (compare_and_swap(s.flag, 0, 1) == 1) /* 대기 */ /* 임계 영역 진입 */ s.count++; if (s.count &lt;= 0) { /* s.queue에 블록된 프로세스를 큐에서 제거 */ /* 전이시키고 준비 큐에 연결 */ } /* 임계 영역 나옴 */ s.flag = 0;\n}\nsemWait(s)\n{ 인터럽트 금지; s.count--; if (s.count &lt; 0) { /* 요청한 프로세스를 s.queue에 연결 */ /* 요청한 프로세스를 블록 상태로 전이시킴(또한 인터럽트 허용) */ } else 인터럽트 허용;\n} semSignal(s)\n{ 인터럽트 금지; s.count++; if (s.count &lt;= 0) { /* s.queue에 블록된 프로세스를 큐에서 제거 */ /* 전이시키고 준비 큐에 연결 */ } 인터럽트 허용;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제병행성세마포어","level":1,"id":"운영체제병행성세마포어_0"},{"heading":"세마포어","level":1,"id":"세마포어_0"},{"heading":"세마포어 코드 및 특징","level":2,"id":"세마포어_코드_및_특징_0"},{"heading":"세마포어 3가지 연산","level":3,"id":"세마포어_3가지_연산_0"},{"heading":"세마포어 특징","level":3,"id":"세마포어_특징_0"},{"heading":"이진 세마포어","level":3,"id":"이진_세마포어_0"},{"heading":"코드","level":4,"id":"코드_0"},{"heading":"연산","level":4,"id":"연산_0"},{"heading":"세마포어 동작 예","level":3,"id":"세마포어_동작_예_0"},{"heading":"상호 배제","level":2,"id":"상호_배제_0"},{"heading":"세마포어를 이용한 상호 배제","level":3,"id":"세마포어를_이용한_상호_배제_0"},{"heading":"생산자/소비자 문제","level":2,"id":"생산자/소비자_문제_0"},{"heading":"소비자","level":3,"id":"소비자_0"},{"heading":"무한 버퍼에서 이진 세마포어를 이용한 생산자 소비자 문제 해결 방법 : 부정확한 버전","level":3,"id":"무한_버퍼에서_이진_세마포어를_이용한_생산자_소비자_문제_해결_방법_부정확한_버전_0"},{"heading":"무한 버퍼에서 이진 세마포어를 이용한 생산자 소비자 문제 해결 방법: 정확한 버전","level":3,"id":"무한_버퍼에서_이진_세마포어를_이용한_생산자_소비자_문제_해결_방법_정확한_버전_0"},{"heading":"무한 버퍼에서 범용 세마포어를 이용한 생산자 소비자 문제 해결 방법","level":3,"id":"무한_버퍼에서_범용_세마포어를_이용한_생산자_소비자_문제_해결_방법_0"},{"heading":"생산자와 소비자 문제에서 유한 크기의 원형 큐로 구현한 버퍼 구조","level":3,"id":"생산자와_소비자_문제에서_유한_크기의_원형_큐로_구현한_버퍼_구조_0"},{"heading":"유한 버퍼에서 범용 세미포어를 이용한 생산자 소비자 문제 해결 방법","level":3,"id":"유한_버퍼에서_범용_세미포어를_이용한_생산자_소비자_문제_해결_방법_0"},{"heading":"세마포어 구현","level":2,"id":"세마포어_구현_0"},{"heading":"Compare and Swap 명령어 이용","level":3,"id":"Compare_and_Swap_명령어_이용_0"},{"heading":"인터럽트 금지 이용","level":3,"id":"인터럽트_금지_이용_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":13002,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_세마포어.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html":{"title":"운영체제_스레드_멀티코어와 멀티스레딩","icon":"","description":" <img src=\"https://i.imgur.com/XKIP8iR.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n<img src=\"https://i.imgur.com/5rtrV80.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n- 처리기의 개수가 많아질수록 속도가 향상된다\n- 오버헤드 =&gt; 멀티프로세서들 간의 통신 및 작업 분배와 캐시 일관성 유지를 위한 추가 작업의 결과로 발생\n- 멀티프로세서를 사용하는 오버헤드에 대한 부담을 증가시켜 성능이 정점을 찍고 감소하기 시작\n- 다수의 상대적으로 독립적인 트랙잭션의 병렬 처리를 하는 서버 =&gt; **멀티코어 구조의 효과적 이용** =&gt; 효과적인 멀티코어 시스템을 위해 응용에서 순차적인 부분에 대한 영향 줄이기\n멀티스레드화된 네이티브 응용 고도의 스레드화된 프로세스를 가짐 멀티프로세스 응용 단일 스레드화된 프로세스들이 존재 자바 응용 자바 언어 자체가 멀티스레드화된 응용 개발에 용이하여 멀티코어 기술의 혜택을 받음 멀티인스턴스 응용 다수의 응용 인스턴스를 멀티코어 구조상에서 병렬적 실행함으로써 속도의 향상\n격리(isolation) 가 필요한 응용 인스턴스의 경우 가상 기술을 사용하여 각각의 인스턴스마다 독립되고 안전한 환경 제공 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제스레드멀티코어와 멀티스레딩","level":1,"id":"운영체제스레드멀티코어와_멀티스레딩_0"},{"heading":"멀티코어와 멀티스레딩","level":1,"id":"멀티코어와_멀티스레딩_0"},{"heading":"멀티코어 상에서의 소프트웨어 성능","level":2,"id":"멀티코어_상에서의_소프트웨어_성능_0"},{"heading":"Amdahl의 법칙","level":3,"id":"Amdahl의_법칙_0"},{"heading":"효율적인 멀티코어의 혜택","level":3,"id":"효율적인_멀티코어의_혜택_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":1848,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_스레드_멀티코어와 멀티스레딩.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html":{"title":"운영체제_스레드_스레드의 유형","icon":"","description":"<img src=\"https://i.imgur.com/EOqtzar.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"><br><img src=\"https://i.imgur.com/R4wwEMq.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nThread2 B를 블록시키는 함수 호출 -&gt; 커널로 제어 이동 커널 입출력 작업 -&gt; 프로세스 B 블록\n(b) -&gt; Thread2는 수행 상태가 아니지만 라이브러리에서는 수행 상태로 인식 프로세스 B 할당 시간 소모 준비 상태로 전이\nThread2는 여전히 수행 상태 Thread2는 Thread1에 의해 블록 프로세스 B는 여전히 수행 상태 스레드 관리와 관계된 모든 일은 응용이 수행하며 커널은 스레드의 존재를 알지 못함 커널은 프로세스 단위로 스케줄하며 프로세스에게 어떤 수행 상태를 할당 ULT 관리 루틴들도 구성된 패키지인 스레드 라이브러리를 이용하여 모든 응용을 멀티스레드 기반으로 프로그래밍 가능\n스레드 라이브러리 스레드의 생성과 제거, 스레드 간 메시지와 데이터 전달, 스레드 수행의 스케줄링, 스레드 문맥의 저장과 복구 등을 위한 코드 모든 작업은 사용자 공간과 단일 프로세스 내에서 이루어짐 스레드 관리를 위한 모든 자료구조가 프로세스의 사용자 주소 공간에 있음\n=&gt; 스레드 교환에 따른 커널 모드 권한 요청 불필요\n응용에 맞게 구성될 수 있는 스케줄링\n어떠한 운영체제에도 적용 대부분의 시스템 호출은 해당 스레드를 블록\n=&gt; 프로세스 내의 모든 스레드가 블록\n=&gt; 멀티프로세싱의 장점을 살릴 수 없음\n임의 시점에 단일 프로세스 내에서 하나의 스레드만을 수행\n응용의 수행 속도를 향상시킬 수 있음 응용을 멀티스레딩 대신 멀티프로세서로 작성\n=&gt; 프로세스 교환을 함으로써 각 교환마다 오버헤드 증가, 스레드의 장점을 살리지 못함 ❌\n자켓팅(jacketing) -&gt; 블록형 시스템 호출을 비블록형(nonblocking) 시스템 호출로 변환\n<br><img src=\"https://i.imgur.com/xMiH1Yf.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n스레드 관리와 관련된 모든 작업이 커널에 의해 이루어짐\n커널이 전체 프로세스에 대한 문맥 정보 및 각 프로세스 내 스레드에 대한 문맥 정보 유지 사용자 모드 스레드의 단점 모두 극복 커널은 여러 처리기에게 같은 프로세스 내의 여러 스레드를 동시에 스케줄\n한 프로세스의 스레드가 블록돼도 커널이 같은 프로세스에서 다른 스레드를 스케줄할 수 있음 같은 프로세스 내의 한 스레드에서 다른 스레드로 제어를 넘길 때 커널로의 모드 전환 필요 커널 모드 진입으로 인한 오버헤드 발생(연산지연 발생) =&gt; KLT 멀티스레드의 이용으로 속도 향상, ULT를 이용한 추가적인 속도 향상(응용의 특성 따라 다름)<br><img src=\"https://i.imgur.com/VzI6zwj.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n스레드 생성이 완전히 사용자 공간에서 이루어짐\n한 응용 내의 스레드들에 대한 스케줄링 및 동기화가 대부분 사용자 공간에서 이루어짐\nULT들이 KLT에 사상(mapping)\n한 응용의 스레드들이 다수의 처리기에서 병렬 수행 가능\n블록형 시스템 호출이 전체 프로세스를 블록시키지 않음\n예) Solaris(ULT:KLT = 1:1)\n순수 ULT 및 KLT 방식의 장점을 모두 살릴 수 있음설계가 어려워서 대부분 안 씀\n단일 프로세스에 여러 스레드를 제공하는 다대일(M:1) 관계와 더불어 다대다(M:N) 관계와 일대다(1:M) 관계의 조합 또한 연구중\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제스레드스레드의 유형","level":1,"id":"운영체제스레드스레드의_유형_0"},{"heading":"스레드의 유형","level":1,"id":"스레드의_유형_0"},{"heading":"사용자 수준 스레드와 커널 수준 스레드","level":2,"id":"사용자_수준_스레드와_커널_수준_스레드_0"},{"heading":"사용자 수준 스레드(ULT: user-level thread)","level":3,"id":"사용자_수준_스레드(ULT_user-level_thread)_0"},{"heading":"작동 방식","level":4,"id":"작동_방식_0"},{"heading":"특징","level":4,"id":"특징_0"},{"heading":"장점","level":4,"id":"장점_0"},{"heading":"단점","level":4,"id":"단점_0"},{"heading":"단점의 해결방법","level":4,"id":"단점의_해결방법_0"},{"heading":"커널 수준 스레드(KLT: kernel-level thread)","level":3,"id":"커널_수준_스레드(KLT_kernel-level_thread)_0"},{"heading":"특징","level":4,"id":"특징_1"},{"heading":"장점","level":4,"id":"장점_1"},{"heading":"단점","level":4,"id":"단점_1"},{"heading":"두 모드를 결합한 형태 📚📚📚","level":3,"id":"두_모드를_결합한_형태_📚📚📚_0"},{"heading":"특징","level":4,"id":"특징_2"},{"heading":"장점","level":4,"id":"장점_2"},{"heading":"단점","level":4,"id":"단점_2"},{"heading":"다른 배합","level":2,"id":"다른_배합_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":5878,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_스레드_스레드의 유형.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html":{"title":"운영체제_스레드_프로세스와 스레드","icon":"","description":"프로세스의 두 가지 특성 자원 소유권 프로세스는 자신의 이미지를 위한 가상주소 공간 포함\n프로세스 이미지 프로세스 제어 블록에 정의되어 있는 프로그램과 데이터, 스택, 속성들의 집합 자원들에 대한 제어와 소유권을 할당 가능\n운영체제의 보호 기능 프로세스들 간에 자원에 대한 불필요한 간섭 방지 스케줄링/수행 하나 이상의 프로그램을 통화하는 수행 경로(궤적)을 따름\n다른 프로세스들과 번갈아가면서(인터리빙) 수행될 수 있음\n수행 상태와 디스패칭 우선순위를 가지며, 운영체제에 의해 스케줄되고 디스패치 이러한 두 가지 특성은 서로 독립적이며 운영체제에 의해서 독립적으로 취급될 수 있다. 디스패칭 단위 스레드(thread) 또는 경량 프로세스(lightweight process) 자원 소유권의 단위 프로세스 또는 태스크(task) 하나의 프로세스 내에서 수행되는 여러 개의 스레드를 지원하는 기능\n각 운영체제 따라서 프로세스와 스레드를 지원하는 범위가 다르다. MS-DOS 단일 프로세스\n단일 스레드 <img src=\"https://i.imgur.com/vYA5BHx.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> UNIX 계열 일부 다중 사용자 프로세스\n프로세스당 하나의 스레드 <br>\n<img src=\"https://i.imgur.com/Vzfr1gT.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> Java 실행 환경(JRE) 단일 프로세스\n다수의 스레드\n<br>\n<img src=\"https://i.imgur.com/nrzULg2.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> Windows, Solaris, 많은 UNIX 다수 프로세스\n프로세스당 다수의 스레드\n<br>\n<img src=\"https://i.imgur.com/ufZqgW0.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 멀티스레드 환경에서 프로세스는 보호의 단위와 자원할당의 단위로 정의됨 프로세스의 이미지를 유지하는 가상 주소 공간(virtual address space)\nCPU, 다른 프로세스, 파일, 입출력 자원에 대한 접근 제어(보호된 접근)\n장점 짧은 생성시간, 종료시간, 쓰레드 간 교환 시간\n효율적인 통신 프로세스는 하나 이상의 스레드를 가지며 다음 사항들을 포함 스레드 수행 상태(수행, 준비 등)\n수행중이 아닐 때 저장되어 있는 쓰레드 문맥\n수행 스택\n지역변수 저장을 위해 각 스레드가 사용하는 어떤 정적 저장소\n프로세스의 메모리 및 자원에 대한 접근으로, 메모리 및 자원은 프로세스 내의 모든 스레드에 의해 공유 <br><img src=\"https://i.imgur.com/IpN2PsY.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n프로세스 제어블록\n사용자 주소공간\n사용자 스택과 커널 스택(하나의 스택 형태에서 나뉘어져 있음) 프로세스 수행 중 함수 호출/복귀 행위 관리 프로세스 수행/비수행 상태에 따라 처리기 레지스터에 대한 동작 수행 상태 -&gt; 처리기 레지스터 내용 제어\n비수행 상태-&gt; 처리기 레지스터 내용 저장 단일스레드와의 공통점\n하나의 프로세스 제어블록(공유)\n하나의 사용자 주소공간(공유)\n=&gt; 프로세스 내의 모든 스레드들은 그 프로세스 상태와 자원 공유(같은 주소 공간 + 동일한 데이터 접근)\n멀티스레드만의 차이점\n스레드마다의 별도 스택(사용자 스택 + 커널 스택)\n스레드마다 레지스터값, 우선순위, 그 외의 스레드 관련 상태 정보를 포함하는 별도의 제어블록(사용중인 레지스터를 회피하기 위함)\n수행에 관련된 대부분의 상태 정보가 스레드 수준의 자료구조에 의해 유지됨 새로운 프로세스 생성 시간보다 새로운 스레드 생성 시간이 더 짧음\n프로세스 종료시간보다 스레드 종료시간이 더 짧음\n프로세스들 간 교환보다 같은 프로세스에 있는 두 스레드 간 교환이 효율적임(커널의 개입 없이 문맥 교환만 이루어지기 때문)\n서로 다른 수행 프로그램 간 통신에서 효율적임 전면(foreground)과 후면(background) 작업 프로그램에서 이전 명령이 완료되기 전에 다음 명령을 신속하게 수행함으로써 응용의 속도 향상 비동기(asynchronous) 처리 운영체제를 통한 주기적인 백업 및 직접 자신을 스케줄 하는 작업\n=&gt; 복잡한 코드 작성 필요가 줄어듦 빠른 수행 어떤 데이터 묶음(batch)를 계산하면서 동시에 어떤 장치로부터 데이터 묶음을 읽어들일 수 있음\n=&gt; 한 스레드가 특정 데이터 묶음을 읽기 위해 입출력 작업 완료를 기다리면서 블록(block)될지라도 또 다른 스레드 수행 모듈 프로그램 구조 다양한 활동 or 입출력 연산에 대한 다양한 출발 및 목적지를 포함하고 있는 프로그램의 경우 스레드를 통한 구현이 편리함 보류(suspension) 모든 스레드는 같은 주소 공간을 공유하기 때문에 swap out될 경우 모든 스레드가 동시에 보류 상태가 되므로 주의 생성(spawn) 프로세스가 생성되면 프로세스를 위한 스레드도 함께 생성\n프로세스 내에서 다른 스레드 생성 가능\n새로 생성된 스레드를 위한 명령 포인터와 인자 제공\n새로운 스레드는 자신의 레지스터 문맥과 스택 공간을 가지며 준비 큐에 위치 블록(Block) 스레드가 어떤 사건을 기다려야 할 때 스레드는 블록\n블록 될 때 자신의 사용자 레지스터, 프로그램 카운터, 스택 포인터 저장\n동일 프로세스 내 or 다른 프로세스 내에 있는 준비 상태의 다른 스레드 수행 가능 비블록(Unblock) 스레드가 블록되어 기다리던 사건이 발생되었을 때 그 스레드는 준비 큐로 이동 종료(Finish) 스레드가 작업을 완료하면 레지스터 문맥과 스택이 해제 한 스레드의 블록이 전체 프로세스를 블록시키는지의 여부\n=&gt; 사용자 수준 스레드(user-level thread) 와 커널 수준 스레드(kernel-level thread) 따라 다름<br><img src=\"https://i.imgur.com/FpxlD1U.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n단일 스레드를 이용한 RPC의 경우 결과를 순차적으로 얻게 됨\n=&gt; 각 서버로부터 응답이 오기를 순서대로 기다려야 함\n<br><img src=\"https://i.imgur.com/2KBXlbO.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n단일 처리기 상에서 서버마다 한 스레드를 사용한 RPC의 경우 각각의 RPC에 대하여 독립된 스레드 사용\n=&gt; 처리 속도의 향상\n단일 처리기일 경우 요청이 순차적으로 생성되고 결과 또한 순차적으로 처리되지만 프로그램은 두 응답을 동시에 기다림\n<br><img src=\"https://i.imgur.com/XelnmKV.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n단일 처리기 상에서 멀티프로세싱과 멀티스레드 멀티프로그래밍으로 인해 여러 프로세스 내의 여러 스레드들이 번갈아가며 수행\n수행 중인 스레드가 블록되거나 정해진 시간 할당량을 모두 소비하면 수행 흐름은 한 스레드에서 다른 스레드로 넘어감\n스레드 A와 B는 각각 번갈아가며 실행됨\n다른 프로세스에서 생성된 스레드 C는 프로세스 1 전체와 프로세스 2가 번갈아 실행되면서 스레드가 수행됨 프로세스 내의 모든 스레드는 주소 공간과 열린 파일과 같은 자원 공유\n=&gt; 하나의 스레드에 의한 자원의 변경은 같은 프로세스 내에 존재하는 모든 스레드의 환경에 영향\n=&gt; 스레드들이 서로 간섭하지 않도록/자료 구조를 손상시키지 않도록 스레드의 행위를 동기화","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제스레드프로세스와 스레드","level":1,"id":"운영체제스레드프로세스와_스레드_0"},{"heading":"프로세스와 스레드","level":1,"id":"프로세스와_스레드_0"},{"heading":"멀티스레딩(Multithreading)","level":2,"id":"멀티스레딩(Multithreading)_0"},{"heading":"프로세스","level":3,"id":"프로세스_0"},{"heading":"스레드","level":3,"id":"스레드_0"},{"heading":"스레드와 프로세스의 차이점","level":3,"id":"스레드와_프로세스의_차이점_0"},{"heading":"단일 스레드 프로세스","level":4,"id":"단일_스레드_프로세스_0"},{"heading":"멀티스레드 프로세스","level":4,"id":"멀티스레드_프로세스_0"},{"heading":"스레드의 주된 장점 📚📚📚","level":4,"id":"스레드의_주된_장점_📚📚📚_0"},{"heading":"단일 사용자 멀티프로세싱 시스템에서 스레드 사용 예시","level":4,"id":"단일_사용자_멀티프로세싱_시스템에서_스레드_사용_예시_0"},{"heading":"스레드 기능","level":2,"id":"스레드_기능_0"},{"heading":"스레드 상태","level":3,"id":"스레드_상태_0"},{"heading":"스레드의 블록과 프로세스의 블록 연관성","level":3,"id":"스레드의_블록과_프로세스의_블록_연관성_0"},{"heading":"전체 프로세스를 블록시키지 않는 스레드의 성능상 장점 - 두 개의 원격 프로시저 호출(RPC: Remote Procedure Call)","level":4,"id":"전체_프로세스를_블록시키지_않는_스레드의_성능상_장점_-_두_개의_원격_프로시저_호출(RPC_Remote_Procedure_Call)_0"},{"heading":"스레드 동기화","level":2,"id":"스레드_동기화_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":8417,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_스레드_프로세스와 스레드.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html":{"title":"운영체제_운영체제 개요_결함 허용","icon":"","description":"\n어떤 시스템 전체 또는 그 일부의 하드웨어나 소프트웨어 결함에도 불구하고 정상 작동할 수 있는 능력\n시스템의 신뢰성을 높이기 위해 여분의 설비를 준비해두고 결함에 대비\n결함 허용의 수준을 높이면 시스템의 신뢰성은 높아지지만, 그만큼 경제적 비용과 시스템의 성능 하락 또한 감수해야 하기 때문에 Trade-off한 면이 있다.\n시스템이 결함 허용을 어느 수준까지 지원하는지를 측정할 수 있는 기본 척도는 신뢰성(reliability) 과 결함이 발생하기까지의 평균 시간(MTTF: mean time to Failure)**, 가용성(availability)로 결정됨.<img src=\"https://i.imgur.com/RcIief2.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nMTTF(Mean Time To Failure)의 경우 결함이 발생하기까지의 평균시간을 구하는 것이므로 총 수행시간에서 사용한 자원의 수로 나눔\n수리 완료까지 평균시간(MTTR: mean time to repair) 도 있는데 결함이 발생한 부품이나 소프트웨어 모듈 수리까지 걸리는 평균 시간을 의미<br>\n<img src=\"https://i.imgur.com/SmU0GEi.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nMTTR(Mean Time To Repair)의 경우 총 수리시간에서 수리한 횟수로 나눔\n<br><img src=\"https://i.imgur.com/ztlfI7C.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n위 사진에서 MTTF의 경우 총 운용시간 B1+B2+B3를 사용한 Asset의 수 3으로 나눔\nMTTR의 경우 수리하는데 걸린 총 시간 A1+A2+A3를 수리한 횟수 3으로 나눔 시스템이나 서비스의 가용성은 해당 시스템이나 서비스가 기동된 후 어느 시점까지의 총 시간 중 사용자의 요청을 서비스할 수 있었던 시간이 얼마나 되는지의 비율로 정의됨\n가용성 A는 다음과 같이 표현됨 위 표는 가용성 수준과 그 수준마다의 연간 다운타임(시스템이 가용하지 않은 시간)\n결함 허용까지는 무고장 시스템으로 허용한다.\n가용성이 높아도 다운타임과 업타임이 조각나있으면 업타입이 짧아 서비스가 원할히 돌아갈 수 없는 상황이 있을 수도 있으므로 평균 업타임을 더 자세히 볼 수 있는 MTTF가 더 유용한 척도로 활용됨 영구적(permanent) 영구적으로 존재하는 결함. 수리 전까지 계속 결함상태.\n하드웨어의 고장 or 소프트웨어 버그들 일시적(temporary) 단발적 일시적 전기충격이나 전원 불안정에 의한 전송 오류와 같은 단발적인 결함 유형 간헐적 예상할 수 없을 때 수차례 발생.\n접촉 불량 등 결함허용 구축은 여분의 설비(redundancy)를 추가함으로써 이루어진다. 여분 설비 추가 기법은 다음과 같다.\n공간적(물리적) 여분 설비 여분의 부품 여러개 설치\n여분의 부품이 백업 역할 시간적 여분 설비 오류가 발생했을 때 동일한 기능이나 동작을 계속 반복할 수 있도록 하는 방식\n영구적 결함에는 효과가 없지만 일시적 결함에 큰 효과\n데이터 전송 중 오류 발생 시 데이터 블록 재전송과 같은 해결방식 정보 여분 설비 데이터 복사, 복구 코드를 데이터에 덧붙이는 방식의 설비 프로세스 분리(Process isolation) 결함을 일으킨 프로세스가 다른 프로세스에 영향을 미치는 것을 막을 수 있게 보호설계 병행성 제어(Concurrency controls)\n가상 기계(Virtual machines) 가상 기계를 통한 응용 간 분리\n한 응용에서 발생한 결함이 다른 응용으로 옮아가지 못하게 하는 결함 차단도 지원\n가상 기계는 여러 개가 동시에 실행될 수 있기 때문에 여분 설비에 의한 결함허용도 해결 체크포인트와 롤백(Checkpoints and rollbacks) 체크포인트 어느 지점으로 돌아오기 위한 상태 정보를 모아놓은 것 롤백 최근의 체크포인트로 돌아가 결함에 대처 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제운영체제 개요결함 허용","level":1,"id":"운영체제운영체제_개요결함_허용_0"},{"heading":"결함 허용(Fault Tolerance)이란?","level":1,"id":"결함_허용(Fault_Tolerance)이란?_0"},{"heading":"측정","level":1,"id":"측정_0"},{"heading":"결함","level":1,"id":"결함_0"},{"heading":"결함 유형","level":2,"id":"결함_유형_0"},{"heading":"여분 설비 추가 기법","level":2,"id":"여분_설비_추가_기법_0"},{"heading":"운영체제의 결함 허용 기법","level":2,"id":"운영체제의_결함_허용_기법_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":4524,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_운영체제 개요_결함 허용.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html":{"title":"운영체제_운영체제 개요_멀티프로세서와 멀티코어를 위한 운영체제 설계 사항","icon":"","description":" SMP 시스템에서 커널은 어느 처리기 상에서도 실행될 수 있음 + 각 처리기는 스스로 스케줄링이 가능하기 때문에 프로세스/쓰레드들 중 원하는 것을 골라 실행 커널 또한 여러 개의 프로세스/쓰레드로 구성될 수 있기 때문에 커널의 일부분이 병렬로 실행되기도 하는데, 이러한 병렬 수행이 일어날 때 동시에 같은 공유 자원을 참조하거나 장치에 접근하는 등의 행위를 조율해야 함 이를 위해서는 공유자원에 대한 요청의 해결/동기화 하는 기법들의 도입이 필요하다. SMP 운영체제는 사용자가 사용 가능한 프로세스가 하나인지 여러개인지를 상관할 필요 없이 여러 개의 프로세스 or 한 프로세스 내 여러 개의 쓰레드 등 이러한 구성의 응용들의 사용을 가능하게 만들어야만 함 따라서 멀티프로그래밍 시스템 기능 뿐만 아니라 멀티프로세서를 활용할 수 있는 추가적 기능들도 같이 제공해야 함 이를 위해서 필요한 것들 동시 병행 프로세스 or 쓰레드 커널에 요청했을 때(권한을 흭득하려고 할 때) 여러 개의 처리기들이 같은 커널 코드를 동시에 실행시키면서 경쟁적 흭득이 일어남\n이 과정에서 경쟁에서 밀려난 코드들이 후에 재진입(reentrant) 할 수 있어야 한다. 스케줄링\n동기화 상호배제와 사건 직렬화(일렬로 줄세우기)를 강제적으로 시행하는 기능\n공유 자원을 참조할 가능성이 있는 여러 개의 프로세스들이 동시에 실행되고 있는 상황이라면 동기화가 절실해진다. 메모리 관리 하드웨어 병렬성을 활용하는 메모리 관리 기법 제공\n페이지나 세그먼트를 여러 처리기가 공유할 때 발생하는 일관성 문제를 담보하기 위한 여러 처리기 상의 페이징 과정 조율 신뢰성과 결함 허용 결함이 발생한 처리기 개수만큼의 성능 하락만 허용\n시스템 전체가 결함이 발생하지 않도록 조율 SMP시스템에서 제시된 고려사항 + a\n요즘에는 점점 CPU에 코어가 많이 늘어나고 있는 매니코어 시스템 시대에 진입\n이러한 멀티코어의 처리 용량을 어떻게 하면 최대로 활용할 것인가와 멀티코어를 담고 있는 단일 CPU 칩 내에 존재하는 상당 용량의 자원들을 어떻게 지능적으로 관리할 것이냐가 관건\n중요한 점은 매니코어 시스템에 내재되어 있는 근원적 병렬성 지원 원리와 응용이 요구하는 성능 수준의 합치인데, 현재의 멀티코어 시스템에서 지원하는 병렬성은 세 단계에 걸쳐 존재 연산자 수준 병렬성 각 코어 처리기 내에서의 하드웨어 병렬성\n컴파일러나 응용 프로그래머가 활용하기 어려움 여기서부터는 운영체제의 효과적이고도 확실한 지원이 없다면 멀티코어 시스템에서 사실상 효과를 발휘하기 어려움\n멀티프로그래밍, 멀티쓰레드 실행에서의 병렬성\n응용 내에서의 병렬성 대부분의 응용들은 여러 개의 태스크로 나누어져 병렬로 실행 가능\n이 태스크들은 여러 개의 프로세스, 그리고 프로세스 안의 쓰레드들로 구성되기도 함\n하지만 이러한 작업들을 어떻게 독립적으로 실행되는 태스크들로 나누어야 할까?\n이를 위해서는 병렬 태스크들에게 자원을 효과적으로 할당해주는 운영체제의 도구가 필요\n그 중에 대표적 도구 중 하나가 GCD(Grand Central Dispatch) 와 가상 기계(Virtual Machine) 방식 GCD(Grand Central Dispatch)\n- 멀티코어용 병렬 프로그래밍 개발자를 효율적으로 지원하는 대표적 도구 중 하나\n- 멀티코어용 응용 프로그래밍을 지원\n- 분할된 태스크들이 서로 충돌을 일으키지 않고 최대한 독립적으로 돌아갈 수 있도록 도와줌\n- 적정 수준의 병렬성을 지원하기 위해 각 태스크들을 쓰레드들에 매핑하는 쓰레드 풀(pool)기법(쓰레드를 미리 만들어놓고 할당하는 방식), 쓰레드가 입출력을 하면 블록시키는 기법 등을 사용\n- 유닉스 기반 Mac OS X &amp; Iphone에 사용 가상 기계(Virtual Machine) 방식\n- 동일한 하드웨어를 공유하는 다수의 실행환경\n- 한 컴퓨터의 하드웨어가 다수의 다른 실행 환경을 제공하도록 추상화 하는 것\n- 가상기계도 커널 모드와 사용자 모드를 가지며, 가상 기계 자체는 커널모드에서 수행됨\n- 다수의 기계가 하나의 CPU를 공유하므로 느려질 수 있음\n- 각 기계는 완전히 격리되므로 시스템 자원이 완전히 보호된다· 각 기계의 자원을 직접 공유할 수 없으나, 가상 통신 네트워크를 통해 공유할 수 있다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제운영체제 개요멀티프로세서와 멀티코어를 위한 운영체제 설계 사항","level":1,"id":"운영체제운영체제_개요멀티프로세서와_멀티코어를_위한_운영체제_설계_사항_0"},{"heading":"대칭적 멀티프로세싱(SMP)를 위한 운영체제 고려사항","level":2,"id":"대칭적_멀티프로세싱(SMP)를_위한_운영체제_고려사항_0"},{"heading":"멀티코어를 위한 운영체제 고려사항","level":2,"id":"멀티코어를_위한_운영체제_고려사항_0"},{"heading":"병렬성의 3단계","level":3,"id":"병렬성의_3단계_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":5318,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_운영체제 개요_멀티프로세서와 멀티코어를 위한 운영체제 설계 사항.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html":{"title":"운영체제_운영체제 개요_최근 운영체제로의 발전","icon":"","description":"\n멀티프로세서의 출현\n크게 향상된 CPU 속도\n고속 네트워크 장비\n메모리 종류의 다양화 및 용량 증가\n운영체제의 경우 하드웨어와 인터넷, 멀티미디어, 클라이언트/서버 컴퓨팅 등 다양하게 발전해가면서 요구사항이 급변해감에 따라 운영체제를 새롭게 구성할 필요성이 대두되었다.\n최근까지 대부분의 운영체제는 단일체 커널(monolithic kernel) 로 특정지어짐\n하나를 고칠 때 다시 전체를 컴파일 해야 하는 전통적인 운영체제\n단일체 커널의 경우 하나의 프로세스 형태로 구현되고 커널 내의 모든 요소들은 같은 주소 공간을 공유한다. 하지만 마이크로커널 구조(microkernel architecture) 는 주소공간, 프로세스 간 통신(IPC), 기본적 스케줄링을 포함한 소수의 핵심 기능만을 커널에 포함시키고, 그 밖의 운영체제 서비스들은 서버라 불리는 프로세스에 의해 제공 이 프로세스들은 사용자 모드에서 수행되며 마이크로 커널에 의해 일반 응용과 동일하게 취급됨\n구현이 간단하고 융통성이 있으며 분산 환경에 적합하다. 본질적으로 마이크로 커널은 지역(local)과 원격(remote) 서버 프로세스를 구분하지 않고 동일한 방식으로 상호작용하기 때문에 분산시스템 구축을 용이하게 한다. 응용을 실행하는 프로세스를 동시에 수행될 수 있는 쓰레드들로 분할하는 기법 쓰레드(thread)\n작업의 디스패치 단위. 처리기 문맥과 고유 데이터 영역으로서의 스택(서브루틴 분기 지원)을 포함\n순차적으로 수행되며 처리기가 다른 쓰레드로 문맥 교환이 이루어질 수 있도록 인터럽트 당할 수 있음 프로세스(process)\n하나 이상의 쓰레드와 관련 시스템 자원들로 구성. 상호 독립적인 많은 태스크를 수행하는 응용에 유용\n<img src=\"https://i.imgur.com/JKc2IrW.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n컴퓨터의 하드웨어 구조를 일컫는 용어지만 해당 구조를 활용하는 운영체제의 행동 양식을 의미하기도 함 SMP용 운영체제는 어떤 처리기에서도 실행될 수 있도록 할 수 있다.\nSMP는 단일처리기 구조에 비해 아래와 같은 잠재적 장점을 가짐 위 사진만 봐도 컴퓨터가 수행할 작업의 일부가 병렬로 처리되면서 하나 이상의 프로세스들이 각각 다른 처리기 상에서 동시에 수행될 수 있음 처리기에 문제가 생기더라도 시스템 전체가 중지되지 않음 모든 처리기들이 동일한 기능을 각각 수행하기 때문 사용자는 성능 향상을 위해 필요할 때마다 처리기를 추가 설치할 수 있음 벤더들은 시스템을 구성하는 처리기 수에 따라 다양한 제품을 공급할 수 있다.\n이처럼 대칭형 멀티프로세싱을 사용함으로써 이와 같은 잠재적 장점을 가질 수 있는데, 이를 위해서는 운영체제가 이를 활용하기 위한 도구와 기능을 제공해야 함\nSMP는 멀티 쓰레딩과 함께 다루어지기도 하지만 독립적인 개념임을 유의해야 함.\nSMP 시스템의 경우 쓰레드화 되지 않은 프로세스에서도 병렬 수행이 가능하기 때문에 유용하며, 멀티쓰레딩과 함께 상호보완적으로 작동하여 효과적 독립된 처리기들의 클러스터(cluster), 즉 멀티컴퓨터 시스템에 대해 단일 시스템 이미지를 제공할 때 다루어야 할 대상은 컴퓨터 개체들의 집합으로, 이들은 각자의 주기억장치와 보조기억장치, 그 외 입출력 모듈 등을 가지고 있음\n분산 운영체제는 사용자에게 단일 주기억장치 공간과 단일 보조기억장치 공간을 사용하는 것처럼 느끼게 해 줄 뿐만 아니라, 분산파일 시스템과 같은 통합 접근 기능을 제공\n이를 통해 여러 CPU에서 서비스하는 작업을 처리한다. 작은 커널을 모듈 단위로 확장해 가는 과정에 대해 규칙을 제공\n운영 체제 수준에서 객체 기반 구조는 시스템의 무결성을 해치지 않으면서 운영체제를 프로그래머의 생각대로 구성할 수 있게 해주어 분산 운영체제 및 분산 도구의 개발을 용이하게 함.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제운영체제 개요최근 운영체제로의 발전","level":1,"id":"운영체제운영체제_개요최근_운영체제로의_발전_0"},{"heading":"최근 운영체제의 발전","level":1,"id":"최근_운영체제의_발전_0"},{"heading":"하드웨어의 발전","level":2,"id":"하드웨어의_발전_0"},{"heading":"운영체제의 발전","level":2,"id":"운영체제의_발전_0"},{"heading":"마이크로커널 구조","level":3,"id":"마이크로커널_구조_0"},{"heading":"멀티 쓰레딩(Multithreading)","level":3,"id":"멀티_쓰레딩(Multithreading)_0"},{"heading":"대칭형 멀티프로세싱(SMP: Symmetric multiprocessing)","level":3,"id":"대칭형_멀티프로세싱(SMP_Symmetric_multiprocessing)_0"},{"heading":"성능(Performance)","level":4,"id":"성능(Performance)_0"},{"heading":"가용성(Availability)","level":4,"id":"가용성(Availability)_0"},{"heading":"점진적 확장(Incremental growth)","level":4,"id":"점진적_확장(Incremental_growth)_0"},{"heading":"크기 조절(Scaling)","level":4,"id":"크기_조절(Scaling)_0"},{"heading":"분산 운영체제(disputed operating system)","level":3,"id":"분산_운영체제(disputed_operating_system)_0"},{"heading":"객체지향 설계(object-oriented design)","level":3,"id":"객체지향_설계(object-oriented_design)_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":4928,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_운영체제 개요_최근 운영체제로의 발전.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html":{"title":"운영체제_운영체제의 목적 및 기능","icon":"","description":"\n운영체제는 응용 프로그램의 수행을 제어하고 응용 프로그램과 컴퓨터 하드웨어 사이의 인터페이스 역할을 하는 프로그램\n운영체제의 목적 편리성: 컴퓨터의 보다 편리한 사용\n효율성: 컴퓨터 시스템 자원의 효율적 사용\n발전성: 효과적인 개발 및 시험 가능, 서비스를 방해하지 않고 새로운 시스템 기능을 도입할 수 있도록 구축 운영체제는 프로그래머와 응용 프로그램이 그와 같은 기능과 서비스에 쉽게 접근하고 편리하게 사용할 수 있게 해주는 중개자로서의 역할을 한다.\n운영체제가 제공하는 서비스 📚📚 프로그램 개발: 프로그램 작성을 위한 문서 편집기, 디버거 등의 기능 및 서비스 제공. 프로그램 실행: 하나의 프로그램 실행에선 운영체제에서 여러 단계를 거친다. <img src=\"https://i.imgur.com/M8MY9sN.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n명령어와 데이터가 주기억장치에 적재되고, 입출력 장치와 파일들이 초기화되어야 하며, 필요시 다른 자원들도 준비되어야 함. 이러한 자원을 사용자 대신 스케줄링하는 의무 수행 입출력 장치 접근: 각 입출력 장치에 대해 세부 사항들을 감추어 프로그래머가 단순 읽기/쓰기 관점에서 입출력 장치를 사용할 수 있도록 일관된 인터페이스 제공\n파일 접근 제어: 디스크, 테이프 드라이브와 같은 입출력장치 뿐만 아니라 저장매체 상에서의 파일 형식에 대한 정보도 반영한다. 또한 여러명의 동시 사용자를 지원하는 시스템의 경우에 운영체제는 파일에 대한 접근을 제어하기 위해 보호 기법 제공.\n시스템 접근: 공공(Public) 시스템의 경우 시스템 전체 및 특정 시스템 자원에 대한 접근을 제어하여 불법 사용자 접근 방지 및 자원 경쟁(같은 자원에 동시에 접근) 문제 해결\n에러 발견 및 응답: 메모리 에러나 장치 결함, 오동작과 같은 에러 발생에 대해 영향을 최소화시키면서도 에러 조건을 제거할 수 있도록 응답. 프로그램 종료, 연산 재시도, 에러 보고 등\n어카운팅(accounting): 여러 자원에 대한 사용 통계 수집 및 성능 척도(응답시간 등) 모니터링 -&gt; 보완 필요성 예상 및 시스템 튜닝에 유용\nInstruction Set Architecture(ISA): 컴퓨터가 따르고 있는 기계 명령어 집합 규정 정의. CPU마다 기계 명령어가 다를 수도 있기 때문에 이에 대해 규정을 정의하여 ISA에 의해 정의된 명령어를 사용하여 동작하도록 만듦.\n응용 실행파일 인터페이스(Application binary interface, ABI): 프로그램 간/서로 다른 컴파일러가 생산하는 실행파일 간 바이너리 호환성을 지원하기 위한 표준. 사용자 ISA에 의해 접근 가능한 하드웨어 자원이나 서비스 또는 운영체제로 전달되는 시스템 콜 인터페이스 규정\n응용 프로그래밍 인터페이스(Application Programming interface, API) : 프로그램들이 사용자 ISA를 통해 시스템에 있는 하드웨어 자원과 서비스에 접근할 수 있도록 해주는 수단. 표준화된 API를 통해 운영체제에서 재컴파일만으로 다른 운영체제에서도 쉽게 이식 가능.\n<br><img src=\"https://i.imgur.com/vOEXIVf.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n운영체제는 컴퓨터의 이동, 저장, 처리와 이 기능들을 제어하는데 필요한 자원들의 관리를 책임짐\n위 사진에서 운영체제는 주기억장치의 일부분을 차지하며 커널(운영체제 내부 코드) 및 OS 부분들이 항상 켜져있으며 처리기와 번갈아가며 제어를 가짐\n처리기가 유용한 작업을 수행할 수 있도록 제어를 양도한 뒤 다음 응용의 수행을 준비하는데 충분한 시간 동안 제어를 돌려 받고 이동안 운영체제는 다른 시스템 자원의 사용을 지시하며 다른 프로그램이 수행될 시점을 결정\n주기억장치의 나머지 부분에는 프로그램과 데이터가 적재된다. 하드웨어 업그레이드 및 새로운 형태의 하드웨어 하드웨어의 업그레이드와 함께 운영체제 또한 이를 위한 지원 확대 새로운 서비스 사용자 또는 시스템 관리자의 요구에 따라 새로운 서비스 제공을 위한 운영체제 확장. 버그 수정 결함이 발생하면 이에 대해서 수정 1940말 ~ 1950 중반까지 사용되었던 방식.\n해당 시스템의 문제점 스케줄링(scheduling) 기계에 소프트웨어를 설치하기 위해선 기계 사용시간을 예약하기 위해 등록 용지(sign-up sheet)을 이용\n30분 단위라 시간이 남아도 해당 시간동안 다른 사용자가 들어올 수 없어 처리 시간이 낭비 준비시간(setup time) 작업(Job)이라 불리는 단일 프로그램 수행에서 컴파일러와 소스 코드를 주기억장치에 적재하고 컴파일된 프로그램을 저장 장치에 저장한 다음, 바이너리 실행 파일과 공용 함수들을 함께 적재하여 링크하는 방식\n각 단계마다 테이프의 장착 여부, 카드 덱의 여부가 달랐음\n준비 과정에서 에러가 발생하면 처음부터 다시해야\u001f 1950년대 중반 IBM 704에 탑재된 버전\n모니터가 사용되기 시작됨 단계별로 컴퓨터에게 직접 명령을 내리지 않고, 작업을 카드나 테이프에 담아 컴퓨터 오퍼레이터에게 제출하고, 오퍼레이터는 작업들을 순서대로 한데 모아 모니터가 처리할 수 있도록 작업 묶음(batch)을 입력장치에 넣어 제어가 모니터로 넘어감\n자동으로 프로그램 실행 완료 후 모니터가 다음 프로그램 적재 <br>동작 과정 이해<img src=\"https://i.imgur.com/7yNRwCb.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 모니터 관점 항상 수행 가능한 상태로 주기억장치에 적재되어 일련의 사건(event)를 제어. 상주 모니터(resident monitor) 로 불림. 나머지 부분은 유틸리티와 공용 함수로 구성되어 모니터의 서브루틴 관리.\n각 작업을 프로그램 영역에 읽어 들이면 제어가 작업으로 넘어가 작업 완료 후 다시 모니터로 돌아오고 자동으로 다음 작업 진행 -&gt; 스케줄링 문제 해결 처리기 관점 주기억장치에서 명령어 수행하면서 다음 작업을 주기억장치의 다른 부분으로 읽어 들임.\n분기명령어를 수행하여 사용자 프로그램의 시작 부분으로 분기 후 종료 or 에러 발생 전까지 명령어 수행\n작업 다 되면 모니터 프로그램 내의 명령어 수행 작업 제어 언어(job control langauge, JCL): 포트란 명령어 $FTN =&gt; 대용량 저장장치로부터 포트란 컴파일러 적재(주기억장치 or 대용량 저장장치). 주기억장치에 저장되면 컴파일-적재-수행 방식(compile, load and go)이라고도 불림\n$LOAD =&gt; 컴파일 작업 후 제어를 다시 얻음. 모니터는 로더를 호출하고 로더는 컴파일러가 차지하고 있던 메모리 위치로 목적 프로그램을 적재한 뒤 제어를 그 프로그램으로 옮김\n프로그램에서는 입력 명령어를 통해 운영체제 내의 입력 루틴 호출 입력 루틴이 JCL 라인 읽으면 모니터로 제어가 넘어가고 다음 JCL 명령어 전까지 라인을 버리기 때문에 읽지 않도록 점검해야함 필요한 하드웨어 기능 메모리 보호 수행중인 사용자 프로그램은 모니터 포함 메모리 영역을 변경하면 안됨.\n시도를 발견하면 처리기가 감지하여 제어를 모니터로 넘기고 모니터는 작업 중단 후 에러 출력 -&gt; 다음 작업 재개 타이머 각 작업이 시작할 때 설정되어 시간을 넘어가면 제어를 모니터로 넘김 특권 명령어 모니터만이 실행할 수 있는 명령어. 모니터가 모든 입출력 장치를 제어할 수 있도록 특권 명령어화되어있음. 인터럽트 초창기 컴퓨터는 인터럽트 안됐지만 이제는 가능하다 사용자 모드(User mode)와 커널모드(kernel mode) 메모리 보호 + 특권 명령어 =&gt; 동작 모드\n사용자 모드(user mode) 특권 명령어 수행 불가\n메모리의 특정 영역 사용 불가 커널 모드(Kernel mode) 특권 명령어 수행 가능\n보호 메모리 영역 접근 가능 문제 주기억장치의 일부를 모니터가 계속 차지\n약간의 컴퓨터 시간을 모니터가 사용\n=&gt; 오버헤드의 발생\n긴 I/O 시간동안 CPU를 놀리면서 효율이 떨어짐<br>\n=&gt; 낮은 시스템 이용률<img src=\"https://i.imgur.com/UAAeZ47.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> <br><img src=\"https://i.imgur.com/BMax38Q.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n한 작업이 입출력 완료를 대기해야 할 때 처리기가 그 틈을 이용해 다음 프로그램 실행\nCPU의 사용률을 높일 수 있음\n<br><img src=\"https://i.imgur.com/Wn7ebz6.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nJOB들을 하나씩 순차적으로 실행되면 30분이라는 시간이 걸림\n하지만 JOB3의 경우만 봐도 디스크에 읽어 프린트만 하면 되므로 처리기 시간을 최소한으로 요구하기 때문에 자원을 비효율적으로 사용하고 있음.\n<br><img src=\"https://i.imgur.com/fQzZ1kj.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n하지만 멀티프로그래밍 운영체제 하에서 병행 수행된다고 보면 각각 서로 차지하는 자원의 사용률이 다르기 때문에 병행수행을 한다 해도 문제될 것이 없음\n이러한 병행 수행의 경우 전체를 동시에 수행하는 것처럼 보이겠지만 사실은 인터럽트를 통해 동시에 수행하는 듯한 효과를 냄\n이렇게 병행수행을 한다면 30분 걸릴 일이 15분으로 줄어듦\n<br><img src=\"https://i.imgur.com/RsgAWHk.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n효율을 비교하면 시간당 작업처리량이 거의 2배에 버금가는 미친 성능\n또한 자원들을 놀리지 않고 알차게 사용하면서 야무지게 써먹음 멀티프로그래밍을 이용하면 일괄 처리로 효율을 내지만 많은 작업이나 트랜잭션 처리와 같은 작업은 대화형 모드가 필수적으로 필요 터미널이 대표적인 대화형 모드 과거에는 대화형 작업을 처리하기 위해서 시분할(time sharing)기법이 사용됨\n이를 통해 각 사용자 프로그램이 짧은 시간동안 번갈아 수행되도록 해주는 운영체제를 통해 다수의 사용자가 터미널을 이용하여 동시에 시스템에 접근\n초기 개발된 시분할 운영체제는 MIT의 CTSS(Compatible Time-Sharing System)으로, IBM 709용으로 개발\n<br><img src=\"https://i.imgur.com/ThuwaZZ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">job1: 15,000\njob2: 20,000\njob3: 5,000\njob4: 10,000\n위 그림은 CTSS의 동작이다.\n제어가 대화형 사용자에게 할당되면 사용자 프로그램과 데이터가 주기억장치의 나머지에 할당됨\n프로그램은 항상 5000번째 워드 위치에 적재하도록 해서 상주 모니터와 메모리와의 관리를 용이하게 만듦\n시스템 클록은 대략 0.2초마다 1회의 비율로 인터럽트를 발생시켰고, 매 클럭 인터럽트마다 제어가 운영체제에 넘겨져 처리기가 다른 사용자에게 할당\n위의 사진에서 메모리 용량이 합쳐서 넘지 않는 이상은 함께 실행됨\nJOB3의 경우는 메모리 요구량이 적으므로 JOB2가 함께 남아있으면서 디스크 쓰기 시간을 줄일 수 있음\n이후에도 일부분을 저장하여 나중에 디스크 쓰기 시간을 줄일 수 있음\n당시에는 최대 32명의 사용자를 지원할 수 있어 효율적 일괄처리 멀티프로그래밍과 시분할의 비교\n프로세스는 수행 중인 프로그램 컴퓨터 상에서 수행 중인 프로그램의 인스턴스(instance, 객체) 처리기에 할당되어 수행될 수 있는 개체(entity) 단일 순차 실행 쓰레드, 현재 상태, 연계된 시스템 자원 등에 의해 특정지어지는 활동 단위 이러한 프로세스는 멀티프로그래밍 일괄처리, 시분할, 실시간 트랜잭션 등의 개발 과정에서 타이밍과 동기화 문제를 발생시킴 이러한 문제의 해결을 위해 프로세스라는 개념이 탄생, 이어 인터럽트라는 도구 또한 사용 하지만 이러한 개념을 이용하여 시스템 소프트웨어를 설계한다고 하더라도 이는 매우 어려웠음 각 프로그램의 작업은 순서대로 처리되어야 할 수많은 단계가 있고 이 사건 순차의 모든 가능한 조합을 분석하는게 불가능했을 뿐더러, 이러한 작업처리 과정들 간의 조정 및 협업을 지원하는 체계적 방법이 없었던 현실 그러다보니 프로그래머들도 임시방편적인 조치만 취하게 되고, 이는 곧 다양한 에러로 이루어짐 부적절한 동기화 I/O 요청이 완료되었음을 알리는 신호가 분실되거나 중복 전달(타이밍 문제) 상호배제 실패 동기화의 문제로 여러 프로그램이 동시에 공유 자원의 사용을 시도 비결정적인(nondeterminate) 프로그램 연산 메모리를 공유하는 프로그램들을 처리기가 인터리빙 방식으로 실행시킬 때, 동일한 공유 메모리에 덮어쓰기 하면서 프로그램의 수행을 서로 방해 교착상태(deadlock) 두 개 이상의 프로그램이 서로 상대방 프로그램에 할당된 자원의 방출(release)를 기다리면서 대기 이러한 문제들의 해결을 위해서는 처리기가 수행하는 프로그램들의 감시 및 제어가 필요했던 상황 이에 대한 기반을 프로세스 개념이 제공 프로세스의 구성 요소 수행 가능한 프로그램\n프로그램 수행에 필요한 관련 데이터(변수, 작업공간, 버퍼 등)\n프로그램 수행 문맥 수행 문맥(execution context, process state)\n운영체제가 프로세스를 감독하고 제어하기 위한 내부 데이터\n프로그램 카운터나 데이터 레지스터 같은 다양한 처리기 레지스터 내용 포함\n프로세스 주소 공간으로부터 분리됨\n<br><img src=\"https://i.imgur.com/FvJUzOt.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n프로세스의 구현 예 각 프로세스는 데이터와 프로그램, 문맥을 가짐\n하나의 프로세스 당 하나의 문맥을 가지고 있어 해당 문맥을 참고하여 우선순위를 정하고 프로세스 처리\n현재는 프로그램 카운터가 프로세스 B의 프로그램을 가리키고 있으므로 프로세스 B가 실행중인 것을 알 수 있음\n프로세스는 자신의 메모리 영역만을 볼 수 있으며, 다른 메모리에 침범시 운영체제가 kill한다. 베이스(Base) 레지스터와 경계(limit) 레지스터\n위 그림의 베이스, 경계 레지스터는 프로세스가 차지하고 있는 메모리 영역을 정의\n베이스 레지스터에는 메모리 영역의 시작 주소가 들어 있고, 경계 레지스터에는 그 영역의 크기가 저장된다.\n저장장치 할당에 대한 효율적이고 체계적인 제어를 요구하는 시스템 관리자를 만족시키기 위해 운영체제는 저장장치를 관리하는데 있어 다음 책무를 가짐\n프로세스 분리(isolation) 서로의 데이터나 메모리 영역을 침범하지 못하도록 분리하는 기법 제공 자동 할당 및 관리 프로그램이 사용하는 메모리 영역은 필요할 때마다 메모리 계층구조를 따라 동적으로 할당하며 자동으로 이루어짐. 모듈식 프로그래밍 지원 프로그램 모듈을 정의, 작성, 삭제가 가능하고 그 크기를 동적으로 변경 가능 보호 및 접근 제어 메모리 계층 어떤 레벨이라도 메모리가 공유되면 한 프로그램이 다른 프로그램의 메모리 주소 공간을 참조할 수 있게 함. 장기 저장 많은 응용 프로그램은 컴퓨터 전원이 꺼진 후에도 유지되는 정보 저장 수단을 필요로 함 이러한 요구사항들은 가상메모리와 파일 시스템을 통해 해결할 수 있다.\n가상메모리란?\n물리적으로 이용 가능한 주기억장치의 크기에 상관없이 프로그램이 메모리의 주소를 논리적 관점에서 참조할 수 있도록 하는 기법<br>\n<img src=\"https://i.imgur.com/2DH0ImO.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n위 사진과 같이 B.0~B.3의 경우 연속적인 메모리는 제약이 많음\n따라서 메모리를 각자 흩어서 배치해놓고 주기억장치에 각자 흩어져 있는 메모리들의 물리적 주소를 가상 주소와 동적 사상(mapping)을 제공함으로써 프로세스를 분리하면서도 정상적으로 읽어들일 수 있다.\n메모리 관리 유닛(Memory Management Unit, MMU)가 처리기와 주기억장치 사이에 위치하여 매핑을 담당한다. 실기억장치에 없는 가상 주소가 참조되면 실기억장치의 내용 중 일부가 보조기억장치(디스크)로 교체되어 나가는 것을 swap out, 주기억장치에 원하는 데이터 블록이 들어오는 것을 swap in이라 한다.\n운영체제는 보호와 보안을 위한 다양한 기법을 지원할 수 있다.\n사용성(availability): 시스템이 중지되지 않게 함\n기밀성(confidentiality): 접근 권한이 부여되지 않은 데이터를 사용자가 읽지 못하도록 보장\n데이터 무결성(data integrity): 데이터가 불법적으로 수정되지 못하게 보호\n신빙성(authenticity): 사용자 신원과 메시지나 데이터의 유효성에 대한 적절한 인증 운영체제의 핵심 작업 중 하나는 다양한 자원 관리 및 활성 프로세스들로부터 자원 사용 요구를 스케줄링 하는 것.\n이러한 과정에서 아래의 정책을 고려해야 함. 공정성 특정 자원을 사용하고자 경쟁하는 모든 프로세스들은 그 자원을 대체적으로 동등하고 공정하게 접근 반응 시간 차등화 다른 서비스 요건을 지닌 작업 클래스들을 구별하면서 모든 요구 조건들을 포괄적으로 만족시킬 수 있도록 할당 및 스케줄링 효율성 작업 처리량 극대화, 반응시간 최소화, 시분할 등 가능한 많은 수의 사용자를 동시에 수용하면서도 충돌이 일어나지 않도록 균형 잡기 <br><img src=\"https://i.imgur.com/LsguGxu.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\nRound-robin 기법 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로서, 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(Time Quantum/Slice)로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘\n컴퓨터 자원을 사용할 수 있는 기회를 프로그램 프로세스들에게 공정하게 부여하기 위한 한 방법\n각 프로세스에 일정시간을 할당하고, 할당된 시간이 지나면 그 프로세스는 잠시 보류한 뒤 다른 프로세스에게 기회를 주고, 또 그 다음 프로세스에게 하는 식으로 돌아가며 기회를 부여하는 운영방식\n위의 사진에서 단기 큐(Short-Term Queue) 의 경우 주기억장치에 적재되어 있고 처리기만 있으면 즉각 실행가능한 준비 상태의 프로세스**들로 구성\n장기 큐(Long-Term Queue) 의 경우 처리기를 사용하기 위해 대기하고 있는 새로운 작업들의 리스트\n운영체제는 장기 큐에서 단기 큐로 프로세스를 이동시키고 실행시키는데, 주기억장치 용량이나 처리기 능력이 초과되지 않도록 관리해야함 인터럽트가 발생하면 운영체제는 처리기에 대한 제어를 넘겨받아 인터럽트 처리 루틴을 수행한다. 프로세스는 시스템 호출(System call) 을 통해 입출력 장치 처리기 등의 운영체제 서비스 요청이 가능하다. 이 경우 서비스 호출 처리기는 운영체제로의 진입 역할을 한다.인터럽트 or 서비스 호출이 처리되고 나면 운영체제는 단기 스케줄러를 호출하여 다음에 수행할 프로세스를 선정한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제의 목적과 기능","level":3,"id":"운영체제의_목적과_기능_0"},{"heading":"사용자/컴퓨터 인터페이스로서의 운영체제","level":4,"id":"사용자/컴퓨터_인터페이스로서의_운영체제_0"},{"heading":"자원 관리자로서의 운영체제","level":4,"id":"자원_관리자로서의_운영체제_0"},{"heading":"운영체제 발전의 용이성","level":4,"id":"운영체제_발전의_용이성_0"},{"heading":"운영체제의 발전","level":3,"id":"운영체제의_발전_0"},{"heading":"순차처리","level":4,"id":"순차처리_0"},{"heading":"단순 일괄처리 시스템(Simple Batch System)","level":4,"id":"단순_일괄처리_시스템(Simple_Batch_System)_0"},{"heading":"멀티프로그래밍 일괄처리 시스템(Multiprogrammed Batch System)","level":4,"id":"멀티프로그래밍_일괄처리_시스템(Multiprogrammed_Batch_System)_0"},{"heading":"시분할 시스템","level":4,"id":"시분할_시스템_0"},{"heading":"주요 성과","level":3,"id":"주요_성과_0"},{"heading":"프로세스 분야에서","level":4,"id":"프로세스_분야에서_0"},{"heading":"메모리 관리","level":4,"id":"메모리_관리_0"},{"heading":"정보 보호와 보안","level":4,"id":"정보_보호와_보안_0"},{"heading":"스케줄링과 자원 관리","level":4,"id":"스케줄링과_자원_관리_0"},{"heading":"스케줄링 정책","level":5,"id":"스케줄링_정책_0"},{"heading":"디스패처 전략","level":5,"id":"디스패처_전략_0"},{"heading":"인터럽트(Interrupt)","level":5,"id":"인터럽트(Interrupt)_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058369,"modifiedTime":1725254058370,"sourceSize":21503,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_운영체제의 목적 및 기능.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html":{"title":"운영체제_입출력 관리와 디스크 스케줄링_디스크 스케줄링","icon":"","description":"처리기와 주기억장치의 속도가 빨라지면서 디스크의 성능을 향상시키는 기법에 관한 고찰<img src=\"https://i.imgur.com/9oXkdcu.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">디스크 암을 필요한 트랙으로 이동시키는데 걸리는 시간\n약 10ms지정된 디스크의 주소 영역이 입출력 헤드에 의해 접근 가능한 위치까지 회전하여 도달하는데 걸리는 시간\n약 2ms(15,000 rpm의 경우)데이터를 읽거나 쓰기 위한 위치에 도달하는데 걸리는 시간\n탐색 시간 + 회전지연시간데이터를 디스크로 보내거나 받을 때 걸리는 전송 시간<br><img src=\"https://i.imgur.com/65reEr2.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n회전속도 7500rpm, 트랙당 512 바이트 섹터 500개\n2500 섹터로 구성된 1.28MB 파일 읽기(5트랙 * 500섹터/트랙)\n순차탐색의 경우 16(처음 섹터까지 도달 + 읽기) + 4(나머지 트랙) * 12(한 섹터를 읽는데 걸리는 회전지연 4 + 500섹터 읽기 8) = 64ms = 0.064초 무작위 탐색의 경우\n- 2500(각 섹터) * 8,016(한 블록을 읽는데 걸리는 시간) = 20040ms = 20.04초\n=&gt; 섹터들이 디스크로부터 읽혀지는 순서는 입출력 성능에 큰 영향\n<br><img src=\"https://i.imgur.com/QDCzYDi.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n* 횡단트랙: 해당 트랙까지 움직인 거리<br><img src=\"https://i.imgur.com/WZ72hnj.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n선입선출 방식으로 순서대로 처리하기 때문에 공정함.\nClustered된 파일 섹터 접근하면 효율이 좋지만 아닌 경우 구림 빨리 처리할 수 있는 거부터 처리하는 방식\n빨리 처리하는 것만 하다가 기아 발생할 수 있음 지역성을 이용하면 작업 처리량을 증가시키고 큐의 길이를 줄일 수 있음\n디스크가 큰 작업 부하 때문에 계속해서 바쁜 상태면 기아 발생 가능성이 있음\n<br><img src=\"https://i.imgur.com/zheMQbF.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n현재 위치에서 디스크 헤드의 움직임을 최소로 하는 디스크 입출력 요청을 선택\nFIFO보다 더 나은 성능\n<br><img src=\"https://i.imgur.com/L1Paxef.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n엘리베이터처럼 이동 방향의 마지막 트랙에 도달하거나 그 방향으로 남아 있는 요청이 없을 때까지 한 방향으로 이동\n끝까지 가면 방향 바꾼다음에 반대 방향으로 모두 스캔\nSSTF와 비슷하지만 지역성을 활용하지는 않음\n가장 안쪽 트랙과 가장 바깥쪽 트랙에 가까운 트랙들에 대한 요청을 한 작업을 선호 C-SCAN으로 해결 가장 최근에 도착한 작업을 선호 N-step-SCAN으로 해결 <br><img src=\"https://i.imgur.com/0kgEJG8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n한 방향으로만 가다가 방향 바꿔서 들리지 않고 한번에 돌아가고 다시 똑같은 방향으로 스캔 반복\n새로운 요청들이 겪게 되는 최대 지연 감소 디스크 요청 큐를 세그먼트로 분할하고 한 번에 한 단편에 속한 요청 전부를 처리\nN-step-SCAN 디스크 요청 큐를 길이가 N인 하위 큐들로 분할\nSCAN을 이용해서 하위 큐 처리 FSCAN 두 개의 하위 큐 이용(모든 요청들을 담은 큐 + 빈 큐)\n스캔하면서 새로운 모든 요청들은 다른 비어있는 큐로 들어가서 원래 요청들이 완료될 때까지 대기 <br><img src=\"https://i.imgur.com/YkC9CHx.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제입출력 관리와 디스크 스케줄링디스크 스케줄링","level":1,"id":"운영체제입출력_관리와_디스크_스케줄링디스크_스케줄링_0"},{"heading":"디스크 스케줄링","level":1,"id":"디스크_스케줄링_0"},{"heading":"디스크 성능 매개변수","level":2,"id":"디스크_성능_매개변수_0"},{"heading":"탐색 시간(seek time)","level":3,"id":"탐색_시간(seek_time)_0"},{"heading":"회전 지연(rotational delay)","level":3,"id":"회전_지연(rotational_delay)_0"},{"heading":"접근 시간(access time)","level":3,"id":"접근_시간(access_time)_0"},{"heading":"전송 시간(transfer time)","level":3,"id":"전송_시간(transfer_time)_0"},{"heading":"전체 시간 계산 예시","level":3,"id":"전체_시간_계산_예시_0"},{"heading":"디스크 스케줄링 정책","level":2,"id":"디스크_스케줄링_정책_0"},{"heading":"FIFO(First-In-First-Out)","level":3,"id":"FIFO(First-In-First-Out)_0"},{"heading":"PRI(우선순위 기반)","level":3,"id":"PRI(우선순위_기반)_0"},{"heading":"LIFO(Last In First Out)","level":3,"id":"LIFO(Last_In_First_Out)_0"},{"heading":"SSTF(Shortest Service Time First)","level":3,"id":"SSTF(Shortest_Service_Time_First)_0"},{"heading":"SCAN(엘리베이터 알고리즘)","level":3,"id":"SCAN(엘리베이터_알고리즘)_0"},{"heading":"C-SCAN","level":3,"id":"C-SCAN_0"},{"heading":"N-step-SCAN과 FSCAN","level":3,"id":"N-step-SCAN과_FSCAN_0"},{"heading":"디스크 스케줄링 알고리즘 비교","level":3,"id":"디스크_스케줄링_알고리즘_비교_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":3752,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_디스크 스케줄링.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html":{"title":"운영체제_입출력 관리와 디스크 스케줄링_디스크 캐시","icon":"","description":"\n캐시 메모리(주기억장치보다 더 작고 빠르면서 주기억장치와 처리기 사이에 위치하는 메모리)의 원칙을 디스크 메모리에 적용\n디스크 섹터를 저장하기 위한 주기억장치의 버퍼\n특정 섹터에 대해 입출력 요청 -&gt; 그 섹터가 디스크 캐시 안에 있는지 검사 -&gt; 존재하면 입출력 작업은 캐시에서 완료 / 존재하지 않으면 요청된 섹터가 디스크로부터 디스크 캐시로 읽혀짐\n참조의 지역성 특성 적용\n새로운 섹터를 디스크 캐시로 가져올 때 현존하는 블록들 중 하나는 교체되어야 함참조 없이 가장 오랫동안 캐시에 존재했던 블록을 교체\n논리적으로 캐시는 스택으로 구성되어 블록이 참조되면 스택의 위쪽으로 다시 들어감\n스택의 맨 밑에 위치한 블록을 제거하고 새로 들어온 블록을 스택의 맨 위에 놓는 방식집합 중에서 참조 횟수가 가장 적은 블록을 교체\n블록이 캐시로 들어오면 카운터 값 1이 배정되고 참조될 때마다 카운터 값이 1씩 증가하여 카운터 값이 가장 작은 블록을 교체시키는 방식\n문제: 지역성 효과가 있는데 참조 카운트가 블록이 바로 다시 참조될 확률을 정확히 반영하지 못함\n=&gt; 빈도 기반 교체를 통한 문제 해결<img src=\"https://i.imgur.com/exIZU2A.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nLRU와 비슷한 논리적 스택 구조\n스택 상부의 일정 블록들은 새로운 섹션용으로 예약되어 있음\n캐시 적중이 발생하면 참조된 블록이 스택 상부로 이동 그 블록이 이미 새로운 섹션 내의 블록이라면 참조 카운트 증가 X\n새로운 섹션 내의 블록이 아니라면 카운트값+1 새로운 섹션이 충분히 크면 짧은 시간 동안 반복적으로 재참조되는 블록들의 참조 카운트는 변하지 않음\n캐시 적중 실패가 발생한 경우 새로운 섹션에 속하지 않는 블록 중 참조 카운트가 가장 작은 블록이 선택되어 교환됨\n카운트 값이 같은 경우 가장 오래 전에 참조된 블록이 선택되어 교환됨\n<br><img src=\"https://i.imgur.com/lsNDGT1.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nLRU가 빈도기반 교체 알고리즘보다 우수한 성능을 나타내는 것처럼 보이지만 동일한 구조를 가지는 캐시에서 동일한 참조 패턴을 이용하면 빈도기반 교체 알고리즘이 훨씬 우수함\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제입출력 관리와 디스크 스케줄링디스크 캐시","level":1,"id":"운영체제입출력_관리와_디스크_스케줄링디스크_캐시_0"},{"heading":"디스크 캐시","level":1,"id":"디스크_캐시_0"},{"heading":"교체 전략 - 페이지 교체 알고리즘","level":2,"id":"교체_전략_-_페이지_교체_알고리즘_0"},{"heading":"LRU(Least Recently Used)","level":3,"id":"LRU(Least_Recently_Used)_0"},{"heading":"LFU(Least Frequently Used)","level":3,"id":"LFU(Least_Frequently_Used)_0"},{"heading":"빈도 기반 교체(Frequency-based Replacement)","level":3,"id":"빈도_기반_교체(Frequency-based_Replacement)_0"},{"heading":"빈도 기반 교체 - 성능 평가","level":4,"id":"빈도_기반_교체_-_성능_평가_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":2683,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_디스크 캐시.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html":{"title":"운영체제_입출력 관리와 디스크 스케줄링_운영체제 설계 이슈","icon":"","description":"\n빠른 처리기와 느린 입출력 장치 -&gt; 병목현상(bottleneck) 발생\n문제의 해결방법 -&gt; 멀티프로그래밍 대량의 주기억장치 시스템에서도 입출력 처리 속도는 처리기의 속도를 못따라잡음 디스크가 가장 중요한 입출력 장치이기 때문에 디스크 입출력이 가장 주목 간결성과 무결성을 위해서는 모든 장치들을 일관된 방식으로 다루어야 함\n입출력 기능 설계에 계층적인 모듈 접근법 사용 입출력 장치의 세부 사항 대부분을 하위 수준의 루틴 내에 감춤으로써 사용자 프로세스와 운영체제의 상위 수준 기능들이 읽기, 쓰기, 열기, 닫기 등의 일반적인 기능들을 통해 장치에 접근 <img src=\"https://i.imgur.com/qXKP7nQ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n장치를 논리적 자원으로 취급하며 실제로 장치를 제어하는 세부사항들은 관심 X\n사용자 프로세스를 대신해서 일반적인 입출력 기능들을 관리\n사용자 프로세스가 장치 식별자와 간단한 명령들로 장치에 접근할 수 있게 함\n요청된 연산과 데이터(버퍼된 문자들, 레코드 등)는 해당하는 입출력 명령, 채널 명령, 제어기 명령으로 변환\n입출력 연산의 실제적인 큐잉과 스케줄링, 연산 제어가 일어나는 계층\n인터럽트 처리 + 입출력 상태가 수집되어 보고\n실제로 입출력 모듈, 하드웨어 장치와 상호작용하는 소프트웨어 계층 파일 시스템을 지원하는 보조기억장치와의 입출력을 관리하는 대표적 구조\n디렉토리 관리(Directory management) 심볼릭 파일 이름이 직접 파일을 가리키거나 파일 디스크럽터 또는 색인 테이블을 통해 간접적으로 파일을 가리키는 식별자로 변환\n추가, 삭제, 재배치와 같이 디렉토리에 영향을 주는 사용자 연산 제공 파일 시스템(file system) 파일의 논리적 구조와 사용자가 명시하는 조작(열기, 닫기, 쓰기 등) 제공 물리적 구성(Physical organization) 파일과 레코드의 논리적 참조 -&gt; 보조기억장치의 물리적 트랙과 섹터 구조를 고려하여 물리적인 보조기억장치 주소로 변환\n보조기억장치 공간과 주기억장치 버퍼를 할당 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제입출력 관리와 디스크 스케줄링운영체제 설계 이슈","level":1,"id":"운영체제입출력_관리와_디스크_스케줄링운영체제_설계_이슈_0"},{"heading":"운영체제 설계 이슈","level":1,"id":"운영체제_설계_이슈_0"},{"heading":"설계 목적","level":2,"id":"설계_목적_0"},{"heading":"효율성(efficiency)","level":3,"id":"효율성(efficiency)_0"},{"heading":"일반성(generality)","level":3,"id":"일반성(generality)_0"},{"heading":"입출력 기능의 논리 구조","level":2,"id":"입출력_기능의_논리_구조_0"},{"heading":"논리적 입출력(Logical I/O)","level":3,"id":"논리적_입출력(Logical_I/O)_0"},{"heading":"장치 입출력(Device I/O)","level":3,"id":"장치_입출력(Device_I/O)_0"},{"heading":"스케줄링과 제어(Scheduling and control)","level":3,"id":"스케줄링과_제어(Scheduling_and_control)_0"},{"heading":"파일시스템의 경우","level":3,"id":"파일시스템의_경우_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":2650,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_운영체제 설계 이슈.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html":{"title":"운영체제_입출력 관리와 디스크 스케줄링_입출력 버퍼링","icon":"","description":"\n사용자 프로세스가 디스크로부터 데이터 블록을 한 번에 하나씩 읽어들이고 싶음\n데이터 블록 길이 512바이트\n데이터 블록은 사용자 프로세스 주소 공간의 가상 위치 1000~1511에 존재하는 영역으로 읽혀짐\n-&gt; 가장 간단한 방법: Read_Block[1000,disk] 입출력은 느리게 수행되는데 입출력 종료까지 멈춰야 함\n운영체제가 스와핑 결정에 방해됨 1000~1511 가상위치 블록을 유지해야 함\n교착 상태 가능성\n오버헤드와 비효율 -&gt; 버퍼링으로 해결 <img src=\"https://i.imgur.com/pOUUoZJ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n블록형(Block-oriented) 장치 정보를 고정 크기를 가지는 블록 형태로 저장\nUSB, 디스크 등 스트림형(stream-oriented) 장치 데이터를 별도의 블록 구조 없이 바이트 스트림으로 저장\n마우스, 키보드 등 사용자 프로세스가 입출력 명령을 내리면 운영체제는 주기억장치의 시스템이 사용하는 영역에 있는 버퍼 하나를 할당<br><img src=\"https://i.imgur.com/HnZmXZ9.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n시스템 버퍼로 입력 데이터 전송\n전송이 완료되면 프로세스는 그 블록을 사용자 공간으로 이동시키고 즉시 다음 블록 요청\n사용자 프로세스는 그 다음 블록을 읽어오는 동안 이미 읽혀진 데이터 블록을 처리\n시스템 버퍼링이 없는 경우에 비해 입출력 속도 향상\n하지만 운영 시스템의 논리를 복잡하게 만듦(운영체제 + 스와핑 논리)\n스트림형 입출력의 경우 라인형 단일 버퍼링 기법\n바이트형 단일 버퍼링 기법 버퍼를 두 개를 두어 프로세스가 데이터를 버퍼로 전송하거나 전송받는 동안 운영체제는 또 다른 버퍼를 비우거나 채움<br><img src=\"https://i.imgur.com/cJBkVLl.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n단일 버퍼링보다 성능 향상\n스트림형 입력의 경우 라인형 입출력 -&gt; 프로세스가 이중 버퍼 연산보다 앞서서 수행되지 않는다면 입력이나 출력이 완료될 때까지 보류될 필요가 없음\n바이트형 -&gt; 별 차이 없음 <br><img src=\"https://upload.wikimedia.org/wikipedia/commons/f/fd/Circular_Buffer_Animation.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n입출력 장치와 프로세스 간의 데이터 흐름을 평탄하게 조절\n두 개 이상의 버퍼\n각 버퍼는 환형 버퍼 할당의 단위\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제입출력 관리와 디스크 스케줄링입출력 버퍼링","level":1,"id":"운영체제입출력_관리와_디스크_스케줄링입출력_버퍼링_0"},{"heading":"입출력 버퍼링","level":1,"id":"입출력_버퍼링_0"},{"heading":"문제를 위한 가정","level":2,"id":"문제를_위한_가정_0"},{"heading":"해당 접근의 문제점","level":3,"id":"해당_접근의_문제점_0"},{"heading":"입출력 장치의 유형","level":2,"id":"입출력_장치의_유형_0"},{"heading":"단일 버퍼","level":2,"id":"단일_버퍼_0"},{"heading":"이중 버퍼","level":2,"id":"이중_버퍼_0"},{"heading":"환형 버퍼","level":2,"id":"환형_버퍼_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":2556,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_입출력 버퍼링.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html":{"title":"운영체제_입출력 관리와 디스크 스케줄링_입출력 장치, 입출력 기능 구성","icon":"","description":"\n데이터 전송률(Data rate)<img src=\"https://i.imgur.com/waKOSBc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n응용(Application) 장치의 용도에 따라 운영체제의 소프트웨어와 정책, 지원 유틸리티에 영향 제어 복잡성(Complexity of control) 각 장치 간의 제어 인터페이스 복잡도\n제어 복잡성의 차이점이 운영체제에 미치는 영향은 장치 제어 입출력 모듈의 복잡성에 의해 어느정도까지는 여과됨 전송 단위(Unit of transfer) 전송 데이터는 일련의 바이트나 문자들의 스트림(stream)형태로 전송될 수 있고, 보다 큰 블록 단위로도 가능 데이터 표현(Data representation) 문자 코드와 패리티 규약(parity conventions) 상의 차이점 등 데이터 인코딩 체계 에러 조건(Error conditions) 에러읜 본질, 보고되는 방식, 결과, 응답 가능 범위는 장치들마다 다름 ✔️ 입출력 기능이 발달하면서 점점 더 많은 입출력 기능이 처리기 개입 없이 수행DMA 장치는 처리기를 흉내낼 수 있고, 실제로 처리기처럼 시스템 버스를 제어할 수 있음\n=&gt; 시스템 버스를 거쳐 메모리로 데이터를 주고받는 데 필요<br><img src=\"https://i.imgur.com/kiWRDMM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\nDMA 모듈에게 입출력 연산을 위임하고 처리기는 다른 작업을 계속함\nDMA 모듈은 처리기를 거치지 않고 한 번에 한 워드씩 데이터 블록 전체를 전송한 후, 처리기에 인터럽트 신호를 보냄\n=&gt; 처리기는 전송의 시작과 마지막에만 관여 읽기/쓰기 여부 처리기와 DMA 모듈 사이의 읽기/쓰기 제어 라인 사용 입출력 장치의 주소 데이터 라인 통해 전송 읽기 혹은 쓰기가 시작될 메모리 위치 데이터 라인 통해 전송\nDMA 모듈의 주소 레지스터에 저장 읽거나 쓸 워드 수 데이터 라인 통해 전송\n데이터 카운트 레지스터에 저장 <br><img src=\"https://i.imgur.com/IVR9bIv.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n✔️ 모든 모듈이 동일한 시스템 버스 공유\n✔️ DMA 모듈은 대행 처리기로서 메모리와 입출력 모듈 간에 데이터를 교환하기 위해 프로그램된 입출력 사용\n✔️ 처리기 제어 하의 프로그램된 입출력처럼 한 단어를 전송시킬 때마다 두 개의 버스 사이클 필요(전송 요청 후 데이터 전송) =&gt; 비효율적<br><img src=\"https://i.imgur.com/eZi3aww.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n✔️ DMA 모듈과 하나 이상의 입출력 모듈 사이에 시스템 버스가 아닌 통로가 존재\n✔️ 입출력 버스를 통해 입출력 모듈들을 DMA 모듈에 연결하는 방식으로 한 단계 진전\n✔️ DMA 모듈의 입출력 인터페이스 수를 하나로 줄여 주고 확장성 높은 구성 제공<br><img src=\"https://i.imgur.com/9jlnv0P.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n✔️ DMA 모듈이 처리기나 주기억장치와 함께 공유하는 시스템 버스\n=&gt;메모리와 데이터를 교환하거나 처리기와 제어 신호를 교환할 때 DMA 모듈에 의해서만 사용됨\n✔️ DMA와 입출력 모듈 간의 데이터 교환은 시스템 버스 밖에서 일어남","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제입출력 관리와 디스크 스케줄링입출력 장치, 입출력 기능 구성","level":1,"id":"운영체제입출력_관리와_디스크_스케줄링입출력_장치,_입출력_기능_구성_0"},{"heading":"입출력 장치","level":1,"id":"입출력_장치_0"},{"heading":"외부 장치의 범주","level":2,"id":"외부_장치의_범주_0"},{"heading":"범주 내의 차이점","level":2,"id":"범주_내의_차이점_0"},{"heading":"입출력 기능 구성","level":1,"id":"입출력_기능_구성_0"},{"heading":"입출력 기능의 발달","level":2,"id":"입출력_기능의_발달_0"},{"heading":"직접 메모리 접근","level":2,"id":"직접_메모리_접근_0"},{"heading":"DMA 모듈에게 명령을 내리는 정보","level":3,"id":"DMA_모듈에게_명령을_내리는_정보_0"},{"heading":"DMA 구성 방안","level":3,"id":"DMA_구성_방안_0"},{"heading":"단일 버스, 분리된 DMA","level":4,"id":"단일_버스,_분리된_DMA_0"},{"heading":"단일 버스, 통합된 DMA 입출력","level":4,"id":"단일_버스,_통합된_DMA_입출력_0"},{"heading":"시스템 버스 &amp; 입출력 버스","level":4,"id":"시스템_버스_&_입출력_버스_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":5898,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_입출력 장치, 입출력 기능 구성.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html":{"title":"운영체제_입출력 관리와 디스크 스케줄링_RAID","icon":"","description":"\n여러 개의 병렬적인 디스크 구성을 통한 디스크의 부가적인 성능 향상 독립적이고 병렬적인 디스크 구성\n다중 디스크의 사용으로 얻는 이점\n- 다양한 방식으로 데이터를 구성\n- 신뢰성을 향상시키기 위한 중복성을 여러 방법으로 추가\n=&gt; RAID 표준 방식 0~6까지 7개의 레벨\n공통된 특성 운영체제에 의해 단일 논리적인 드라이브로 판단되는 물리적 디스크 드라이브의 집합\n데이터는 배열의 물리적 드라이브에 스트라이핑 기법을 사용하여 분산됨\n중복된 디스크 용량은 패리티 정보를 저장하기 위해 사용, 디스크 실패가 발생했을 때 데이터 복구에 사용 중복 요구를 효과적으로 다룸\n<img src=\"https://i.imgur.com/Eq2Jqb1.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n물리적으로는 2개의 이상의 디스크\n2개 이상의 디스크가 1개의 통합된 디스크로 보임\n일정한 스트립(strip)으로 잘라서 저장됨 연속적인 스트립의 집합은 스트라이프(stripe) N개를 쓰면 N배만큼 빨라짐\n하나의 디스크라도 문제가 발생하면 사용할 수 없음\n<br><img src=\"https://i.imgur.com/aNcimHR.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n미러링을 통해 모든 데이터를 똑같은 수의 디스크에 복사(mirror disk)\n읽기 -&gt; 두 개의 디스크 중 탐색시간과 회전 지연 시간이 짧은 디스크로 가서 읽으면 됨\n쓰기 -&gt; 두 개 다 써야 하지만 병렬적으로 시행될 수 있어 두 개의 쓰기 중에서 더 느린 것으로 결정됨\n디스크가 고장나도 다시 갈아끼우고 미러링된 디스크에서 복사받으면 됨\n디스크 두개씩 사서 비쌈\n<br><img src=\"https://i.imgur.com/YlbUPIV.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n비트 단위로 스트라이핑 하고 에러 복구 코드로 해밍코드 사용 한비트씩 디스크에 저장 최소 3개의 디스크 중복 디스크 수(복구하는데 필요한 디스크)는 데이터 디스크 수의 로그 값에 비례\n읽기 -&gt; 모든 디스크가 동시에 접근\n1개의 디스크가 에러나면 복구가능하지만 2개가 동시에 에러나면 조짐\n<br><img src=\"https://i.imgur.com/wuXnELQ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nRAID 2와 비슷한 방식의 구조지만 하나의 중복 디스크만 필요함\n작은 스트립들로 데이터 분산시키고 데이터를 병렬로 접근\n에러 교정 코드 대신에 하나의 단순한 패리티 비트가 모든 데이터 디스크 상의 동일한 위치에 있는 각 비트들의 집합에 대해 계산됨\n1개 디스크 에러 교정은 되지만 2개 이상 동시에 에러나면 조짐\n<br><img src=\"https://i.imgur.com/A8WI8Io.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n블록 단위로 스트라이핑\n비트별 패리티 스트립(bit-by-bit parity strip)이 각 데이터 디스크 상의 상응하는 스트립에 대해 계산되고 패리티 비트들은 패리티 디스크 상의 상응하는 스트립에 저장됨\n<br><img src=\"https://i.imgur.com/VqKBuxu.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nRAID 4와 비슷함 패리티 비트의 분산 저장 -&gt; 병목현상 피할 수 있음\n한 디스크때문에 전체 데이터 접근 못하는 현상 방지\n가장 많이 사용\n<br><img src=\"https://i.imgur.com/26z0h71.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n블록 단위 스트라이핑\nRAID 4에서 성능, 용량을 줄이고 안정성을 높인 버전\n패리티 비트를 이중저장\n두 개의 디스크에서 에러가 나도 복구 가능\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"RAID(Redundant Array of Independent Disks)","level":1,"id":"RAID(Redundant_Array_of_Independent_Disks)_0"},{"heading":"RAID 방식","level":2,"id":"RAID_방식_0"},{"heading":"RAID 0","level":3,"id":"RAID_0_0"},{"heading":"RAID 1","level":3,"id":"RAID_1_0"},{"heading":"RAID 2","level":3,"id":"RAID_2_0"},{"heading":"RAID 3","level":3,"id":"RAID_3_0"},{"heading":"RAID 4","level":3,"id":"RAID_4_0"},{"heading":"RAID 5","level":3,"id":"RAID_5_0"},{"heading":"RAID 6","level":3,"id":"RAID_6_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":5875,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_RAID.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html":{"title":"운영체제_입출력 관리와 디스크 스케줄링_UNIX SVR4의 입출력","icon":"","description":"UNIX에서는 각 개별 입출력 장치는 각각의 특수 파일과 관련됨<img src=\"https://i.imgur.com/5YPnxWi.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n장치에 대한 읽고 쓰기 -&gt; 장치와 연결된 특수 파일에 읽기 및 쓰기 요청\n파일 서브 시스템 -&gt; 보조기억장치의 파일들 관리 + 장치를 파일처럼 다루기 때문에 프로세스가 장치를 사용할 수 있는 인터페이스 역할\nUNIX의 입출력 버퍼 방식 시스템 버퍼 캐시\n문자 큐 버퍼를 사용하지 않는 입출력 방식 DMA 장치를 이용한 입출력 모듈과 프로세스 입출력 영역 간의 직접적인 데이터 전송 <br><img src=\"https://i.imgur.com/8SB5AQK.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">\n디스크 캐시로 디스크의 입출력 연산들을 버퍼 캐시를 통해 처리\n버퍼 캐시와 사용자 프로세스 공간 사이의 데이터 전송은 DMA 활용\n블록 교체에는 LRU 알고리즘 사용 가용 리스트 할당 가능한 모든 캐시 슬롯의 리스트 장치 리스트 현재 각 디스크와 연관되어 있는 모든 버퍼들의 리스트 드라이버 입출력 큐 특정 장치에서 입출력이 실행되기를 기다리거나 현재 입출력이 진행 중인 버퍼들의 리스트 특정 장치 상에 있는 물리적 번호가 참조되면 운영체제는 그 블록이 버퍼 캐시에 있는지 검사\n-&gt; 해시테이블로 구성된 장치 리스트에서 각각의 참조가 해시테이블의 특정한 항목으로 매핑됨\n-&gt; 각 버퍼와 존재하는 해시 포인터는 그 해시 테이블 항목을 위한 체인의 다음 버퍼를 가리킴단말기나 프린터와 같은 문자형 장치 -&gt; 다른 유형의 버퍼링이 적절\n문자 큐는 입출력 장치가 쓰고 프로세스가 읽거나 프로세스가 쓰고 장치가 읽음\n=&gt; 문자 큐들은 오직 한 번만 읽혀질 수 있음단순히 장치와 프로세스 공간 사이의 DMA를 의미\n프로세스가 쓸 수 있는 가장 빠른 입출력 방법\n버퍼를 사용하지 않는 입출력을 수행하는 프로세스는 주기억장치에 잠겨 스왑될 수 있음\n=&gt; 주기억장치 일부를 고착시켜 스와핑 기회를 줄임.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"UNIX SVR4의 입출력","level":1,"id":"UNIX_SVR4의_입출력_0"},{"heading":"버퍼 캐시","level":2,"id":"버퍼_캐시_0"},{"heading":"버퍼 캐시를 관리하기 위한 리스트","level":3,"id":"버퍼_캐시를_관리하기_위한_리스트_0"},{"heading":"작동 과정","level":3,"id":"작동_과정_0"},{"heading":"문자 큐","level":3,"id":"문자_큐_0"},{"heading":"버퍼를 사용하지 않는 입출력","level":3,"id":"버퍼를_사용하지_않는_입출력_0"},{"heading":"UNIX 장치","level":2,"id":"UNIX_장치_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":2906,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_UNIX SVR4의 입출력.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html":{"title":"운영체제_파일 관리_개요","icon":"","description":"파일 시스템 -&gt; 파일이라 불리는 데이터 집합을 생성하도록 허용\n장시간 보존(long-term existence) 디스크나 보조기억장치에 저장하면 삭제 전까지 보존 프로세스들 간에 공유 가능(sharable between processes) 파일은 제어된 공유를 허용하는 연관된 접근 권한을 지님 구조(Structure) 파일 -&gt; 파일시스템에 의존하여 특정한 응용에 편리한 내부 구조 생성(Create)\n삭제(Delete)\n열기(Open)\n닫기(Close)\n읽기(Read)\n쓰기(Write) 필드(Field) 데이터의 기본요소로 각 필드에 단일 값을 가짐 레코드(Record) 어떤 응용 프로그램이 하나의 단위로 취급될 수 있는 관련된 필드를 모아놓은 것 파일(File) 유사 레코드들을 모아놓은 것\n단일 개체로 취급되며 그 이름으로 참조\n접근제어 제약은 대개 파일 수준에 적용 데이터베이스(Database) 관련된 데이터들의 집합\n데이터 요소간의 관계들이 명시 + 서로 다른 응용에 의해 사용될 수 있도록 설계됨 사용자들과 응용에게 파일 사용과 관련된 서비스를 제공하는 일련의 시스템 소프트웨어<img src=\"https://i.imgur.com/U3Eouf4.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">가장 하위 레벨로 주변 장치들이나 장치 제어기, 채널 등과 직접 통신물리 입출력 레벨, 컴퓨터 시스템 외부 환경과의 주된 인터페이스로 디스크나 테입 시스템들과 교환되는 데이터 블록들을 처리 모든 입출력 개시와 종료를 책임짐\n선택된 파일에 근거를 두고 파일 입출력이 수행되는 장치 선택사용자들과 응용이 레코드에 접근할 수 있게 해줌\n기존 파일 시스템이 데이터 블록을 다루고 논리 입출력 모듈은 파일 레코드를 다룸\n사용자와 가장 가까운 파일시스템 레벨 -&gt; 접근법(Access Method)\n접근법(Access Method)\n응용과 파일 시스템, 데이터를 보유하는 장치들 간의 표준 인터페이스 제공 <br><img src=\"https://i.imgur.com/ppfVwhl.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">사용자 또는 프로그램 명령어\n=&gt; 디렉터리(파일 위치나 속성 기술) &amp; 사용자 접근 제어(인증받은 사용자들만 접근) - 파일 구조\n=&gt; 파일 접근 연산들이 레코드 레벨에서 실행 - 레코드\n=&gt; 파일의 레코드들은 출력을 위해 블록화되고 입력 후에 블록이 해제됨\n=&gt; 디스크 스케줄링을 통해 입출력 요청들에 대한 관리","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제파일 관리개요","level":1,"id":"운영체제파일_관리개요_0"},{"heading":"개요","level":1,"id":"개요_0"},{"heading":"파일과 파일 시스템","level":2,"id":"파일과_파일_시스템_0"},{"heading":"파일의 특성","level":3,"id":"파일의_특성_0"},{"heading":"파일 시스템의 전형적 연산","level":3,"id":"파일_시스템의_전형적_연산_0"},{"heading":"파일 구조","level":2,"id":"파일_구조_0"},{"heading":"파일관리 시스템","level":2,"id":"파일관리_시스템_0"},{"heading":"파일관리 시스템 구조","level":3,"id":"파일관리_시스템_구조_0"},{"heading":"장치 드라이버(Device Driver)","level":4,"id":"장치_드라이버(Device_Driver)_0"},{"heading":"기본 파일 시스템(Basic File System)","level":4,"id":"기본_파일_시스템(Basic_File_System)_0"},{"heading":"기본 입출력 관리자(Basic I/O Supervisor)","level":4,"id":"기본_입출력_관리자(Basic_I/O_Supervisor)_0"},{"heading":"논리 입출력(Logical I/O)","level":4,"id":"논리_입출력(Logical_I/O)_0"},{"heading":"파일 관리 기능","level":3,"id":"파일_관리_기능_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":2897,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_개요.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html":{"title":"운영체제_파일 관리_파일 구성과 접근","icon":"","description":"파일 구성을 선택할 때 중요하게 보는 기준\n짧은 접근 시간\n쉬운 갱신\n저장장치의 경제성\n간단한 유지관리\n신뢰성\n기준들이 모순될 수도 있음<img src=\"https://i.imgur.com/JmqKVjz.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/Gr4kS5z.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n단순히 대량의 데이터를 축적해서 저장하는 방식\n각 필드는 필드 값 뿐 아니라 필드 명을 포함하여 자신을 나타내고 있어야 함\n각 필드의 길이는 구분자로 나타내기/명확하게 서브필드로 표시/해당 필드의 기본 유형이 알려져야 함\n더미에는 구조가 없어 레코드 접근이 철저한 탐색에 의해 이루어짐(선형적)\n데이터가 수집, 저장될 때나 데이터를 조직하기 쉽지 않을 때 활용\n저장된 데이터의 크기나 구조가 서로 다를 때 공간 활용도를 높여주고, 전체 데이터를 조사해야 하는 경우에 최적이며 갱신도 쉬움 가장 일반적인 형태의 파일 구조\n고정된 길이 레코드와 필드들의 고정 순서\n키 필드 기반 순차 순서\n일괄처리 응용이나 모든 레코드를 처리해야 하는 경우 적합\n레코드의 추가 작업같은 경우 로그 파일이나 트랜잭션 파일이라는 파일에 위치시킴 순차파일의 단점 보완(느린 탐색)\n=&gt; 인덱스를 통해 원하는 레코드 부근에 빨리 도달\n단일 레벨 인덱스 사용 - 두 개의 필드 주 파일의 키 필드와 동일한 키 필드\n주 파일을 가리키는 포인터 원하는 키 값에 앞서거나 동등한 키 값중에 가장 높은 값을 인덱스에서 검색\n파일에 대한 레코드의 추가 -&gt; 주 파일의 선행 레코드를 갱신하여 오버플로우 파일에 추가된 새 레코드에 대한 포인터를 갖게 함\n단일 레코드 접근에 필요한 시간이 상당히 감소(오버플로우 파일에 대한 포인터 발견까지 순차처리)\n훨씬 더 큰 접근 효율성 -&gt; 다중 인덱스 레벨의 사용 인덱스 순차파일과 순차파일간의 동일한 제약사항 -&gt; 특정 필드 하나에 대해서만 효과적 처리가 가능\n다중 인덱스 -&gt; 검색 대상이 될 수 있는 필드 별로 인덱스 설정\n인덱스의 두 가지 유형 완전 인덱스 주 파일에 있는 모든 레코드에 대해 각각 하나씩의 항목 설정 부분 인덱스 관심 필드가 존재하는 레코드들에 대한 항목이 있음 정보의 적시성이 중요하고 일괄처리가 거의 없는 응용에서 사용\n어떤 블록이든지 직접 접근할 수 있는 디스크 특성 활용\n키 값에 대한 해싱 이용","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제파일 관리파일 구성과 접근","level":1,"id":"운영체제파일_관리파일_구성과_접근_0"},{"heading":"파일 구성과 접근","level":1,"id":"파일_구성과_접근_0"},{"heading":"파일시스템의 5가지 기본 구성","level":2,"id":"파일시스템의_5가지_기본_구성_0"},{"heading":"더미(Pile)","level":3,"id":"더미(Pile)_0"},{"heading":"순차파일","level":3,"id":"순차파일_0"},{"heading":"인덱스 순차파일","level":3,"id":"인덱스_순차파일_0"},{"heading":"인덱스 파일","level":3,"id":"인덱스_파일_0"},{"heading":"직접(혹은 해시)파일","level":3,"id":"직접(혹은_해시)파일_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":2873,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_파일 구성과 접근.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html":{"title":"운영체제_파일 관리_B-트리, 파일 디렉토리","icon":"","description":"주 키에 대한 인덱스를 저장하기 위해 사용하는 효율적인 자료 구조<img src=\"https://i.imgur.com/W2WvDzB.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n블록의 크기 만큼 구성 -&gt; m-원 탐색 트리\n여러 개의 노드와 리프로 구성\n각 노드는 파일 레코드를 구별할 수 있는 키를 적어도 하나 이상 포함하고 자식과 리프를 가리키는 한 개 이상의 포인터를 가짐\n각 노드는 최대 키 개수만큼 제한됨\n노드의 키는 비내림차순으로 저장\n각 키에는 하나의 자식이 연결\n자식 간의 순서 관계 유지\n<br><img src=\"https://i.imgur.com/i8dnHyA.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">파일관리 시스템과 파일 그룹에 연계되며, 파일에 대한 정보(속성, 위치, 소유권 등)를 포함\n이들 정보 대부분은 운영체제에 의해 관리되는데, 디렉토리 자체가 다양한 파일 관리 루틴들을 통해 접근 가능한 파일\n디렉토리 안의 정보는 시스템 루틴을 거쳐 간접적으로 제공<br><img src=\"https://i.imgur.com/yVuzoq9.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n보편적으로 쓰이는 구조 -&gt; 계층구조(트리구조)\n마스터 디렉토리와 다수의 사용자 디렉토리\n사용자 디렉토리가 서브디렉토리들과 파일들을 그 항목으로 포함할 수 있음 + 어떤 레벨의 디렉토리에 대해서도 이와 같이 가능 <br><img src=\"https://i.imgur.com/PlkHhdn.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n트리구조 디렉토리를 사용하여 유일한 명칭 부여에 대한 어려움을 최소화\n루트로부터 여러 단계의 가지를 거쳐 그 파일에 도달할 때까지의 경로를 명시(경로명)\n파일 명칭 선택은 용이하지만 참조할 때마다 전체 경로명을 명시해야 하는 단점 -&gt; 상대경로","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"B-트리","level":1,"id":"B-트리_0"},{"heading":"B-트리의 특징","level":2,"id":"B-트리의_특징_0"},{"heading":"파일 디렉토리","level":1,"id":"파일_디렉토리_0"},{"heading":"내용","level":2,"id":"내용_0"},{"heading":"파일 디렉터리의 정보 요소","level":2,"id":"파일_디렉터리의_정보_요소_0"},{"heading":"구조","level":2,"id":"구조_0"},{"heading":"파일 명명","level":3,"id":"파일_명명_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":4608,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_B-트리, 파일 디렉토리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html":{"title":"운영체제_파일 관리_Linux의 가상파일시스템과 windows 파일 시스템","icon":"","description":"사용자 프로세스에게 단일의 일관된 파일시스템 인터페이스 제공\nVFS를 통해 파일시스템의 일반적인 특성과 행동을 모두 나타낼 수 있는 공통적인 파일 모델 정의\n<img src=\"https://i.imgur.com/ZXaIRJo.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n사용자 프로세스 -&gt; VFS 파일 방식을 이용해서 파일시스템 호출을 수행\nVFS는 이 호출을 내부적인 파일시스템 호출로 전환하고 다시 구체적 파일시스템에 대한 사상기능으로 전달\n<br><img src=\"https://i.imgur.com/6Kz6lJD.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nVFS -&gt; 객체지향 방식 + 각 객체는 데이터와 데이터에 대한 연산들을 가리키는 포인터를 가지고 있음\nVFS의 주요 객체 타입\n수퍼블록 객체(Superblock object) 마운트된 특정 파일시스템 inode 객체(Inode object) 특정 파일 dentry 객체 특정 디렉토리 항목 파일 객체(FIle object) 프로세스와 연계된 열린 파일 특정 파일시스템을 관리하기 위한 정보. 많은 데이터 항목들로 구성\n파일시스템이 마운트되어 있는 장치\n파일시스템의 기본 블록 크기\ndirty 플래그(수퍼블록이 변경되었지만 디스크 재쓰기는 하지 않았다는 것을 나타냄)\n플래그들(읽기 전용 플래그 등)\n파일시스템 디렉토리의 루트를 가리키는 포인터\n열려있는 파일들의 리스트\n파일시스템 접근 제어를 위한 세마포어\n수퍼블록 연산들의 리스트\n각각의 inode는 하나의 파일과 연계\ninode 객체는 파일명과 파일의 실제 데이터를 제외한 모든 파일 관련 정보를 담음\n소유자, 소유 그룹, 접근허가, 파일 접근시간, 데이터 크기, 링크 수 등파일과 디렉토리 접근을 용이하게 함\ninode와 수퍼블록을 가리키는 포인터 포함\n부모 객체와 하위 dentry 객체들에 대한 포인터 포함\n해당 파일과 연계된 dentry 객체\n해당 파일이 포함된 파일시스템\n파일 객체에 대한 사용 카운터\n사용자의 사용자 ID\n사용자의 그룹 ID\n파일 포인터(다음 연산의 기점이 될, 파일 내 현재 위치)\n각 파일 개체는 VFS가 파일 객체에 실행시킬 수 있는 파일시스템구현 함수들을 기술하는 inode 연산 객체 포함\n성능 향상을 위한 캐시의 사용(3종류)\nInode캐시 디렉토리 나열 명렬 또는 파일 디렉토리 캐시 완전한 디렉토리 이름과 해당 inode 번호와의 매핑 저장\n디렉토리 나열 연산 족도를 줄임 버퍼 캐시 동일한 데이터가 자주 필요하다면 이후의 요청은 디스크가 아닌 버퍼 캐시에서 처리 Windows의 파일시스템 NTFS아주 단순한 파일시스템 모델을 기반으로 만들어짐\n복구 능력(Recovery) 시스템 다운과 디스크 장애로부터 복구할 수 있는 능력\n저널링을 통한 복구 보안성 보안성 강화를 위해 Windows 객체 모델 사용\n열린 파일은 자체의 보안 속성을 정의한 보안 디스크럽터를 가진 파일 객체로서 구현 대용량 디스크와 대용량 파일 FAT 뿐만 아니라 대부분의 파일시스템보다 효율적으로 대용량 디스크와 파일 지원 다중 데이터 스트림 파일의 실제 내용은 바이트스트림으로 취급 저널링 볼륨 상의 파일에 행해진 모든 변경의 로그를 유지\n어느 파일이 변경되었는지를 확인하기 위해 저널을 읽으면 됨 압축과 암호화 전체 디렉터리와 개별 파일들은 투명하게 압축 또는 암호화, 혹은 둘 다 될 수 있음 Hard link, Symbolic Link 경성 링크(Hard link) -&gt; 하나의 파일을 같은 볼륨에 존재하는 여러 경로명으로 접근\n심볼릭 링크(Symbolic link) -&gt; 하나의 파일이나 디렉터리를 서로 다른 볼륨에 존재하는 여러 이름으로 접근 섹터(sector) 디스크 상의 가장 작은 물리적 저장 단위\n2의 멱수로 거의 항상 512바이트 클러스터(cluster) 하나 이상의 인접트랙\n섹터 단위의 클러스터 크기는 2의 멱수\npage, block이라고도 함 볼륨(volume) 디스크의 논리적 파티션으로 하나 이상의 클러스터로 구성되어 있고 한 파일시스템에 의해 공간 할당에 사용됨\n하나의 볼륨은 하나의 파일시스템 정보와 파일들의 집합, 파일에 할당될 수 있는 볼륨 상의 가용 공간 등으로 구성\nNTFS의 최대 볼륨 크기 바이트 <br><img src=\"https://i.imgur.com/XeaFTbY.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n파티션 부트 섹터 부트 시작 정보 및 볼륨 레이아웃과 파일시스템 구조에 대한 정보 마스터 파일 테이블(MFT, Master File Table) 1024바이트 길이 행들의 테이블로 구성\nMFT2 MFT의 첫 몇 행에 대한 미러\nMFT를 저장하는 섹터 영역에서 한 섹터만 오류가 발생할 경우에 볼륨에 대한 접근을 보장하기 위해 사용 로그파일 NTFS 복구에 사용되는 트랜잭션 단계 리스트 Cluster Bitmap 어떤 클러스터가 사용중인지 나타내는 볼륨의 한 표현 속성정의표(attribute definition table) 볼륨 상에서 지원되는 속성 타입 정의\n인덱싱, 시스템 복구 연산을 통한 복구 가능 여부 등 시스템 다운이나 디스크 장애 등 -&gt; NTFS는 파일시스템을 일관성 있는 상태로 복구\n복구성을 지원하는 주요 요소\n입출력 관리자\n로그파일서비스\n캐시관리자\n가상메모리관리자<br>\n<img src=\"https://i.imgur.com/yWwFnbm.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Linux의 가상파일시스템(VFS, Virtual File System)","level":1,"id":"Linux의_가상파일시스템(VFS,_Virtual_File_System)_0"},{"heading":"수퍼블록 객체","level":2,"id":"수퍼블록_객체_0"},{"heading":"inode 객체","level":3,"id":"inode_객체_0"},{"heading":"dentry(Directory entry) 객체","level":3,"id":"dentry(Directory_entry)_객체_0"},{"heading":"파일 객체 항목","level":3,"id":"파일_객체_항목_0"},{"heading":"캐시","level":3,"id":"캐시_0"},{"heading":"Windows 파일 시스템","level":1,"id":"Windows_파일_시스템_0"},{"heading":"NTFS의 주요 특성","level":2,"id":"NTFS의_주요_특성_0"},{"heading":"NTFS 볼륨과 파일구조","level":2,"id":"NTFS_볼륨과_파일구조_0"},{"heading":"디스크 저장 개념","level":3,"id":"디스크_저장_개념_0"},{"heading":"NTFS 볼륨 레이아웃","level":3,"id":"NTFS_볼륨_레이아웃_0"},{"heading":"복구성(recoverability)","level":2,"id":"복구성(recoverability)_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058370,"modifiedTime":1725254058371,"sourceSize":5997,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_Linux의 가상파일시스템과 windows 파일 시스템.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html":{"title":"운영체제_파일 관리_UNIX의 파일 관리","icon":"","description":"6가지의 파일 타입\n일반파일 사용자, 응용 프로그램, 시스템 유틸리티 프로그램이 만들어 입력한 정보 등이 들어있음\n파일 시스템은 바이트 스트림으로 취급 디렉토리 파일명과 inode(index node) 번호들의 리스트 특수파일 데이터는 없지만 물리적 장치들을 파일명에 사상시키는 기법 제공\n단말기나 프린터와 같은 주변장치 등 명명파이프 프로세스 간 통신장치 링크 본질상 존재하는 파일을 공유한 또 다른 파일명 심볼릭 링크 자신과 연결된 파일명을 저장하고 있는 데이터 파일 각각의 파일에 대한 주요 정보가 저장된 제어 구조로, 모든 유형의 UNIX 파일은 inode를 통해 운영체제가 관리\n각 파일 당 단 하나의 inode, 파일 속성들은 모두 inode에 저장FreeBSD inode 구조(최소크기 4KB, 디폴트 16KB)\n파일의 유형 및 접근 모드\n파일의 소유주 및 그룹 접근 식별자\n파일 생성시간\n파일 크기\n블록 포인터의 나열\n물리 블록의 개수\n파일을 가르키는 디렉토리 항목의 개수 등\n\u0003블록 단위 파일할당 + 동적할당\n인덱스 중 일부가 해당 파일의 inode에 저장됨\n모든 UNIX 구현에서 inode는 몇개의 직접 포인터와 3개의 간접지정 포인터 포함(단일,이중,삼중)UNIX 파일의 용량<img src=\"https://i.imgur.com/rob3Csy.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">해당 inode 파일 구조의 장점\ninode는 작은 고정크기라 장시간동안 주기억장치에 있어도 됨\n작은 파일들은 간접 접근이 거의 없어서 처리 시간과 디스크 접근 시간을 줄여줌\n파일의 이론적 최대 크기는 실제로 모든 응용프로그램을 충족시킬만큼 큼\n<br><img src=\"https://i.imgur.com/RZ7kduY.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">계층적인 트리 형태로 구조화\n각 디렉토리(dentry)는 파일이나 다른 디렉토리 포함 가능(서브디렉토리)\n디렉토리 = 파일명 + inode 번호(i-number)의 리스트\n파일이나 디렉토리가 접근되면 그 인덱스 번호가 inode 테이블의 인덱스로 사용되는 방식UNIX 파일 시스템은 단일 논리 디스크 혹은 디스크 파티션에 위치하며 다음 요소로 구성\n부트블록(Boot block) 운영체제 부팅에 필요한 코드 수퍼블록(Superblock) 파티션 크기, inode 테이블 그기 등 파일시스템에 대한 속성 및 정보 inode 테이블(inode table) 파일별 inode들의 집합 데이터 블록(Data blocks) 데이터 파일과 서브디렉토리에 할당 가능한 저장공간 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"UNIX의 파일 관리","level":1,"id":"UNIX의_파일_관리_0"},{"heading":"Inode","level":2,"id":"Inode_0"},{"heading":"파일 할당","level":2,"id":"파일_할당_0"},{"heading":"디렉토리와 볼륨구조","level":2,"id":"디렉토리와_볼륨구조_0"},{"heading":"디렉토리","level":3,"id":"디렉토리_0"},{"heading":"볼륨구조","level":3,"id":"볼륨구조_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":3137,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_UNIX의 파일 관리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html":{"title":"운영체제_파일관리_보조 저장공간 관리","icon":"","description":"파일에 블록 할당 책임 -&gt; 운영체제 / 파일관리 시스템\n두 가지 관리 이슈\n보조 저장공간을 파일에 할당\n가용공간을 지속적으로 인지하고 있어야 함\n파일 할당에서 고려해야 할 사항사전 할당의 경우 -&gt; 공간 부족할까봐 크게 설정하면 공간 낭비가 초래됨\n동적 할당의 경우 -&gt; 연속영역들을 파일 저장에 필요한 만큼만 할당하게 되어 이점이지만 어려움연속영역의 크기를 정할 때 단일 파일 관점의 효율성과 전체 시스템의 효율성을 절충할 필요\n-&gt; 절충하기 위한 대안들\n가변 크기는 낭비를 없애고 파일할당 테이블은 작음\n가변크기 연속영역들을 사용할 경우 가용공간의 단편화 고려한 전략 필요 최초적합(First fit) 가용블록 리스트에서 최초로 발견되는 충분한 크기의 연속된 블록 집단을 선택 최적적합(Best fit) 충분한 크기의 가장 작은 연속된 블록 집단 선택 근접적합(Nearest fit) 파일의 지역성을 증가시키기 위해 그 이전 할당에 가장 가까운 충분한 크기의 연속된 블록 집단 선택 블록들 고정크기의 작은 연속영역들은 보다 큰 유연성 제공 <img src=\"https://i.imgur.com/QycySrP.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">연속할당(contiguous allocation)<br>\n<img src=\"https://i.imgur.com/nMqUMX8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n파일 생성 시 단일의 연속된 블록 집단 할당\n개별 순차파일 입장에서 가장 좋은 방법\n충분한 길이의 연속된 블록 집단을 찾기 어려운 외부단편화 문제\ncompaction 필요\n연결 할당(chained allocation)<br>\n<img src=\"https://i.imgur.com/akY3IWe.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n각 블록은 체인 상에서 그 다음 블록을 나타내는 포인터를 가짐\n파일할당 테이블에는 각 파일에 하나의 항목(시작 블록+파일의 길이)를 가짐\n외부단편화 문제 X\n순차처리되는 순차파일에 가장 적합(체인 따라 추적)\n지역성의 원리 수용 X\n=&gt; 통합정리(consolidation)로 문제 해결\n인덱스 할당(indexed allocation)<br>\n<img src=\"https://i.imgur.com/Dj3SOf5.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n각 파일에 대한 별개의 한 단계 인덱스가 있고 이 인덱스는 파일에 할당된 연속영역 각각에 대한 항목을 가짐\n파일 인덱스는 별개의 블록에 저장되고 해당 파일에 대한 파일할당 테이블 항목이 인덱스가 저장된 블록을 가리키게 됨\n블록 단위 할당 -&gt; 외부단편화 제거\n가변크기 연속영역 단위 할당 -&gt; 지역성 증가\n파일 통합정리 작업의 경우 블록 -&gt; 인덱스 크기 변함 없음\n가변길이 -&gt; 인덱스 크기가 줄어듦 어떤 파일에도 할당되지 않은 공간도 관리가 필요함\n=&gt; 가용상태를 알기 위한 디스크할당 테이블의 필요성디스크 블록 하나당 한 비트가 대응된 벡터 이용\n0 -&gt; 가용 블록\n1 -&gt; 사용중인 블록\n16GB 용량 기준 약 4MB 정도의 비트테이블 필요\n메모리에 위치시키는 것이 가장 나음\n가용 연속영역들은 자기 영역 내의 포인터와 길이 값을 사용하여 서로 연결\n체인 시작부에 대한 포인터와 첫 연속 영역의 길이만 필요 -&gt; 공간적 부담이 적음\n하지만 어느정도 지나면 상당 부분이 단편화되어 많은 연속영역들이 단일 블록 길이가 될 수 있음\n+블록할당마다 블록을 읽어 체인연결 조정하는 과정에서 오버헤드가용 공간을 하나의 파일로 간주하며 파일 할당에서 설명한 인덱스 테이블 사용\n인덱스는 블록보다는 가변크기 연속영역을 기초로각 블록에 순차적으로 번호를 부여하고 가용블록의 번호 유지\n하나의 블록번호는 24비트 / 32비트\n-&gt; 가용블록 리스트의 크기는 그에 해당하는 비트테이블 크기의 24/32배가 되므로 디스크에 저장","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제파일관리보조 저장공간 관리","level":1,"id":"운영체제파일관리보조_저장공간_관리_0"},{"heading":"보조 저장공간 관리","level":1,"id":"보조_저장공간_관리_0"},{"heading":"파일 할당","level":2,"id":"파일_할당_0"},{"heading":"사전 할당 vs. 동적 할당","level":3,"id":"사전_할당_vs._동적_할당_0"},{"heading":"연속 영역의 크기","level":3,"id":"연속_영역의_크기_0"},{"heading":"가변의 큰 연속영역들","level":4,"id":"가변의_큰_연속영역들_0"},{"heading":"파일할당 방법","level":4,"id":"파일할당_방법_0"},{"heading":"가용공간 관리","level":2,"id":"가용공간_관리_0"},{"heading":"비트테이블(Bit tables)","level":3,"id":"비트테이블(Bit_tables)_0"},{"heading":"연결된 가용 연속영역(Chained free portions)","level":3,"id":"연결된_가용_연속영역(Chained_free_portions)_0"},{"heading":"인덱싱","level":3,"id":"인덱싱_0"},{"heading":"가용블록 리스트","level":3,"id":"가용블록_리스트_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":4342,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일관리_보조 저장공간 관리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html":{"title":"운영체제_파일관리_파일 공유와 레코드 블로킹","icon":"","description":"다중사용자 시스템에서의 파일 공유 과정에서 나오는 이슈 -&gt; 접근권한과 동시접근 관리특정 파일에 대해 특정 사용자에게 부여될 수 있는 대표적 접근권한\n없음(none)\n인지(knowledge)\n실행(execution) -&gt; 복사 X\n읽기(reading) -&gt; 복사 X\n첨가(appending) -&gt; 파일 내용을 수정 및 삭제 X. 끝 부분에만 추가\n갱신(updating) -&gt; 파일에 대한 초기 쓰기, 완전 혹은 부분 되쓰기, 데이터 전부나 일부 제거 등\n권한변경(changing protection) -&gt; 파일 소유자만 가짐\n삭제(deletion)\n계층 구조를 가지는 권한들 -&gt; 권한에 따르는 부수적 권한\n접근권한이 주어지는 사용자 부류의 구별\n특정 사용자(Specific User) 사용자 ID로 지명 사용자 그룹(User Groups) 사용자 그룹의 구성원 전체 모든 사용자 공용 파일 파일 갱신 시 전체 파일 잠금 가능\n세부적으로 개별 레코드 각각을 잠글 수 있도록 허용\n레코드 -&gt; 구조화된 파일의 논리적 접근 단위\n블록 -&gt; 보조기억장치에 대한 입출력 단위\n입출력의 실행 -&gt; 레코드들이 블록 단위로 구성\n입출력에 대한 고려사항\n블록 -&gt; 고정길이 / 가변길이 고정길이는 입출력과, 한 블록을 평균 레코드와 비교해 볼 때 상대적으로 지니는 크기 클수록 입출력 연산의 횟수가 줄어들어 처리속도가 높아지지만 큰 입출력 버퍼 필요 + 버퍼 관리 필요 <img src=\"https://i.imgur.com/dtb1BzO.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n고정 블로킹 고정길이 레코드\n한 블록에 정수 개의 레코드가 저장\n내부단편화(각 블록 끝부분의 비사용 공간) 가변길이 신장 블로킹 가변길이 레코드들이 비사용 공간 없이 채워짐\n두 블록 사이에 걸치게(span)되는 경우도 있음. 포인터로 연속성 표시\n구현이 어려움 가변길이 비신장 블로킹 가변길이 레코드 사용\n신장(spanning)안됨\n다음 레코드가 남아있는 비사용 공간보다 더 크면 블록의 나머지 부분을 사용할 수 없어 낭비되는 공간이 생김 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제파일관리파일 공유와 레코드 블로킹","level":1,"id":"운영체제파일관리파일_공유와_레코드_블로킹_0"},{"heading":"파일 공유","level":1,"id":"파일_공유_0"},{"heading":"접근권한","level":2,"id":"접근권한_0"},{"heading":"동시접근 관리","level":2,"id":"동시접근_관리_0"},{"heading":"레코드 블로킹","level":1,"id":"레코드_블로킹_0"},{"heading":"특정 블록 크기에 대해 사용가능한 블로킹 방법","level":2,"id":"특정_블록_크기에_대해_사용가능한_블로킹_방법_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":2354,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일관리_파일 공유와 레코드 블로킹.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html":{"title":"운영체제_프로세스 기술과 제어_운영체제의 수행","icon":"","description":"\n운영체제가 프로그램의 집합이라는 점과 처리기에 의존한다는 점 때문에 하나의 프로세스로 인식하고 이러한 문제에 대해 다양한 접근 방법이 제안되었다. <img src=\"https://i.imgur.com/u4wH2hl.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n전통적인 방법으로 모든 프로세스의 외부에서 운영체제 커널을 수행\n운영체제는 자신이 사용할 메모리 영역도 갖고, 프로시저 호출과 복귀를 위한 자신의 시스템 스택도 가지며, 분리된 개체로서 수행되고 특권 모드에서 동작 작은 컴퓨터(PC, 워크스테이션) 상에서 구동되는 운영체제는 보통 사용자 프로세스 문맥에서 모든 운영체제 소프트웨어를 수행<br>\n<img src=\"https://i.imgur.com/3s2uvR7.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 이런 식으로 운영체제는 n개의 프로세스 이미지를 관리 <br>\n이러한 프로세스 이미지의 구조를 자세히 살펴보면\n<img src=\"https://i.imgur.com/5HYm7HB.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\"> 이런 식으로 프로세스가 커널 모드에 있는 동안에 수행한 호출과 복귀를 관리하기 위해 다른 영역과 분리된 커널 스택이 사용됨 공유주소 공간에는 운영체제 코드와 데이터가 들어가 있어 모든 사용자 프로세스에 의해 공유된다. 인터럽트/트랩/수퍼바이저 호출 등이 발생되면 처리기는 커널 모드로 전이하여 운영체제가 제어를 가지게 되고, 사용자 프로그램으로부터 OS로 제어를 넘겨주기 위해 모드 문맥이 저장되고, 운영체제 루틴으로 모드 전환이 이루어짐 하지만 수행은 현재 사용자 프로세스 내에서 프로세스 교환 없이 같은 프로세스 내에서 모드 전환만이 발생\n현재 프로세스 내에 있는 인터럽트된 프로그램의 수행을 재개할 수 있다는 점에서 이점을 가짐 하지만 이전에 수행되던 프로그램으로 제어가 복귀되지 않고 프로세스를 교환하기로 했다면 제어가 프로세스 교환 루틴으로 넘어감 이 과정에서 현재 프로세스는 비수행 상태로, 다른 프로세스는 수행 프로세스로 선택됨 이 때 수행되는 작업은 모든 프로세스의 외부에서 일어남 이러한 운영체제에 대한 관점이 주목받는 이유는 사용자 코드가 아닌 공유 가능한 운영체제 코드에서 프로세스가 자신의 상태 정보를 저장하고 제어를 넘겨주는 과정이 이루어지기 때문이다. 사용자 프로세스 환경에서 운영체제 루틴들이 수행되고 있어도 사용자/커널 모드로 나누어져 있기 때문에 사용자는 운영체제 루틴에 관여할 수 없다는 사실이 곧 프로세스와 프로그램이 일대일 관계가 아니라는 것을 상기시킴 <br><img src=\"https://i.imgur.com/QmMuko8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n운영체제를 시스템 프로세스들의 집합으로 구현한 형태이다.\n커널의 소프트웨어 부분은 커널 모드에서 수행되지만 커널의 주요 기능들은 위에 보이는 것처럼 여러 개의 분리된 프로세스로 구성되며, 여기서도 각 프로세스 밖에서 수행되는 작은 크기의 프로세스 교환 코드가 있을 수 있음\n이점 운영체제의 모듈화 각 모듈간에 최소의 명료한 인터페이스를 가져 프로그램 설계 원칙에 충실할 수 있음 운영체제의 기능 중 그리 중요치 않은 것들은 개별적인 프로세스로 쉽게 구현 가능\n다중 처리기나 멀티 컴퓨터 환경에서 유용 운영체제에 의해 제공되는 서비스를 지정된 처리기에서 수햄함으로써 성능 향상 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제프로세스 기술과 제어운영체제의 수행","level":1,"id":"운영체제프로세스_기술과_제어운영체제의_수행_0"},{"heading":"운영체제의 수행","level":1,"id":"운영체제의_수행_0"},{"heading":"비프로세스 커널(Nonprocess Kernel)","level":2,"id":"비프로세스_커널(Nonprocess_Kernel)_0"},{"heading":"사용자 프로세스 내에서 수행(Execution within User Processes)","level":2,"id":"사용자_프로세스_내에서_수행(Execution_within_User_Processes)_0"},{"heading":"프로세스 기반 운영체제(Process-Based Operating System)","level":2,"id":"프로세스_기반_운영체제(Process-Based_Operating_System)_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":3957,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_프로세스 기술과 제어_운영체제의 수행.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html":{"title":"운영체제_프로세스 기술과 제어_프로세스 기술","icon":"","description":" 운영체제 =&gt; 컴퓨터 시스템에서 발생하는 사건들을 제어하면서 프로세스가 사용하는 시스템 자원들을 관리하는 개체\n<img src=\"https://i.imgur.com/dvyKgM8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 멀티프로그래밍 환경에서 가상메모리에 여러 프로세스들이 존재 P1 최소한 자신의 일부분은 주기억장치에 있으면서도 두 개의 입출력 장치에 대한 제어권을 가지고 수행중 P2 P2 또한 주기억장치에 존재하지만 P1에게 할당된 입출력 장치를 얻기 위해 기다리면서 블록 상태에 있는 상태를 점선으로 표현 Pn 주기억장치로부터 스왑아웃(swap out) 된 상태가 점선으로 표시되어 있으며, 현재는 보류 상태 이렇듯 각각의 프로세스에는 상태가 존재하고, 이러한 상태를 운영체제는 계속해서 모니터링하고 자원들을 관리해야 할 필요성을 가짐 운영체제는 각 개체(프로세스)에 대한 정보를 관리하기 위해 개체에 대한 정보를 테이블로 구성해서 유지\n테이블의 구조<br>\n<img src=\"https://i.imgur.com/qMZVjVq.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n운영체제가 관리해야 할 서로 다른 4가지 타입의 테이블 메모리\n입출력 장치\n파일 프로세스\n에 대한 정보들은 계속 유지 메모리 테이블은 주기억장치(실메모리)와 보조기억장치(가상메모리) 모두의 자취(track) 를 유지하기 위해 사용\n메모리 테이블의 정보 프로세스에게 할당된 주기억장치\n프로세스에게 할당된 보조기억장치\n어떤 프로세스가 특정 공유 메모리 영역에 접근이 가능한 속성 등의 주기억장치/가상메모리 블록들에 대한 보호 속성\n가상 메모리를 관리하기 위해 필요한 정보 입출력 장치와 컴퓨터 시스템의 채널들을 관리하기 위해 사용\n특정 프로세스에 할당되어있는 경우/사용가능한 경우가 있으며 입출력 동작이 진행 중일 때 운영체제는 입출력 동작의 진행 상태와 입출력 전송의 출발지/목적지로 사용되는 주기억장치 내의 위치를 알아야함 파일의 존재 여부와 보조기억장치에 저장된 파일의 위치, 현재 상태, 그 밖에 다른 속성들에 대한 정보가 저장됨\n이러한 정보들은 대부분 파일 관리 시스템에 의해 유지되고 사용된다. 프로세스 관리를 위한 테이블\n각 프로세스들은 Hash로 연결된 연결리스트로 되어 있다.\n메모리, 입출력, 파일 테이블 모두 프로세스를 위해 관리되는 테이블이기 때문에 프로세스 테이블은 이러한 자원들에 대한 참조가 직간접적으로 이루어져야 함\n이러한 테이블들은 그림 상으로는 분리되어 있는 것처럼 보이지만 서로 어떤 식으로든 연결되거나 상호 참조되어야 함\n운영체제가 임의 프로세스를 관리하고 제어하기 위해 알아야 할 사항\n=&gt; 프로세스가 어느 곳에 위치하고 있는지를 알고, 프로세스를 관리하는데 있어 필요한 속성들을 알아야 함 프로세스는 수행될 하나의 프로그램 혹은 여러 프로그램 집합을 가지고 있어야 하며, 그 프로그램과 관련된 전역 및 지역 변수들, 미리 정의된 상수 등에 대한 데이터 위치들의 집합이 있어야 함\n이렇게 구성된 프로세스는 프로그램 수행 시 프로시저 호출들의 트랙(track)과 프로시저들 간에 전달되는 매개변수, 호출 주소(복귀 주소) 등을 유지하는데 사용되는 스택이 필요하다.\n이러한 속성들을 모두 담아 프로세스를 제어하기 위한 하나의 집합으로 만드는데, 이를 프로세스 제어블록이라고 함\n프로그램과 데이터, 스택, 속성들의 집합을 프로세스 이미지라고 함\n프로세스 이미지의 일반적인 요소들\n사용자 데이터 사용자 공간에서 수정 가능한 부분\n프로그램 데이터와 사용자 스택 영역\n수정될 수 있는 프로그램 사용자 프로그램 수행 될 프로그램 시스템 스택 각 프로세스는 하나 이상의 시스템 스택을 가짐\n스택은 프로시저와 시스템 호출에 필요한 매개변수와 호출 주소(복귀 주소)를 저장하는데 사용 프로세스 제어 블록 프로세스 식별 주 프로세스 테이블에 대한 인덱스\n=&gt; 사상(mapping) 기법을 통한 프로세스 테이블 위치 파악\n작업에 대해 책임지고 있는 사용자 지시 프로세스 상태 정보\u001e 레지스터 집합(프로그램 상태 워드, PSW, Program Status Word) 사용자가 사용 가능한 레지스터\n제어 레지스터 및 상태 레지스터\n스택 포인터 프로세스 제어 정보 스케줄링과 상태 정보\n자료구조화(Data Structuring)\n프로세스간 통신(IPC)\n프로세스 권한(Process Privileges)\n메모리 관리\n자원의 소유권과 이용률\n<br>x86 EFLAGS 레지스터 <img src=\"https://i.imgur.com/WkPhXlV.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 프로세스 이미지의 위치는 어떤 메모리 관리 기법이 사용되는가에 따라서 달라짐.\n간단하게는 프로세스 이미지를 메모리(보조기억장치, 디스크 등에서 관리)의 연속된 인접 블록에 위치시키고 운영체제는 프로세스 이미지의 일부를 주기억장치 내에 유지함으로써 프로세스를 관리 프로세스 제어 블록들은 스케줄링, 자원 할당, 인터럽트 처리, 성능 측정과 분석 등에 관련된 모듈들을 포함하여 운영체제의 모든 모듈에 의해 읽혀지고 수정될 수 있음\n따라서 프로세스 제어블록의 집합은 운영체제 상태를 정의한다고 말할 수 있음\n이러한 설계의 문제점 운영체제 내에 있는 수많은 루틴들은 프로세스 제어블록에 있는 정보들을 접근할 필요가 있기 때문에 각 프로세스의 유일한 ID를 Index로 사용하여 정보들에 접근할 수 있음\n하지만 이 과정에서 두 가지 문제점 인터럽트 핸들러와 같은 단일 루틴에서의 버그가 프로세스 제어블록에 손상을 줄 수 있고 결국 해당 프로세스를 관리하는 시스템 기능이 파괴될 수 있음\n프로세스 제어블록의 구조와 의미(semantics)부분의 설계가 변경되면 수많은 운영체제 모듈이 영향받음 이러한 문제를 해결하는 법은 운영체제의 모든 루틴들에게 핸들러(handler)루틴을 통하도록 요구함으로써 프로세스 제어 블록을 보호할 수 있다. 핸들러 루틴\n프로세스 제어블록을 보호하는 것으로 제어블록에 대한 읽고 쓰기 연산을 제어하는 유일한 조정자 역할을 한다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제프로세스 기술과 제어프로세스 기술","level":1,"id":"운영체제프로세스_기술과_제어프로세스_기술_0"},{"heading":"프로세스 기술(description)","level":1,"id":"프로세스_기술(description)_0"},{"heading":"운영체제 제어 구조","level":2,"id":"운영체제_제어_구조_0"},{"heading":"메모리 테이블","level":3,"id":"메모리_테이블_0"},{"heading":"입출력 테이블","level":3,"id":"입출력_테이블_0"},{"heading":"파일 테이블","level":3,"id":"파일_테이블_0"},{"heading":"프로세스 테이블","level":3,"id":"프로세스_테이블_0"},{"heading":"프로세스 제어 구조","level":2,"id":"프로세스_제어_구조_0"},{"heading":"프로세스 제어블록과 이미지","level":3,"id":"프로세스_제어블록과_이미지_0"},{"heading":"프로세스 위치","level":3,"id":"프로세스_위치_0"},{"heading":"프로세스 제어 블록의 역할","level":3,"id":"프로세스_제어_블록의_역할_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":7340,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_프로세스 기술과 제어_프로세스 기술.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html":{"title":"운영체제_프로세스 기술과 제어_프로세스 제어","icon":"","description":"\n대부분의 처리기는 최소한 두 가지 수행 모드를 지원한다. 권한에 따라 특정 명령어의 수행이나 다른 제어 등이 제한됨 권한을 덜 가진 모드 =&gt; 사용자 모드(user mode)\n더 높은 권한을 가진 모드 =&gt; 시스템 모드(system mode), 제어 모드(control mode), 커널 모드(kernel mode) 커널(kernel)은 중요한 시스템 기능들을 포함하는 운영체제의 일부로 다음과 같은 요소들을 가진다. 프로세스 관리 프로세스 생성과 종료\n프로세스 스케줄링과 디스패칭\n프로세스 교환\n프로세스 동기화와 프로세스 간 통신 지원\n프로세스 제어블록 관리 메모리 관리 프로세스에 주소공간 할당\n스와핑(swapping)\n페이지와 세그먼트 관리 입출력 관리 버퍼 관리\n프로세스에 입출력 채널과 장치 할당 지원 기능 인터럽트 핸들링\n어카운팅\n모니터링 두 가지 모드를 사용하는 이유 사용자 프로그램의 간섭으로부터 운영체제 및 프로세스 제어블록과 같은 주요 운영체제 테이블을 보호할 필요가 있기 때문\n사용자 프로그램의 경우 그리 높은 수준의 제어 수준이 필요하지 않고, 안전을 위해서도 이러한 권한 자체를 제한해 놓는 것이 바람직함 프로그램 모드를 변경하려면 프로그램 상태 워드(PSW)의 한 비트를 사용하여 수행 모드를 나타낼 수 있음 해당 비트는 특정 사건에 따라서 변하는데, 사용자가 운영체제 서비스를 호출하거나 인터럽트가 운영체제의 한 경로의 수행을 촉발시킬(trigger) 때 모드는 커널 모드로 설정된다. 대표적인 예로 인텔 ITanium 처리기의 경우 4레벨 모드로 나뉘어 2비트의 cpl(current privilege level)필드를 포함하는 처리기 상태 레지스터(psr, processor status register)를 가진다. 0(최상위)~3(최하위)까지의 레벨이 있다. 인터럽트가 발생하면 처리기는 cpl 필드 포함 psr에 있는 비트 대부분을 리셋하여 cpl을 레벨0으로 설정 인터럽트 핸들링 마지막 명령어는 irt(interrupt return)인데, 처리기를 인터럽트된 프로그램의 psr로 복구시켜 프로그램의 권한 레벨이 복원되는 방식 응용이 미리 정의된 영역에 시스템 호출 식별자와 시스템 호출 인자들을 위치시키고, 다음으로 사용자 레벨의 수행을 인터럽트하여 커널로 제어를 넘겨주는 특별한 명령를 수행함으로써 시스템 호출을 수행 실제로 프로세스를 생성하는데 필요한 단계들은 아래와 같다.\n새로운 프로세스에 유일한 프로세스 식별자 할당\n프로세스에 공간 할당 사용자 주소공간, 사용자 스택, 프로세스 제어 블록을 위한 공간을 결정하고 생성\n이미 존재하는 주소공간이 새로 생성된 프로세스에 의해 공유되면 적절한 연결(linkage)을 설정 프로세스 제어블록 초기화 프로세스의 ID 및 또 다른 ID, 부모 프로세스의 ID와 같은 정보가 포함\n처리기 상태정보 중 프로그램 카운터, 시스템 스택 포인터 제외 대부분 항목이 0으로 초기화 적절한 연결 설정 스케줄링 큐를 연결 리스트로 유지하고 있다면 새로운 프로세스를 준비/보류 리스트에 놓음 추가적 자료구조 생성 프로세스에 대한 과금 or 어카운팅 파일 유지 프로세스 교환의 경우 수행 중인 프로세스가 어느 시점에 인터럽트되면, 운영체제는 다른 프로세스를 수행 상태로 바꾸고 그 프로세스에게 제어를 넘김\n여기서 설계 시 고려해야 할 점\n1. 어떤 경우에 프로세스 교환을 유발시킬 것인가?\n2. 모드 전환(mode switching)과 프로세스 교환의 차이는 무엇인가?\n3. 프로세스 교환을 위해 운영체제의 자료구조들을 어떻게 다를 것인가?\n등이 있다. 운영체제가 현재 수행 중인 프로세스로부터 제어를 넘겨받을 때마다 프로세스 교환이 발생\n이러한 사건들은 아래 표와 같다. 📚📚📚 클럭 인터럽트(clock interrupt) 현재 수행중인 프로세스가 자신에게 허용된 시간 할당량(time slice) 를 모두 사용했는지 여부 판단.\n시간 만료된 프로세스는 준비 상태가 되고 다른 프로세스가 디스패치 입출력 인터럽트 발생된 입출력 동작이 하나 이상의 프로세스가 대기하고 있던 사건과 관련이 있다면, 운영체제는 그 사건에 대해 블록되어 있던 모든 프로세스를 준비 상태로 전이 (블록/보류 -&gt; 준비/보류) 메모리 폴트(Memory fault, 메모리 부재) 주기억장치에 있지 않은 워드에 대한 가상메모리 주소 참조를 처리할 때 해당 참조(주소)를 포함하고 있는 메모리 블록(페이지/세그먼트)을 보조기억장치로부터 주기억장치로 가져와야 함\n메모리 블록 가져오기 IO 요청 후 메모리 폴트를 유발시킨 프로세스는 블록 상태\n원하던 블록이 메모리로 적재되면 이전에 메모리 폴트를 유발시킨 프로세스는 준비 상태가 됨 트랩이 발생하면 관련 오류 또는 예외 조건이 치명적인지 아닌지에 따라서 처리 여부가 나뉨\n치명적일 경우 -&gt; 현재 수행되고 있는 프로세스는 종료 상태로 전이 + 프로세스 교환\n치명적이지 않을 경우 -&gt; 오류의 특성과 운영체제 설계에 따라 복구 프로시저 수행 or 사용자 통보 등 다르게 동작. 프로세스 교환/수행 재개될 수도 있음 운영체제 코드에 속한 어떤 루틴으로 제어를 넘기게 되며, 이 시스템 호출로 인해 해당 사용자 프로세스는 블록 상태로 전이 인터럽트 단계에서 처리기는 인터럽트 시그널 존재여부를 가지고 인터럽트가 발생되었는지 검사\n대기하고 있는 인터럽트가 없다면 처리기는 반입 단계를 계속 수행하여 해당 프로그램의 다음 명령어를 가져온다. 대기하고 있는 인터럽트가 있는 경우 처리기는 프로그램 카운터의 값을 인터럽트 핸들러 프로그램의 시작 주소로 설정\n사용자 모드를 커널 모드로 전환시켜 인터럽트 처리 코드가 특권 명령어(privileged instruction) 을 수행할 수 있도록 함\n의 작업을 수행한다. 이 과정에서 인터럽트된 프로세스 문맥은 인터럽트된 프로그램의 프로세스 제어 블록에 저장 처리기 상태 정보, 프로그램 카운터와 처리기의 다른 레지스터들의 내용, 스택 정보 등이 저장된다. 이렇게 계속 반입 단계를 계속 수행하여 인터럽트를 처리하는 인터럽트 핸들러 프로그램은 인터럽트가 존재하는지를 나타내는 플래그나 지시자(indicator)를 초기화시킨다.\n이후 인터럽트 핸들러가 오류 조건을 검사하고 오류가 발생되었다면 입출력 동작을 요구한 프로세스에게 시그널을 보내거나, 클럭 인터럽트의 경우는 제어를 스케줄러에 넘겨주게 된다.\n그렇다고 인터럽트 발생이 항상 프로세스 교환이 필요한 것은 아님. 인터럽트 핸들러가 수행된 후 현재 수행중인 프로세스의 처리기 상태 정보를 저장한 후 인터럽트 되었던 프로그램으로 제어가 다시 넘어왔을 때 현재 수행 중인 프로세스의 정보를 복구하여 재개될 가능성도 있다. 주로 이러한 저장과 복구 기능은 하드웨어적으로 이루어진다. 모드 전환은 현재 수행 상태에 있는 프로세스의 상태를 바꾸지 않고 수행될 수 있다는 점에서 프로세스 교환과는 다른 개념 모드 전환 과정에서 문맥을 저장하거나 나중에 복구할 때 생기는 오버헤드는 거의 없지만 현재 수행상태인 프로세스가 다른 상태(준비 상태 or 블록 상태 등)로 전이되면, 운영체제의 환경은 크게 변경된다. 완전한 프로세스의 교환 순서\n프로그램 카운터와 다른 레지스터들을 포함한 처리기 문맥 저장\n현재 수행 상태의 프로세스 제어 블록 갱신 후 다음 상태(준비 상태,블록 상태, 준비/보류 상태, 종료 상태) 로 전이\n해당 프로세스의 프로세스 제어블록을 적절한 큐(준비큐, 블록큐, 준비/보류 큐 중 1) 로 옮김\n다음에 수행시킬 다른 프로세스 선택\n선택된 프로세스의 프로세스 제어블록 갱신. 수행 상태로 전이\n메모리 관리와 관련된 자료구조 갱신\n선택된 프로세스가 이전의 수행 상태에서 사용했던 처리기의 문맥 복원(이전에 저장했던 처리기 문맥의 값을 처리기로 적재) 이러한 프로세스의 상태 전이를 거치므로 프로세스 교환은 모드 전환에 비해 상당히 많은 작업을 요구한다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"운영체제프로세스 기술과 제어프로세스 제어","level":1,"id":"운영체제프로세스_기술과_제어프로세스_제어_0"},{"heading":"프로세스 제어","level":1,"id":"프로세스_제어_0"},{"heading":"수행 모드(Modes of Execution)","level":2,"id":"수행_모드(Modes_of_Execution)_0"},{"heading":"프로세스 생성","level":2,"id":"프로세스_생성_0"},{"heading":"프로세스 교환(Process Switching)","level":2,"id":"프로세스_교환(Process_Switching)_0"},{"heading":"프로세스의 교환 시점","level":3,"id":"프로세스의_교환_시점_0"},{"heading":"인터럽트","level":4,"id":"인터럽트_0"},{"heading":"트랩(trap)","level":4,"id":"트랩(trap)_0"},{"heading":"수퍼바이저 호출(Kernel 진입)","level":4,"id":"수퍼바이저_호출(Kernel_진입)_0"},{"heading":"모드 전환","level":3,"id":"모드_전환_0"},{"heading":"프로세스 상태 변경","level":3,"id":"프로세스_상태_변경_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":10048,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_프로세스 기술과 제어_프로세스 제어.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/브라우저의-렌더링과-캔버스.html":{"title":"브라우저의 렌더링과 캔버스","icon":"","description":"나는 개인적으로 html canvas를 활용한 서비스는 프론트엔드의 정수라고 생각한다. 아마 극한으로 프론트엔드에서 극한까지 사용하게 된다면 figma와 같은 궁극의 결과물이 나오지 않을까.. 생각해서 찍먹해보지 않을 수 없었다.\n그래서 새롭게 프로젝트를 시작하는 과정에서 나는 마인드맵을 캔버스로 그려주는 서비스를 만들려고 했는데, 여기서 고민이 하나 있었다.html 캔버스는 그래픽 요소를 그리기 위한 html 내장 콘텐츠로, 원하고자 하는 것을 비트맵 기반으로 그려낼 수 있다.\n하지만 사실 다이어그램같은 요소들을 그려내는 과정에서 캔버스는 굳이 필수사항이 아니라고 생각한다.<img src=\"https://i.imgur.com/Wk5GFIn.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n당장 react-flow만 보아도 각 다이어그램들을 모두 div로 표현하면서, 여기서 CSS를 붙여 사용하는 방식인데, 캔버스로 굳이 할 필요가 없다는 생각도 들었다.\n하지만 canva와 excalidraw와 같은 서비스들은 모두 canvas 기반으로 작동하는 서비스들이었기 때문에, 문득 이 html 요소들과 canvas 중에 무엇이 더 성능에 좋을까? 하는 의문이 들었다.이에 대해서는 보다 브라우저의 렌더링에 대해 이해해야지 이유를 찾을 수 있을 것 같다고 판단하여 브라우저의 렌더링에 대해 간략하게나마 정리해보았다.우리는 브라우저가 어떻게 보여지는지에 대해서 말해보라는 질문을 받으면 아마 간단하게 'HTML를 해석해서 DOM Tree로 파싱하고 CSS도 파싱한 담에 그려냅니다'라고 말할 수 있다. 하지만 이 '그려냅니다'라는 말은 많은 과정이 함축되어 있는 말이다.<br><img src=\"https://i.imgur.com/LeIQ6n2.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">브라우저는 Rendering Engine, Javascript Engine, Graphics Library 3가지 요소로 렌더링이 처리된다. 각 요소들은 가지는 한계가 명확하기 때문에 각자의 역할만을 담당한다.\n렌더링 엔진 HTML 파싱 후 DOM트리 생성 자바스크립트 엔진(V8) 자바스크립트 코드 실행 그래픽 라이브러리 화면에 그리기 렌더링 엔진의 경우 자바스크립트를 읽을 수 없기 때문에 html의 렌더링만 담당한 후, 구글의 V8 자바스크립트 엔진을 통해 자바스크립트를 해석하고 그래픽 라이브러리를 통해 우리가 보는 화면을 그려낸다.\n이 일련의 과정은 모두 메인 쓰레드에서 작동한다.<br>\n<img src=\"https://i.imgur.com/Y1kZrdv.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n하지만 이 DOM 요소를 만들고 자바스크립트를 해석하여 화면을 그리는 과정 자체가 16ms를 넘다 보니까 모니터의 주사율 60Hz의 관점에서도 프레임 드랍이 발생한다.<br>\n<img src=\"https://i.imgur.com/aC7OzHT.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n이 문제는 메인 쓰레드가 이 세 가지 작업을 모두 하려고 하다 보니까 생기는 문제이다.\n그렇다면 이 문제를 해결하기 위한 방법은 무엇이 있을까?\n바로 메인 스레드가 모든 작업을 처리하지 않게 하는 것이다.<br><img src=\"https://i.imgur.com/6sYm0n8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">브라우저에서 사용되는 스레드는 비단 메인스레드만 있지 않다.\n웹페이지를 효율적이고 부드럽게 렌더링하기 위해 별도의 컴포지터 스레드와 래스터 스레드가 렌더러 프로세스에서 실행된다.\n그렇다면 이 컴포지터 스레드와 래스터 스레드가 무엇인지, 또 그것의 역할이 무엇인지에 대해서는 다시 브라우저 렌더링을 파악하면서 알아보도록 하자.앞에서 말했던 것처럼 브라우저는 DOM 트리를 만들고, CSS를 파싱하여 스타일 시트를 생성하고, 스타일을 계산한다.스타일을 계산한다고 모든 요소들이 우리가 예상한 대로 화면에 그려지는 과정에서도 많은 과정들이 수반된다.해당 단계에서는 여러 파싱 단계를 거친다.\nHTML을 파싱하여 DOM Tree 생성\nCSS를 파싱하여 CSSOM 생성\nDOM + CSSOM의 렌더 트리 생성\n이 과정 자체도 많지만 사실 이 정도는 기본으로 알고 있는 브라우저의 렌더링 단계이니 더 깊은 설명은 생략한다\n<br><img src=\"https://i.imgur.com/9Vsu0Qv.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"max-width: 100%;\">이 단계에서는 어디에 그려야 할 지에 대해서 결정한다.<br><img src=\"https://so-so.dev/c6dc3877cfc2c9133a2cfd37ba174120/layout_cost.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">위 예시에서도 글자 크기가 커지면서 박스를 넘어가게 되면 이 부분에 대해서도 줄바꿈 등의 계산을 모두 해당 과정에서 수행해야 한다.<br><img src=\"https://i.imgur.com/1yipANC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그렇기에 브라우저는 스타일이 적용된 DOM을 다시금 훑으면서 레이아웃 트리를 만든다. 이 레이아웃 트리에는 오로지 '보이는' 요소들이 '어디에' 보여야 할 지에 대한 정보를 가지고 있다.레이아웃 트리가 만들어지면 다음에는 Pre-paint와 paint과정을 거친다. pre-paint는 말 그대로 그리기 전에 하는 작업과 그리는 작업이다.Pre-painting는 다음 단계에서 화면에 그려낼 레이어를 구성하기 위한 준비 단계이다. 해당 단계에서는 두가지 단계로 이루어진다.\npaint Invalidation\n브라우저가 화면의 일부를 다시 그려야 한다고 판단할 때 기존의 페인팅 정보를 무효화한다. 이 과정은 페이지의 시각적 상태가 바뀌어 현재의 그리기 정보가 더 이상 유효하지 않다고 판단될 때 실행된다.<br>\n<img src=\"https://i.imgur.com/3BkJTo9.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nProperty Tree<br>\n<img src=\"https://i.imgur.com/2h5NdF4.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n무효화가 끝나면 transform, opacity 등의 속성을 트리화시켜 각 노드에서 이 Property Tree의 노드를 참조하여 레이어를 합치는 단계에서 필요한 효과를 빠르게 적용할 수 있다.\n이 DOM, 스타일, 레이아웃을 기반으로 브라우저에게 '어떻게 그려야 할 지' 에 대해 정의하는 paint records를 생성한다. 위에서 말한 것과 같이 z-index를 두는 경우 요소들을 브라우저 내에서 그리게 된다면 그리는 순서에도 차이가 발생하기 때문이다. 페인트 레코드에는 세 가지 정보가 포함된다.\nAction (e.g. Draw Rect)\nPosition (e.g. 0, 0, 300, 300)\nStyle (e.g. backgroundColor: red)\n<br><img src=\"https://i.imgur.com/IZ6wQSy.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">하지만 이 받은 정보들을 기반으로 실제로 그리는 작업은 여기서 수행되지 않는다는 점을 기억해야 한다.<br><img src=\"https://i.imgur.com/GOoIoqa.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Paint Records를 만들었으면 그 paint records를 가지고 일정한 기준에 따라 layer로 분리한 다음에 Paint Layer를 생성한다.\n이렇게 페인트 레이어를 분리하는 과정을 Layerize 과정이라고 한다. 이 과정에서 나오는 결과물은 여러개의 paint layer이다. 이 paint layer는 보통\n최상위 요소(root element)\nposition: relative, absolute&nbsp;사용\n3D(translate3d,&nbsp;preserve-3d, ,..)나 perspective transform 사용\n&lt;video&gt;,&nbsp;&lt;canvas&gt;&nbsp;태그 사용\nCSS&nbsp;filter나 alpha mask 사용\n정도로 구분된다.\nPaint Layer중 Compositing Trigger 를 가지고 있거나 스크롤 가능한 컨텐츠가 있을 경우 별도의 Graphics Layer가 생성된다.Compositing Trigger\n3D 변형:&nbsp;translate3d,&nbsp;translateZ&nbsp;…\n&lt;video&gt;,&nbsp;&lt;canvas&gt;,&nbsp;&lt;iframe&gt;&nbsp;요소\nposition: fixed\nCSS 트랜지션과 애니메이션을 사용해 구현한&nbsp;transform과opacity&nbsp;애니메이션\nposition: fixed\nwill-change\nfilter\n분리된 graphnics Layer들은 독립적인 픽셀화가 가능하여 프레임마다 후에 설명할 단계인 래스터하는 과정을 다시 실행하지 않고 GPU 연산이 가능하기 때문에 빠른 스크롤링이나 애니메이션이 가능하다.<br><img src=\"https://i.imgur.com/d3pIRBM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">아무튼 이 Composited Layer List 과정에서 각 레이어를 그리는 스레드는 래스터 스레드, 이를 통해 만들어진 결과물을 웹페이지에 합성하는 작업은 컴포지트 스레드가 담당하면서 메인스레드와는 별개로 작동한다.Layerize단계의 출력인 Composited Layer List는 PrePaint단계에서 생성한 Property Tree와 함께 합성 스레드(Composite Thread)로 복사되는 과정을 ‘Commit’이라 한다.<br><img src=\"https://i.imgur.com/SFctXRI.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">메인 스레드의 작업은 여기에서 끝난다는 사실도 중요하게 기억해야 할 점이다. 커밋 이후에는 자바스크립트를 실행하거나 렌더링 파이프라인을 다시 실행할 수 있다.이 과정에서는\n요소들을 작은 단위로 나누어 \"그려내는\" 래스터화 작업 (Tilling)\n이를 통해 만들어진 요소들을 한 곳에 \"합치는\" 작업인 컴포지트 작업(Composite)\n으로 나누어진다.\nTilling단계에서는 받았던 Paint Layer를 기반으로 각 레이어들을 따로 그려야 할 필요성이 있다. 레이어를 따로 그린 다음에 이를 합쳐 하나의 결과물이 나오도록 하기 때문이다.하지만 이 레이어는 크기가 클 수도 있기 때문에 이를 다수의 타일(Tile) 형태로 나눠 래스터 스레드로 보내면서 래스터화해 GPU 메모리에 저장한다. <br><img src=\"https://i.imgur.com/0Mbs6pd.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nTilling은 이렇게 타일 형태로 분할하는 작업을 의미한다. 각 타일에는 PaintRecord가 포함되고, 뷰 포트 포함 여부나 인접성 등에 따라 다른 우선순위를 가지면서 래스터화된다.이 Raster 단계가 실질적으로 그리는 단계이다.<br>\n<img src=\"https://i.imgur.com/2ZUerC4.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">각 타일을 래스터화 시키는 작업은 skia라는 그래픽 라이브러리를 사용하여 비트맵 이미지를 생성하고 이를 GPU 메모리에 저장한다.<br><img src=\"https://i.imgur.com/77UTyqh.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이 과정 자체를 cpu가 아닌 gpu에게 담당하도록 하면서 보다 자연스러운 애니메이션 등을 연출할 수 있는 환경이 주어진다.이렇게 타일들이 래스터화되면 drawquad라는 데이터가 생성되고, 쿼드에는 메모리에서 타일의 위치와 웹 페이지 합성을 고려해 타일을 웹 페이지의 어디에 그려야 하는지에 관한 정보를 가지고 있으며, 앞서 생성한 레이어와 Property Tree 정보를 바탕으로 생성된다.<br><img src=\"https://i.imgur.com/cX8ejby.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이 쿼드들이 모인 것을 컴포지터(합성) 프레임이라고 하는데, 이는 웹 페이지의 프레임을 나타낸다. <br><img src=\"https://i.imgur.com/D8qVSjE.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">컴포지트 스레드의 경우에는 pending tree와 active tree를 가지고 서로 swap하는 멀티버퍼링 패턴을 가지고 있다. 비동기로 진행되는 래스터 작업 중에 이전 커밋에 대한 내용을 보여주어야 하기 때문에 가지는 패턴이다.pending tree는 커밋을 받고 렌더링에 필요한 작업이 완료되면 pending tree를 active tree로 복제한다. 이렇게 분리 된 트리구조로 인해 active tree에서 GPU작업을 하는 동안 pending tree에서 커밋된 변경사항을 대기시킬 수 있다.마지막으로 activate된 쿼드들은 Compositor Frame, 즉 위에서 말한 합성 프레임이라는 데이터로 묶여 GPU프로세스로 전달된다.\n컴포지트 스레드의 최종 목표는 commit받은 레이어를 쪼개서(tiling) 래스터화하고 Frame으로 만들어 GPU에 전달하는 것이다.만약 스크롤 이벤트가 발생하면 컴포지터 스레드는 GPU에게 보내질 다른 컴포지터 프레임을 생성한다.<br><img src=\"https://i.imgur.com/Q1Ow2Ed.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n마지맞 Display에서는 GPU 프로세스의 viz 스레드에서 여러 개의 합성 프레임을 단일 합서으 프레임으로 합치는 작업을 하며, 화면에 픽셀을 렌더링하면서 한 프레임을 그리는 과정까지가 렌더링의 파이프라인이다.앞의 렌더링 과정에서 보면 어느정도 왜 캔버스를 사용하는 것이 성능적으로 이점을 가지는 지에 대해서는 감이 조금은 올 수도 있다.기존 DOM 요소를 통해 다이어그램을 조작한다고 생각해보자.\n다이어그램을 조작하는 과정에서 사용자는 계속해서 클라이언트와 상호작용할 일이 많다. 이를 다른 말로 생각하면 그만큼 요소가 변할 일이 많고, 기존 DOM 요소가 변경되거나 수정이 되면 HTML 파싱, Layout, Pre-paint 등의 과정이 반복해서 이루어지면서 오버헤드가 생길 수 있다는 이야기기도 하다.<br><img src=\"https://i.imgur.com/yBCtbGX.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">하지만 캔버스의 경우에는 다르다. 캔버스의 경우에는 자바스크립트로 canvas api를 통해서 각 요소들을 어떻게 그려야 하는 지에 대해 Paint Record의 형태로 이미 정의되어 있다. 그렇기 때문에 캔버스에서 그려지는 요소들이 메인 스레드에서 하는 작업이라고는 자바스크립트를 통해 paint record들을 정의하는 작업정도밖에 되지 않는다. 따라서 위 사진처럼 메인쓰레드에서는 Recording만을 수행하여 그림을 그리는 방법을 정의하기만 하고, 컴포지터 스레드와 래스터 스레드를 통해 타일링과 래스터링하는 과정이 진행되면서, 보다 CPU의 부담은 낮아짐으로써 프레임 드랍이 일어날 확률 또한 줄어들게 된다.<br><img src=\"https://i.imgur.com/uJCIKSa.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">추가적으로 현재는 Offscreen Canvas API가 새롭게 생기며, canvas를 조작하는 자바스크립트만을 또 떼어내 이를 Web worker에서 처리함으로써 기존에 메인 스레드에서 동작하던 코드를 워커 스레드에서 실행 및 비트맵 그리기를 수행하면서 보다 성능이 향상될 수 있다.<br><img src=\"https://i.imgur.com/XZ5IBsq.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이 OffscreenCanvas는 기존의 DOM에서 완전히 분리되고 동기화 기능이 없기 때문에 일반 캔버스에 비해 속도가 향상되는 효과를 가질 수 있다.이를 통해 쓰레드의 경우에는 계속해서 리렌더링할 DOM이 줄어들면서 자원을 더 사용할 수 있는 여유가 생기기 때문에 이 부분에서도 이점을 가질 수 있다.캔버스에 그릴만한 요소가 많아지면 많아질수록 DOM 객체로 만들게 되면 그만큼 걸리는 과정에서 오버헤드가 크므로 캔버스의 경우가 DOM 객체를 그리는 과정보다는 보다 성능이 좋을 수 있다.<br><a data-tooltip-position=\"top\" aria-label=\"https://idchoi2.medium.com/javascript-%EB%8F%84%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0-html-vs-svg-vs-canvas-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-9e1ce2396fcd\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://idchoi2.medium.com/javascript-%EB%8F%84%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B8%B0-html-vs-svg-vs-canvas-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-9e1ce2396fcd\" target=\"_self\">도형 그리기 html vs svg vs canvas 성능 비교</a>\n이는 레퍼런스에서 또한 확연하게 좋아지는 성능을 통해서도 증명할 수 있는 사실이다.하지만 캔버스의 경우 또한 반복해서 렌더링하는 방식이다보니, 이 과정에서 애니메이션의 처리와 같은 부분에서 성능이 저하될 수 있는 가능성 또한 배제할 수 없다. 따라서 이러한 부분의 경우에는 캔버스의 최적화를 최대한 고려하면서 개발하는 편이 가장 이상적이라고 생각한다.처음에 개발을 시작하면서 브라우저가 어떻게 띄워지는지에 대해서는 DOM tree와 CSSOM 정도로만 알고 있었는데, 이번 기회에 렌더 트리를 만들고 '그려내는' 작업에 대해서 딥다이브를 해보니 브라우저가 정말 많은 기술의 집합체였구나를 깨달았다. 하긴 그렇게 쉬우면 다 만들었지..\n아무튼 이번 기회를 통해 브라우저의 렌더링 과정을 이해하면서 캔버스를 활용할 때 좋은 배경 지식이 생긴 것 같아 나름 만족스럽다.\n지금 쓴 것도 나름 축약해서 정리한 것이긴 한데, 나중에 시간이 된다면 보다 더 면밀하게 살펴볼 예정이다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://d2.naver.com/helloworld/5237120\" target=\"_self\">https://d2.naver.com/helloworld/5237120</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.chrome.com/blog/inside-browser-part3\" target=\"_self\">https://developer.chrome.com/blog/inside-browser-part3</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://so-so.dev/web/browser-rendering-process/\" target=\"_self\">https://so-so.dev/web/browser-rendering-process/</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.chrome.com/docs/chromium/blinkng#composite-after-paint-pipelining-paint-and-compositing\" target=\"_self\">https://developer.chrome.com/docs/chromium/blinkng#composite-after-paint-pipelining-paint-and-compositing</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://onlydev.tistory.com/82\" target=\"_self\">https://onlydev.tistory.com/82</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"들어가며","level":2,"id":"들어가며_0"},{"heading":"캔버스만이 선택지일까?","level":3,"id":"캔버스만이_선택지일까?_0"},{"heading":"브라우저의 엔진","level":2,"id":"브라우저의_엔진_0"},{"heading":"브라우저의 렌더링","level":2,"id":"브라우저의_렌더링_0"},{"heading":"파싱","level":3,"id":"파싱_0"},{"heading":"Layout","level":3,"id":"Layout_0"},{"heading":"Pre-Paint","level":3,"id":"Pre-Paint_0"},{"heading":"Paint","level":3,"id":"Paint_0"},{"heading":"Layerize","level":3,"id":"Layerize_0"},{"heading":"Commit","level":3,"id":"Commit_0"},{"heading":"Tilling","level":4,"id":"Tilling_0"},{"heading":"Raster","level":4,"id":"Raster_0"},{"heading":"Activate","level":3,"id":"Activate_0"},{"heading":"Display","level":3,"id":"Display_0"},{"heading":"그래서 왜 캔버스가 나은데?","level":2,"id":"그래서_왜_캔버스가_나은데?_0"},{"heading":"결론","level":2,"id":"결론_0"},{"heading":"참조","level":2,"id":"참조_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/브라우저의-렌더링과-캔버스.html","pathToRoot":"../..","attachments":[],"createdTime":1730392795313,"modifiedTime":1730645140716,"sourceSize":16589,"sourcePath":"학습 정리/Computer Science/브라우저의 렌더링과 캔버스.md","exportPath":"학습-정리/computer-science/브라우저의-렌더링과-캔버스.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/웹페이지,-웹사이트,-웹서버,-검색엔진의-차이.html":{"title":"웹페이지, 웹사이트, 웹서버, 검색엔진의 차이","icon":"","description":"얼핏보면 비슷해 보이지만 이러한 용어들을 명확히 구분하여 이해할 필요가 있다.Firefox, 구글 크롬, 오페라, MS 익스플로러나 엣지, 애플의 Safari 같은 웹 브라우저에서 보여지는 단순 문서이다. HTML로 쓰여진다.\n이렇게 쓰여진 하나의 문서를 페이지라고 한다.다양한 방식으로 그룹으로 묶이거나 연결된 웹 페이지들의 모음이다. 페이지들이 모여 만들어진 것이 웹사이트이다.\n각각의 웹사이트에서 다른 링크가 주어진 다른 웹 페이지로 이동할 수 있다.인터넷에 웹사이트를 호스팅하게 해주는 컴퓨터이다.제공자 등의 사업자가 주로 개인 홈페이지의 서버 기능을 대행하는 것을 의미한다. 즉 서버의 일부 혹은 전체를 이용할 수 있도록 임대해주는 서비스을 일컫는다.\n호스팅에는 웹 호스팅, 서버 호스팅, 클라우드 서버 호스팅이 있으며 이들은 웹, 서버 관리, 비용 부담을 줄일 수 있는 장점을 가지고 있다.\n웹 호스팅 : 하나의 서버 장비를 여러 명이 공유하여 사용한다. 가격이 저렴하고 대중적으로 가장 많이 사용된다.\n트래픽이 많지 않은 기업 사이트나 개인 사이트에 사용된다. 서버 호스팅: 한 명의 고객이 하나의 서버장비를 임대하는 호스팅. 가격이 비싼 대신 대용량 트래픽을 처리할 수 있다.\n서버의 단독사용으로 설치나 삭제 등 개발이 자유롭다 클라우드 호스팅: 물리적 서버가 아닌 가상의 서버를 임대한다. 자유롭게 서버 스펙을 조절할 수 있고 이용한 만큼만 비용을 지불하면 된다. 쇼핑몰 호스팅: 인터넷 쇼핑몰 사이트 제작 및 운영할 수 있도록 서버 공간과 쇼핑몰 프로그램 및 결제 시스템 등 쇼핑몰에 필요한 일련의 요소들을 제공한다.\n메일 호스팅: 사용자가 도메인을 직접 구매하고 해당 도메인과 연결하여 이메일을 만들어 제공한다.\n웹 서버는 하드웨어와 소프트웨어 또는 두 개가 같이 동작하는 것을 의미할 수 있다.\n하드웨어의 측면에서\n웹 서버의 소프트웨어와 웹사이트의 컴포넌트 파일들(HTML,CSS,JS 등)을 저장하는 컴퓨터\n웹에 연결된 기기들이 이런 데이터를 주고받을 수 있도록 만든다 소프트웨어의 측면에서\nHTTP 서버를 의미한다.\n웹 사용자가 호스트파일에 접근하는 방식을 관리한다.\nHTTP서버는 URL(웹 주소)과 HTTP(프로토콜)의 소프트웨어 일부이다.\n브라우저가 웹 서버에서 불러와진 파일이 필요하면 HTTP를 통해 파일을 요청한다.\n요청이 올바르다면 HTTP 서버는 요청된 문서를 HTTP를 이요해 보내준다.<img src=\"https://i.imgur.com/RFtNJ0A.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">웹 사이트를 공개적으로 보이게 하기 위해서는 정적 혹은 동적 웹 서버가 필요하다.\n정적이란?\n있는 그대로 제공되는 것 정적 웹 서버\nHTTP 서버가 있는 컴퓨터로 구성되어 있다. 서버가 불려진 파일을 전송할 때 정적인 웹 서버라고 말한다. 동적이란?\n서버가 컨텐츠를 처리(생성 포함)하는 것. 동적 웹 서버\n정적 웹 서버 + 추가적인 소프트웨어(데이터베이스 등)로 구성되어 있다.\n애플리케이션 서버가 HTTP 서버를 통해 브라우저에게 불려진 파일들을 전송하기 전에 애플리케이션 서버가 업데이트하기 때문에 이를 동적이라고 말한다.\n이렇게 웹 서버가 있고 호스팅 파일들이 있다면 HTTP(HyperText Transfer Protocol)를 이용해 통신할 수 있다.\n호스팅 파일\nHTML로 이루어진 웹 사이트 파일들, 이미지, CSS Stylesheet, JS, 파일 등을 포함한다.\nHTTP는 두 컴퓨터간의 hypertext를 어떻게 전송하는지 서술한다.\nHTTP의 특성\nTextual: 모든 명령들은 사람들이 읽을 수 있는 명렁어이다.(HTTP/2 이후 X)\nStateless: 서버 혹은 클라이언트는 이전의 통신을 기억하지 않는다. 이를 기억하기 위해서는 애플리케이션 서버가 필요하다.\n클라이언트는 HTTP 요청(URL 파일 제공)을 하고 서버는 클라이언트의 HTTP 요청에 응답한다.\n여기서 클라이언트는 무조건 URL 파일을 제공해야 하고,\n웹 서버는 모든 HTTP 요청에 에러를 포함해서 응답해야 한다.이렇게 웹 서버에서 HTTP 요청이 들어오면 HTTP 서버는\n요청받은 URL이 존재하는 파일과 매칭이 되는지 확인 -&gt; 매칭되는 파일 내용을 되돌려 주고, 그렇지 않다면 애플리케이션 서버는 필요한 파일 구축 -&gt; 전 과정이 실패하면 에러 반환\n의 과정을 거친다.구글, 빙, 야후 같은 다른 웹 페이지들을 찾게 도와주는 웹사이트이다.\n크롤러를 통해 웹의 정보를 긁어와서 검색에 뜨도록 만들어준다.\n사실상 검색 엔진 자체는 프로그램이지만 웹사이트를 지칭하는 단어로 거의 혼용해서 쓴다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kathylee/07-What-is-hosting%ED%98%B8%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" target=\"_self\">https://velog.io/@kathylee/07-What-is-hosting%ED%98%B8%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://m.blog.naver.com/lhhoo1717/221365274221\" target=\"_self\">https://m.blog.naver.com/lhhoo1717/221365274221</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://m.blog.naver.com/gowori/221491556923\" target=\"_self\">https://m.blog.naver.com/gowori/221491556923</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/What_is_a_web_server\" target=\"_self\">https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/What_is_a_web_server</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Webpage","level":2,"id":"Webpage_0"},{"heading":"Website","level":2,"id":"Website_0"},{"heading":"Web Server","level":2,"id":"Web_Server_0"},{"heading":"호스팅이란?","level":3,"id":"호스팅이란?_0"},{"heading":"호스팅의 종류","level":4,"id":"호스팅의_종류_0"},{"heading":"웹 서버에 대해서","level":3,"id":"웹_서버에_대해서_0"},{"heading":"웹 서버의 동작 방식","level":4,"id":"웹_서버의_동작_방식_0"},{"heading":"검색 엔진","level":2,"id":"검색_엔진_0"},{"heading":"참고문헌","level":2,"id":"참고문헌_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/웹페이지,-웹사이트,-웹서버,-검색엔진의-차이.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":5712,"sourcePath":"학습 정리/Computer Science/웹페이지, 웹사이트, 웹서버, 검색엔진의 차이.md","exportPath":"학습-정리/computer-science/웹페이지,-웹사이트,-웹서버,-검색엔진의-차이.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/이벤트-루프와-비동기.html":{"title":"이벤트 루프와 비동기","icon":"","description":"이벤트 루프는 특정 이벤트나 메시지가 발생할 때까지 대기하다가 이벤트가 발생하면 디스패치하는 디자인 패턴이다.\n각 운영체제에서도 각각의 이벤트 루프가 다양한 방식으로 활용되고 있으며, 자바스크립트의 경우는 싱글스레드 언어이기 때문에 node.js를 통해 하나의 호출스택만 사용하는 구조에서 동시성을 구현하기 위해 사용하는 디자인 패턴이다.\n동시성: 서로 다른 사건이 동시에 일어나는 것\n고전적으로는 이 동시성을 위해 멀티스레드를 열고 작업이 완료될 때까지 스레드의 실행을 차단하는 방법을 사용했다. 하지만 여기에선 쓰레드를 열었음에도 idle time, 즉 유효한 시간이 각각의 쓰레드에게 발생하기 때문에 이는 곧 자원의 낭비로 이어진다.이어 나온 방식은 논블로킹의 이벤트 디멀티플렉싱메커니즘이다.\n<img src=\"https://i.imgur.com/o1TK327.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n멀티플렉서가 요청들을 하나로 묶고 디멀티플렉서가 요청을 싱글 스레드에 나눔으로써 모든 요청들을 관리하고 요청이 완료되기 전까지 블로킹, 완료가 된 후에는 이벤트큐에 푸시하는 방법 또한 사용했다.\n이러한 메커니즘에 특화된 디자인 패턴으로는 리액터 패턴이 있다.<br>\n<img src=\"https://i.imgur.com/uQBTe8v.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">리액터 패턴은 이벤트 디멀티플렉서에서 I/O 요청이 완료되었을 때, 이벤트와 이벤트에 해당하는 핸들러를 이벤트 큐에 넣고 이벤트 루프를 통해 이러한 핸들러를 실행시키는 방식으로 작동한다.\n여기서 이벤트 루프가 존재를 드러내기 시작한다. 이러한 이벤트 루프의 기본적인 작동 방식이 현재 우리가 알고 있는 Node.js 등의 이벤트 루프의 기반으로 작동한다. 그럼 이러한 작동 방식에서 기본적인 구조인 Event Queue, Loop, Handler에 대해서 알아보자.이벤트 큐는 메시지와 이벤트를 보내는 시점과 처리하는 시점을 다르게 하기 위한 비동기형 디자인패턴으로 관찰자 패턴의 형태이다.\n이벤트가 계속해서 들어오면 이러한 이벤트를 처리하기 위해 프로그램은 이벤트 루프를 통해 이벤트 핸들러를 담은 이벤트를 실행한다.while(running){ Event event = getNextEvent();\n}\n수도코드를 보면 아직 처리하지 않은 사용자 입력을 가져오고 실행을 반복하느느 구조를 지닌다.\n이러한 요청 안에는 클로저, 즉 해당 이벤트가 끝난 뒤 실행하는 함수인 이벤트 핸들러가 담겨져 있기 때문에 작업이 끝난 후 별도의 스레드에서 실행된다. 그렇기 때문에 이벤트루프는 이러한 작업을 핸들러에게 위임하고 바로 애플리케이션의 다음 IO를 받을 수 있도록 하는 비동기성을 가진다. 이를 통해 애플리케이션과의 상호작용이 가능한 것이다.<br><img src=\"https://i.imgur.com/z609IYv.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">EventQueue에 있는 이벤트는 이벤트루프가 deque를 통해 받아서 이벤트를 처리하는 방식으로 동작한다. 여기서 중요한 점은 앞에서도 말했듯 해당 이벤트 핸들러를 ‘받아서’ 이벤트를 처리한다는 점이다.이러한 이벤트 핸들러는 이벤트가 모두 실행된 후 실행되게 되는데, 이 때 실행되는 이벤트 핸들러는 원래의 이벤트 큐가 아닌 별도의 스레드에서 실행시키면서 비동기적인 특성을 유지할 수 있다.해당 패턴은\n요청을 들어온 순서대로 저장\n요청 보내는 곳에서는 요청을 큐에 넣은 뒤에 결과를 기다리지 않고 리턴\n요청을 처리하는 곳에서는 큐에 들어있는 요청을 나중에 처리\n의 과정을 지닌다. 이러한 과정은 비단 nodejs의 libuv 뿐만 아니라 다양한 곳에서도 여러 방식으로 활용되고 있다. 특히 운영체제에서 많이 쓰이는데, 다양하게 일어나는 이벤트 요청에 대해서 스레드는 한정적이기 때문에 고정적인 스레드 수를 가지는 스레드 풀을 만들어 이를 이벤트 루프와 함께 활용하면서 스레드 풀에서의 스레드가 놀지 않도록 계속해서 이벤트를 넣어주고, 실행이 끝나면 핸들러를 실행하는 식의 이벤트 루프 패턴을 사용한다. 이를 Worker Thread라고 한다.<br><img src=\"https://i.imgur.com/IedMcfk.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> WorkerThread와 Event Loop와의 관계는 플랫폼마다 다르지만 기본적인 원리는 똑같다.\n- node의 libuv\n- emitter + queue\n- 모바일 main thread\n- event / operation queue\n- coroutine\n이벤트가 들어왔을 때, 이를 큐에 쌓아놓고 있고 이를 처리하는 루퍼가 반복되면서 주기적으로 큐의 이벤트를 꺼내 특정한 콜백(클로저)를 호출해주는 방식이다.\nㄱ<br><img src=\"https://i.imgur.com/JsQtIsR.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n동작할 클로저를 객체 단위로 만듦(Operation class)\noperation이라는 작업 단위로 순차적으로 처리하고, 이를 동시에 처리해줄 worker를 얼마나 둘지 설정해둘 수 있음\n전형적인 eventLoop를 동작시키는 추상화된 동작 방식\n<br><img src=\"https://i.imgur.com/p0BTiqc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n싱글 스레드에서 루프를 두는 스타일이지만 timer나 I/O pool 등에 대한 클로저가 개별적으로 설정되어 있는 형태\n이를 돌아가면서 각 단계마다 블록을 걸면서 순차적으로 돌아가면서 확인\nIO가 일어나는, 즉 다른 worker Thread가 돌아가는 구조라면, 다른 OS의 worker thread와 동작하는 경우들은 개별적인 다른 쓰레드가 있고, 그 쓰레드들이 콜백을 주는 형태\n<br><img src=\"https://i.imgur.com/ysQnI5I.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nIOS, Android에서는 실행하는 앱 별로 다른 쓰레드가 생김\n그 쓰레드별로 메인 run loop(event Loop)가 생기고, 앱이 끝나면 해당 이벤트 루프 또한 끝남\n터치 이벤트, IO이벤트 등을 이벤트 루프에서 확인하고 화면을 그리게 됨\n<br><img src=\"https://i.imgur.com/X5bOprp.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nAndroid에서도 Context 단위로 쓰레드가 유지가 되고, 그 안에 루퍼가 있음 Context 단위는 Activity, Service, Fragment, animations, onClick 등.. 루퍼가 핸들러를 호출하는 구조\n결국 모든 비슷한 형태의 비동기 형태의 이벤트 루퍼\n<br><img src=\"https://i.imgur.com/hwB2x4L.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n타임 아웃이 될 때마다 등록해놓은 콜백을 실행하는 구조\n타이머 애니메이션을 처리하는데 있어서 스레드가 필요한가?가 중요한 포인트\n타이머들이 쓰레드가 필요없이 메인 쓰레드에서 동작하는 경우가 있음 node의 이벤트 루퍼가 대표적인 예. 다른 쓰레드에 타이머를 놓게 되면 애니메이션에 의해 타이머가 멈추거나, 타이머 때문에 애니메이션이 멈추는 경우도 있음\n타이머가 어느 쓰레드에서 실행되는지 확인하는 것이 중요\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Event Loop","level":1,"id":"Event_Loop_0"},{"heading":"왜 나왔을까?","level":2,"id":"왜_나왔을까?_0"},{"heading":"<strong>Event Queue</strong>","level":2,"id":"**Event_Queue**_0"},{"heading":"Event Loop와 Worker Thread","level":2,"id":"Event_Loop와_Worker_Thread_0"},{"heading":"Apple Platform Foundation에서의 OperationQueue","level":2,"id":"Apple_Platform_Foundation에서의_OperationQueue_0"},{"heading":"node.js와 libuv Looper","level":2,"id":"node.js와_libuv_Looper_0"},{"heading":"IOS에서의 Main Looper","level":2,"id":"IOS에서의_Main_Looper_0"},{"heading":"Android의 Main Looper","level":2,"id":"Android의_Main_Looper_0"},{"heading":"타이머","level":2,"id":"타이머_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/이벤트-루프와-비동기.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058403,"modifiedTime":1727007283430,"sourceSize":7326,"sourcePath":"학습 정리/Computer Science/이벤트 루프와 비동기.md","exportPath":"학습-정리/computer-science/이벤트-루프와-비동기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html":{"title":"이벤트 전파와 위임에 대한 고찰","icon":"","description":"DOM API를 통해 이벤트를 등록하고 이를 실행할 때면, 내가 원하는 예상대로 동작하지 않는 경우가 꽤 많다. 이는 이벤트 전파에 의한 예외 상황을 고려하지 않았을 때 주로 발생하며, 이에 이벤트 전파와 위임에 대해 자세히 알아볼 필요가 있다.DOM 트리 상에 존재하는 DOM 요소의 노드에서 이벤트가 발생하면, 이벤트 객체는 DOM 트리를 통해 다른 DOM 요소 노드로 전파된다. 이를 이벤트 전파라고 한다.쉽게 말해보자면, 트리 구조로 이루어진 DOM이니만큼, 계층적인 구조를 가지고 있어 이벤트가 일어날 경우 해당 태그에서만 하나의 이벤트를 등록하고 싶어도, 부모 요소에도 이벤트가 달려 있다면 부모 요소의 이벤트도 연쇄적으로 일어난다는 것이다.이러한 이벤트의 전파는 전파 방향에 따라 버블링과 캡처링으로 나눌 수 있다.\n버블링(Bubbling): 자식 요소 -&gt; 바깥 부모 요소로 전파\n캡처링(Capturing): 부모 요소 -&gt; 자식 요소 순서대로 계속해서 이벤트 전파\n<img src=\"https://i.imgur.com/i1TIkvz.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">표준 DOM 이벤트에서는 이벤트 흐름을 3단계로 정의한다.\n캡처링 단계 -&gt; 이벤트가 하위 요소로 전파\n타깃 단계 -&gt; 이벤트가 실제 타깃 요소에 전달\n버블링 단계 -&gt; 이벤트가 상위 요소로 전파\n위의 그림처럼 td를 클릭하면 맨 처음 캡처링 단계를 통해 이벤트가 전파되고, 이벤트가 타깃 요소에 도착하면 해당하는 이벤트가 실행되며, 다시 위로 올라가며 버블링 단계를 거치면서 요소들에 할당된 이벤트 핸들러들이 실행된다&lt;!doctype html&gt;\n&lt;body&gt;\n&lt;style&gt; body * { margin: 10px; border: 1px solid blue; }\n&lt;/style&gt; &lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;\n&lt;/form&gt; &lt;script&gt; for(let elem of document.querySelectorAll('*')) { elem.addEventListener(\"click\", e =&gt; alert(`캡쳐링: ${elem.tagName}`), true); elem.addEventListener(\"click\", e =&gt; alert(`버블링: ${elem.tagName}`)); }\n&lt;/script&gt;\n&lt;/body&gt;\n이런 식으로 모든 요소에 이벤트를 달아주게 되면, 타깃을 눌렀을 때, 처음 해당 요소로 들어가기까지 캡처링을 통해 모든 이벤트들이 부모요소의 수만큼 실행되게 되고, 타깃에 다다른 후 다시 돌아올 때는 다시 노드를 올라가면서 버블링을 거치기 때문에 다시 부모요소의 수만큼 이벤트 핸들러가 실행된다.이를 단계별로 정리하면\nHTML&nbsp;→&nbsp;BODY&nbsp;→&nbsp;FORM&nbsp;→&nbsp;DIV&nbsp;(캡처링)\nP&nbsp;(타깃 단계로 캡쳐링과 버블링 둘 다 리스너를 설정해서 두 번 호출됨)\nDIV&nbsp;→&nbsp;FORM&nbsp;→&nbsp;BODY&nbsp;→&nbsp;HTML&nbsp;(버블링)\n으로 총 10번의 이벤트가 발생하게 되는 것이다.\n사실 부모요소와 자식 요소 둘 다 이벤트가 등록되어 있을 경우, 자식요소의 이벤트만 실행시키려고 할 때, click을 예시로 들어보자면 사실상 자식요소만을 누른다고 해도 결국은 부모 요소의 자식이기 때문에 부모 요소의 이벤트 또한 작동할 수밖에 없다. 계층적인 구조에서는 당연한 일이라고 생각한다. 어찌보면 자식 요소를 클릭한 것이 부모 요소를 클릭한 것과 같은 셈이니까.상황에 따라서는 유용하게 사용할 수도 있지만, 캡처링의 경우는 부모 요소의 이벤트들을 따로 실행시키지 않고 내가 이벤트를 등록한 타겟요소의 이벤트핸들러만 실행시키고 싶은 때가 있을 수도 있다.그럴 때 필요한게 이벤트의 stopPropagation 메소드이다.\n이 메소드는 버블링 또는 캡처링 설정에 따라 상위, 하위로 가는 이벤트 전파를 차단함으로써 내가 원하는 타겟 요소의 이벤트핸들러만 실행시킬 수 있는 환경을 제공할 수 있다.&lt;html&gt; &lt;script&gt; const ancestor = document.querySelector(\"#ancestor\") const parent = document.querySelector(\"#parent\") const child = document.querySelector(\"#child\") let count = 1; ancestor.addEventListener(\"click\", (e) =&gt; { e.stopPropagation() print('ancestor') }) parent.addEventListener(\"click\", (e) =&gt; { e.stopPropagation() print('parent') }) child.addEventListener(\"click\", (e) =&gt; { e.stopPropagation() print('child') }) function print(name) { document.querySelector(\"section\") .insertAdjacentHTML(\"beforeend\",`&lt;p&gt;${count++}. ${name} clicked&lt;/p&gt;`); } document.body.addEventListener(\"click\", (e) =&gt; { [...document.querySelector(\"section\").children].forEach(e =&gt; { e.remove(); }) count = 1; }, true) &lt;/script&gt; &lt;body&gt; &lt;div id=\"ancestor\"&gt; &lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;section&gt;&lt;/section&gt; &lt;/body&gt;\n&lt;/html&gt;\n이렇게 한다면 각 요소에 있는 이벤트를 버블링 및 캡처링 하는 과정에서 불필요한 이벤트 핸들러의 실행을 차단시킬 수 있다.\n이를 통해 각 요소의 이벤트 리스너만 동작시킬 수 있는 것이다.이러한 부모-자식 요소의 html element 뿐만 아니라, 형제 요소들의 이벤트의 실행 또한 제어할 수 있는데, 이는 stopImmediatePropagation() 메소드를 통해 여러 개의 이벤트를 실행시키지 않고 하나의 이벤트만 실행시킬 수 있다.child.addEventListener(\"click\", (e) =&gt; { if(조건) e.stopImmediatePropagation() print('child')\n}) child.addEventListener(\"click\", (e) =&gt; { print('child 2')\n})\n기존의 이벤트에 대해서 메소드들을 통해서 캡처링, 버블링을 중간에 차단시키는 방법도 있지만, target element에 dataset attribute를 이용해서 조작하는 방법도 있다.html의 dataset 속성은 커스텀 사용자 속성을 DOM 요소에 직접적으로 저장할 수 있는데, 이렇게 저장한 요소의 경우 html 내에서 동작하는 자바스크립트 변수와 같은 느낌이 있어 문자열 데이터를 넣어놓고 상태를 조작하거나 특정 target의 id 등을 저장해놓는 방식에도 잘 활용된다.&lt;input type=\"text\" data-country=\"Norway\" data-code=\"c03\" name=\"Country\"&gt;\n이런 식으로 앞에 data- prefix를 붙이고 내가 쓰고 싶은 데이터의 속성명을 기재해주고, 이를 자바스크립트의 이벤트 핸들러안에서 찾아서 특정 요소만 검색하는 방식으로도 가능하다const $div = document.getElementById('post'); // 일반적인 객체 속성 접근\n$div.dataset.code // \"c03\" // 배열 인덱스로 접근\n$div.dataset['name'] // \"Country\" // data-country에서 dataset.country로 변환됨\n$div.dataset.country // \"Norway\"\n이러한 방식은 조금 더 각각의 요소에 유니크한 값을 넣어놓고 정밀하게 조정할 때 유용한데, 이 부분은 이벤트 위임에서 계속 쓸 예정이다.이처럼 브라우저는 3단계의 과정을 거치기 때문에, 버블링과 캡처링이 내가 예상한 동작 외의 이벤트들 또한 실행될 수 있다는 단점이 있지만, 이를 활용하여 유용하게 사용할 수도 있다.어차피 부모 요소의 이벤트 또한 자식 요소에도 영향을 끼치는데, 그렇게 한다면 여러 개의 컴포넌트가 있었을 때, 가장 상위에서 이벤트를 등록해놓는다면, 이를 통해서 여러 개가 있는 자식 요소들을 모두 하나의 이벤트 등록으로도 관리할 수 있다는 발상이 가능해진다. 이러한 방식을 이벤트 위임이라고 한다.&lt;table&gt; &lt;tr&gt; &lt;th colspan=\"3\"&gt;&lt;em&gt;Bagua&lt;/em&gt; Chart: Direction, Element, Color, Meaning&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"nw\"&gt;&lt;strong&gt;Northwest&lt;/strong&gt;&lt;br&gt;Metal&lt;br&gt;Silver&lt;br&gt;Elders&lt;/td&gt; &lt;td class=\"n\"&gt;...&lt;/td&gt; &lt;td class=\"ne\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt;\n&lt;/table&gt;\n위와 같은 예시를 javascript.info 에서 가져왔다.\n해당 테이블에 있는 각각의 td 요소들을 누르면 누른 td 요소가 highlight되는 효과를 부여하려 한다.이를 위해서는 크게 두 가지 방법이 있다.\n해당하는 모든 td 요소를 querySelectorAll로 검색한 뒤 forEach를 통해 캡처링 &amp; 버블링 이벤트 제어 하는 이벤트를 등록한다.\n부모요소에서 이벤트를 등록하면서 캡처링 방식으로 넘겨주되, 특정한 data attribute를 통해 각각의 요소를 구분하고, 뽑아낸 특정 요소에 대한 이벤트 핸들링\n하지만 1번의 경우 모든 요소에 대해 이벤트를 일일이 등록해주는 행위 자체는 성능성의 이슈가 있기도 하고, 새로운 요소가 추가되었을 경우에도 계속해서 이벤트를 직접 추가해줘야 하므로 상당히 비효율적이라고 생각한다.따라서 2번의 방식을 생각하게 되는데, 이 부분의 경우 세심하게 고려할 부분이 있다.이벤트 핸들러에 parameter로 오는 event 객체에는 target이라는 속성이 있다. 해당 target 속성은 이 이벤트가 이루어진 요소가 어떤 html 요소인지를 보여준다.let selectedTd; table.onclick = function(event) { let target = event.target; // 클릭이 어디서 발생했을까요? if (target.tagName != 'TD') return; // TD에서 발생한 게 아니라면 아무 작업도 하지 않습니다, highlight(target); // 강조 함\n}; function highlight(td) { if (selectedTd) { // 이미 강조되어있는 칸이 있다면 원상태로 바꿔줌 selectedTd.classList.remove('highlight'); } selectedTd = td; selectedTd.classList.add('highlight'); // 새로운 td를 강조 함\n}\n그래서 해당 타겟의 html element를 보고 해당 element에 효과를 넣어주는 방식으로 이벤트 위임을 할 수 있다.하지만 event.target의 중요한 점은 클릭이 이루어진 해당 '요소' 를 정확히 찾아내 리턴한다는 점이다.\n따라서 td를 포함하는 td안의 들어있는 모든 요소 대해서 이벤트가 실행되도록 하고 싶은데, 만약에 td 요소 안의 strong 태그 안에 있는 텍스트를 누르게 되면 event.target 으로 받은 html element가 td 안에 들어있는 strong element만을 리턴한다.따라서 내가 이벤트를 등록하려는 Html element의 범위에 대해서 생각하고, 등록하려는 html element 안의 요소를 클릭했을 때, 어떤 방식으로 해당 부모 요소까지 조작할 지에 대해 고려해야 할 필요성이 있다.이를 쉽게 할 수 있는 방법 중 하나는 html element의 closest 메소드를 활용하는 것이다.closest메소드를 활용하여 내가 누른 요소와 가장 가까이에 있는 타켓 요소를 선택할 수 있도록 할 수 있다.table.onclick = function(event) { let td = event.target.closest('td'); // (1) if (!td) return; // (2) if (!table.contains(td)) return; // (3) highlight(td); // (4)\n};\n이를 통해 누른 요소의 가장 가까운 td 요소를 가져와 해당 요소에 대해서 조작을 해줌으로써 세심하게 이벤트를 제어할 수 있다. html 요소의 attribute에 데이터를 넣어 사용하는 dataset을 활용하는 방식은 closest만큼, 혹은 그보다 더 세심하게 자식 요소의 기능을 관리할 수 있는 방식이다.&lt;table&gt; &lt;tr&gt; &lt;th colspan=\"3\"&gt;&lt;em&gt;Bagua&lt;/em&gt; Chart: Direction, Element, Color, Meaning&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td0\"&gt;&lt;strong&gt;Northwest&lt;/strong&gt;&lt;br&gt;Metal&lt;br data-action=\"silver\" data-target=\"td0\"&gt;Silver&lt;br&gt;Elders&lt;/td&gt; &lt;td class=\"td1\"&gt;...&lt;/td&gt; &lt;td class=\"td2\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt; &lt;tr&gt;...2 more lines of this kind...&lt;/tr&gt;\n&lt;/table&gt;\n해당 코드에서는 dataset의 action이라는 데이터에 부모 요소의 안쪽 요소들의 세부적인 기능을 제어하기 위한 기능적인 명시를 해두었다.\n이러한 div 태그에는 각각 유니크한 id가 붙어있고, 가장 상위에 있는 table이나 html의 body 자체에 이벤트를 등록해두는 것이다.let selectedTd; table.onclick = function(event) { if(event.target.dataset.action === \"silver\"){ let target = event.target.dataset.target; target = document.getElementByID(target) highlight(target); // 강조 함 }\n}; function highlight(td) { if (selectedTd) { // 이미 강조되어있는 칸이 있다면 원상태로 바꿔줌 selectedTd.classList.remove('highlight'); } selectedTd = td; selectedTd.classList.add('highlight'); // 새로운 td를 강조 함\n}\n이벤트에 대한 세부 기능을 data-action attribute로 넣어놓고 이를 포함하는 부모 요소의 unique한 id를 data-target attribute로 부여해주었다. 이렇게 되었을 경우 보다 부모 요소에서 세부적인 기능을 발견했을 경우 해당 이벤트와 그 기능에 대해서만 처리할 수 있도록 핸들링 할 수 있는 것이 유용하다.&lt;div id=\"menu\"&gt; &lt;button data-action=\"save\"&gt;저장하기&lt;/button&gt; &lt;button data-action=\"load\"&gt;불러오기&lt;/button&gt; &lt;button data-action=\"search\"&gt;검색하기&lt;/button&gt;\n&lt;/div&gt; &lt;script&gt; class Menu { constructor(elem) { this._elem = elem; elem.onclick = this.onClick.bind(this); // (*) } save() { alert('저장하기'); } load() { alert('불러오기'); } search() { alert('검색하기'); } onClick(event) { let action = event.target.dataset.action; if (action) { this[action](); } }; } new Menu(menu);\n&lt;/script&gt;\nclass 컴포넌트를 이용해서 관리하는 방식은 보다 가독성이 뛰어나다고 생각한다. 클래스의 메소드를 활용하여 버튼마다 핸들러를 할당해주는 코드를 따로 작성할 필요가 없고, 다른 이벤트 핸들러의 수정 또한 메소드만 관리해주면 되기 때문에 각 기능들에 대해서도 관리하는 방식은 확실히 스마트하다.constructor에서 onclick 이벤트에는 this를 바인딩하게 되는데, 바인딩된 요소는 해당 Menu 객체의 요소를 가리킨다.\n바인딩된 onClick 이벤트는 캡처링을 통해 자식의 요소들의 onclick 이벤트 또한 감지하고, 이를 action으로 나누어 세부적인 기능들을 메소드로 구분할 수 있기 때문에 활용성을 보다 높였다고 생각한다.이러한 이벤트위임의 장점은 앞에서도 이야기를 많이 했지만,\n핸들러를 일일이 할당하지 않아 초기화가 단순해지고 메모리 절약\n요소를 추가, 제거,수정 등에 대해서 할당된 핸들러를 따로 건들 필요가 없음\ninnerHTML이나 유사한 기능을 하는 스크립트로 요소 덩어리를 더하거나 뺄 수 있기 때문에 컴포넌트 기반 개발이 편리함\n등이 있다.\n하지만 그럼에도 불구하고, 이벤트 위임에도 단점은 있다.\n이벤트 위임을 사용하기 위해서는 이벤트의 버블링이 필수인데, 몇몇 이벤트는 버블링이 불가능한 이벤트도 있음 + 낮은 레벨에 할당한 핸들러에 stopPropagation 사용 불가\n부모 요소에서 핸들러를 관리하기 때문에 그 안쪽의 모든 요소에 대해서 등록된 이벤트가 실행되기 때문에 CPU 작업부하 무시할만한 수준이라고는 한다. 이벤트 전파와 위임에 대해 제대로 이해하는 것은 이번이 아마 처음이었던 것 같다. vanilla js를 거의 쓰지 않고 리액트만 주로 썼던 나에게는 어떠한 이벤트가 '전파'된다는 사실 자체가 생소하게 들렸다. 리액트는 주로 이벤트를 따로 등록할 때에는 attribute의 onClick 속성에 이벤트 핸들러 함수를 넣어주었고, 이러한 이벤트들은 각각의 이벤트 핸들러를 모두 가지고 있기 때문에 이벤트 위임 또한 생소하게 느껴졌다고 생각한다.\n기본기가 탄탄해야 하나의 프레임워크에 의존되지 않고 여러 프레임워크를 빠르게 적응하고 사용할 수 있는 숙련도가 쌓이는 것 같다.\n아무튼 이렇게 기존의 이벤트 핸들러를 보다 효율적이고 스마트하게 사용하는 법을 통해 다양하게 시도해보는 습관을 계속 쌓아나가는 것이 좋은 방식이라고 생각한다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%BA%A1%EC%B3%90%EB%A7%81\" target=\"_self\">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%BA%A1%EC%B3%90%EB%A7%81</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-HTML-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%85%8Bdata-%EC%86%8D%EC%84%B1\" target=\"_self\">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-HTML-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%85%8Bdata-%EC%86%8D%EC%84%B1</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.javascript.info/bubbling-and-capturing\" target=\"_self\">https://ko.javascript.info/bubbling-and-capturing</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.javascript.info/event-delegation\" target=\"_self\">https://ko.javascript.info/event-delegation</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"이벤트 전파","level":1,"id":"이벤트_전파_0"},{"heading":"이벤트 전파의 종류","level":2,"id":"이벤트_전파의_종류_0"},{"heading":"표준 DOM 이벤트","level":2,"id":"표준_DOM_이벤트_0"},{"heading":"왜 그럴까?","level":3,"id":"왜_그럴까?_0"},{"heading":"전파 흐름 제어하기","level":2,"id":"전파_흐름_제어하기_0"},{"heading":"stopPropagation","level":3,"id":"stopPropagation_0"},{"heading":"stopImmediatePropagation","level":3,"id":"stopImmediatePropagation_0"},{"heading":"target에 조건을 걸은 이벤트 핸들러 컨트롤","level":3,"id":"target에_조건을_걸은_이벤트_핸들러_컨트롤_0"},{"heading":"이벤트 위임","level":1,"id":"이벤트_위임_0"},{"heading":"event의 target 고려하기","level":3,"id":"event의_target_고려하기_0"},{"heading":"closest 메소드 활용하기","level":4,"id":"closest_메소드_활용하기_0"},{"heading":"dataset 활용하기","level":4,"id":"dataset_활용하기_0"},{"heading":"class를 이용하여 요소 관리하기","level":4,"id":"class를_이용하여_요소_관리하기_0"},{"heading":"장단점","level":3,"id":"장단점_0"},{"heading":"끝내며","level":1,"id":"끝내며_0"},{"heading":"참조","level":2,"id":"참조_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058387,"modifiedTime":1725254058387,"sourceSize":17349,"sourcePath":"학습 정리/Computer Science/이벤트 전파와 위임에 대한 고찰.md","exportPath":"학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/쿠키와-세션.html":{"title":"쿠키와 세션","icon":"","description":"쿠키와 세션에 대해 알기 위해서는 HTTP 프로토콜의 특성에 대해 알 필요가 있다. HTTP 프로토콜의 특성에 대해 가지는 결점을 보완하기 위해 나온 것이 쿠키와 세션이기 때문이다.\nClient-Server 구조 각각의 서버와 클라이언트는 독립되어 있는 상태이다\n클라이언트는 서버에 요청을 보내고 응답이 올 때까지 대기하며, 서버는 클라이언트에서 받은 요청에 대한 결과를 만들어 응답을 한다(Request&lt;-&gt;Response) Connectionless(비연결성) 계속해서 연결을 유지한는 TCP/IP와는 달리 HTTP 프로토콜은 클라이언트에서 서버에 요청(Request)을 보내면 서버는 클라이언트에 응답(Response)을 하고&nbsp;연결을 끊는 특징을 가지고 있다. 이를 통해 최소한의 자원으로 서버를 유지할 수 있도록 한다.\n하지만 트래픽이 많거나 큰 규모의 서비스를 운영할 경우, 비연결성은 한계를 보인다. HTTP 1.0이 각각의 자원을 다운로드 하기 위해 연결과 종료를 반복하는 등의 3 Way Handshake(연결 -&gt; 요청/응답 -&gt; 종료 과정에서 일어나는 시간 지연때문에 이를 해결하고자 HTTP1.1부터는 지속 연결(Persistant Connections)가 가능해졌다. stateless(무상태성) 서버는 클라이언트의 상태를 저장하지 않는다 이처럼 HTTP 프로토콜의 특성을 고려할 때, 비연결성과 무상태성의 특성을 유지하면서도 서버와 클라이언트가 통신을 하면서 로그인이나 장바구니 등등 계속해서 상태를 간직해야 하는 부분이 불가능하다. 따라서 이러한 약점을 보완하고자 나온 개념이 쿠키와 세션이다.HTTP의 일종으로 사용자가 어떤 웹 사이트를 방문할 경우, 해당 사이트가 사용하고 있는 서버에서&nbsp;사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다.\nHTTP에서 클라이언트의 상태정보를 쿠키 형태로 클라이언트 PC에 저장하였다가&nbsp;필요 시 정보를 참조하거나 재사용할 수 있다.\nKey-Value쌍으로 구성\n쿠키이름, 쿠키값, 만료시간, 전송할 도메인명, 전송할 경로, 보안연결여부, HttpOnly여부로 구성\n도메인 당 20개의 쿠키를 가질 수 있음\n하나의 쿠키는 4KB(= 4096 byte)까지 저장이 가능\n<img src=\"https://i.imgur.com/0xyg0F8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n클라이언트가 서버에 로그인 요청\n서버는 클라이언트의 로그인 요청의 유효성을 확인하고(아이디와 비밀번호 검사) 응답헤더에&nbsp;set-cookie:&nbsp;를 통해 쿠키를 추가하여 응답\n클라이언트는 이후 서버에 요청할 때 전달받은 쿠키를 자동으로 요청헤더에 추가하여 요청한다. 헤더에 쿠키값을 자동으로 추가하여 주는데 이는 브라우저에서 처리해줌 쿠키의 기한이 정해져있지 않고 명시적으로 지우지 않는다면 반 영구적으로 쿠키가 남아있음 세션 관리(Session Management) 로그인, 사용자 닉네임, 접속 시간, 장바구니 등의 서버가 알아야할 정보들을 저장 개인화(Personalization) 사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있다. 트래킹(Tracking) 사용자의 행동과 패턴을 분석하고 기록 이러한 쿠키의 경우 클라이언트에서 수정할 수 있기 때문에 위변조의 위험이 항상 존재한다.\n이에 쿠키값을 암호화해야하며, 민감하거나 중요한 정보를 담지 않도록 해야 한다.일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술이다.\n여기서 일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.\n즉, 브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해주는 기술을 세션이라고 한다.\n웹 서버에&nbsp;웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.\n웹 서버에 저장되는 쿠키(세션 쿠키 / session cookie)이다.\n브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되기 때문에&nbsp;쿠키보다 비교적 보안적으로 우수하다.\n저장 데이터에 제한이 없다.(서버 용량 허용 범위 내에서)\n각 클라이언트에&nbsp;고유 세션 ID(Session ID)를 부여한다. 세션 ID를 통해 클라이언트를 구분하여 각 요구에 맞는 서비스를 제공한다.\n<br><img src=\"https://velog.velcdn.com/images/octo__/post/43cd0113-e3d4-4139-9bf9-4c3d06e050ad/image.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n클라이언트가 서버에 로그인 요청\n서버는 클라이언트의 로그인 요청의 유효성을 확인하고(아이디와 비밀번호 검사)&nbsp;unique한 id를 session ID로 생성하여 저장한다.\n서버가 응답할 때&nbsp;응답헤더에 세션 ID를 쿠키에 추가하여 응답합니다.\n클라이언트는 이후 서버에 요청할 때 전달받은 세션 ID를 쿠키에 자동으로 요청 헤더에 추가하여 요청한다.\n서버에서는 요청 헤더의 세션 ID 값을 저장된 세션저 장소에서 찾아보고 유효한지 확인 후 요청을 처리하고 응답한다.\n사용자나 다른 누군가에게 노출되면 안되는 보안적으로 중요한 정보들을 서버 안에서 다루기 위해 사용한다.세션의 내용은 서버에 저장되기 때문에 계속하여 늘어날 경우 서버에 부하가 발생할 수 있다.\n또한 세션에 대한 정보가 서버에 있어 쿠키에 비해 비교적 속도가 느리다.\n쿠키:&nbsp;클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드디스크\n세션:&nbsp;서버의 메모리에 저장 쿠키: 저장할 때 expires 속성을 정의해 무효화시키면&nbsp;삭제될 날짜 지정 가능\n세션: 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화되어&nbsp;정확한 시점을 알 수 없음 쿠키: 클라이언트에 저장되고, 클라이언트의 메모리를 사용하기 때문에&nbsp;서버 자원을 사용하지 않음\n세션: 서버에 저장되고, 서버의 메모리로 로딩되기 때문에&nbsp;세션이 생길 때마다 리소스를 차지함 쿠키: 클라이언트도 모르게 접속되는 사이트에 의해 설정될 수 있기 때문에 쿠키로 인한 문제가 발생하는 것을 막기 위해&nbsp;한 도메인 당 20개, 한개의 쿠키 당 4KB로 제한\n세션: 클라이언트가 접속하면 서버에 의해 생성되므로&nbsp;개수나 용량 제한 없음\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"쿠키와 세션","level":1,"id":"쿠키와_세션_1"},{"heading":"HTTP 프로토콜의 특징","level":2,"id":"HTTP_프로토콜의_특징_0"},{"heading":"쿠키","level":2,"id":"쿠키_0"},{"heading":"쿠키의 특징","level":3,"id":"쿠키의_특징_0"},{"heading":"작동 방식","level":3,"id":"작동_방식_0"},{"heading":"쿠키의 사용목적","level":3,"id":"쿠키의_사용목적_0"},{"heading":"쿠키의 종류","level":3,"id":"쿠키의_종류_0"},{"heading":"세션(Session)","level":2,"id":"세션(Session)_0"},{"heading":"세션의 특징","level":3,"id":"세션의_특징_0"},{"heading":"세션의 작동 방식","level":3,"id":"세션의_작동_방식_0"},{"heading":"세션의 사용목적","level":3,"id":"세션의_사용목적_0"},{"heading":"세션의 단점","level":3,"id":"세션의_단점_0"},{"heading":"쿠키 vs 세션","level":2,"id":"쿠키_vs_세션_0"},{"heading":"저장 위치","level":2,"id":"저장_위치_0"},{"heading":"만료 시점","level":2,"id":"만료_시점_0"},{"heading":"리소스","level":2,"id":"리소스_0"},{"heading":"용량 제한","level":2,"id":"용량_제한_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/쿠키와-세션.html","pathToRoot":"../..","attachments":[],"createdTime":1725354949286,"modifiedTime":1725357331051,"sourceSize":8795,"sourcePath":"학습 정리/Computer Science/쿠키와 세션.md","exportPath":"학습-정리/computer-science/쿠키와-세션.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/broadcast,-unicast,-multicast.html":{"title":"Broadcast, Unicast, Multicast","icon":"","description":"1:1 통신 방식으로 받는 인터넷 대부분의 통신 방식이다.\n하나의 호스트가 다른 하나의 호스트와 통신을 하기 위한 목적으로 설계되었다.\n데이터는 프레임에 자신의 MAC 주소와 상대방의 호스트의 목적지 MAC 또는 목적지 IP 정보를 활용하여 데이터를 전송한다.\n같은 네트워크에 있는 모든 시스템들은 IP/MAC 주소를 받아 자신의 IP/MAC 주소와 비교 후에 자신의 IP/MAC 주소와 같지 않다면 프레임을 버리고, 같으면 프레임을 받아서 처리한다.\nMAC주소 (Media Access Control Address)\n네트워크 인터페이스에 할당된 물리적 고유 식별 주소\n네트워크 통신을 계층화하여 설명하는 OSI 모델에서 데이터 링크 계층의 일부\n1:N의 통신 방식으로, N은 네트워크 내 전체 호스트를 의미한다.\n보내는 대상의 IP/MAC 주소를 모르더라도 통신이 가능하다.\n하나의 호스트가 같은 네트워크 대역의 모든 호스트들에게 통신을 하기 위한 목적으로 설계되어 있다.브로드캐스트 방식의 경우 브로드캐스트용 주소가 미리 정해져있고, 수신받는 시스템은 해당 주소가 오면 패킷을 자신의 CPU로 전송하고 CPU가 패킷을 처리한다.\n모든 시스템에게 패킷이 전송되는 만큼, 이에 따른 트래픽은 증가하며 CPU 또한 패킷을 처리하면서 성능저하 이슈가 생길 수 있다.\n통신하고자 하는 시스템의 MAC 주소를 알지 못하는 경우\n네트워크에 있는 모든 시스템에게 알리는 경우\n라우터끼리 정보를 교환하거나 새로운 라우터를 찾는 경우\n등에 이용이 된다.\n멀티캐스트는 네트워크에 연결되어 있는 시스템 중 일부들에게만 정보를 전송하는 것으로, 라우터가 멀티캐스트를 지원해야만 사용이 가능하다.멀티캐스트를 사용하는 이유는 그룹간 통신을 위하여 다중 사용자에게 동일한 데이터를 보낼 때 유니캐스트 전송 방식을이용하면 데이터 패킷을 여러번 전송해야 하고, 이에 따른 네트워크의 효율이 낮아지게 된다. 하지만 멀티캐스트는 여러 수신자에게 한 번에 메시지가 전송되므로 네트워크의 자원 낭비를 최소화한다. 멀티캐스트 전송의 경우 일반적으로 TCP/IP의 헤더에 수신자의 인터넷 주소를 표시하여 전송하는 것과는 달리 수신자들을 그룹으로 묶어 그룹 주소를 표시하여 패킷을 전송한다.이러한 멀티캐스트 그룹으로 묶는 작업은 애플리케이션이 실행될 때 수행되는데, 멀티캐스트 IP/MAC 주소를 라우터에 등록되면서 멀티캐스트 그룹에 속하게 된다. 하나의 클라이언트에서 여러 멀티캐스트 주소를 수용할 수 있다.<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://jwprogramming.tistory.com/29\" target=\"_self\">https://jwprogramming.tistory.com/29</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Unicast","level":1,"id":"Unicast_0"},{"heading":"Broadcast","level":1,"id":"Broadcast_0"},{"heading":"Multicast","level":1,"id":"Multicast_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/broadcast,-unicast,-multicast.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058392,"modifiedTime":1725254058392,"sourceSize":2973,"sourcePath":"학습 정리/Computer Science/Broadcast, Unicast, Multicast.md","exportPath":"학습-정리/computer-science/broadcast,-unicast,-multicast.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/computer-science.html":{"title":"Computer Science","icon":"","description":"\n<a data-href=\"운영체제\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/운영체제/운영체제.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">운영체제</a>\n<br><a data-href=\"브라우저의 렌더링과 캔버스\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/브라우저의-렌더링과-캔버스.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">브라우저의 렌더링과 캔버스</a>\n<br><a data-href=\"쓰레드 풀이란?\" href=\"https://alsgud8311.github.io/.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">쓰레드 풀이란?</a>\n<br><a data-href=\"이벤트 루프와 비동기\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/이벤트-루프와-비동기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">이벤트 루프와 비동기</a>\n<br><a data-href=\"이벤트 전파와 위임에 대한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">이벤트 전파와 위임에 대한 고찰</a>\n<br><a data-href=\"쿠키와 세션\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/쿠키와-세션.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">쿠키와 세션</a>\n<br><a data-href=\"Broadcast, Unicast, Multicast\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/broadcast,-unicast,-multicast.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Broadcast, Unicast, Multicast</a>\n<br><a data-href=\"OSI 7 Layer\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/osi-7-layer.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">OSI 7 Layer</a>\n<br><a data-href=\"TCP-IP\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/tcp-ip.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">TCP-IP</a>\n<br><a data-href=\"TELNET과 SSH\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/telnet과-ssh.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">TELNET과 SSH</a>\n<br><a data-href=\"HTTP란?\" href=\"https://alsgud8311.github.io/.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">HTTP란?</a>\n<br><a data-href=\"HTTP 세션\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/http-세션.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">HTTP 세션</a>\n<br><a data-href=\"HTTP 메시지\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/http-메시지.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">HTTP 메시지</a>\n<br><a data-href=\"HTTP3\" href=\"https://alsgud8311.github.io/학습-정리/computer-science/http3.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">HTTP3</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["학습-정리/computer-science/운영체제/운영체제.html#_0","학습-정리/computer-science/브라우저의-렌더링과-캔버스.html#_0",".html","학습-정리/computer-science/이벤트-루프와-비동기.html#_0","학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html#_0","학습-정리/computer-science/쿠키와-세션.html#_0","학습-정리/computer-science/broadcast,-unicast,-multicast.html#_0","학습-정리/computer-science/osi-7-layer.html#_0","학습-정리/computer-science/tcp-ip.html#_0","학습-정리/computer-science/telnet과-ssh.html#_0",".html","학습-정리/computer-science/http-세션.html#_0","학습-정리/computer-science/http-메시지.html#_0","학습-정리/computer-science/http3.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/computer-science.html","pathToRoot":"../..","attachments":[],"createdTime":1738514660870,"modifiedTime":1738514682113,"sourceSize":352,"sourcePath":"학습 정리/Computer Science/Computer Science.md","exportPath":"학습-정리/computer-science/computer-science.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/frontend-roadmap.html":{"title":"Frontend RoadMap","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<a data-href=\"인터넷은 어떻게 동작하는가?\" href=\"인터넷은 어떻게 동작하는가?\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">인터넷은 어떻게 동작하는가?</a>","level":4,"id":"[[인터넷은_어떻게_동작하는가?]]_0"},{"heading":"<a data-href=\"HTTP에 대해서\" href=\"HTTP에 대해서\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">HTTP에 대해서</a>","level":3,"id":"[[HTTP에_대해서]]_0"},{"heading":"<a data-href=\"웹페이지, 웹사이트, 웹서버, 검색엔진의 차이\" href=\"웹페이지, 웹사이트, 웹서버, 검색엔진의 차이\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">웹페이지, 웹사이트, 웹서버, 검색엔진의 차이</a>","level":3,"id":"[[웹페이지,_웹사이트,_웹서버,_검색엔진의_차이]]_0"}],"links":[".html",".html","학습-정리/computer-science/웹페이지,-웹사이트,-웹서버,-검색엔진의-차이.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/frontend-roadmap.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":144,"sourcePath":"학습 정리/Computer Science/Frontend RoadMap.md","exportPath":"학습-정리/computer-science/frontend-roadmap.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/http-메시지.html":{"title":"HTTP 메시지","icon":"","description":"HTTP 메시지는 서버와 클라이언트 간에 데이터가 교환되는 방식이다.\n개요에서 설명했던 것처럼, 메시지 타입은 요청(Request), 응답(Response)이 있다.HTTP 메시지는 ASCII로 인코딩된 여러 줄의 텍스트 정보이다. HTTP/1.1때는 읽을 수 있었지만 HTTP/2부터는 읽을 수 없으며 HTTP 프레임으로 나누어진다.<img src=\"https://i.imgur.com/dLP88on.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nHTTP/2의 이진 프레이밍 메커니즘을 통해 사용자가 API나 설정 파일 등을 변경할 필요가 없게 설계되어 보고 이해하기가 쉽다.요청과 응답의 구조는 아래와 같다 시작줄에 실행되어야 할 요청/응답(성공 or 실패) 기록\nHTTP 헤더(option) -&gt; 요청, 메시지 본문 등에 대한 설명 요청에 대한 모든 메타 정보가 전송되었음을 알리는 빈 줄\n요청에 관련된 내용 응답 관련 문서 등(option. 본문의 존재 유무 및 크기는 첫 줄과 HTTP 헤더에 명시)\nHTTP 메시지의 페이로드로 오는 본문 <br><img src=\"https://i.imgur.com/INOxtoc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n요청 헤드(head): HTTP 메시지의 시작 줄 + HTTP 헤더\n본문(body): HTTP 메시지의 페이로드(Payload)\n여기서 요청과 응답의 구조에 대해서 조금 더 자세히 살펴보자\nHTTP 메서드(GET, PUT, POST, HEAD, OPTIONS 등)를 통해 서버가 수행해야 할 동작을 나타냄 요청 타겟 -&gt; URL/ 포트, 도메인, 프로토콜의 절대 경로 등 타겟의 포맷은 HTTP 메서드에 따라 달라짐 일반적인 포맷 Origin 형식으로 알려진 절대경로 ex) HEAD /test.html?query=minsu absolute 형식으로 알려진 완전한 URL <br>ex) GET <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://developer.mozilla.org/ko/docs/Web/HTTP/Messages\" target=\"_self\">http://developer.mozilla.org/ko/docs/Web/HTTP/Messages</a> HTTP/1.1 authority 형식으로 알려진 도메인 이름 &amp; 옵션 포트(URL의 인증 컴포넌트로 HTTP 터널을 구축하는 경우에만 CONNECT와 함께 사용가능) ex) CONNECT developer.mozilla.org:80 HTTP/1.1 asterisk 형식으로 알려진 모든 서버 나타내는 포맷 ex) OPTIONS * HTTP/1.1 HTTP 버전\n문자열 다음에 콜론(:)이 붙고 뒤에 오는 값은 헤더 따라 달라짐.<br><img src=\"https://i.imgur.com/rtFLB4L.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nVia(메시지 전달추적, 요청루프 방지, 발신자의 프로토콜 기능 식별) 등의 General Header -&gt; 메시지 전체 적용\nRequest Header -&gt; 요청 구체화, 컨텍스트 제공, 제약 설정, 요청 내용 수정 등\nRepresentation Header -&gt; 메시지 데이터의 원래 형식과 적용된 인코딩 설명 요청의 마지막 부분.\nGET, HEAD, DELETE, OPTIONS처럼 리소스를 가져오는 요청은 본문이 필요없다본문은 두 가지 종류로 나뉜다\n헤더 두 개(Content-Type, Content-Length)로 정의된 단일 페이지로 구성되는 단일-리소스 본문\n다중 리소스 본문 -&gt; Web Form(유저와의 상호작용)과 관련. HTTP 응답의 시작 줄.\n보통 HTTP/1.1인 프로토콜 버전\n요청의 성공 여부를 나타내는 상태코드\nHTTP 메시지를 이해할 때 도움되는 상태 텍스트 상태 코드는 5개의 블록으로 나뉜다. 1XX Informational\n2XX 성공\n3XX 리디렉션\n4XX 클라이언트 오류\n5XX Server Error XX는 0~99의 숫자를 나타내며 대부분 대표적인 숫자가 있다.\nex) 200, 404, 500 등\n다른 헤더와 동일한 구조를 가진다\n문자열 다음 콜론(:), 그 뒤의 값은 헤더 따라 다르다.<br><img src=\"https://i.imgur.com/O75dGT3.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nVia(메시지 전달추적, 요청루프 방지, 발신자의 프로토콜 기능 식별) 등의 General Header -&gt; 메시지 전체 적용\nResponse Header -&gt; 서버에 대한 추가 정보 제공. Vary나\nVary : 요청 메시지의 메서드 및 URL을 제외하고 응답 내용에 영향을 준 부분 설명. 콘텐츠 협상(동일한 URL에서 리소스의 서로 다른 버전을 제공하기 위해 사용하는 메커니즘. 제일 잘 맞는 언어, 인코딩 등을 명시)\nRepresentation Header -&gt; 메시지 데이터의 원래 형식과 적용된 인코딩 설명 응답의 마지막 부분\n본문이 없을 수도 있다(201 Created, 204 No content 등)\u001d\nContent-Type와&nbsp;Content-Length라는 두 개의 헤더로 정의하는 길이가 알려진 하나의 파일로 구성된 단일-리소스 본문(Single-resource bodies). Transfer-Encoding가&nbsp;chunked로 설정된 청크로 나뉘어 인코딩되는 길이를 모르는 하나의 파일로 구성된 단일-리소스 본문\nTransfer-Encoding : 사용자에게 entity를 안전하게 전송하기 위해 인코딩 형식을 지정한 헤더 서로 다른 정보를 담고 있는 멀티파트 본문으로 이루어진&nbsp;다중 리소스 본문(option)\nHTTP/1.X 버전은 성능 결함이 있어 현재는 대부분 2 이상을 쓴다\n따라서 2는 이 문제들을 다른 방식으로 보완했다고 볼 수 있다.\n본문은 압축이 되지만, 헤더는 압축이 되지 않는 HTTP/1.X 연속된 메시지들은 비슷한 헤더 구조를 가지지만 메시지마다 반복되어 전송됨\n다중전송(multiplexing)이 불가능\n이러한 문제들을 보완한 HTTP/2의 프레임은 다음과 같다<br>\n<img src=\"https://i.imgur.com/1fDNkh2.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n이렇게 프레임으로 나누어 스트림에 끼워넣으면서 데이터와 헤더 프레임을 분리한다.\n데이터와 헤더 프레임을 분리함으로써 기존에 가진 문제점을 해결할 수 있다.\n프레임을 분리하면서 헤더 프레임만 선택하여 압축이 압축이 가능해진다.\n스트림 여러개를 한 번에 묶는 멀티플렉싱이 가능해지면서 TCP 연결이 효율적이게 된다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"HTTP 메시지란?","level":2,"id":"HTTP_메시지란?_0"},{"heading":"HTTP 요청","level":2,"id":"HTTP_요청_0"},{"heading":"시작 줄","level":3,"id":"시작_줄_0"},{"heading":"헤더","level":3,"id":"헤더_0"},{"heading":"요청 헤더의 종류","level":4,"id":"요청_헤더의_종류_0"},{"heading":"본문","level":3,"id":"본문_0"},{"heading":"HTTP 응답","level":2,"id":"HTTP_응답_0"},{"heading":"상태 줄","level":3,"id":"상태_줄_0"},{"heading":"상태코드","level":4,"id":"상태코드_0"},{"heading":"헤더","level":3,"id":"헤더_1"},{"heading":"헤더 종류","level":4,"id":"헤더_종류_0"},{"heading":"본문","level":3,"id":"본문_1"},{"heading":"본문의 종류","level":4,"id":"본문의_종류_0"},{"heading":"HTTP/2 프레임","level":2,"id":"HTTP/2_프레임_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/http-메시지.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":6015,"sourcePath":"학습 정리/Computer Science/HTTP 메시지.md","exportPath":"학습-정리/computer-science/http-메시지.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/http-세션.html":{"title":"HTTP 세션","icon":"","description":"클라이언트-서버 프로토콜의 HTTP의 세션은 세 가지 과정을 거친다.\n클라이언트가 TCP 연결 수립(TCP가 아니어도 다른 연결 필요)\n클라이언트가 요청 전송 후 응답 대기\n서버가 요청을 처리하고 응답을 상태 코드, 요청에 부합하는 데이터와 함께 돌려보냄\nHTTP/1.1부터는 세 번째 과정 이후 클라이언트가 해당 시점에 또 다른 요청을 보낼 수 있도록 연결을 닫지 않아 계속해서 요청을 받을 수 있다.클라이언트는 연결을 수립한다.\nHTTP에서 연결을 연다는 것은 TCP인 기본적인 전송 계층 내에서 연결하는 것을 의미한다.TCP 연결의 경우 HTTP 서버를 위한 기본 포트는 80이다. (AWS에서 배포할 때도 기본 포트를 80으로 해놔야 나중에 도메인을 Route53을 통해서 바꿀 수 있다).\n8000등의 포트들도 쓰이긴 하지만 80의 경우에는 URL에서 포트 번호를 생략 가능할 수 있기 때문에 좋다.연결이 된 후에는 user-agent(웹 브라우저, 크롤러 등)는 요청을 보낼 수 있다.\n클라이언트 요청은 세 가지 블록으로 나누어진 CRLF(Carriage return, followed by line feed)로 구분된 텍스트 지시자들로 이루어진다.GET / HTTP/1.1\nHost: developer.mozilla.org\nAccept-Language: fr 첫번째 줄 -&gt; Parameter가 따른는 요청 메서드 문서의 경로, 프로토콜과 도메인 이름을 제외한 절대경로 URL\n사용중인 HTTP 프로토콜 버전 다음 줄들은 각각 특정 헤더를 나타낸다. 데이터의 적합성, 서버의 동장 수정 데이터 등에 관한 몇 가지 정보를 서버에 제공한다. 이런 헤더는 빈 줄로 끝나는 블록을 형성한다.\n마지막 블록은 부가적인 데이터 블록으로 POST 메서드에 의해 사용된다\nPOST /contact_form.php HTTP/1.1\nHost: developer.mozilla.org\nContent-Length: 64\nContent-Type: application/x-www-form-urlencoded name=Joe%20User&amp;request=Send%20me%20one%20of%20your%20catalogue\n결과는 이런 식으로 전송한다.주어진 자원에 대해 실행되길 바라는 동작을 가리키는 요청 메서드가 정의되어 있다.웹 서버가 요청을 처리하고 응답을 보낸다.\n이 또한 세 개의 다른 블록으로 나누어진 CRLF로 구분된 텍스트 지시자들로 이루어져 있다.HTTP/1.1 200 OK\nDate: Sat, 09 Oct 2010 14:28:02 GMT\nServer: Apache\nLast-Modified: Tue, 01 Dec 2009 20:18:22 GMT\nETag: \"51142bc1-7449-479b075b2891b\"\nAccept-Ranges: bytes\nContent-Length: 29769\nContent-Type: text/html &lt;!DOCTYPE html... (here comes the 29769 bytes of the requested web page) 첫번째 줄(상태줄) -&gt; HTTP 버전의 acknowledgment\n특정 HTTP헤더. 데이터에 관한 정보를 제공하고 이후 빈 줄로 끝나는 블록 형성\n마지막 블록 -&gt; 데이터가 있다면 데이터 블록\n<img src=\"https://i.imgur.com/QBkGMee.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">대부분 보이는 것들만 보인다","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"전형적인 HTTP 세션","level":2,"id":"전형적인_HTTP_세션_0"},{"heading":"연결","level":2,"id":"연결_0"},{"heading":"클라이언트 요청 전송","level":2,"id":"클라이언트_요청_전송_0"},{"heading":"요청 메서드","level":2,"id":"요청_메서드_0"},{"heading":"서버 응답 구조","level":2,"id":"서버_응답_구조_0"},{"heading":"성공 응답","level":2,"id":"성공_응답_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/http-세션.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":3838,"sourcePath":"학습 정리/Computer Science/HTTP 세션.md","exportPath":"학습-정리/computer-science/http-세션.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/http3.html":{"title":"HTTP3","icon":"","description":"HTTP/3은 HTTP/2 이후 새롭게 나온 개발 표준으로, 웹 브라우저와 서버가 통신하는 방식에 영향을 미치며, 성능, 안정성, 보안 등 사용자 경험을 크게 업그레이드했으며, 2022년 6월 6일 IETF(Internet Engineering Task Force) RFC 9114로 표준화되었다.1991년 최초의 하이퍼텍스트 전송 프로토콜(HTTP)이 출시된 후, 이후 여러 차례 새로운 버전을 내놓으면서 기본 코드를 변경하지 않고도 웹 사이트를&nbsp;더 빠르게&nbsp;만들 수 있었다.가장 중요한 차이점은 기존 TCP통신 방식의 HTTP/2와는 달리 UDP 기반의 QUIC 프로토콜을 사용하여 통신한다는 점이다.\nUDP(User Datagram Protocol)\n컴퓨터가 다른 컴퓨터와 데이터 통신을 하기 위한 프로토콜의 일종.\nOSI 모형(국제표준화기구가 개발한 네트워크 프로토콜 디자인 및 통신 계층)에서 전송 계층(Transport Layer)에서 사용하는 프로토콜이다.\nQUIC 프로토콜은 구글이 만든 프로토콜로, 닉값하듯이 빠른 속도를 자랑한다.\n훨씬 빠른 데이터 전송 속도를 자랑하며 더 많은 리소스를 병렬로 전송할 수 있다. 이 차이를 이해하기 위해서는 먼저 TCP의 Handshake에 대해 이해할 필요가 있다.TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정이다. 논리적인 접속을 성립시키기 위해 3-way handshake를 사용한다.<img src=\"https://i.imgur.com/G5Zsw5b.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">TCP는 PAR(Positive Acknowledgement with Re-transmission) 이라는 기능을 통해 안정적인 통신을 제공한다.전송 계층의 &nbsp;PDU(Protocol Data Unit)를 세그먼트라고 하는데, PAR을 사용하는 장치는 승인을 받을 때까지 세그먼트를 다시 보낸다.\n수신측에서 수신한 데이터 단위가 손상된 경우, 해당 세그먼트를 폐기하고 송신자는 다시 세그먼트를 보내야 한다.\n여기서 송신자는 클라이언트, 수신자는 서버를 의미한다\n이렇게 세그먼트를 보내는 과정에서 세 개의 세그먼트가 교환된다.<br><img src=\"https://i.imgur.com/adtHZnt.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nSYN(Synchronize sequence numbers)\n연결을 요청할 때 SYN bit를 1로 설정,\n나머지 경우에는 SYN bit를 0으로 설정한다. ACK: Acknowlegment\n패킷을 받았다는 응답을 할 때 사용한다.\nAcknowlegment Number가 유효한지 나타낸다. 1단계(SYN) : 클라이언트는 서버와 연결을 설정하기 위해 SYN이 포함된 세그먼트를 보낸다. 이 세그먼트에는 클라이언트가 통신을 시작할 것이라고 알리는 역할을 한다. SYN bit를 1로 설정하면서 통신을 시작할 것임을 알린다\nSYN 세그먼트를 전송 후 SYNSENT 상태로 서버의 ACK 세그먼트를 기다린다. 2단계(SYN + ACK) : 서버는 클라이언트의 요청인 SYN 세그먼트에 대한 ACK 세그먼트를 전송함과 동시에 서버가 클라이언트에 연결을 요청하는 SYN Segment를 전송한다. 클라이언트는 SYN + ACK 세그먼트를 전송하고 SYN RCVD 상태로 클라이언트의 ACK를 기다린다.\n클라이언트는 ACK 세그먼트를 받고 연결이 완료된 ESTAB 상태가 된다. 3단계(ACK): 클라이언트는 서버의 SYN 세그먼트에 대한 ACK 세그먼트를 전송하고, 실질적으로 믿을 수 있는 데이터 교환 연결이 성립된다. 서버는 ACK 세그먼트를 받고 연결이 완료된 ESTAB 상태가 된다. 암튼 TCP에서는 새 연결을 설정하기 위해서는 Handshake 과정이 필요하다.\n하지만 이러한 연결은 네트워크의 왕복이 필요하고, 여기서 지연이 발생할 가능성이 있다.\n그래서 QUIC의 경우는 위와 같은 3-way Handshake 대신 1-RTT/0-RTT 세션을 통해 더 빠른 연결을 제공한다.<br><img src=\"https://i.imgur.com/KvMf6e6.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">왕복 시간 없는 연결의 재시작을 지원한다.\n연결을 시작하면서 동시에 클라이언트가 바로 애플리케이션 데이터를 보낼 수 있다.\n3-Way-Handshake처럼 따로 세그먼트의 교환이 필요가 없어 네트워크 왕복이 필요없으며, 이에 따라 지연되는 시간 또한 없다.\n빠른 속도로 업데이트가 가능한 만큼, 라이브 트래픽에 주로 사용되며, 화상 회의나 게임 같은 곳에 유용하다.<br><img src=\"https://i.imgur.com/LUSot2s.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nTLS, TCP 및 QUIC의 Handshake 비교<br><img src=\"https://i.imgur.com/ICAzAHp.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">HTTP/2의 경우는 TLS(Transport Layer Security)를 사용하여 데이터를 암호화하지만, HTTP/3의 경우는 QUIC에 내장된 TLS 암호화를 사용하기 때문에 보안이 기본적으로 내장되어 있다. <br><img src=\"https://i.imgur.com/DvldmyC.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">또한 별도의 TLS Handshake 없이 보안 연결을 설정할 수 있기 때문에 패킷 헤더와 pyaload에서의 전송 계층 메타데이터도 암호화되기 때문에 여러 이점을 가진다.\n더 빠른 속도\n전송 및 암호화 Handshake를 하나로 결합하여 왕복 시간 절약과 함께 보안성 향상\n완전히 암호화되어 네트워크의 미들박스가 내부 작동을 관찰하고 해석할 수 없다. 따라서 업데이트가 어려운 미들 박스 대신 최종 장치만 업데이트하면 되어 보다 업데이트가 용이하다. 미들박스\n서로 통신하는 두 개의 최종 호스트 사이 경로에 있는 네트워크 내 디바이스로, TCP 연결의 경우 전송 중인 패킷 스크림을 모니터링, 필어틸, 변환이 가능하다. HTTP/1.1에서는 리소스 로딩 프로세스에서 각 파일 자체에 대해 TCP연결이 제공되었고 각각의 연결에 오버헤드가 있었기 때문에 비효율적이었다.HTTP/2에서는 이를 개선하고자 단일 TCP 연결을 통해 다양한 리소스들을 다운로드하는 바이트 스트림의 Multiplexing을 이용하였다.<br><img src=\"https://i.imgur.com/UV6mW83.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이렇게 HTTP/1.1에서는 각 파일마다 TCP 연결 제공되었기 때문에 하나씩 순서대로 다운로드할 수밖에 없었다.하지만 HTTP/2의 경우 이렇게 각각의 파일에 대해 조금씩 혼합하여 다운로드받기 때문에 HTTP/1.1보다 속도도 조금 낫도 오버헤드가 훨씬 낮다는 장점이 있다.하지만 여기엔 TCP에 문제가 있는데, 여러 파일을 전송하지만 TCP는 이를 단일 파일 하나를 전송한다고 생각하기 때문에 중간에 데이터 패킷에 손실이 나면 하나만 안 뜨는게 아니라 이후의 파일들도 처리되지 못해 속도가 급격히 느려지는 현상이 나타난다. 이러한 현상을 HOL(Head-Of-Line) Blocking 문제라고 한다.이러한 문제를 해결하는 것이 QUIC의 과제였는데 QUIC는 스트림 별로 패킷 손실 감지 및 복구 로직을 수행할수 있게 만듦으로써 HOL Blocking 문제를 해결하였다.<br><img src=\"https://i.imgur.com/mYUOiDV.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이런 식으로 손실된 데이터 패킷만 따로 빼놓고 복구시킴으로써 다른 데이터 패킷들이 다운로드 받을 수 있다.\n1인용 에스컬레이터는 한 명이 꿋꿋하게 서 있으면 뒤에 있는 사람들은 걸어서 못 올라간다.\n하지만 2인용 에스컬레이터는 한 줄로 서있는 줄과 따로 걸어서 올라가는 줄이 있어 한 줄이 막고 있어도 다른 줄로 걸어올라가면 된다.\n이와 같은 차이라고 생각하면 될 것 같다.\nQUIC의 연결은 TCP 연결보다 더 오래 지속될 수 있다.\n이 이유에 대해 알기 위해서는 패킷이 연결되어 어떻게 목적지까지 전송되는 지에 대해서 알아야 한다. 인터넷에서 IP 주소는 두 개의 고유한 시스템 간에 패킷을 라우팅하는데 사용된다. 하지만 이 두 IP만 있어서는 충분하지 않다. 각 끝에서 동시에 여러 네트워크 프로그램을 실행할 수 있어야 하기 때문이다.기존 TCP 연결에서 이러한 시스템과 애플리케이션 전반에 걸쳐 고유한 연결을 정의하기 위해서는 클라이언트 IP 주소 + 클라이언트 포트 + 서버 IP주소 + 서버 포트 4가지로 이루어진 4-tuple이 필요하다.하지만 문제는 이 4-tuple 중 하나만 바뀌어도 연결은 무효화되고 새로 설정되어야 한다는 점이다. 여기서 parking-lot 문제라고 하는게 생긴다.<br><img src=\"https://i.imgur.com/hvCxieJ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">내가 집에서는 와이파이를 쓰기 때문에 클라이언트 IP 주소가 와이파이 IP 주소로 설정되어 있지만 주차장으로 가면 데이터로 바뀌기 때문에 클라이언트 IP 주소가 바뀌게 된다.\n클라이언트 IP 주소가 바뀌게 되면 또 새롭게 연결을 시도해야 하는 것이다.게다가 TCP 연결 자체가 워낙 오래된 연결이다보니 이러한 새로운 연결이 이루어졌다는 사실 조차 알 수 없으며, 기존의 연결조차 닫는 방법이 없다.결국 새로운 Handshake를 실행해야 하기 때문에 애플리케이션 수준 프로토콜에 따라 진행중인 작업 또한 다시 시작해야 한다. 파일 다운로드 같은 경우에도 다시 요청해야 하는 경우도 생기는 것이다.QUIC는 이러한 문제를 해결하기 위해 연결 식별자(CID, Connection ID)이라는 개념을 신규 도입한다. 기존의 4-Tuple 위에 다른 번호가 추가적으로 할당된다.이 CID는 QUIC 자체 전송 계층에서 정의되어 네트워크 간 이동시 변경되지 않는다. <br><img src=\"https://i.imgur.com/u45hExv.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이런 식으로 CID를 통해 네트워크가 달라져도 연결은 변동이 없는 것이다.\nQUIC 서버와 클라이언트는 CID만 보고 같은 연결인지 확인하기 때문이다. 이러한 기능을 연결 마이그레이션(Connection Migration) 이라고 한다.하지만 이렇게 같은 CID만 사용하면 네트워크를 통해 해커들이 사용자 추적과 물리적 위치 추론 등을 할 수 있기 용이하기 때문에 새 네트워크가 사용될 때마다 CID를 변경해야 할 필요성이 있다.그렇다면 어떻게 하느냐<br><img src=\"https://i.imgur.com/7W7cvdM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">동일한 개념적 연결에 매핑되는 무작위 CID를 생성하면 된다.\n연결을 X라고 하면 연결 X에 매핑되는 CID A,B,C,D... 등을 계속해서 만들어내면 되는 것이다.\n이렇게 하면 공격을 시도하는 사람은 이러한 CID가 X라는 것을 알지 못하지만 클라이언트와 서버는 이를 알고 연결을 계속 유지할 수 있다.유연성과 발전 가능성과 같은 경우는 위에서도 하나 언급했다시피 미들박스가 아닌 엔드포인트(클라이언트 및 서버)만 업데이트하면 되어 보다 업데이트가 용이하다는 장점이 있다.추가적으로 유연성과 발전 가능성을 가지는 이유가 하나 더 있다.\nTCP와 달리 QUIC는 모든 프로토콜 메타 데이터를 전송하기 위해 단일 고정 패킷 헤더를 사용하지 않는다. 대신 QUIC는 짧은 패킷 헤더를 가지고 패킷 페이로드 내부의 다양한 프레임(소형 특수 패킷)을 사용하여 추가 정보를 전달한다.<br><img src=\"https://i.imgur.com/JYOcfk8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이렇게 프레임을 사용하여 정보를 전달할 경우 최적화가 가능해 보다 바이트를 절약할 수 있으며 프레임 사용으로 미래에 QUIC를 확장하면서 새로운 프레임 유형을 정의하는 것이 쉽다는 점이 장점이다.추가적으로, QUIC은 사용자 정의 Transport Parameter라는 TLS 확장을 사용한다. 이를 통해 클라이언트와 서버는 QUIC 연결에 대한 구성을 선택할 수 있다. 즉, 어떤 기능을 활성화하고 기본값을 따로 정의함으로써 프로토콜을 유연하게 만드는 것이다. 이러한 구현은 또한 사용자 공간에 수행되어 'kernel spance(커널 공간)'에서 수행되는 TCP보다 QUIC 구현 변형 및 확장의 실험 및 배포가 훨씬 쉽다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.geeksforgeeks.org/tcp-3-way-handshake-process/\" target=\"_self\">https://www.geeksforgeeks.org/tcp-3-way-handshake-process/</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake\" target=\"_self\">https://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.mozilla.org/ko/docs/Glossary/TCP_handshake\" target=\"_self\">https://developer.mozilla.org/ko/docs/Glossary/TCP_handshake</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://hojunking.tistory.com/106\" target=\"_self\">https://hojunking.tistory.com/106</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/\" target=\"_self\">https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"HTTP3란?","level":2,"id":"HTTP3란?_0"},{"heading":"HTTP/2와의 차이점","level":2,"id":"HTTP/2와의_차이점_0"},{"heading":"빠른 속도","level":3,"id":"빠른_속도_0"},{"heading":"TCP의 3-Way Handshake","level":4,"id":"TCP의_3-Way_Handshake_0"},{"heading":"메커니즘","level":5,"id":"메커니즘_0"},{"heading":"돌아와서..","level":4,"id":"돌아와서.._0"},{"heading":"QUIC 0-RTT","level":4,"id":"QUIC_0-RTT_0"},{"heading":"보안","level":3,"id":"보안_0"},{"heading":"다중화(Multiplexing)","level":3,"id":"다중화(Multiplexing)_0"},{"heading":"연결 마이그레이션(Connection Migration)","level":3,"id":"연결_마이그레이션(Connection_Migration)_0"},{"heading":"유연성과 발전 가능성","level":3,"id":"유연성과_발전_가능성_0"},{"heading":"참고자료","level":3,"id":"참고자료_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/http3.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":12828,"sourcePath":"학습 정리/Computer Science/HTTP3.md","exportPath":"학습-정리/computer-science/http3.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/osi-7-layer.html":{"title":"OSI 7 Layer","icon":"","description":"OSI(Open Systems Interconnection) 모델은 한국어로 번역하면 오픈 시스템 상호 연결 모델로, 네트워크 통신 기능을 7개의 계층으로 가누는 개념적인 프레임워크이다.\n이 데이터 모델은 컴퓨터간 네트워킹을 위한 범용 언어를 제공하기 때문에 다양한 기술이 표준 프로토콜/통신 규칙을 사용하여 통신할 수 있다.\n각 계층별로 모든 유형의 네트워크 통신 기술이 캡슐화되어 특정 기능을 제공하고 이를 네트워킹에 유용하게 사용할 수 있으며, 흐름을 한 눈에 알아보고 이해하기 쉽다.<img src=\"https://i.imgur.com/YD36UjY.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n각 계층은 독립적으로 작용하며, 해당 계층에 맞는 프로토콜이 각각 존재한다.<br>\n<img src=\"https://i.imgur.com/yzjxdAQ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이 프로토콜에 의해서 하위 계층으로 갈 수록 헤더가 붙으면서 데이터의 크기는 점점 커진다.비트 단위로 데이터가 이루어져 있으며, 네트워크 케이블과 신호에 관한 규칙을 다루고 있다.\n통신 케이블의 종류와 신호의 규격 및 무선통신 주파수 설정, 커넥터 형태 등을 정한다.\n관련된 장비로는 동축 케이블의 아날로그 신호를 디지털 데이터로 변환하는 모뎀, 다수의 컴퓨터를 연결하여 하나의 네트워크로 보내는 허브, 디지털 신호를 증폭해주는 리피터 등이 있다.\n이 계층에서는 통신 케이블을 통해 데이터를 전송만 하는 기능만 하므로, 어떤 데이터인지나 에러에 대해서는 신경쓰지 않는다.물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할로, 통신에서의 에러 검출, 재전송, 흐름 제어(충돌 점검)의 기능을 가지고 있다.\n이 계층에서는 MAC 주소를 가지고 통신하게 되며, 이 계층에서 전송되는 단위를 프레임이라고 한다.대표적인 장비로는 브리지, 스위치 등이 있어 이러한 장비를 통해 MAC 주소를 가지고 물리계층에서 받은 정보를 전달한다.\nMAC 주소(Media Access Control Address)\n네트워크 인터페이스에 할당된 물리적 고유 식별 주소\n데이터를 목적지까지 가장 안전하고 빠르게 전달하는 라우팅의 기능을 가진 계층이다.\n해당 계층의 데이터 단위는 패킷(packet)으로, 경로와 주소를 정하고 경로에 따라 패킷을 전달해 주는 것이 이 계층의 역할이다. 이를 통해 데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능해진다.대표적인 장비는 라우터이며, 최상위 계층으로 데이터를 전송하는 최적의 경로를 찾아 설정하고, 청구 정보를 관리한다.\n해당 계층에서는 논리적 주소인 IP 주소를 사용하면서 전송 계층에서 요구하는 서비스 품질(Qos)을 위한 수단을 제공한다.전송 계층은 서비스를 구분하고 사용자 사이의 신뢰성있는 데이터 전달은 담당하는 계층이다.\n해당 계층의 프로토콜에는 신뢰성있는 데이터 전송이 목적인 TCP(Transmission Control Protocol)와 빠른 데이터 전송이 목적인 UDP(User Datagram Protocol)가 있다.TCP의 경우 세그먼트(Segment)라는 데이터 단위를 사용하며 UDP는 데이터그램(Datagram) 이라는 데이터 단위를 사용한다.TCP는 세그먼트를 작은 패킷으로 나눠 여러 경로를 통해 데이터를 전송하고 목적지에서 순서대로 패킷을 조립하여 데이터를 전달하는 반면, 데이터그램은 순서에 상관없이 데이터를 전달하기 때문에 신뢰성이 없다.세션 계층은 데이터가 통신하기 위한 논리적인 연결을 의미하며, 일종의 통신수단, 대화통로 등으로 볼 수 있다.\n데이터의 송수신 타이밍과 방법이 해당 계층에서 규정되며, 세션 설정, 유지, 종료, 전송 중단시 복구 등의 기능을 한다.\n해당 계층을 통해 TCP/IP 세션을 만들고 없애는 책임을 진다.표현 계층은 전송되는 정보의 구문(Syntax) 및 의미(Semantics)에 관여하는 계층으로, 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고 암호화한다.\n따라서 인코딩(Encoding), 데이터 압축(Compression), 암호화(Cryptography) 등 주요한 동작을 수행한다.\n파일의 확장자(txt, jpeg, mp4, html 등)는 이 계층과 관련된 프로토콜이다.응용 서비스를 수행하고 사용자 인터페이스를 제공하는 계층으로, HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다.\n해당 통신 패킷들은 방금 나열한 프로토콜에 의해 모두 처리되며 우리가 사용하는 브라우저나, 메일 프로그램은 프로토콜을&nbsp;보다 쉽게 사용하게 해주는 응용프로그램이다. 한마디로 모든 통신의 양 끝단은 HTTP와 같은 프로토콜이지 응용프로그램이 아니다.\n복잡한 시스템에 대한 이해 공유 복잡한 네트워크 시스템 아키텍쳐를 구성하고 모델링이 가능\n주요 기능에 따라 각 시스템 구성 요소의 운영 계층 분리\n추상화를 통해 시스템을 분해하여 사람들이 시스템을 전체적으로 개념화하는 것을 쉽게 만듦 더 빠른 연구 및 개발 엔지니어가 새로운 시스템을 만들 때 OSI 모델의 어떤 계층을 대상으로 개발하는지 알고 개발하기 때문에 이에 대한 이해도를 기반으로 더 빠른 연구 및 개발이 가능 유연한 표준화 네트워크 통신 개발을 표준화하여 시스템에 대한 사전 지식 없이도 복잡한 시스템을 이해, 구축 및 분해 가능 <br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://shlee0882.tistory.com/110\" target=\"_self\">https://shlee0882.tistory.com/110</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://huimang2.github.io/etc/iso-standard-7498\" target=\"_self\">https://huimang2.github.io/etc/iso-standard-7498</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://aws.amazon.com/ko/what-is/osi-model/\" target=\"_self\">https://aws.amazon.com/ko/what-is/osi-model/</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"OSI 7 Layer란?","level":1,"id":"OSI_7_Layer란?_0"},{"heading":"7개의 계층","level":2,"id":"7개의_계층_0"},{"heading":"물리 계층(Physical Layer)","level":3,"id":"물리_계층(Physical_Layer)_0"},{"heading":"데이터 링크 계층(DataLink Layer)","level":3,"id":"데이터_링크_계층(DataLink_Layer)_0"},{"heading":"네트워크 계층(Network Layer)","level":3,"id":"네트워크_계층(Network_Layer)_0"},{"heading":"전송 계층(Transport Layer)","level":3,"id":"전송_계층(Transport_Layer)_0"},{"heading":"세션 계층(Session Layer)","level":3,"id":"세션_계층(Session_Layer)_0"},{"heading":"표현 계층(Presentation Layer)","level":3,"id":"표현_계층(Presentation_Layer)_0"},{"heading":"애플리케이션 계층(Application Layer)","level":3,"id":"애플리케이션_계층(Application_Layer)_0"},{"heading":"OSI 모델의 장점","level":2,"id":"OSI_모델의_장점_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/osi-7-layer.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058393,"modifiedTime":1725254058393,"sourceSize":6352,"sourcePath":"학습 정리/Computer Science/OSI 7 Layer.md","exportPath":"학습-정리/computer-science/osi-7-layer.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/tcp-ip.html":{"title":"TCP-IP","icon":"","description":"전송프로토콜 TCP(Tansmission Control Protocol)와 인터넷 프로토콜(Internet Protocol)을 합친 말. 인터넷 &amp; 이와 유사한 컴퓨터 네트워크 사이에서 정보를 주고받는데 이용되는 통신 프로토콜의 모음으로, 온라인상의 안전하고 효율적인 데이터 전송의 표준화된 요건이다.TCP는 한 기기에서 다른 기기로 데이터를 전송할 때 필요한 표준 요건이라면, IP는 데이터들을 최대한 빨리 대상 IP 주소로 보내는 역할을 위한 표준 요건이다. 이러한 TCP/IP는 공통적으로 온라인상의 안전하고 효율적인 데이터를 전송한다는 공통적 결과를 목표로 하기 때문에 합쳐져 사용된다. 이러한 TCP/IP가 규칙이나 프로토콜이 적용되는 조건 하에서 세워진 통신과 데이터 전송의 방식이 4가지의 계층으로 나누어진다.<img src=\"https://i.imgur.com/U7Ok7UJ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n사용자가 상호작용하기 가장 쉬운 계층\n사용자가 네트워크에 접근할 수 있는 인터페이스 제공\n종류 메일 -&gt; SMPT(Simple Mail Transfter Protocol)\n인터넷 브라우저 -&gt; HTTP(Hypertext Transfer Protocol)\n파일 전송 -&gt; FTP(File Transfer Protocol)\n동적 호스트 설정 통신 -&gt; DHCP(Dynamic host Configuration protocol)\n간이 망 관리 -&gt; SNMP(Simple Network Management Protocol)\n도메인 -&gt; DNS(Domain Name System) 데이터의 전송을 담당하는 계층으로,TCP 뿐만 아니라 사용자 데이터그램 통신 규약(User Datagram Protocol: UDP)도 있음\nTCP는 두 네트워크 사이에 연결을 형성하고 효율적 작업을 위해 데이터를 작은 패킷으로 나눠서 데이터를 전송\n데이터의 전달을 보증하고 보낸 순서대로 받게해줌\u001e\n- 순서가 맞지 않거나 중간에 뭐가 빠졌으면 점검 요청\n\\ IP뿐만 아니라 주소 변환 규약(Address Resolution Protocol: ARP) 인터넷 그룹 관리 프로토콜(Internet Group Management Protocol: IGMP)\\\n인터넷 제어 메세지 프로토콜(Internet Control Message Protocol: ICMP)도 있음 데이터의 원천지(origin)와 목적지에 관한 정보 첨부\n패킷 전달 여부를 보증하지 않고, 어떻게든 빨리 보내야 함 데이터 전송의 최하위 계층\n데이터가 원하는 IP 주소에 도달할 뿐만 아니라 해당 네트워크 내의 연결된 기기에 연결되어 있는지 확인\n원하는 기기의 MAC 주소를 확인하고 이더넷 케이블 및 와이파이를 통한 데이터 전송 관리 등의 작업 담당\n<br><img src=\"https://i.imgur.com/YHmZe4I.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n송신측 클라이언트의 애플리케이션 계층에서 어느 웹 페이지를 보고 싶다라는 HTTP 요청을 지시\n그 다음에 있는 트랜스포트 계층에서는 애플리케이션 계층에서 받은 데이터(HTTP 메시지)를 통신하기 쉽게 조각내어 안내 번호와 포트 번호(TCP 패킷)를 붙여 네트워크 계층에 전달\n네트워크 계층에서 데이터에 IP 패킷을 추가해서 링크 계층에 전달\n링크 계층에서는 수신지 MAC 주소와 이더넷 프레임을 추가\n이로써 네트워크를 통해 송신할 준비가 됨\n수신측 서버는 링크 계층에서 데이터를 받아들여 순서대로 위의 계층에 전달하여 애플리케이션 계층까지 도달\n수신측 애플리케이션 계층에 도달하게 되면 클라이언트가 발신했던 HTTP 리퀘스트를 수신할 수 있다. 시스템 사이에서 파일 전송\n원격 시스템에 로그인\n원격 시스템에서 명령 실행\n원격 시스템에 파일 인쇄\n원격 사용자에 이메일 전송\n원격 사용자와 대화식 통신\n네트워크 관리 패킷 데이터의 전달을 보증하고 보낸 순서대로 받게 해준다\n도착한 조각을 점검하여 줄을 세우고 망가졌거나 빠진 조각을 다시 요청하는 식으로 순서를 보증.\nTCP는 데이터를 상대방에게 확실하게 보내기 위해서&nbsp;3 way 핸드쉐이킹이라는 방법을 사용하고 있다. 이 방법은 패킷을 보내고 잘 보내졌는지 여부를 상대에게 확인하러 간다.\n여기에서 고유의 'SYN'와 'ACK'라는 TCP 플래그를 사용한다. (일종의 확인 마크 정도로 이해하면 된다)\n한마디로 TCP는 IP의 문제를 보완해주는 녀석이라고 보면 된다.\n상대 클라이언트와 연결되기 전에 가상 연결을 하여 패킷으로 보내 확인하는 동작<br>\n<img src=\"https://i.imgur.com/JftQwrz.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n클라이언트 -&gt; 서버 SYN : 연결을 생성할 때 클라이엍느가 서버에 시퀀스 번호를 보냄 서버 -&gt; 클라이언트 SYN-ACK : 시퀀스 번호를 받은 서버가 ACK 값을 생성하여 클라이언트에게 응답 다시 클라인언트 -&gt; 서버 ACK : ACK 값을 사용하여 응답하는 패킷\n데이터 패킷 이후: 클라이언트 -&gt; 서버 데이터 패킷 전송 <br><img src=\"https://i.imgur.com/yNrYr50.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">3 way shake에서 통신을 마칠 때 거치는 과정이 추가된 버전이다.<br><img src=\"https://i.imgur.com/Ir6TBSH.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nSegment에 있는&nbsp;첫 번째 바이트의 바이트 스트림 번호 TCP는 데이터를 단지 순서대로 정렬되어 있는 바이트 스트림으로 본다.\nex) 0~999, 1000~1999의 Segment를 보낼 때 seq# = 각각 0, 1000 TCP 연결, 종료 시에는&nbsp;Sequence Number를 임의의 랜덤 값으로 설정한다. Sequence Number가 노출되면 공격자가 위조 패킷을 보낼 수 있어 보안을 위해 랜덤 값으로 설정한다. 받고 싶은 다음 바이트 번호 ex) 0~999, 1000~1999의 Segment를 받았을 때 ack# = 각각 1000, 2000 ACK(Acknowledgement) 패킷을 받았다는 응답을 할 때 사용\nAcknowledgement Number의 유효성\n최초 연결의 첫 번째 세그먼트를 제외한 모든 Segment의 ACK 비트는 1로 설정 FIN(Finish) TCP 연결을 종료할 때 사용\n더 이상 전송할 데이터가 없음을 의미 RST(Reset) TCP 연결을 강제로 종료할 때 사용\n비 정상적인 세션 연결 끊기에 해당\n연결을 즉시 끊고자 할 때 사용 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"TCP/IP란?","level":1,"id":"TCP/IP란?_0"},{"heading":"TCP/IP의 4계층","level":2,"id":"TCP/IP의_4계층_0"},{"heading":"응용 계층","level":3,"id":"응용_계층_0"},{"heading":"전송 계층","level":3,"id":"전송_계층_0"},{"heading":"인터넷 계층","level":3,"id":"인터넷_계층_0"},{"heading":"네트워크 인터페이스 계층","level":3,"id":"네트워크_인터페이스_계층_0"},{"heading":"TCP/IP 4계층 동작 순서","level":2,"id":"TCP/IP_4계층_동작_순서_0"},{"heading":"TCP IP 기능","level":2,"id":"TCP_IP_기능_0"},{"heading":"TCP 의 전송 제어 방식","level":2,"id":"TCP_의_전송_제어_방식_0"},{"heading":"TCP 3 way handshake","level":2,"id":"TCP_3_way_handshake_0"},{"heading":"4-Way-handShake","level":2,"id":"4-Way-handShake_0"},{"heading":"4-Way-Handshake에서 사용되는 TCP 헤더 필드","level":3,"id":"4-Way-Handshake에서_사용되는_TCP_헤더_필드_0"},{"heading":"Sequence Number","level":4,"id":"Sequence_Number_0"},{"heading":"Acknowledgement Number","level":4,"id":"Acknowledgement_Number_0"},{"heading":"Control bits","level":4,"id":"Control_bits_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/tcp-ip.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058395,"modifiedTime":1725254058395,"sourceSize":6687,"sourcePath":"학습 정리/Computer Science/TCP-IP.md","exportPath":"학습-정리/computer-science/tcp-ip.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/computer-science/telnet과-ssh.html":{"title":"TELNET과 SSH","icon":"","description":"로컬 영역이나 인터넷에 있는 원격 시스템의 가상 터미널을 제공하는 클라이언트와 서버간 응용 프로토콜\nTelnet(텔넷)을 이용하면 네트워크에 있는 컴퓨터를 자신의&nbsp;컴퓨터처럼 파일 전송, 파일 생성, 디렉토리 생성 등을 자유롭게 할 수 있다.Telnet 클라이언트는 사용자의 컴퓨터에 실행되며, 원격 서버에 접속하여 커맨드를 전송하고 결과를 받아옵니다. 이를 통해 원격 컴퓨터에서 마치 로컬 컴퓨터에서 작업하는 것처럼 명령어를 실행할 수 있습니다.\nTCP/IP 기반의 프로토콜\n원격 터미널 접속 서비스\nTCP 23번 포트(Default)\n보안성을 위해 사용자가 포트 변경 가능 보안에 취약 Telnet은 데이터를 암호화하지 않고&nbsp;평문(바이트 스트림) 으로 전송하기 때문에 네트워크 상에서&nbsp;데이터가 노출되거나 가로채질 위험이 있음\n또한 사용자 인증 정보(예: 비밀번호)도 평문으로 전송되어 보안 위험이 있음 기능적 부족 원격 작업을 위한&nbsp;기본적인 기능만 제공하며, 고급 기능이나 파일 전송 등의 다양한 기능을 제공하지 않습니다. 이러한 이유로, 현재는 대부분의 경우 SSH(Secure Shell)와 같은 보안이 강화된 프로토콜을 사용한다.SSH(Secure Shell)은 다른 사용자가 세션을 엿듣지 못하도록 세션을 감싸주는 Telnet 응용프로그램으로 보안버전의 프로그램이다. TCP 상에 보안 채널(터널링)을 형성하여 안전한 데이터 교환이 이루어질 수 있도록 만든 버전이다.패스워드와 같은 민감정보들이 암호화된 채로 전송되기 때문에 보안에 적합하며, 기본포트번호는 22번을 사용한다. 보안 과정에서 SSH는 기존 telnet과는 다르게 KEY를 사용하여 연결 상대를 인증하고 안전하게 데이터를 주고받을 수 있도록 한다. 이 KEY를 생성하는 방식은 두 가지가 있는데, '대칭키'와 '비대칭키(공개키)' 를 사용한다.맨 처음 접속을 하는 과정에서 사용자와 서버는 서로의 정체를 증명해야 한다. 여기서 사용되는 것이 비대칭키 방식이다.\n비대칭키에서는 서버나 사용자가 Key pair 를 생성한다. 이 키 페어는 공개 키(public key)와 개인 키(Private Key)로 이루어져 있으며, 공개키는 .pub / 개인 키는 .pem 의 파일 형식을 가진다.여기서 중요한 점은 공개 키가는 누구나 가질 수 있지만, 개인 키는 공개 키 하나에 1:1 매핑되어있는 관계이기 때문에 함께 생성된 개인 키와 공개 키만 서로 해석이 가능하다.따라서 서버는 사용자로부터 전송받은 공개 키를 자신이 가지는 개인 키와 비교하고, 두 값이 같게 되면 서버는 자신이 기억하고 있는 사용자가 맞음을 판단하고 접속을 허용해주게 되는 것이다. 이러한 방식으로 최초 접속 시에 인증 절차가 완료된다.대칭키의 경우는 비대칭키를 통해 사용자와 서버 간의 인증이 완료된 후, 데이터를 주고받을 때 사용되는 키 방식이다.\n대칭키 방식에서는 비대칭키 방식과 달리 하나의 대칭 키만을 사용하는데, 이 대칭 키는 사용자와 서버가 각자 만들어 공유한다.\n이 공유하는 대칭 키로 사용자가 데이터를 암호화해서 전송하면, 서버에선 이 대칭키를 똑같이 사용해서 암호를 푼 다음 데이터를 얻을 수 있다.\n이러한 대칭 키는 정보 교환때마다 계속해서 갱신된다.두 프로토콜의 차이점은 로그인, 프로그램 실행, 하드디스크 체크, 로그아웃 등의 작업에서 이루어지는 사용자와 서버간의 통신 방법이다.\n사용자는 어떤 작업을 서버에 알려주기 위해 네트워크를 통해 TCP/IP 패킷정보를 전달하고 결과값을 다시 서버에서 받게 되는데, 이 과정에서 telnet은 정보를 byteStream으로 받지만, SSH의 경우는 DES, RSA 등 고급 암호화를 통해 통신을 하여 보안에 가장 큰 차이점이 있다.\n하지만 이 과정에서 SSH가 조금 더 많은 오버헤드가 발생한다는 점이 있지만, 보안을 보완해준다는 점에서 이러한 단점을 상쇄한다.<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@jeongbeom4693/SSH%EC%99%80-Telnet\" target=\"_self\">https://velog.io/@jeongbeom4693/SSH%EC%99%80-Telnet</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://dev-kwon.tistory.com/88\" target=\"_self\">https://dev-kwon.tistory.com/88</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@froajnzd/%EC%9B%90%EA%B2%A9-%EC%A0%91%EC%86%8D%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95-2%EA%B0%80%EC%A7%80-SSH-TELNET\" target=\"_self\">https://velog.io/@froajnzd/%EC%9B%90%EA%B2%A9-%EC%A0%91%EC%86%8D%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95-2%EA%B0%80%EC%A7%80-SSH-TELNET</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"TELNET이란?","level":1,"id":"TELNET이란?_0"},{"heading":"특징","level":2,"id":"특징_0"},{"heading":"취약점","level":2,"id":"취약점_0"},{"heading":"SSH란?","level":1,"id":"SSH란?_0"},{"heading":"대칭키와 비대칭키","level":2,"id":"대칭키와_비대칭키_0"},{"heading":"비대칭키","level":3,"id":"비대칭키_0"},{"heading":"대칭키","level":3,"id":"대칭키_0"},{"heading":"Telnet과 SSH의 차이점","level":2,"id":"Telnet과_SSH의_차이점_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/computer-science/telnet과-ssh.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058395,"modifiedTime":1725254058395,"sourceSize":4801,"sourcePath":"학습 정리/Computer Science/TELNET과 SSH.md","exportPath":"학습-정리/computer-science/telnet과-ssh.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/design-pattern/design-pattern.html":{"title":"Design Pattern","icon":"","description":"\n<a data-href=\"fsd 패턴\" href=\"https://alsgud8311.github.io/학습-정리/design-pattern/fsd-패턴.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">fsd 패턴</a>\n<br><a data-href=\"MVC패턴\" href=\"https://alsgud8311.github.io/학습-정리/design-pattern/mvc패턴.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">MVC패턴</a>\n<br><a data-href=\"Observer 패턴\" href=\"https://alsgud8311.github.io/학습-정리/design-pattern/observer-패턴.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Observer 패턴</a>\n<br><a data-href=\"Pub-Sub 패턴\" href=\"https://alsgud8311.github.io/학습-정리/design-pattern/pub-sub-패턴.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Pub-Sub 패턴</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["학습-정리/design-pattern/fsd-패턴.html#_0","학습-정리/design-pattern/mvc패턴.html#_0","학습-정리/design-pattern/observer-패턴.html#_0","학습-정리/design-pattern/pub-sub-패턴.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/design-pattern/design-pattern.html","pathToRoot":"../..","attachments":[],"createdTime":1738514624127,"modifiedTime":1738514638466,"sourceSize":76,"sourcePath":"학습 정리/Design Pattern/Design Pattern.md","exportPath":"학습-정리/design-pattern/design-pattern.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/design-pattern/fsd-패턴.html":{"title":"fsd 패턴","icon":"","description":"기능 분할 설계(Feature-sliced Design, FSD)는 모듈 간의 느슨한 결합과 높은 응집력을 제공할 수 있으며, 쉽게 확장할 수 있는 아키텍처이다.\n<img src=\"https://i.imgur.com/tO9yswk.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n이러한 패턴은 세 가지 구분 개념이 있다.\n이러한 세 가지 구분 개념이 곧 depth를 의미하기 때문에 이는 곧 디렉토리의 depth는 3으로 제한됨을 의미한다.\n그렇다면 이 가장 상위의 디렉토리들을 중심으로 어떻게 애플리케이션이 구성될까?\n이전에 가장 최상위의 layer부터 알아보자\napp 애플리케이션 로직이 초기화되는 곳\n프로바이더, 라우터, 전역 스타일, 전역 타입 선언 등\n애플리케이션의 진입점 역할 processes(depricated) 이 레이어는 여러 단계로 이루어진 등록과 같이 여러 페이지에 걸쳐 있는 프로세스를 처리\n이 레이어는 더 이상 사용되지 않는 것으로 간주되지만 여전히 가끔씩 마주할 수 있습니다. 선택적 레이어입니다. pages 애플리케이션 각각의 페이지 widgets 페이지에 사용되는 독립적인 UI 컴포넌트\nentities가 모인 것들 features 이 레이어는 비즈니스 가치를 전달하는 사용자 시나리오와 기능\n각 이벤트들을 담당하는 로직\n선택적 레이어 entities 비즈니스 엔티티\n사용자, 리뷰, 댓글 등과 같이 분리할 수 있는 컴\u001e포넌트\n핵심 도메인 모델과 비즈니스 로직을 담고 있음 shared 이 레이어에는 특정 비즈니스 로직에 종속되지 않은 재사용 가능한 컴포넌트와 유틸리티\n여기에는 UI 키트, axios 설정, 애플리케이션 설정, 비즈니스 로직에 묶이지 않은 헬퍼 등 각각 7개의 디렉토리들은 기능적으로 세분화되어 각자의 역할을 담당하고, 이러한 요소들이 계층적인 구조를 가지기 때문에 한 방향으로만 흐르는 linear flow를 유지한다. 즉, 위의 사진에서 하나의 layer는 자기 자신을 가리키는 layer 아래의 layer들만 참조 가능하다.\n이러한 여러 layer들이 계층 구조를 유지하면서 서로 약한 의존 관계를 가진 상태로하나로 점점 합쳐져 하나의 app이 완성되는 구조인데, 이 점이 FSD의 핵심이자 가장 중요한 법칙이다<br>\n<img src=\"https://i.imgur.com/CREMf65.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>\n<img src=\"https://i.imgur.com/iJJFpxc.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n추상화한다면 위의 사진과 같이\nshared(재사용한 컴포넌트들)\n-&gt; entities(독립된 컴포넌트들)\n-&gt; features(각 컴포넌트의 기능을 명시한 script)\n-&gt; widgets(컴포넌트들이 모여 만든 하나의 큰 컴포넌트 단위)\n-&gt; pages(큰 컴포넌트들이 모여 만든 하나의 페이지)\n-&gt; app(entry point)\n의 순서로 하나의 큰 애플리케이션을 위해 계층적으로 올라가면서 결국 마지막엔 이 모든 것이 합쳐진 하나의 애플리케이션이 완성되는 구조이다.각자 레이어들 안에는 서브 디렉토리가 존재하는데, 이를 slice라고 한다.\nslice는 주로 도메인 별로 나눈다.\n슬라이스는 특정 엔티티에 대해서 코드를 그룹화 하는데, 추상적인 것에 대한 연결이 아닌 명확한 비즈니스 개체에 대한 연결이 존재하고 이를 코드의 가치에 따라 그룹화한다.<br>\n<img src=\"https://i.imgur.com/yVam9En.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n이와 같이 필요한 값에 대해서 독립적으로 다룰 수 있는 디렉토리를 생성한다.각 슬라이스는 세그먼트로 구성되며 목적에 따라 슬라이스 내의 코드를 나누는데 도움이 될 수 있다.\napi - 필요한 서버 요청 및 데이터 타입, mapper 등\nUI - 슬라이스의 UI 컴포넌트.\nmodel - 비즈니스 로직, 즉 상태와의 상호 작용. actions 및 selectors가 이에 해당\nlib - 슬라이스 내에서 사용되는 보조 기능(유틸함수들)\nconfig - 슬라이스에 필요한 구성값이지만 구성 세그먼트는 거의 필요하지 않음.\nconsants - 필요한 상수.\n이와 같이 계층적인 디렉토리 구조에서 private한 컴포넌트들을 유지하기 위해 중요한 점이 있는데, index.js의 활용이다.\n각 layer바로 아래의 디렉토리들에는 index.js를 두고, 이를 하위 폴더들의 것들에서 전부 import해오고, 상위 계층에서 이 index.js를 Import 해와서 사용하는 방식이다. 이런식으로 캡슐화를 이루어낼 수 있다.\n높은 응집도: 코드는 영향력의 범위(layer), 도메인(slice), 그리고 기술적 목적(segement)에 따라 관리가 되어, 새롭게 접하는 사람들에게 이해하기 쉬운 정형화된 아키텍쳐를 제공한다.\n로직 재사용 통제: 각 아키텍쳐의 컴포넌트는 목적과 예상 가능한 의존성 (dependency)을 지닌다. 이는 곧 코드에서 지역적으로 사용할 것과 전역적으로 사용할 것을 엄격하게 구분한다는 뜻이기도 하다. 따라서, DRY 원칙과 적응 가능성간의 균형을 잡아준다.\n변경이나 리팩토링에 안정적임: 특정 layer의 모듈은 같은 layer의 다른 모듈에서 사용 불가능하다. 다른 상위 layer에서도 마찬가지로 사용 불가능하다. 따라서 독립적인 변경이 가능하여 예상치 못한 결과를 방지할 수 있다\n균일성: 러닝커브가 높기는 하지만 표준화된 구조덕에 적응 후에는 프로젝트가 보다 수월하게 굴러감\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"FSD 패턴","level":3,"id":"FSD_패턴_0"},{"heading":"Layer","level":4,"id":"Layer_0"},{"heading":"Slices","level":4,"id":"Slices_0"},{"heading":"Segment","level":4,"id":"Segment_0"},{"heading":"왜 좋을까?","level":3,"id":"왜_좋을까?_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/design-pattern/fsd-패턴.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058372,"modifiedTime":1728313582594,"sourceSize":5604,"sourcePath":"학습 정리/Design Pattern/fsd 패턴.md","exportPath":"학습-정리/design-pattern/fsd-패턴.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/design-pattern/mvc패턴.html":{"title":"MVC패턴","icon":"","description":"MVC 패턴이란 Model-View-Controller의 앞글자만 따온 약자로, 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴이다.\n디자인 패턴이란?\n프로그램이나 어떤 특정한 것을 개발하는 중에 발생했던 문제점들을 정리해서 상황에 따라 간편하게 적용하여 쓸 수 있는 것을 정리한 규약\n해당 패턴은 소프트웨어의 비즈니스 로직과 화면을 구분하는데 중점을 두고 있다. 즉, 하나의 애플리케이션을 설계함에 있어서 구성 요소를 세 가지 역할로 나누어 구분한 것이다.\n세 가지 역할은\n모델(Model) : 데이터와 비즈니스 로직 관리\n뷰(View) : 레이아웃과 화면 처리\n컨트롤러(Controller) : 모델과 뷰로 명령을 전달\n로 구분된다\n<img src=\"https://i.imgur.com/ZqqejMn.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n위의 그림처럼 서로의 관계가 정의되어 있다.\n각각의 요소에 대해서 자세히 알아보자애플리케이션의 정보, 데이터를 나타낸다.\n데이터베이스, 상수, 초기화값, 변수 등을 뜻하며, 이러한 정보들을 가공하는 역할을 한다.\n사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 함\n뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 함 뷰를 참조하는 내부 속성값을 지니면 안됨 변경이 일어나면, 변경 통지에 대한 처리방법을 구현 정보 변경이 일어나면, 이벤트를 발생시켜 전달하고, 이를 뷰에서 수신하여 처리하거나 하는 처리 방법이 따로 있어야 함\n모델은 재사용가능해야 하며 다른 인터페이스에서도 변하지 않아야 함 사용자 ui를 담당하는 요소이다. 데이터 및 객체의 입력, 출력을 담당한다.\n데이터를 기반으로 사용자들이 볼 수 있는 화면이다. 즉, 표시할 데이터를 모델로부터 받아 출력한다.\n모델이 가지고 있는 정보를 따로 저장해서는 안됨 임의의 뷰 내부에 저장 금지 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 함 모델과 같은 자기 자신을 제외하고 다른 요소들의 참조나 동작을 모름\n데이터를 받으면 단순히 화면에 표시만 함 변경이 일어나면 변경 통지에 대한 처리 방법 구현 모델과 같이 변경이 일어났을 때 변경을 알려줘야 하는 방법 구현\n재사용가능하게끔 설계 컨트롤러는 데이터와 ui(사용자 인터페이스) 요소들을 잇는 다리 역할이다.\n사용자가 데이터를 클릭하면 수정하는 것에 대한 이벤트들을 처리한다\n모델이나 뷰에 대해서 알고 있어야 함 모델이나 뷰는 서로 모르즈만 컨트롤러는 그 사이에 둘을 모두 알고 있는 상태에서 변경을 외부로 알리거나 수신할 수 있어야 함 모델이나 뷰의 변경을 모니터링 해야함\n이러한 3개의 구성 요소로 나누어 동작하는 웹 서버의 구조를 활용하면 가지는 장점들이 뚜렷하다.\n유지보수성 향상 모델, 뷰, 컨트롤러가 명확하게 나누어져 있어 코드의 수정이나 확장이 용이하다\n유지보수가 필요한 부분을 집어 해당 부분만 수정하면 됨 개발의 병렬성 증가 따로따로 개발이 가능해서 협업을 할 경우 개발의 분업화가 잘 이루어질 수 있음 유연성과 확장성 애플리케이션의 기능을 쉽게 추가 및 확장 가능하다\n각각의 요소에 맞추어 추가하기만 하면 된다 테스트 용이성 mvc 패턴은 각 컴포넌트가 독립적으로 동작하도록 설계되었기 때문에 단위 테스트를 수행하기 쉬움 코드의 명확한 구조 코드의 구조가 명확해짐\n코드의 가독성을 높임 중복 코드 감소 중복 코드를 하나로 묶음으로써 재사용이 용이하고 코드의 중복이 사라짐 <br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.mozilla.org/ko/docs/Glossary/MVC\" target=\"_self\">https://developer.mozilla.org/ko/docs/Glossary/MVC</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://m.blog.naver.com/jhc9639/220967034588\" target=\"_self\">https://m.blog.naver.com/jhc9639/220967034588</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"MVC 패턴","level":2,"id":"MVC_패턴_0"},{"heading":"모델(Model)","level":3,"id":"모델(Model)_0"},{"heading":"규칙","level":4,"id":"규칙_0"},{"heading":"뷰(View)","level":3,"id":"뷰(View)_0"},{"heading":"규칙","level":4,"id":"규칙_1"},{"heading":"컨트롤러(Controller)","level":3,"id":"컨트롤러(Controller)_0"},{"heading":"규칙","level":4,"id":"규칙_2"},{"heading":"장점","level":3,"id":"장점_0"},{"heading":"참조","level":2,"id":"참조_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/design-pattern/mvc패턴.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058372,"modifiedTime":1725254058372,"sourceSize":4265,"sourcePath":"학습 정리/Design Pattern/MVC패턴.md","exportPath":"학습-정리/design-pattern/mvc패턴.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/design-pattern/observer-패턴.html":{"title":"Observer 패턴","icon":"","description":"<img src=\"https://i.imgur.com/QtK5Ay8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://i.imgur.com/7MVzWmk.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">옵저버 패턴은 객체의 상태 변화를 관찰하는 관찰자(옵저버)의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 드등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인패턴이다.옵저버는 계속해서 객체의 상태를 관찰하고 있는 상태이고, 이러한 상태 변화를 감지하여 연관된 객체들에게 알림을 보낸다고 하는데, 한낮 다른 객체에 불과한 옵저버가 어떻게 알고있는걸까?답은 이벤트 처리에 있다.객체가 생성되는 시점에 해당 객체에 옵저버를 구독(attach)시키고, 해당 객체에 의존하고 있는 다른 객체들에게도 옵저버를 통해 업데이트 상황을 알 수 있도록 한다.class Observer { constructor() { this.students = []; } add(student){ this.students.push(student); } getStateUpdate(student,action){ console.log(`학생 ${student.name}이 ${action}을 했네요 건강하게만 커야한다~`) }\n}\n학생 옵저버를 만들었다. class Student{ observer constructor(name){ this.name = name; } attach(observer){ this.observer = observer; } eat(){ console.log(`${this.name}이 밥을 먹는다`) this.#notify(this,\"밥먹기\") } #notify(who,action) { this.observer.getStateUpdate(who,action); } } const obeserver = new Observer(); const minsu = new Student(\"minsu\"); minsu.attach(obeserver) minsu.eat()\n그리고 학생 객체를 만든 뒤에 민수에게 옵저버를 구독시키고, 민수의 메서드에서는 해당 옵저버에게 자신의 상태가 업데이트되었음을 함께 알리는 메서드를 실행시킨다.<br><img src=\"https://i.imgur.com/X3DlW4K.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n그럼 옵저버는 이러한 상태 업데이트의 이벤트를 받아 처리하는 것이다.\n해당 옵저버는 배열을 통해 자신이 바라보고 있는 객체들을 관리할 수 있으며, 이러한 객체들에 관해서도 각각 상태가 갱신되었을 때 forEach를 통해 객체들을 돌면서 동일하게 상태 업데이트에 대해서 처리하는 메서드를 실행시킨다면 각 객체들이 이러한 한 객체의 이벤트를 받아 자신들도 동일하게 객체를 동기화시키는 작업을 시킬 수 있다.이러한 관계는 객체간의 느슨한 결합성이 포인트이다.\n두 객체가 느슨하게 결합되어 있다는 것은 디자인패턴 중 Pub-Sub 패턴처럼, 서로가 상호작용을 하지만서도 서로에 대해 모르는 상태이기 떄문에 이에 대해서 유연하게 처리가 가능하다.\n옵저버를 언제든 새로 추가 및 제거\n새로운 형식의 옵저버라도 주제를 변경할 필요가 없음\n주제와 옵저버는 서로 독립적으로 사용 가능\n주제나 옵저버가 바뀌더라도 서로에게 영향을 미치지 않음\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/design-pattern/observer-패턴.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058393,"modifiedTime":1725254058393,"sourceSize":3100,"sourcePath":"학습 정리/Design Pattern/Observer 패턴.md","exportPath":"학습-정리/design-pattern/observer-패턴.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/design-pattern/pub-sub-패턴.html":{"title":"Pub-Sub 패턴","icon":"","description":"<img src=\"https://i.imgur.com/pwO2e66.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n발행-구독 패턴은 옵저버 패턴과 비슷하지만 조금 다른 점이 특징인 디자인패턴이다.\n옵저버 패턴이 한 객체의 상태가 바뀔 때 그 객체에 의존하는 다른 객체들에게 알림이 가고 자동으로 정보가 갱신되는 1:N의 강한 관계를 가졌다면, Pub-sub패턴은 이보다는 느슨한 관계를 가지는 디자인 패턴이다.이 디자인 패턴은 비동기 메세징 패러다임으로 ,발행자인 Publisher가 있고, 이벤트에 대해서 구독중인 Subscriber가 있으며 그 둘 사이에는 Message Broker가 존재한다.Message Broker는 Publisher가 발행하는 이벤트에 대해서 관리하고, 만약 이벤트를 호출하게 된다면 Message Broker를 통해 정해진 범주에 따라 구독을 신청한 수신자에게 전달을 하는 역할이다. 이 과정에서 메시지 큐가 브로커의 역할을 수행하며, 구독과 발행 이후의 메시지를 처리해준다.따라서 발행자가 어떠한 이벤트를 발생시키거나 구독자가 어떤 이벤트에 대해서 구독한 뒤의 일은 모두 메시지 브로커가 일임하여 던져져 있는 구독과 발행을 보고 알아서 메시지를 처리하기 때문에 옵저버 패턴과 가장 큰 차이점으로 발행자와 구독자가 서로를 몰라도 소통이 가능하다는 점이기도 하다.이 외에도 차이점은\n옵저버 패턴보다 더 낮은 결합도\n옵저버 패턴은 동기적으로 동작하지만 발행구독 패턴은 비동기적으로 동작\n옵저버 패턴 단일 도메인에서 동작하며 발행구독 크로스 도메인 상황에서도 동작이 가능\n옵저버 패턴보다 코드 관리, 재사용성, 안정성이 높음\n등이 있다.\n이러한 메시지 브로커에 있는 메시지 큐의 경우 메시지 지향 미들웨어 (MOM : Message Oriented Middleware, 비동기 메시지를 사용하는 응용 프로그램 간 데이터 송수신)로 구현한 시스템으로, 대용량 데이터 처리를 위한 배치 작업이나 채팅 서비스, 비동기 데이터 처리 등에 이용된다. 비동기(Asynchronous) : 큐에 넣어서 나중에 처리 가능\n비동조(Decoupling) : 앱과 분리 가능\n탄력성(Resilience) : 일부 실패가 전체에 영향을 끼치지 않음\n과잉(Redunadancy) : 실패할 경우 재실행 가능\n보증(Guarantees) : 작업 처리 확인 가능\n확장성(Scalable) : 다수 프로세스들이 큐에 메시지 보내기 가능\n하지만 이러한 메시지 큐의 단점으로는 큐이기 때문에 결국 뒤에 있는 메시지의 경우 구독자에게 가기 까지 과도한 트래픽에 따라 지연이 많이 발생할 수도 있다는 점이 있다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"옵저버 패턴과의 차이점","level":2,"id":"옵저버_패턴과의_차이점_0"},{"heading":"메시지 큐","level":2,"id":"메시지_큐_0"},{"heading":"메시지 큐의 특징","level":3,"id":"메시지_큐의_특징_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/design-pattern/pub-sub-패턴.html","pathToRoot":"../..","attachments":[],"createdTime":1725254058394,"modifiedTime":1725254058394,"sourceSize":2898,"sourcePath":"학습 정리/Design Pattern/Pub-Sub 패턴.md","exportPath":"학습-정리/design-pattern/pub-sub-패턴.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html":{"title":"배럴 파일에 대한 고찰","icon":"","description":"\n해당 글은 다음 글을 번역 및 정리한 글입니다.\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/\" target=\"_self\">https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/</a>\n만약 여러 파일들을 가진 프로젝트를 사용한다고 하면, 우리는 이런 식으로 import해와서 해당 모듈을 사용한다.import { foo } from \"./some/other-file\"; export function myCoolCode() { // Pretend that this is super smart code :) const result = foo(); return result;\n}\n하지만 이런 파일이 한두개라면 괜찮겠지만, 라이브러리들을 보면 정말 많은 모듈들이 있다. 또한 각 모듈마다 파일을 나누게 된다면 우리가 사용하는 import 문은 점점 더 많아지게 된다.하지만 이렇게 import를 하지 않기 위해서는 모듈들을 한 곳에 모두 모아놓고 관리할 수도 있으나, 그렇게 되면 파일 자체가 여러 역할을 지니기 때문에 나중에 유지보수성이 낮아지게 된다.사이즈가 점점 더 커질 때마다 이 문제는 점점 더 심해질 것이다.import { foo } from \"../foo\";\nimport { bar } from \"../bar\";\nimport { baz } from \"../baz\";\n결국 우리는 각각의 디렉토리에서 모듈들을 하나하나씩 다 import문을 쓰게 되된다. 불필요하게 import가 길어지면서 코드가 예뻐보이지 않을 수 있다.이러한 문제를 해결하기 위해 배럴 파일(barrel file) 이라는 패턴을 사용할 수 있다.\n배럴 파일은 여러 개의 모듈 디렉토리 위에 하나의 index.js를 두고 export 하는 방식이다.// feature/index.js\nexport * from \"./foo\";\nexport * from \"./bar\";\nexport * from \"./baz\";\n이렇게 상위에서 모든 것들을 다시금 export해주는 파일을 만들게 되면 여러 모듈들을 한번에 import 해올 수 있기 때문에, 위 예시처럼 3개의 import 문이 하나로 합쳐질 수 있다.import { foo, bar, baz } from \"../feature\";\n여러 개의 모듈을 한번에 모아서 한 곳에서 받아오면 이만큼 보기 좋은게 없다!실제로 리액트의 경우도 이런 방식으로 배럴 파일을 두고 있다.// react/packages/react/index.js\n/** * Copyright (c) Meta Platforms, Inc. and affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. * * @flow */ ... // Export all exports so that they're available in tests.\n// We can't use export * from in Flow for some reason.\nexport { __CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, __COMPILER_RUNTIME, Children, Component, Fragment, Profiler, PureComponent, StrictMode, Suspense, cloneElement, createContext, createElement, createRef, use, forwardRef, isValidElement, lazy, memo, cache, startTransition, unstable_DebugTracingMode, unstable_LegacyHidden, unstable_Activity, unstable_Scope, unstable_SuspenseList, unstable_TracingMarker, unstable_getCacheForType, unstable_useCacheRefresh, useId, useCallback, useContext, useDebugValue, useDeferredValue, useEffect, experimental_useEffectEvent, useImperativeHandle, useInsertionEffect, useLayoutEffect, useMemo, useOptimistic, useSyncExternalStore, useReducer, useRef, useState, useTransition, useActionState, version,\n} from './src/ReactClient';\n그렇기 때문에 우리는 이런 식으로 간편하게 import문을 통해서 여러 훅들을 가져와 사용한다.import { useState } from \"react\";\n정말 깔끔하고 보기 좋지 않은가?\n이걸 보고 각각의 여러 모듈들을 가진 파일들에 대해 index를 두고 import하려는 사람들은 성능에 대해서 생각해볼 필요가 있다.만약 이러한 패턴이 가독성이 좋아보여서 자신의 폴더 구조 또한 배럴 파일 패턴을 적용하기 위해서 많은 파일들이 있는 디렉토리에서 index.js를 두고 다시금 export 한다고 생각해보자.그렇게 된다면, 이 index.js들은 디렉토리 계층 구조에서 한 계단씩 계속 올라가면서도 index.js 배럴 파일이 생길 것이고, 마지막 루트에서는 하나의 index.js에 모든 모듈들을 담을 수 있게 된다.아유 깔끔하니 야무지네~..~<br>\n<img src=\"https://i.imgur.com/cy5w2kr.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">라고만 생각한다면 나중에 큰코 다칠 수 있다.우리는 이 index.js 파일을 통해 하나의 모듈을 import 한다고 했을 때, 내가 필요한 모듈만을 import해와서 사용한다고 생각한다. 하지만 이는 반은 맞고 반은 틀리다.내가 필요한 모듈만을(X) import해와서 사용한다(O)배럴 파일에 있는 모듈들 중에 하나를 import해와서 사용하는 경우, 배럴 파일에 있는 모든 모듈들은 import를 해오는 과정에서 함께 import된다.이 말의 의미는 무엇인가?\n결국 전역변수가 있다면 이에 따른 예외가 발생할 수 있다는 것이다.// a.js\nglobalThis.foo = 123; // b.js\nconsole.log(globalThis.foo); // should log: 123 // index.js\nimport \"./a\";\nimport \"./b\";\n여기에서 이런 식으로 b를 실행하게 되면 123이 출력되는 것을 알 수 있다.\n결국 이는 곧 전역 변수를 생성했을 때, 하나라도 충돌이 날 수 있다는 가능성을 포함한다. 그렇기에 우리의 예상과는 다른 동작이 일어날 수 있다.결국 위 예시를 통해서도 알 수 있듯이, 내가 b 모듈만 가져와서 사용한다고 하더라도, 배럴 파일에서 가져오는 과정에서 배럴 파일이 import하는 모든 모듈들 또한 함께 딸려오게 된다.\n이 문제는 테스트를 할 때 더 안좋은 방향으로 작용한다.jest와 같은 테스트러너는 테스트 파일마다 새로운 자식 프로세스에서 실행되는데, 만약 테스트 파일이 여러개라면 모듈 그래프를 각 파일마다 처음부터 그리고 import해오는 과정이 반복적으로 발생하기 때문에 이에 대한 비용을 모두 지불해야 한다.\n모듈 그래프를 그리는데 6초가 걸린다고 가정하면, 테스트 파일이 100개일 때는 10분동안 테스트만 돌려야 한다는 뜻이다.문제는 모듈 그래프를 그리는 비용 뿐만이 아니다. import cycle linitng rules에 대한 린팅 과정에서 생기는 비용 또한 부가적으로 발생한다.\nimport cycle liniting rules\n모듈들이 순환 참조하는 상황을 방지하기 위해 정해놓는 린팅 규칙으로, 모듈 간의 의존성을 명확하게 유지하기 위해 사용한다.\n린터는 파일 별로 실행되기 때문에 결국 테스트파일 100개가 생기면 여기에 따라서도 린터가 각각 생성될 수밖에 없다. 그렇게 되면 린팅도 각각 import되는 모든 모듈에 대해 검사를 진행하는 과정에서 시간은 기하급수적으로 증가한다.<br><img src=\"https://i.imgur.com/z7nHx1U.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n레퍼런스에서는 순환참조하는 파일을 만든 후에, 모듈 그래프를 그리는 비용을 측정한 그래프를 첨부했다. 모듈은 비어있는 상태임에도 불구하고 모듈이 많아지면 많아질수록 비용은 엄청나게 높아지는 것을 볼 수 있다. 500개 모듈:&nbsp;0.15s * 100 / 4&nbsp;=&nbsp;3.75s&nbsp;오버헤드\n1000개 모듈:&nbsp;0.31s * 100 / 4&nbsp;=&nbsp;7.75s&nbsp;오버헤드\n10000개 모듈:&nbsp;3.12s * 100 / 4&nbsp;=&nbsp;1:18m&nbsp;오버헤드\n25000개 모듈:&nbsp;16.81s * 100 / 4&nbsp;=&nbsp;~7:00m&nbsp;오버헤드\n50000개 모듈:&nbsp;48.44s * 100 / 4&nbsp;=&nbsp;~20:00m&nbsp;오버헤드\n만약 4개의 프로세스가 병렬 처리된다고 해도, 50000개 모듈까지 가면 테스트 한번 하는데 한세월 걸리는 대참사가 벌어진다.\n그래서 최근 현업에서는 배럴 파일의 사용을 최대한 지양하고 있다고 한다. 우리 또한 이러한 배럴 파일이 성능에 미치는 영향을 제대로 알고 사용할 필요가 있다.\n개발 환경의 성능을 높이기 위해서는 배럴 파일 사용을 재고하자\n모듈 관리의 편리함보다 성능이 더 중요하다\n효율적인 코드 관리를 위해서는 각 모듈을 명확하게 import하는 것이 바람직하다\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"배럴 파일 패턴이란?","level":2,"id":"배럴_파일_패턴이란?_0"},{"heading":"문제점","level":2,"id":"문제점_0"},{"heading":"전역 변수가 주는 예외","level":3,"id":"전역_변수가_주는_예외_0"},{"heading":"성능적 문제","level":3,"id":"성능적_문제_0"},{"heading":"어떻게 해야 할까?","level":2,"id":"어떻게_해야_할까?_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html","pathToRoot":"../../..","attachments":[],"createdTime":1728798242113,"modifiedTime":1728802871414,"sourceSize":8382,"sourcePath":"학습 정리/Frontend/Javascript/배럴 파일에 대한 고찰.md","exportPath":"학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/javascript/클로저에-관한-고찰.html":{"title":"클로저에 관한 고찰","icon":"","description":"내 기준 '자바스크립트를 조금 할 줄 안다'의 기준은 클로저와 커링에 대한 이해도라고 생각한다(그런 의미에서 나는 걍 코드싸개임이 분명하다).\n<img src=\"https://i.imgur.com/2EqfV3e.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n하지만 자바스크립트를 사용하는 프레임워크 대부분이 함수형 프로그래밍으로 되어 있고, 프론트엔드라면 함수 안에 함수가 들어있는 형태를 익숙해질 필요가 있다.암튼 정리 시작\n클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다\n여기서 중요하게 보아야 할 키워드는 '함수가 선언된 렉시컬 환경'이다.const x = 1 function outerFunc(){ const x = 10 function innerFunc(){ console.log(x); //10 } innerFunc();\n}\nouterFunc();\nouterFunc 함수 내부에서 중첩 함수 InnerFunc가 정의되고 호출되었다.\n이때 중첩함수 InnerFunc의 상위 스코프는 외부 함수 outerFunc 의 스코프로, innerFunc 내부에서 자신을 포함하고 있는 외부 함수 outerFunc의 x 변수에 접근할 수 있다.\n하지만 중첩된 함수가 아니라면 innerFunc는 outerFunc함수의 변수에 접근할 수 없다.이 이유는 자바스크립트가 렉시컬 스코프를 따르는 언어이기 때문이다.\n렉시컬 스코프(정적 스코프)란?\n외부 렉시컬 환경에 대한 참조에 저장할 참조값\n함수를 어디에 정의했는지에 따라 상위 스코프를 정할 수 있는 자바스크립트의 스코프\n이처럼 선언된 함수(호출 위치x)의 위치에 따라서 상위 스코프가 정해지는 것이다.\n따라서 위 예제의 outerFunc()를 보면 해당 함수는 가장 바깥에서 실행되었기 때문에 해당 함수의 스코프는 전역으로 볼 수 있다.위에서 말한 것처럼 함수가 정의된 환경(위치)와 호출되는 환경(위치)는 다를 수 있다.\n따라서 렉시컬 스코프가 가능하기 위해서는 함수가 자신이 정의된 환경, 즉 상위 스코프를 기억해야 한다.\n그렇기 때문에 함수는 자신의 내부 슬롯 [[environment]]에 자신이 저장된 환경(상위 스코프의 참조)을 저장해 놓는다.가장 바깥의 함수의 경우 전역 렉시컬 환경을 참조하도록 맨 처음 함수 정의 평가가 실행될 때 저장되지만, 함수 안의 내부 함수는 바깥쪽 함수가 실행될 때 해당 외부 함수 렉시컬 환경의 참조가 저장된다. 이 부분이 이해가 가지 않는다면 함수가 호출될 때 실행되는 내부 로직을 보면 된다.함수는 호출될 때 함수 내부로 코드의 제어권이 이동하며, 함수 코드를 평가한다.\n함수 실행 컨텍스트 생성\n함수 렉시컬 환경 생성 -&gt; 요기서 상위 스코프를 결정한다 함수 환경 레코드 생성\nthis 바인딩\n외부 렉시컬 환경에 대한 참조 결정 const x = 1; function outer(){ const x = 10; const inner = () =&gt; { console.log(x); } return inner } const innerFunc = outer();\ninnerFunc() //10\n예제를 통해 보자.\n해당 환경에선 중첩 함수로 inner() 가 들어가 있다. 그리고 outer()는 실행되면서 해당 함수를 반환하고 생명주기를 마감하지만, 막상 inner를 실행했을 때는 10이 나온다.이 이유는 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 중첩 함수는 이미 생명주기가 종료한 외부 함수의 변수를 참조할 수 있기 때문이다. 이러한 중첩 함수를 클로저라고 부른다.이러한 클로저의 경우는 계속해서 외부 함수의 렉시컬 환경을 기억하고, 참조하고 있으며, 이는 계속해서 해당 중첩함수가 존재하는 한 유지된다. 해당 렉시컬 환경을 내부 함수가 참조하고 있기 때문에 가비지 컬렉션의 대상이 되지 않기 때문이다.그렇다면 어찌됐든 가장 상위 스코프도 전역 렉시컬 환경을 참조하고 있기 때문에 클로저가 아니냐! 라고 하면 아니다. 이론적으로는 맞지만 일반적으로 쓰이는 경우는 해당 함수가 상위 렉시컬 환경의 변수를 참조하고 있느냐? 가 클로저임을 구분하는 중요한 기준이 된다.추가적으로 이러한 클로저에 의해 참조되는 상위 스코프의 변수를 자유변수(free variable)이라고 부른다.따라서 클로저를 다른 말로 하자면 '함수가 자유 변수에 의해 닫혀있다(closed)'라는 의미이다. 여기서 닫히다라는 표현은 대상과 같은 범주 안에 속한다라는 의미로, 또 닫혀있다라는 말을 풀어보면 '자유변수에 묶여있는 함수라고 볼 수 있다.클로저는 자바스크립트의 야무진 기능으로, 함수형 프로그래밍에 많이 활용된다.클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다.\n이 말인 즉슨, 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용한다는 것이다.let x = 1; function increase(){ return ++x\n}\n만약에 전역 변수 x의 상태를 바꾸는 함수를 이렇게 만들었다고 치면, 얘는 누구나 변경할 수 있다. 이러한 경우에 같은 함수를 계속 호출하다가도 중간에 누가 바꿔서 NaN 값이 떠버리는 때에는 바로 에러뜬다는 의미이다.그렇기 때문에 카운트 상태 변경 함수 안의 렉시컬 환경에 변수를 선언한 다음 사용하는 것이 정보의 은닉화에 유리하다.const increase = function () { let x = 0; return ++num\n} increase()//1\nincrease()//1\nincrease()//1\n근데 요런식으로 만들면 함수가 호출될 때마다 초기화가 이루어지기 때문에 이전 정보를 유지하지 못한다.\n그래서 클로저를 활용한다.const increase = (function () { let x = 0; return function(){ return ++num; }\n}())\n이런 식으로 클로저를 활용하면, 해당 함수는 상위 렉시컬 환경인 increase 함수의 x 변수값을 계속해서 참조하면서 카운트 상태를 업데이트 할 수 있다.이런 점을 봤을 때, 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고, 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지시킬 수 있다.생성자 함수를 통해 만들어보자const Counter = (function () { let num = 0; function Counter(){ this.num = 0; //&lt;-- 얘처럼 프로퍼티로 놓으면 은닉 안됨 } Counter.prototype.increase = function () { return ++num; } Counter.prototype.decrease = function () { reuturn &gt; 0 ? --num : 0; } return Counter;\n}())\n...\nconst counter = new Counter();\nconsole.log(counter.increase()) //1\nconsole.log(counter.increase()) //2\nconsole.log(counter.increase()) //3\nconsole.log(counter.increase()) //4\n이런 식으로 만들면 num은 계속해서 증가하지만, 우리가 접근할 수는 없고, increase()나 decrease() 메서드로만 접근할 수 있다.추가적으로 프로토타입을 통해 increase, decrease 메서드를 상속받은 인스턴스를 만들어 해당 메서드를 실행시키는 방법은 이 각 메서드가 모두 자신의 함수 정의가 평가되어 함수 객체가 될 때 실행 중인 실행컨텍스트인 즉시 실행 함수 실행 컨텍스트의 렉시컬 환경을 기억하는 클로저기 때문에 즉시 실행 함수의 자유 변수 num을 사용할 수 있다.하지만 this바인딩을 통해 함수의 프로퍼티로 놓게 된다면 은닉되지 않으므로 접근할 수 있는 값이 되어 은닉성이 사라지기 때문에 주의해야 한다.아무튼 이러한 부분은 함수형 프로그래밍이 지향하는 바와 같은데, 외부 상태 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에서 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높일 수 있는 킹갓제너럴 클로저를 많이 활용한다.//카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저 반환\nfunction makeCounter(aux) { let counter = 0; return function () { counter = aux(counter); return counter; };\n} // 보조함수들\nfunction increase(n) { return ++n;\n} function decrease(n) { return --n;\n} const increaser = makeCounter(increase);\nconsole.log(increaser()); // 1\nconsole.log(increaser()); // 2 const decreaser = makeCounter(decrease);\nconsole.log(decreaser()); //-1\nconsole.log(decreaser()); //-2 해당 코드는 함수형 프로그래밍을 잘 활용한 코드로, makeCounter 함수를 고차함수로 만들어 보조 함수를 인자로 전달받고 함수를 반환하도록 하였다.\nmakeCounter 함수가 반환하는 함수는 자신이 생성됐을 때의 렉시컬 환경인 makeCounter 함수의 스코프에 속한 counter 변수를 기억하는 클로저이다. 이를 실행하면 makeCounter 함수의 실행 컨텍스트가 생성되고 함수 객체를 생성하여 반환한 후 소멸되는 과정을 반복한다.하지만 계속해서 보조 함수를 넣은 고차함수가 계속해서 반환하는 함수를 실행할 때마다 makeCounter가 만든 렉시컬 환경의 스코프 환경은 참조되고 있는 상태이기 때문에 소멸되지 않고 렉시컬 환경의 스코프에 속하는 counter 변수가 기억하는 변수를 계속해서 갱신할 수 있는 것이다.여기에서는 increase, decrease를 인자로 받은 각각의 독립된 렉시컬 환경을 선언했지만, 만약 둘 다 가능한 카운터를 만들기 위해서는 고차함수를 두번 사용하지 않고 한번만 사용함으로써 두 렉시컬 환경을 합쳐주어야 한다.//카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저 반환\nconst counter = (function () { let counter = 0; return function (aux) { counter = aux(counter); return counter; };\n})(); // 보조함수들\nfunction increase(n) { return ++n;\n} function decrease(n) { return --n;\n} console.log(counter(increase)); //1\nconsole.log(counter(increase)); //2\nconsole.log(counter(increase)); //3\nconsole.log(counter(increase)); //4\nconsole.log(counter(decrease)); //3\nconsole.log(counter(decrease)); //2\nconsole.log(counter(decrease)); //1\nconsole.log(counter(decrease)); //0 클로저에서 주의해야 할 점 중 하나는 전역변수 var의 사용이다.\nes6 문법이 나오기 전까지는 var가 모든 변수 선언을 대체하고 있었는데 이러한 var 키워드의 문제는 함수 레벨 스코프를 갖는다는 점이다.var funcs = []; for (var i = 0; i &lt; 3; i++) { funcs[i] = () =&gt; { return i; };\n} funcs.forEach((j) =&gt; { console.log(j()); // 3 3 3\n}); 위 코드처럼 i를 var로 선언한 다음 배열에 각각 i를 리턴하도록 하는 함수를 넣어주게 되면, 전역 변수 i를 계속해서 참조하고 있는 상태이기 때문에 배열이 다 돌고 난 후의 i값인 3만 계속해서 출력한다. 해당 함수가 아닌 그 상위의 i값을 보고 출력하는 함수의 형태로 되어있기 때문이다.이를 위해서는 크게 두 가지의 방법이 있다.var funcs = []; for (var i = 0; i &lt; 3; i++) { funcs[i] = ((id) =&gt; { return function () { return id; }; })(i);\n} funcs.forEach((j) =&gt; { console.log(j()); // 3 3 3\n}); id를 인자로 받는 함수를 만들고, 거기에 리턴값으로 함수를 새로 선언하여 넣어준 뒤 해당 렉시컬 환경의 id를 가져오는 방식으로 바꿔준다. 또한 해당 함수를 실행시키면서 i의 값을 넣어주면 i의 값은 id의 인자로 받아들이며 복사되기 때문에 각각의 렉시컬 환경을 가지는 객체들을 배열마다 만들 수 있다.아까의 문제는 var 키워드로 선언한 i가 함수 레벨 스코프이기 때문에 발생한 문제지만, let은 블록 레벨 스코프이기 때문에 훨씬 편하다. for문의 변수 선언문에서 let 키워드로 선언한 변수를 활용하면 for문의 코드 블록이 반복 실행될 때마다 for문 코드 블록만의 렉시컬 환경이 생성되기 때문에 해당 블록 내에서 선언한 함수의 경우 해당 함수의 상위 스코프는 새롭게 생성되던 렉시컬 환경을 참조하기 때문이다. var funcs = []; for (let i = 0; i &lt; 3; i++) { funcs[i] = () =&gt; { return i; };\n} funcs.forEach((j) =&gt; { console.log(j()); // 0 1 2\n}); 이렇게 각각의 배열에 할당된 함수가 독립적인 렉시컬 환경을 가지고 있기 때문에 for문이 돌면서 갱신된 i의 값을 각각 다르게 기억하고 있음을 알 수 있다.var funcs = Array.from({ length: 3 }, (_, i) =&gt; () =&gt; i); funcs.forEach((j) =&gt; { console.log(j()); // 3 3 3\n}); 고차함수를 사용하면 여러모로 좋은 점이 많다. 5줄이 넘어갈 수도 있는 코드를 한 줄로 줄인다는 점이 참 매력적이다.\nArray.from은 두 번째 인자로 mapfn을 받는데, 이 콜백함수는 각각의 배열 요소들을 돌면서 콜백 함수를 실행시킨다.\n이 과정에서 콜백함수 내에서 i라는 인덱스 값을 받아 i를 반환하는 함수를 선언하기 때문에 각 배열에 할당된 각 i는 독립적인 렉시컬 환경을 가지게 된다.클로저는 캡슐화와 보안에 뛰어난 효과를 지녔으며, 자바스크립트 함수형 프로그래밍의 정수와 같은 느낌이라고 생각한다.그렇기 때문에 클로저를 통해서 렉시컬 환경을 이해하고, 이를 활용하는 수준이 곧 함수형 프로그래밍 코드의 퀄리티를 높인다고 생각한다. 앞으로 코드를 작성함에 있어서 조금 더 심화적으로 활용을 이어나가면서 익숙해져야겠다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"클로저","level":1,"id":"클로저_0"},{"heading":"클로저란?","level":2,"id":"클로저란?_0"},{"heading":"[[environment]]","level":3,"id":"\\[\\[environment]]_0"},{"heading":"그래서 클로저가 뭔데..","level":3,"id":"그래서_클로저가_뭔데.._0"},{"heading":"어따 써먹을까?","level":2,"id":"어따_써먹을까?_0"},{"heading":"정보의 은닉(information hiding)","level":3,"id":"정보의_은닉(information_hiding)_0"},{"heading":"바람직한 클로저의 사용","level":2,"id":"바람직한_클로저의_사용_0"},{"heading":"var의 사용 주의","level":2,"id":"var의_사용_주의_0"},{"heading":"1. i의 값을 인자로 받아 복사하기","level":3,"id":"1._i의_값을_인자로_받아_복사하기_0"},{"heading":"2. es6 문법을 사용(let)","level":3,"id":"2._es6_문법을_사용(let)_0"},{"heading":"3. 고차함수의 활용","level":3,"id":"3._고차함수의_활용_0"},{"heading":"결론","level":2,"id":"결론_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/javascript/클로저에-관한-고찰.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058407,"modifiedTime":1725254058408,"sourceSize":14454,"sourcePath":"학습 정리/Frontend/Javascript/클로저에 관한 고찰.md","exportPath":"학습-정리/frontend/javascript/클로저에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/javascript/javascript.html":{"title":"Javascript","icon":"","description":"\n<a data-href=\"배럴 파일에 대한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">배럴 파일에 대한 고찰</a>\n<br><a data-href=\"클로저에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/javascript/클로저에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">클로저에 관한 고찰</a>\n<br><a data-href=\"setInterval과 setTimeout에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">setInterval과 setTimeout에 관한 고찰</a>\n<br><a data-href=\"this 바인딩과 간접 호출\" href=\"https://alsgud8311.github.io/학습-정리/frontend/javascript/this-바인딩과-간접-호출.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">this 바인딩과 간접 호출</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html#_0","학습-정리/frontend/javascript/클로저에-관한-고찰.html#_0","학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html#_0","학습-정리/frontend/javascript/this-바인딩과-간접-호출.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/javascript/javascript.html","pathToRoot":"../../..","attachments":[],"createdTime":1738514494523,"modifiedTime":1738514506622,"sourceSize":156,"sourcePath":"학습 정리/Frontend/Javascript/Javascript.md","exportPath":"학습-정리/frontend/javascript/javascript.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html":{"title":"setInterval과 setTimeout에 관한 고찰","icon":"","description":"setTimeout과 setInterval은 호출을 할 때 자주 쓰이는 메서드이다.\n이 두 함수들에는 '일정 시간이 지난 후 원하는 함수를 예약 실행' 할 수 있게 해주는 기능을 가진다.\n하지만 이 예약 실행에도 작동 방식에 따라 setTimeout과 setInterval이 나누어진다.\nsetTimeout -&gt; 일정 시간이 지난 후에 함수를 실행\nlet timerId = setTimeout(func|code, [delay], [arg1], [arg2], ... ) setInterval -&gt; 일정 시간 간격을 두고 함수 실행\nlet timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)\n두 개의 작동 방식은 다르지만 setInterval을 통해 setTimeout을 만들 수 있고, setTimeout을 이용해 setInterval로 만들 수도 있다./** setInterval을 이용하지 않고 아래와 같이 중첩 setTimeout을 사용함\nlet timerId = setInterval(() =&gt; alert('째깍'), 2000);\n*/ let timerId = setTimeout(function tick() { alert('째깍'); timerId = setTimeout(tick, 2000); // (*)\n}, 2000);\n이처럼 두 함수의 역할은 보다 명확한 '시간'을 가지고 함수를 다루는 비슷한 함수들이라고 생각을 할 수 있다. 실제로 setTImeout과 setInterval이 받는 인자의 종류와 개수가 같기 때문에, 만약 같은 함수를 지속적으로 실행하는 스케줄링과 같은 경우에 있어서 setInterval을 많이 쓰곤 한다.\n하지만 이러한 setInterval을 쓸 때 꼭 주의해야 할 점이 있다.let i = 1;\nsetInterval(function() { func(i++);\n}, 100);\n다음과 같은 setInterval은 똑같이 동작하도록 setTimeout을 이용하여 만들 수 있다.let i = 1;\nsetTimeout(function run() { func(i++); setTimeout(run, 100);\n}, 100);\n하지만 이 각각의 코드가 동작 자체는 똑같이 동작하지만, 실제로 이 함수가 실행되는 방식에 대해서는 조금 다르다.let i = 1;\nsetInterval(function() { func(i++);\n}, 100);\n<img src=\"https://i.imgur.com/VCUyoS7.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nsetInterval로 함수를 실행하는 경우에는 함수간 호출의 지연 간격이 실제 명시한 간격보다 짧아지는 효과를 가진다.\n왜냐하면 함수에는 그 함수를 실행시키는 과정에서 걸리는 시간 또한 간격에 포함되어 있기 때문이다.반면 setTimeout을 중첩으로 실행하여 일정 간격으로 함수를 실행시키는 방법을 보자let i = 1;\nsetTimeout(function run() { func(i++); setTimeout(run, 100);\n}, 100);\n<br><img src=\"https://i.imgur.com/YIsYlYk.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n중첩 setTimeout을 사용할 경우에는 이전 함수의 실행이 종료된 이후에 다음 함수 호출에 대한 스케줄링 계획이 짜여지기 때문에 명시한 지연 시간이 보장된다.\n따라서 보다 명확하게 스케줄링 시간을 관리하기 위해서는 setTimeout을 통해 스케줄링 하는 것이 보다 확실한 방법이다.하지만 둘 다 스케줄링 메서드 중 하나기 때문에 CPU의 과부하나 브라우저 탭이 백그라운드인 등의 상황에 대해서는 타이머의 지연 시간이 이에 따라 늘어나기 때문에 이 또한 유의해서 사용해야 할 필요성이 있다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"지연 간격 보장 문제","level":3,"id":"지연_간격_보장_문제_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html","pathToRoot":"../../..","attachments":[],"createdTime":1728967282322,"modifiedTime":1728971277227,"sourceSize":3297,"sourcePath":"학습 정리/Frontend/Javascript/setInterval과 setTimeout에 관한 고찰.md","exportPath":"학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/javascript/this-바인딩과-간접-호출.html":{"title":"this 바인딩과 간접 호출","icon":"","description":"this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)이다. this는 C++이나 자바와 같은 클래스 기반 언어에서 클래스가 생성하는 인스턴스를 가리키는데, 자바스크립트의 경우 특이 케이스로, 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.함수의 호출 방식은\n함수 호출\n메소드 호출\n생성자 함수 호출\napply/call/bind 호출\n로 나누어지는데, 이러한 함수의 호출 방식에 따라 this 바인딩이 그때그때 결정된다는 의미기도 하다. 바인딩이란?\n식별자와 값을 연결하는 과정\nvar foo = function () { console.dir(this);\n}; // 1. 함수 호출\nfoo(); // window\n// window.foo(); // 2. 메소드 호출\nvar obj = { foo: foo };\nobj.foo(); // obj // 3. 생성자 함수 호출\nvar instance = new foo(); // instance // 4. apply/call/bind 호출\nvar bar = { name: 'bar' };\nfoo.call(bar); // bar\nfoo.apply(bar); // bar\nfoo.bind(bar)(); // bar\n그러면 각각의 함수 호출하는 방식에 따라서 binding이 어떻게 이루어지는지 파헤쳐보자일반 함수에서 this를 가리키는 경우 전역 객체를 가리킨다.\n전역 객체란?\n모든 객체의 유일한 최상위 객체\nBrowser-side에서는 window를, Server-side(Node.js)에서는 global 객체를 가리키게 된다.// in browser console\nthis === window // true // in Terminal\nnode\nthis === global // true\n사실 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수로 쓰이기 때문에,","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"일반 함수 호출","level":2,"id":"일반_함수_호출_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/javascript/this-바인딩과-간접-호출.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058386,"modifiedTime":1725254058386,"sourceSize":1736,"sourcePath":"학습 정리/Frontend/Javascript/this 바인딩과 간접 호출.md","exportPath":"학습-정리/frontend/javascript/this-바인딩과-간접-호출.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/others/aws-배포.html":{"title":"aws 배포","icon":"","description":"aws 배포를 하게됐다\n이전까지는 프론트만 배포하는걸 해봤었는데, 프론트와 서버를 합친 풀스택으로 프로젝트를 배포해보는 좋은 경험을 얻게 되었다.\n서버는 express, db는 mysql, 클라이언트는 서버사이드 렌더링 + 클라이언트 사이드 렌더링으로 된 프로젝트로, 내가 실질적으로 서버를 가동시켜야 하는 것은 mysql과 express가 있었다.\nmysql같은 경우는 mysql-server를 통해 쉽게 db를 계속 돌릴 수 있었다.\n하지만 express의 경우 한번도 안해봤다는게 문제,,,라서 나중에라도 까먹을까봐 배포한 과정을 적어놓으려 한다.\n거두절미하고 스타트인스턴스 생성 과정에서는 생성 후에 미리 탄력적 ip(elastic ip)를 만들어 할당해놓자.\n나중에 만들지 않으면 다시금 접속하는 과정이 귀찮다.ec2 콘솔의 메뉴에서 Elastic IP addressses -&gt; Allocate Elastic IP address 를 통해 고정적으로 IP를 할당해준다. 설정하지 않을 경우 인스턴스 재실행마다 ip가 바뀔 수 있기때문에 고정적인 ip를 사용하는 것이 낫다\n<img src=\"https://i.imgur.com/bFiJ458.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">탄력적 IP가 만들어졌으면 Actions -&gt; Associate Elastic IP Address 를 통해 인스턴스에 할당해준다.ssh 연결은 ec2 인스턴스를 사용한다면 꼭 필요하다\n매번 aws 들어가서 할 것도 아니고 애초에 설정 자체가 어렵지 않다\nec2 생성할 때 만든 키페어를 가지고ssh -i 키페어.pem Username@PublicIP\n를 통해 연결해준다.<br>\n<img src=\"https://i.imgur.com/O8ONpKJ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n그럼 이런 식으로 연결이 된다의 경우 이 링크를 참고도 이 링크를 참고git clone 레포지토리 주소\n나는 private repository로도 한번 만들어 봤는데, 이러한 레포지토리를 clone하기 위해서는 계정 정보 인증이 필요하다.나는 access token을 부여해서 해당 토큰을 비밀번호로 사용하는 방식을 택했다.settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Fine-grain tokens에 들어가 새롭게 토큰을 발급해주고, 적당한 권한을 설정해준 뒤에 git clone할 때 유저네임을 입력 후 비밀번호 입력란에 발급된 토큰을 입력해주면 clone할 수 있다.mvm(node.js 버전 매니저)를 이용해서 node와 딸려오는 npm을 다운로드 할 수 있다.# installs nvm (Node Version Manager)\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash # download and install Node.js (you may need to restart the terminal)\nnvm install 20 # verifies the right Node.js version is in the environment\nnode -v # should print `v20.17.0` # verifies the right npm version is in the environment\nnpm -v # should print `10.8.2`\n$ sudo apt-get update\n$ sudo apt-get install nginx\n아래는 잘 설치되었나 버젼 확인하는것\n$ sudo nginx -v\n공식 NGINX 리포지토리에서 미리 빌드된 우분투 패키지 설치\n$ sudo wget https://nginx.org/keys/nginx_signing.key nginx stop: 빠른 종료\nnginx quit: 정상종료\nnginx reload: 구성파일 다시 로드\nnginx reopen: 로그파일 다시열기\nnginx restart: 재시작\nnginx를 설치하고 제대로 작동을 시키기 위해서는 nginx의 환경을 설정해줘야 한다.sudo vi /etc/nginx/sites-available/default\nnginx.conf를 통해 Include된 서버 설정 관편 파일을 vi 에디터를 통해 수정해준다.server { listen 80 default_server; listen [::]:80 default_server; ... server_name 서버이름 location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. proxy_pass http://127.0.0.1:3000; proxy_http_version 1.1; }\n...\n} server_name 서버이름; 이 서버 도메인으로 들어오는 요청을 처리한다.\n해당 도메인으로 접근할 때 Nginx가 이 설정을 사용한다 location / { ... } location /은 모든 루트 경로 (/)로 들어오는 요청을 처리 proxy_pass http://127.0.0.1:3000; 들어오는 요청을 127.0.0.1:3000으로 프록시(전달)한다\n나는 서버를 돌릴 때 3000 포트로 돌렸기 때문에 3000포트로 프록시를 전달하도록 했다 proxy_http_version 1.1;\n- Nginx가 프록시 요청을 보낼 때 HTTP 1.1 버전을 사용하도록 지정\n변동 사항을 적용시키기 위해서는 재시작 해준다.\nsudo systemctl restart nginx\npm2는 프로세스 관리자로 Node.js로 만들어진 프로그램의 프로세스를 편리하게 관리할 수 있도록 도와주며 아래와 같은 기능을 제공한다.\n프로그램 종료시 자동 재시작\n코드 변경 시 프로세스 재시작\n로그 화면 지원\n먼저 전역적으로 Pm2 사용을 위해 설치해준다.\n$ npm install pm2 -g\n슬만한 명령어는 이정도가 있다\npm2 start [name] : 시작\npm2 list : 목록\npm2 stop id|name|namespace|all|json|stdin : 종료\npm2 delete id|name|namespace|all|json|stdin : 제거\npm2 start [name] --watch : 코드 변경시 프로세스를 재시작\npm2 log : 로그 확인\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"인스턴스 생성 과정에서","level":2,"id":"인스턴스_생성_과정에서_0"},{"heading":"ssh 연결하기","level":2,"id":"ssh_연결하기_0"},{"heading":"첫 연결 시 locale 설정","level":2,"id":"첫_연결_시_locale_설정_0"},{"heading":"Mysql-server","level":2,"id":"Mysql-server_0"},{"heading":"원격 저장소에서 clone","level":2,"id":"원격_저장소에서_clone_0"},{"heading":"mvm, nodejs 설치","level":2,"id":"mvm,_nodejs_설치_0"},{"heading":"NGINX 설치 및 실행","level":2,"id":"NGINX_설치_및_실행_0"},{"heading":"pm2 설치","level":2,"id":"pm2_설치_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/others/aws-배포.html","pathToRoot":"../../..","attachments":[],"createdTime":1725798801718,"modifiedTime":1725802781992,"sourceSize":5475,"sourcePath":"학습 정리/Frontend/Others/aws 배포.md","exportPath":"학습-정리/frontend/others/aws-배포.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/others/firebase-functions.html":{"title":"firebase functions","icon":"","description":"Firebase Cloud Functions란?\nFirebase에서 cloud functions에 대한 설명을 찾아보면 아래와 같이 나온다.\nFirebase용&nbsp;Cloud Functions는 백그라운드 이벤트, HTTPS 요청,&nbsp;Admin SDK&nbsp;또는&nbsp;Cloud Scheduler&nbsp;작업에 의해 트리거된 이벤트에 대한 응답으로 백엔드 코드를 자동으로 실행할 수 있는 서버리스 프레임워크입니다.\n쉽게 말해서 서버가 기본적인 api에 대한 로직을 작성한 후 이후 해야 하는 배포부터 관리 문제 전반을 firebase쪽에 이관하는 것이다.\n유명한 서버리스 프레임워크는 functions 말고도 aws lambda 등이 있다.\n그렇다면 이 서버리스라는 개념은 정확히 무엇을 의미하는 걸까?단어 그대로 server + less, 서버를 관리할 필요가 적어진다는 뜻이다.\n개발자가 일일이 서버를 관리할 필요 없이 애플리케이션을 빌드하고 실행할 수 있도록 하는 클라우드 네이티브 개발 모델이다.\n그렇다고 서버가 없어지는 것은 아니다. 그저 개발자가 서버를 건드릴 필요가 없다는 뜻이지, 서버리스 모델에도 서버는 존재한다. 하지만 그걸 관리하는 주체가 클라우드 제공업체로 바뀐다는 점과 이 클라우드 제공업체에서 서버 인프라에 대한 프로비저닝, 유지관리, 스케일링 등 서버 관리에서 필요한 필수적인 요소를 대신 해준다.서버리스 아키텍처와 IaaS(Infrastructure-as-a-Service)는 클라우드 컴퓨팅 모델이라는 점에서 공통점을 가지지만, 서버리스는 이벤트 관리 기반 모델이라는 점에서 큰 차이점을 가진다.\n\u001e\n<img src=\"https://i.imgur.com/Iae7V2n.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nIaas(Infrastructure-as-a-Service)\nPaaS(Platform-as-a-Service) SaaS(Software-as-a-Sercvice) 와 함께 3대 클라우드 서비스 모델 중 하나이며, 스토리지, 네트워크, 서버 등을 모두 제공하면서 \b서버 관련 인프라를 모두 제어해준다\nIaas는 사용자가 인프라를 직접 관리하는 것이지만 서버 설정, 네트워킹, OS 설치 등의 세팅과 같은 일련의 과정을 클라우드 상에서 하는 것이다. 반면 서버리스의 경우에는 서버 인프라의 처음부터 끝까지 클라우드를 통해 서비스를 제공하기 때문에 서로 관여하는 정도가 다르다.또한 가장 중요한 점은 Iaas는 서버를 계속 돌리고 있는 상태여야 하기 때문에 가동 시간이나 용량 등에 대해서 비용이 책정되는 반면, 서버리스는 내가 설정해놓은 특정 함수가 실행되었을 경우에 이벤트를 발생시켜 리소스를 동적으로 할당한다(그래서 이름을 lambda나 functions로 하는듯). 따라서 아무리 트래픽이 몰린다 하더라도 동적 할당으로 견딜 수 있다. 하지만 쓴 만큼 돈은 나온다.(on-demand)아무튼 이러한 서버리스 아키텍쳐는 FaaS(Function-as-a-Service) 와 Baas(Backend-as-a-Service) 로 나뉘는데, 우리가 서버리스를 지칭할 때는 주로 FaaS를 나타낸다고 보면 된다.\nFaas는 특정 함수 단위로 코드를 실행할 수 있는 서비스로, 클라우드 서비스 제공자가 특정 요청에 대해 발생하는 함수를 실행할 수 있는 환경을 제공하도록 하여 사용자들의 요청에 함수가 실행될 수 있도록 한다.\nBaaS(Backend-as-a-Service)\nBaaS는 클라우드 제공자가 백엔드(서버)에서 필요한 모든 것들을 제공한다(인증, 스토리지, db 등). Firebase나 AWS Amplify가 대표적이며, 이를 통해 remote 푸시 알림과 같은 기능들을 사용할 수 있다. Stateless하다 함수가 실행되는 동안만 관련된 리소스만을 할당하고 끝나면 반환하기 때문에 상식적으로 생각해도 stateless할 수밖에 없다. 따라서 지속되는 상태를 유지하기 위해서는 DB를 따로 이용해야 할 필요성이 있다. Ephemeral하다(일시적임) stateless와 비슷한 결이긴 하다. 특정 이벤트가 발생했을 경우 컨테이너로서 배포가 되고 회수되는 과정이 반복되기 때문에 일시적으로 배포된다고 볼 수 있다. 장점은 무엇보다 서버를 그대로 맡기기 때문에 서버에 대한 문제를 신경쓰지 않을 수 있다는 점이다. 나같은 프론트가 작은 애플리케이션 하나 만들려면 서버가 필요하기 때문에 서버 코드 쓰고 aws 인스턴스를 파고 배포하랴.. 프록시 설정하랴.. pm2 설정하랴.. crontab 설정하랴... 할게 많은데 제대로 할줄도 몰라서 킹받게 시간을 많이 잡아먹는다.\n하지만 이 귀찮은 작업들을 알아서 처리해준다고 하니 우리야 땡큐다. 게다가 대부분 호출 100만건정도는 무료로 제공하는 횟수이니, 미니 프로젝트에서는 이만큼 안성맞춤인 서버가 없다. 또한 갑자기 트래픽이 몰린다고 해도 다이나믹하게 알아서 스케일업을 해주기 때문에 신경쓸 필요가 없다(사실 신경쓰긴 해야함).하지만 장점이 뚜렷한 만큼 그에 따른 단점 또한 명확하다.\n서버에 대한 상세 설정이나 인프라 제어 등에 대해서는 모조리 서비스 제공하는 곳에서 관리하기 때문에 우리가 설정할 수 있는 범위가 제한된다는 점이 자유도를 묶는다.\n또한 서버리스 함수의 경우에는 나 또한 이번에 하면서 느낀 현상으로, 콜드 스타트(Cold Start) 라는 현상인데 처음 호출 시에 시간 지연이 조금 발생한다.위에서 말했듯이 서버리스는 함수가 실행될 때마다 리소스(자원)을 동적으로 할당하는 구조이기 때문에 함수가 실행되는 동안만 관련된 자원이 할당되고, 실행이 끝나고 응답이 돌아왔다면 함수는 할당된 리소스를 반환한다.<br><img src=\"https://i.imgur.com/sSac1EY.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n여러 요청이 동시에 오는 경우 기능 복사본을 생성하여 재활용하거나 한번 요청이 갔을때 유지하는 유휴 상태에서 벗어나게 되면 다시 위와 같은 라이프사이클을 돌아야 하게 되니, 다시금 속도가 느려지게 되는 현상이 있다.\n예전에 IEEE에서 AWS Lambda와 Microsoft Azure Functions에서 벤치마크를 수행한 결과가 있는데, 300ms에서 24초까지 시간이 걸렸다고 하니 이 점이 사용자에게 서비스 제공 과정에 있어서 치명적인 단점으로 작용한다.\n그래서 firebase의 cloud functions와 같은 곳에서는 최소 인스턴스 수를 설정하여 컨테이너를 유지함으로써 최소한 들어올 수 있는 사용자에 대해 바로 응답할 수 있도록 하는 등의 대비책을 통해 속도를 줄이는 방법을 사용한다. 추가적으로 종속성 줄이기, 캐싱 헤더 사용, 올바른 지역 선택 등을 통해 속도를 줄일 수 있다고는 하지만 효과적으로 줄이기 위한 확실한 방법은 최소 인스턴스 수를 유지하는 것이다. 이를 위해 스케줄링을 따로 시켜 계속해서 인스턴스를 유지하도록 하는 등의 방법을 쓰는 것으로 보인다.서버리스(FaaS)에 대해 알아보았으니 사용하면서 직접 알아가보자.\n나는 FaaS들 중에 firebase Functions를 사용했다. 이유는 이 전에 firebase를 사용한 cloud messaging 기술을 내 프로젝트 앱에 사용했던 경험이 있는데, firebase에 cloud messaging 말고도 다른 기능들이 정말 많아 계속 한번쯤은 사용해보고 싶다는 생각이 들었기 때문이다.\n나는 기존 functions를 통해 런타임에 배포하는 것을 넘어 db 또한 따로 배포하기 귀찮았기 때문에 firebase에서 제공하는 cloud db인 firestore까지 이용할 것이다.\n해당 글은 node.js 기준으로 작성되었습니다.\n<br><a data-tooltip-position=\"top\" aria-label=\"https://console.firebase.google.com/?hl=ko\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://console.firebase.google.com/?hl=ko\" target=\"_self\">Firebase&nbsp;Console에서 프로젝트 추가하기</a><br>\n<img src=\"https://i.imgur.com/VbeYh5o.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n프로젝트를 추가하는 것은 사이트에서 추가하면 되기 때문에 어려운 것은 없다. 등록을 끝내고 나면 이런 식으로 콘솔이 뜬다.npm install -g firebase-tools\nfirebase functions를 런타임에 배포하기 위해서는 Firebase CLI가 필요하다.\nnpm을 통해 다운로드 받아주자\n다운로드 받으면 Firebase를 실행하여 로그인 및 기타 초기화 작업을 할 수 있다.// 얘 쓰면 로그인창 뜸\nfirebase login // 내가 프로젝트 생성할 디렉토리로 이동\ncd 디렉토리 // firestore init\nfirebase init firestore // functions init\nfirebase init functions\n이렇게 세팅하다보면 어떤 언어 쓸거냐는 질문이 나올건데 나는 js로 선택해주었다myproject\n+- .firebaserc # `firebase use` 명령어를 통해 프로젝트 간 전환을 빠르게 도와주는 숨김 파일\n|\n+- firebase.json # 프로젝트 속성을 설명하는 파일\n|\n+- functions/ # 모든 함수 코드가 포함된 디렉터리 | +- .eslintrc.json # 자바스크립트 린팅 규칙을 포함한 선택적 파일 | +- package.json # Cloud Functions 코드를 설명하는 npm 패키지 파일 | +- index.js # Cloud Functions 코드의 메인 소스 파일 | +- node_modules/ # package.json에 선언된 의존성들이 설치되는 디렉터리\n그럼 이런 식으로 처음 세팅이 완료된다//package.json\n{ \"name\": \"functions\", \"description\": \"Cloud Functions for Firebase\", \"scripts\": { \"lint\": \"eslint .\", \"serve\": \"firebase emulators:start --only functions\", \"shell\": \"firebase functions:shell\", \"start\": \"npm run shell\", \"deploy\": \"firebase deploy --only functions\", \"logs\": \"firebase functions:log\" }, \"engines\": { \"node\": \"22\" }, \"main\": \"index.js\", \"dependencies\": { \"cors\": \"^2.8.5\", \"firebase-admin\": \"^12.1.0\", \"firebase-functions\": \"^5.0.0\" }, \"devDependencies\": { \"eslint\": \"^8.15.0\", \"eslint-config-google\": \"^0.14.0\", \"firebase-functions-test\": \"^3.1.0\" }, \"private\": true\n}\npackage.json을 열어보면 이런 식으로 scripts가 짜여 있어서 쓰기 편하다\n기억하면 좋은 것은\nengines : 내가 쓸 node 버전 설정\nscripts\n- serve : emulator를 통해서 로컬에서 서버를 킬 수 있다. ui도 제공하니 보고 테스트하기 댕꿀이다\n- deploy: functions만 배포\n솔직히 난 이정도만 썼다\n// The Cloud Functions for Firebase SDK to create Cloud Functions and triggers.\nconst {logger} = require(\"firebase-functions\");\nconst {onRequest} = require(\"firebase-functions/v2/https\");\nconst {onDocumentCreated} = require(\"firebase-functions/v2/firestore\"); // The Firebase Admin SDK to access Firestore.\nconst {initializeApp} = require(\"firebase-admin/app\");\nconst {getFirestore} = require(\"firebase-admin/firestore\"); initializeApp();\n처음에 index.js가면 잡다한 테스트용들이 주석처리 되어 있고 이런 식으로 해보라고 한다.\ninitializeApp()을 통해 Firebase 서비스에 접근 가능하도록 초기 설정을 할 수 있으며 인증처리 등의 과정이 이루어지면서 연결된다.요청 핸들러를 사용하면 HTTP 요청을 통해 함수를 트리거시키고, 해당 함수를 통해 응답을 반환시킬 수 있다.요청에 대한 옵션은 이렇게 지정해줄 수 있다.const { onRequest } = require(\"firebase-functions/v2/https\"); exports.sayHello = onRequest( { cors: [/firebase\\.com$/, \"flutter.com\"] }, (req, res) =&gt; { res.status(200).send(\"Hello world!\"); }\n);\n요런 식으로 cors의 경우 내가 가지고 있는 도메인들을 설정할 수 있으며, 일반 express 사용하듯이 요청과 응답에 대한 콜백함수를 onRequest를 통해 보낼 수 있다.\n참고로 exports.뒤의 이름은 기본 url 뒤의 uri로 더 붙게된다const functions = require(\"firebase-functions\");\nexports.api = functions.region(\"asia-northeast3\").https.onRequest();\n이렇게 region 옵션도 지정해주어 리전 설정해서 속도를 조금이라도 올릴 수 있다.\n또한 https 프로퍼티를 통해 onRequest 메서드를 실행하면 배포할 때 https 로 배포된다.기존의 웹 서버 프레임워크를 initialize한 app을 요청 핸들러에 인자로 넣으면 전체 앱을 HTTP 함수에 전달할 수 있다. 따라서 요청과 응답을 웹 서버 프레임워크를 통해 관리할 수 있는 것이다.나는 express를 사용해서 요청과 응답을 처리해보고, 클라이언트와 서버 모두 해당 서버에서 돌릴 생각이었다.const functions = require(\"firebase-functions\");\nconst path = require(\"path\");\nconst { initializeApp } = require(\"firebase-admin/app\");\nconst express = require(\"express\");\nconst { routeManager } = require(\"./controller/index.js\");\nconst cors = require(\"cors\"); initializeApp();\nconst app = express(); app.use(cors());\napp.use(express.static(path.join(__dirname, \"dist\")));\napp.use(express.json()); routeManager(app);\napp.get(\"/\", (req, res, next) =&gt; { res.send(\"index\");\n}); exports.api = functions.region(\"asia-northeast3\").https.onRequest(app);\n이렇게 onRequest에 initialize한 app을 인자로 넣어주었다. 그렇게 되면 해당 functions로 오는 http 요청들이 모두 app을 통하게 된다.\n나는 간단한 프로젝트를 만들 예정이었기 때문에 미들웨어로 cors와 번들링할 정적 파일들에 대한 설정, json 파싱 등에 대한 설정만 해주었다.클라이언트는 esbuild를 통해 번들링하여 dist라는 디렉토리에 넣어두었기 때문에 저렇게 설정해주었고, 기본 url에 대해서는 index.html파일만을 보내도록 했다. 어차피 SPA로 만든 프로젝트기 때문에 저거 하나만 설정해두었다.\napi uri에 클라이언트까지 때려박은 이유는 귀찮아서다<br>\n<img src=\"https://i.imgur.com/ZlDgKYs.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n아무튼 다른 추가적인 uri가 붙는 것에 대해서는 따로 functions를 나누지 않고 express의 Router를 이용해서 각 요청과 응답을 처리해주었다. functions를 도메인별로 나누는 것도 좋고 깔끔한게 좋으면 express에서 route만 별도 파일로도 관리할 수 있어서 취향차이인 것 같다.\n암튼 이정도 세팅을 간단하게만 해주고 deploy '딸깍' 하면 배포도 척척 잘된다.참고로 배포하려면 무료 요금제(spark) 요금제에서 Blaze 요금제로 바꿔야 한다.<br>\n<img src=\"https://i.imgur.com/UMyMqP7.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n그래도 앵간한 만큼은 공짜로 쓸 수 있으니 야무지게 써먹자<br>\n<img src=\"https://i.imgur.com/sx8OoQw.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br>아무튼 '딸깍'만으로 관리할 필요가 없어지는 서버리스는 프론트인 나에게 그저 빛...<img src=\"https://i.imgur.com/Tg6rEWE.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://i.imgur.com/sEjPPwh.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n처음 초기 세팅하는 과정에서 functions 세팅을 하고 firestore 세팅도 따로 할 수 있다.\nhttp 요청에 따른 CRUD도 express에서 firestore에 접근하여 조작하면 된다.const admin = require(\"firebase-admin\");\nasync function getUserList() { try { const data = await admin.firestore().collection(\"todo\").get(); return data.docs.map((doc) =&gt; new User(doc.data()); } catch (error) { throw new Error(error); }\n}\nadmin의 firestore 메서드를 사용하면 해당 프로젝트에 연결되어 있는 firestore에 접근하여 CRUD를 수행할 수 있다.const cityRef = db.collection('cities').doc('SF');\nconst doc = await cityRef.get();\nif (!doc.exists) { console.log('No such document!');\n} else { console.log('Document data:', doc.data());\n}\n중요한 점은 개별 데이터 객체에 대해서 data() 메서드를 사용해야만 내가 원하는 데이터가 나온다따로 functions 없이 firestore에만 접근하고 싶다면 firebase SDK를 따로 설정한 뒤에 서버를 키면서 초기화 시켜주면 된다.firebase 콘솔 -&gt; 프로젝트 설정 -&gt; 아래 내 앱 -&gt; SDK 설정 및 구성에서 내 firebase config를 볼 수 있다.npm install firebase\nfirebase 따로 설치하고// Import the functions you need from the SDKs you need\nimport { initializeApp } from \"firebase/app\";\nimport { getAnalytics } from \"firebase/analytics\";\n// TODO: Add SDKs for Firebase products that you want to use\n// https://firebase.google.com/docs/web/setup#available-libraries // Your web app's Firebase configuration\n// For Firebase JS SDK v7.20.0 and later, measurementId is optional\nconst firebaseConfig = { apiKey: \"API키\", authDomain: \"도메인\", projectId: \"프로젝트ID\", storageBucket: \"스토리지버킷\", messagingSenderId: \"메시지 센더ID\", appId: \"앱아이디\", measurementId: \"측정ID\"\n}; // Initialize Firebase\nconst app = initializeApp(firebaseConfig);\nconst analytics = getAnalytics(app);\n이렇게 InitializeApp하고 사용하면 된다.// Create a reference to the cities collection\nconst citiesRef = db.collection('cities'); // Create a query against the collection\nconst queryRef = citiesRef.where('state', '==', 'CA');\nconst citiesRef = db.collection('cities');\nconst snapshot = await citiesRef.where('capital', '==', true).get();\nif (snapshot.empty) { console.log('No matching documents.'); return;\n} snapshot.forEach(doc =&gt; { console.log(doc.id, '=&gt;', doc.data());\n});\nwhere문을 사용하게 되면 쿼리 객체를 가져오게 되고, get()을 통해 결과를 검색한 결과를 받아올 수 있다.\n가져온 객체는 QueryDocumentSnapshot객체로, 여러 개의 프로퍼티를 가지고 있기 때문에 우리가 필요한 데이터만 가져오기 위해서는 data() 메서드를 통해 반환된 데이터를 이용해야 한다.where()&nbsp;메서드는 필터링할 (필드, 비교 연산자, 값)의 3가지 매개변수를 사용한다.\n연산자는\n&lt;&nbsp;: 미만\n&lt;=&nbsp;: 작거나 같음\n==&nbsp;: 같음\n&gt; :&nbsp;보다 큼\n&gt;= :&nbsp;이상\n!=&nbsp;: 같지 않음\narray-contains : 포함하는 배열\narray-contains-any : 배열 안의 것들과 일치하는 모든 레코드\nin : 지정된 필드가 비교값과 일치하는 레코드\nnot-in : 동일한 필드에서 같지 않은 에코드\nconst stateQueryRes = await citiesRef.where('state', '==', 'CA').get();\nconst populationQueryRes = await citiesRef.where('population', '&lt;', 1000000).get();\nconst nameQueryRes = await citiesRef.where('name', '&gt;=', 'San Francisco').get();\n==나 array-contains를 연결하여 제약 조건을 AND와 결합citiesRef.where('state', '==', 'CO').where('name', '==', 'Denver');\ncitiesRef.where('state', '==', 'CA').where('population', '&lt;', 1000000);\n제약 조건을 논리적 OR과 결합const bigCities = await citiesRef .where( Filter.or( Filter.where('capital', '==', true), Filter.where('population', '&gt;=', 1000000) ) ) .get();\ndb.collection(\"cities\").whereEqualTo(\"country\", “USA”).orderBy(“population”);\n해당 쿼리에 대해서 정렬 기준을 잡고 정렬\norderBy 안에 들어있는 필드가 없으면 반환하지 않음function addTodo(req) { const id = crypto.randomUUID(); const created_at = new Date().toISOString(); return admin.firestore().collection(\"todo\").add({ id, detail: req.body.detail, created_at, });\n}\n넣으려는 도메인에 대해서 add메서드를 통해 객체를 그대로 넣어줄 수 있다.\nNOSQL인 만큼 데이터를 변형되지 않도록 신경써야 할 것 같다.const citiesRef = db.collection('cities');\nconst snapshot = await citiesRef.where('capital', '==', true).get();\nif (snapshot.empty) { console.log('No matching documents.'); return;\n} snapshot.forEach(doc =&gt; { console.log(doc.id, '=&gt;', doc.data());\n});\n아까 봤던 예시처럼 get()을 통해 데이터를 가져오고 개별 데이터에 대해서 data()를 통해 내가 원하는 데이터만 반환받자async function updateTodo(req) { try { console.log(req.body); const id = req.body.id; const detailToUpdate = req.body.detail; const todoToUpdate = await admin .firestore() .collection(\"todo\") .where(\"id\", \"==\", id) .limit(1) .get(); if (todoToUpdate.empty) { throw new Error(\"update할 todo를 찾지 못했습니다.\"); } const todo = new Todo(cardToUpdate.docs[0].data()); todo.update(detailToUpdate); return cardToUpdate.docs[0].ref.update(todo); } catch (error) { throw new Error(\"예상치 못한 Error가 발생했습니다.\"); }\n}\n데이터를 찾아와서, 데이터를 갱신한 다음 update()메서드를 통해 새롭게 교체할 객체를 넣어주면 통으로 바뀐다async function deleteTodo(req) { try { const id = req.params.id; const cardToDelete = await admin .firestore() .collection(\"todo\") .where(\"id\", \"==\", id) .limit(1) .get(); console.log(\"???\", cardToDelete.docs[0]); if (cardToDelete.empty) { throw new Error(\"삭제할 todo를 찾지 못했습니다.\"); } return cardToDelete.docs[0].ref.delete(); } catch (error) { throw new Error(error); }\n}\n원하는 데이터에 대해서 찾고 ref property의 delete() 메서드를 통해 삭제할 수 있다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"서버리스 아키텍처(serverless architecture)","level":2,"id":"서버리스_아키텍처(serverless_architecture)_0"},{"heading":"특징","level":3,"id":"특징_0"},{"heading":"장단점","level":3,"id":"장단점_0"},{"heading":"Cold Start란?","level":4,"id":"Cold_Start란?_0"},{"heading":"firebase Functions를 사용해서 서버리스 배포하기(node.js)","level":2,"id":"firebase_Functions를_사용해서_서버리스_배포하기(node.js)_0"},{"heading":"프로젝트 initialize","level":3,"id":"프로젝트_initialize_0"},{"heading":"프로젝트 추가하기","level":4,"id":"프로젝트_추가하기_0"},{"heading":"Firebase CLI 설치 및 초기화","level":4,"id":"Firebase_CLI_설치_및_초기화_0"},{"heading":"http 요청 받기","level":4,"id":"http_요청_받기_0"},{"heading":"express + firebase functions로 요청과 응답 관리하기","level":3,"id":"express_+_firebase_functions로_요청과_응답_관리하기_0"},{"heading":"firestore 설정과 알면 좋을 것들","level":2,"id":"firestore_설정과_알면_좋을_것들_0"},{"heading":"functions 없이 firestore만 사용하기","level":3,"id":"functions_없이_firestore만_사용하기_0"},{"heading":"쿼리","level":3,"id":"쿼리_0"},{"heading":"where문을 사용해서 단일 혹은 여러개 가져오기","level":4,"id":"where문을_사용해서_단일_혹은_여러개_가져오기_0"},{"heading":"복합쿼리(And)","level":4,"id":"복합쿼리(And)_0"},{"heading":"OR 쿼리 만들기","level":4,"id":"OR_쿼리_만들기_0"},{"heading":"orderBy 및 존재 여부","level":3,"id":"orderBy_및_존재_여부_0"},{"heading":"Firestore CRUD","level":2,"id":"Firestore_CRUD_0"},{"heading":"Create","level":3,"id":"Create_0"},{"heading":"Read","level":3,"id":"Read_0"},{"heading":"Update","level":3,"id":"Update_0"},{"heading":"Delete","level":3,"id":"Delete_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/others/firebase-functions.html","pathToRoot":"../../..","attachments":[],"createdTime":1727774753076,"modifiedTime":1727973878501,"sourceSize":23532,"sourcePath":"학습 정리/Frontend/Others/firebase functions.md","exportPath":"학습-정리/frontend/others/firebase-functions.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/others/nosql-맛보기.html":{"title":"NOSQL 맛보기","icon":"","description":"Not Only SQL의 약자.\nRDBMS의 한계를 극복하기 위해 만들어진 데이터베이스로, RDBMS와 같이 고정된 스키마나 JOIN이 존재하지 않는 다소 자유로운 데이터베이스.\u001f앞에서도 말했듯이 RDBMS에는 어느정도 한계가 있다.\n복잡도와 용량적인 측면에서 한계를 가지고 있으며, 활용에도 제약이 깐깐하기 때문에 이러한 점은 장점이면서도 단점으로 다가온다.NoSQL은 유연성과 확장성이 더 뛰어나기 때문에 많은 경우 SQL보다 선호됩니다. NoSQL 시스템 사용의 주요 이점은 개발자가 기존 관계형 데이터베이스의 오버헤드 없이 데이터를 빠르고 쉽게 저장하고 액세스할 수 있다. 따라서 개발을 함에 있어서 기본 데이터 스토리지 구현에 대한 걱정 없이 기능 및 코어 비즈니스 로직을 더 빠르게 제공하는 데 집중할 수 있다.이를 정리해보면\n유연성 : 스키마 선언 없이 필드의 추가 및 삭제가&nbsp;자유로운 Schema-less 구조\n확장성 : 스케일 아웃에 의한&nbsp;서버 확장이 용이\n고성능 : 대용량 데이터를 처리하는&nbsp;성능이 뛰어나다\n가용성 : 여러 대의 백업 서버 구성이 가능하여 장애 발생 시에도&nbsp;무중단 서비스가 가능\n등의 장점을 가진다. 하지만 이렇게 유연성과 같은 장점은 단점으로도 작용할 수 있는 점이 있다.\n스키마가 없기 때문에 그만큼 유연하지만, 유연한 만큼 데이터베이스 일관성에 약하다.\n추가적으로 key값에 대한 입출력만 지원\n스키마가 정해져 있지 않아, 데이터에 대한 규격화가 되어 있지 않다.\n데이터가 여러 컬렉션에 중복되어 있어서 데이터를&nbsp;UPDATE 하는 경우 모든 컬렉션에서 수행해야하기 때문에 느리다.\n데이터 중복으로 인한 수정 작업의 번거로움\n<img src=\"https://i.imgur.com/UZWsSBv.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> BASE\n(Basically Available, Soft State, Eventually Consistent)\nBasically Available(가용성)<br>\n<img src=\"https://blog.kakaocdn.net/dn/VoGEi/btrmgJc8ylA/eASXClupzZr4n9jOTBIZWk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Master 서버에 장애 발생 시에도 여러 Slave 서버로 인해 무중단 서비스가 가능함Soft State(소프트 상태)<br><img src=\"https://blog.kakaocdn.net/dn/VCgVg/btrmhZzvs5a/u4Vf2vb95KScglJ41lZfl0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">각각의 데이터가 도달한 시점에 데이터가 갱신됨Eventually Consistent(결과적 일관성)<br><img src=\"https://blog.kakaocdn.net/dn/rIkdf/btrmhtASzmH/O6lknKCfk6J9bKWvjPtQu0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">복제 메커니즘에 의해 모든 서버에 데이터 복제가 동시에 실행될 수 없음\n시스템 부하 및 네트워크 속도에 따라 서버에 복제하는 시간이 다를 수 있으나 최종적으로는 모든 서버에 데이터가 복제됨\n특징 : 데이터 가용성과 데이터 처리 성능이 향상되도록한다\n중점 사항 : 서비스 가용성\nKey와 Value으로 구성된 배열구조의 데이터베이스로 가장 단순한 구조\n저장과 조회 라는 가장 간단한 원칙에 충실한 데이터베이스 기본적인 패턴으로 Key, Value가 하나의 묶음으로 저장되는 구조이기 때문에 속도가 빠르며 분산 저장에 용이하다\n값에 모든 데이터 타입이 허용가능하다. 대신 모든 데이터 타입을 허용하는 만큼 데이터 입력 단계에서 검증 로직을 제대로 구현해야 한다 Key는 중복될 수 없고 이 Unique Key에 각각 하나의 Value를 가지고 있는 형태가 된다. 데이터를 조회 및 입력할 때, Key를 가지고 접근할 수 있다. 성능 향상을 위해 RDBMS 에서 캐싱 (Redis)\n장바구니 같은 웹애플리케이션에서 일시적인 속성 추적\n이미지나 오디오 파일 같은 대용량 객체 저장 Redis\nAWS DynamoDB\nRiak\nDocument Database 또는 Document-Oriented Database는 위의 Key-Value Database와 같이 데이터 저장에 Key-Value Type를 사용한다.\n하지만 Key-Value Database와의 중요한 차이는&nbsp;Document Database는 값을 문서로 저장함 문서란&nbsp;semi-structured entity이며 보통 JSON이나 XML 같은 표준 형식 값을 저장하기 전에 schema를 별도로 정의하지 않으며, 문서를 추가하면 그게 바로 schema가 된다.\n각 문서별로 다른 필드를 가질 수 있으며, 따라서 개발자가 애플리케이션에서 데이터를 입력하는 단계에서 컬럼과 필드의 관리가 제대로 이루어지도록 보장하는 것이 매우 중요하다. 예를 들어 필수 속성(Null을 허용하지 않는 속성)에 대한 관리도 애플리케이션 레벨에서 관리가 이루어져야 한다. 예시로 MongoDB의 AirBnB DataSet의 일부를 보자. 다음과 같은 JSON 형태의 문서로 관리된다.{ \"_id\": \"10006546\", \"listing_url\": \"https://www.airbnb.com/rooms/10006546\", \"name\": \"Ribeira Charming Duplex\", \"summary\": \"Fantastic duplex apartment with three bedrooms, located in the historic area of Porto, Ribeira (Cube)...\", \"house_rules\": \"Make the house your home...\", \"property_type\": \"House\", \"calendar_last_scraped\": { \"$date\": { \"$numberLong\": \"1550293200000\" } }, \"amenities\": [ \"TV\", \"Cable TV\", \"Wifi\", \"Kitchen\", \"Paid parking off premises\", \"Smoking allowed\", \"Microwave\" ] }\nDocument Database 는 다음과 같은 목적으로 주로 활용된다.\n1. 대용량 데이터를 읽고 쓰는 웹 사이트용 백엔드 지원\n2. 제품처럼 다양한 속성이 있는 데이터 관리\n3. 다양한 유형의 메타데이터 추적\n4. JSON 데이터 구조를 사용하는 애플리케이션\n5. 비정규화된 중첩 구조의 데이터를 사용하는 애플리케이션\nMongoDB CouchDB Couchbase\n컬럼 패밀리 데이터베이스는 대용량 데이터, 읽기와 쓰기 성능, 고가용성을 위해 설계되었다.\n구글의 Big Table, 페이스북은 Cassandra가 있다.\nRelation Database와 동일한 용어를 사용하여 스키마 정의\n컬럼 수가 많으면 관련된 컬럼들을 컬렉션으로 묶음\nDocument Database와 마찬가지로 미리 정의된 스키마를 사용하지 않아 개발자가 데이터를 입력하는 시점에 원하는 대로 컬럼을 추가\n테이블간 조인 지원 안함\n일반적으로 비정규화 되어 있으며 한 객체에 관련된 모든 정보를 가능한 매우 너비가 넓은 단일 Row에 넣어서 보관함\n여러대로 구성된 클러스터에서 운영 되므로 데이터가 적다면 document나 key-value database가 나음\n<br><img src=\"https://miro.medium.com/v2/resize:fit:1400/0*dlH4j-lgJcWU2WlT.jpg\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n데이터베이스에 쓰기 작업이 많은 애플리케이션 지리적으로 여러 데이터 센터에 분산되어 있는 애플리케이션 복제본 데이터가 단기적으로 불일치하더라도 큰 문제가 없는 애플리케이션 동적 필드를 처리하는 애플리케이션 수백만 테라바이트 정도의 대용량 데이터를 처리할 수 있는 애플리케이션 Hbase Cassandra GCP BigTable Microsoft Azure Cosmos DB**\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"NOSQL이란?","level":2,"id":"NOSQL이란?_0"},{"heading":"장점","level":2,"id":"장점_0"},{"heading":"단점","level":2,"id":"단점_0"},{"heading":"NoSQL의 기술 요소","level":2,"id":"NoSQL의_기술_요소_0"},{"heading":"기술 요소","level":4,"id":"기술_요소_0"},{"heading":"기술 요소 상세","level":4,"id":"기술_요소_상세_0"},{"heading":"Key-Value Database","level":2,"id":"Key-Value_Database_0"},{"heading":"특징","level":3,"id":"특징_0"},{"heading":"활용","level":3,"id":"활용_0"},{"heading":"종류","level":3,"id":"종류_0"},{"heading":"Document Database","level":2,"id":"Document_Database_0"},{"heading":"활용","level":3,"id":"활용_1"},{"heading":"종류","level":3,"id":"종류_1"},{"heading":"Column Family Database","level":2,"id":"Column_Family_Database_0"},{"heading":"특징","level":3,"id":"특징_1"},{"heading":"활용","level":3,"id":"활용_2"},{"heading":"종류","level":3,"id":"종류_2"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/others/nosql-맛보기.html","pathToRoot":"../../..","attachments":[],"createdTime":1728902718199,"modifiedTime":1728908174553,"sourceSize":8087,"sourcePath":"학습 정리/Frontend/Others/NOSQL 맛보기.md","exportPath":"학습-정리/frontend/others/nosql-맛보기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/others/others(frontend).html":{"title":"Others(Frontend)","icon":"","description":"\n<a data-href=\"Tailwind 설정하기\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/tailwind-설정하기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Tailwind 설정하기</a>\n<br><a data-href=\"Prettier 설정하기\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/prettier-설정하기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Prettier 설정하기</a>\n<br><a data-href=\"aws 배포\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/aws-배포.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">aws 배포</a>\n<br><a data-href=\"firebase functions\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/firebase-functions.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">firebase functions</a>\n<br><a data-href=\"NOSQL 맛보기\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/nosql-맛보기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">NOSQL 맛보기</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["학습-정리/frontend/others/tailwind-설정하기.html#_0","학습-정리/frontend/others/prettier-설정하기.html#_0","학습-정리/frontend/others/aws-배포.html#_0","학습-정리/frontend/others/firebase-functions.html#_0","학습-정리/frontend/others/nosql-맛보기.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/others/others(frontend).html","pathToRoot":"../../..","attachments":[],"createdTime":1738514583063,"modifiedTime":1738514617807,"sourceSize":120,"sourcePath":"학습 정리/Frontend/Others/Others(Frontend).md","exportPath":"학습-정리/frontend/others/others(frontend).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/others/prettier-설정하기.html":{"title":"Prettier 설정하기","icon":"","description":"{ \"arrowParens\": \"always\", // 화살표 함수의 매개변수가 하나일 때 괄호를 사용할지 여부 \"bracketSpacing\": true, // 객체 리터럴에서 중괄호 내부에 공백 삽입할지 여부 \"endOfLine\": \"auto\", // EoF 방식, OS별로 처리 방식이 다름 \"htmlWhitespaceSensitivity\": \"css\", // HTML 공백 감도 설정 \"jsxBracketSameLine\": false, // JSX의 마지막 `&gt;`를 다음 줄로 내릴지 여부 \"jsxSingleQuote\": false, // JSX에 singe 쿼테이션 사용 여부 \"printWidth\": 80, // 한 줄에 출력되는 코드의 최대 길이 \"proseWrap\": \"preserve\", // markdown 텍스트의 줄바꿈 방식 (v1.8.2) \"quoteProps\": \"as-needed\" // 객체 속성에 쿼테이션 적용 방식 \"semi\": true, // 세미콜론 사용 여부 \"singleQuote\": true, // single 쿼테이션 사용 여부 \"tabWidth\": 2, // 탭 간격 \"trailingComma\": \"all\", // 여러 줄을 사용할 때, 후행 콤마 사용 방식 \"useTabs\": false, // 탭 사용 여부 \"vueIndentScriptAndStyle\": true, // Vue 파일의 script와 style 태그의 들여쓰기 여부 (v1.19.0) \"parser\": '', // 사용할 parser를 지정, 자동으로 지정됨 \"filepath\": '', // parser를 유추할 수 있는 파일을 지정 \"rangeStart\": 0, // 포맷팅을 부분 적용할 파일의 시작 라인 지정 \"rangeEnd\": Infinity, // 포맷팅 부분 적용할 파일의 끝 라인 지정, \"requirePragma\": false, // 파일 상단에 미리 정의된 주석을 작성하고 Pragma로 포맷팅 사용 여부 지정 \"insertPragma\": false, // 미리 정의된 @format marker의 사용 여부 (v1.8.0) \"overrides\": [ { \"files\": \"*.json\", \"options\": { \"printWidth\": 200 } } ], // 특정 파일별로 옵션을 다르게 지정함, ESLint 방식 사용\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/others/prettier-설정하기.html","pathToRoot":"../../..","attachments":[],"createdTime":1728287324761,"modifiedTime":1728287338207,"sourceSize":1834,"sourcePath":"학습 정리/Frontend/Others/Prettier 설정하기.md","exportPath":"학습-정리/frontend/others/prettier-설정하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/others/tailwind-설정하기.html":{"title":"Tailwind 설정하기","icon":"","description":"npm install -D tailwindcss postcss autoprefixer npx tailwindcss init -p\ntailwind만 설치하면 될 줄 알았으나 tailwind가 작동하기 위해서는 postcss와 autoprefixer가 필요하다. 이 둘의 역할에 대해 알아보자.<img src=\"https://i.imgur.com/whuE2nD.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">postcss의 공식문서에는 PostCSS is a tool for transforming styles with JS plugins. 라고 적혀있다. js를 이용하여 css를 변환시킨다는 이야기이다.postcss는 다른 scss, Stylus들과는 다르게 후처리기의 성격을 지닌다.\nCSS 전처리기\n화면에 보이기 전에 CSS를 변경하고, 스타일을 적용\nCSS 작성 -&gt; 실행 전에 기본 CSS로 컴파일 -&gt; 렌더링\nStylus, Sass, Less 등 CSS 후처리기\n화면에 보여진 뒤에 CSS 스타일을 적용\nCSS 작성 -&gt; 렌더링 -&gt; 외부 모듈을 사용하여 스타일 변경\nPostCSS 등\n<br><img src=\"https://i.imgur.com/oHM1gfQ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\npostCSS는 위와 같이 Parser -&gt; plugins -&gt; Stringifier 의 과정을 거친다.가장 먼저 Parser에서는 문자열을 tokenizing한 다음 AST로 변환하여 단일 파일을 작성하는 과정을 거친다.\n기존의 CSS에 대해서 토큰화 하는 과정을 살펴보자..className { color: #FFF; }\n위와 같은 CSS를 만들기 위해서는 우선 이러한 CSS에 대해 tokenizing한 결과를 보면 [ [\"word\", \".className\", 1, 1, 1, 10] [\"space\", \" \"] [\"{\", \"{\", 1, 12] [\"space\", \" \"] [\"word\", \"color\", 1, 14, 1, 18] [\":\", \":\", 1, 19] [\"space\", \" \"] [\"word\", \"#FFF\" , 1, 21, 1, 23] [\";\", \";\", 1, 24] [\"space\", \" \"] [\"}\", \"}\", 1, 26]\n]\n이런 식으로 각각 단일 토큰에 대해서 배열로 관리하며, 토큰 타입, 단어, 위치 정보 등을 관리한다.const token = [ // 토큰 타입 'word', // 매칭된 단어 '.className', // 앞 두 숫자 -&gt; 토큰의 시작 위치(optional) // `space`와 같은 토큰은 위치 정보 없음 // 여기서 첫 번째 숫자는 줄 번호이고, 두 번째 숫자는 해당 줄의 열 번호 1, 1, // 이 토큰처럼 여러 문자의 토큰에 대해 끝 위치(optional) // 숫자는 위에서 설명한 규칙과 같음 1, 10\n] 이렇게 토큰화된 각각의 CSS에 대해서 postcss의 lib/parse.js와 lib/parser.js의 모듈을 통해 파싱한다. 이 파서를 통해서 CSS에 대한 AST를 생성한다.'use strict' let Container = require('./container')\nlet Input = require('./input')\nlet Parser = require('./parser') function parse(css, opts) { let input = new Input(css, opts) let parser = new Parser(input) try { parser.parse() } catch (e) { if (process.env.NODE_ENV !== 'production') { if (e.name === 'CssSyntaxError' &amp;&amp; opts &amp;&amp; opts.from) { if (/\\.scss$/i.test(opts.from)) { e.message += '\\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser' } else if (/\\.sass/i.test(opts.from)) { e.message += '\\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser' } else if (/\\.less$/i.test(opts.from)) { e.message += '\\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser' } } } throw e } return parser.root\n} module.exports = parse\nparse.default = parse Container.registerParse(parse)\n해당 parse에서는 parser 생성자를 통해 다시금 토큰화된 것들을 AST로 만드는 과정을 거치고, 이에 대한 root를 반환한다.그렇게 만들어진 ast에 대해서는 processor(lib/processor.js)를 통해서 플러그인들을 초기화하고 문법적으로 변환하는 과정을 거친다.'use strict' let Document = require('./document')\nlet LazyResult = require('./lazy-result')\nlet NoWorkResult = require('./no-work-result')\nlet Root = require('./root') class Processor { constructor(plugins = []) { this.version = '8.4.47' this.plugins = this.normalize(plugins) } normalize(plugins) { let normalized = [] for (let i of plugins) { if (i.postcss === true) { i = i() } else if (i.postcss) { i = i.postcss } if (typeof i === 'object' &amp;&amp; Array.isArray(i.plugins)) { normalized = normalized.concat(i.plugins) } else if (typeof i === 'object' &amp;&amp; i.postcssPlugin) { normalized.push(i) } else if (typeof i === 'function') { normalized.push(i) } else if (typeof i === 'object' &amp;&amp; (i.parse || i.stringify)) { if (process.env.NODE_ENV !== 'production') { throw new Error( 'PostCSS syntaxes cannot be used as plugins. Instead, please use ' + 'one of the syntax/parser/stringifier options as outlined ' + 'in your PostCSS runner documentation.' ) } } else { throw new Error(i + ' is not a PostCSS plugin') } } return normalized } process(css, opts = {}) { if ( !this.plugins.length &amp;&amp; !opts.parser &amp;&amp; !opts.stringifier &amp;&amp; !opts.syntax ) { return new NoWorkResult(this, css, opts) } else { return new LazyResult(this, css, opts) } } use(plugin) { this.plugins = this.plugins.concat(this.normalize([plugin])) return this }\n} module.exports = Processor\nProcessor.default = Processor Root.registerProcessor(Processor)\nDocument.registerProcessor(Processor)\n이렇게 문법적으로 변환하는 과정을 마치면 이를 다시 순수 CSS 구문으로 바꿔줘야 하는데, Stringifier가 AST를 순회하면서 각 노드에 대해 CSS 문자열을 생성해낸다. /** @type {import('tailwindcss').Config} */\nexport default { content: [ \"./index.html\", \"./src/**/*.{js,ts,jsx,tsx}\", ], theme: { extend: {}, }, plugins: [],\n}\n%% index.css %%\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Tailwind와 필요한 것들 설치","level":2,"id":"Tailwind와_필요한_것들_설치_0"},{"heading":"postcss와 autoprefixer는 왜 필요할까?","level":3,"id":"postcss와_autoprefixer는_왜_필요할까?_0"},{"heading":"postcss","level":4,"id":"postcss_0"},{"heading":"autoprefixer","level":4,"id":"autoprefixer_0"},{"heading":"템플릿 경로 지정","level":2,"id":"템플릿_경로_지정_0"},{"heading":"index.css에 tailwind 설정 추가","level":2,"id":"index.css에_tailwind_설정_추가_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/others/tailwind-설정하기.html","pathToRoot":"../../..","attachments":[],"createdTime":1728347067386,"modifiedTime":1728348960657,"sourceSize":6372,"sourcePath":"학습 정리/Frontend/Others/Tailwind 설정하기.md","exportPath":"학습-정리/frontend/others/tailwind-설정하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/others/xss-공격.html":{"title":"xss 공격","icon":"","description":"XSS 공격은 웹 해킹 공격 중 하나이다.\nCross Site Scripting의 약자로 CSS와 겹치지 않게 XSS 공격이라고 부른다.XSS는 게시판이나 웹 메일 등에 자바스크립트 코드를 삽입하여 개발자가 고려하지 않은 기능을 작동시킬 수도 있는 치명적인 공격이다.Reflected XSS는 스크립트가 포함된 공격용 악성 URL을 만들어 사용자가 해당 URL을 클릭했을 때 정보를 흭득하는 방식으로 공격이 이루어진다.\n<img src=\"https://i.imgur.com/PIo0PxZ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">URL을 만들어서 클릭해서 실행되게 하는 방식으로&nbsp;특정인을 대상으로&nbsp;한다\nURL&nbsp;파라미터 데이터가 그대로 서버 응답에 삽입되어 오는 곳에서 발생하며(요청과 응답 페이지가 동일해야 함) , 데이터 전달은&nbsp;GET 방식이여야 한다(POST 방식은 공격에 활용할 여지가 없음)<br><img src=\"https://i.imgur.com/yxoWQUn.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nStored XSS는&nbsp;취약한 웹 서버에 악성 스크립트를 심어놓고, 사용자가 접근하면 해당&nbsp;스크립트가 실행되는 공격이다.보통 서버에서 필터링을 하기 때문에 공격을 우회하기 어렵지만, 한 번 성공하면 관리자 입장에서는 눈치채기 힘들고&nbsp;광범위한 피해를 줄 수 있다는 것이 특징이다. &nbsp; 데이터가&nbsp;저장되고,&nbsp;출력되는 곳 (저장되는 페이지와 출력되는 페이지는 달라도 상관 없음)\n-&nbsp;접근하는 모든 사람에게 공격이 가능하기 때문에 광역기 수준의 위험도를 가짐\n<br><img src=\"https://i.imgur.com/8epYE3J.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nReflected XSS와 Stored XSS 공격이 서버의 취약점을 이용해서 악성 스크립트가 포함된 응답 페이지를 전달하는 것이다. 반면 DOM XSS는 서버와 관련없이 클라이언트 단에서 파라미터를 처리할 때 발생한다.&nbsp;DOM XSS 공격은 사용자가 공격자가 조작한 URL을 클릭하는 순간, 악성 스크립트가 실행되면서 사용자 브라우저를 공격하는 방법이다.XSS 공격에 대응하는 방법은, 주로 XSS의 접근 방식을 보완하면 된다.\nXSS는 사용자의 입력 값에서부터 발생하여, HTML Entity로 입력 값 조작을 방지하는 것이 근본적인 대방책이다.\n&lt;&gt;\";&amp;와 같은 HTML 예약어에 대해서 정규표현식 등으로 검사한 뒤에 스크립트가 실행될 수 있는 환경을 만듦으로써 공격자의 우회 방식을 방어할 수 있다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"공격 유형","level":2,"id":"공격_유형_0"},{"heading":"Reflected XSS","level":3,"id":"Reflected_XSS_0"},{"heading":"Stored XSS","level":3,"id":"Stored_XSS_0"},{"heading":"DOM based XSS","level":3,"id":"DOM_based_XSS_0"},{"heading":"XSS 방어하기","level":2,"id":"XSS_방어하기_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/others/xss-공격.html","pathToRoot":"../../..","attachments":[],"createdTime":1725338180168,"modifiedTime":1725338726635,"sourceSize":2589,"sourcePath":"학습 정리/Frontend/Others/xss 공격.md","exportPath":"학습-정리/frontend/others/xss-공격.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/react/concurrent-mode.html":{"title":"Concurrent mode","icon":"","description":"동시성 모드(concurrent mode)는 한 가지 일이 끝날 때 까지 무조건 다음 작업을 기다리는 것이 아닌, 한 가지 일이 실행 중일 동안 다른 일을 수행하는 것을 의미한다.\n그렇다면 이 동시성(concurrency)이 병행성(parallelism)과 같은 의미를 가진 동의어가 아닌가? 라고 생각할 수 있겠지만 둘이 말하는 작업의 동시성은 조금 다르다.동시성의 경우 한 가지 일이 무조건 끝날 때까지 기다리는 것이 아니라, 그 사이에 다른 일을 할 수 있으면 하는 것이다.\n반면 병행성의 경우는 동시에 두 가지 이상의 일을 하는 것이다. 그러니 한 가지 일이 끝날 때까지 기다리는 것과는 상관이 없고 작업마다 각각 알아서 수행하는 것이다.\n가장 쉬운 예로, 손이 두개지만 빠른 사람과 손이 여덟개인 사람을 생각하면 동시성과 병행성이 무엇을 의미하는 것인지 느낌이 올 것이다.리액트에서의 동시성 처리는 여러 작업을 처리할 수 있도록 작업들을 작은 조각들로 나누고, 스케줄러를 통하여 각 작업들의 중요도에 따른 우선순위를 부여한다(time-slicing). 아무리 손이 빠른 사람이라고 하더라도 사실상 단계별로 하지 않으면 결국 전체적인 작업은 망가지기 마련이다.\n샌드위치 만드는 과정에서 빵을 굽는 작업과 잼을 바르는 작업을 할 때, 빵을 먼저 굽고 잼을 바르듯이 작업에도 우선순위를 부여하고 이에 따라 작업을 처리할 필요가 있다.리액트가 이렇게 나눈 작업들을 처리하는 과정에서 메인스레드는 블록되지 않으며, 동시에 여러 작업을 처리하면서 우선 순위에 따라 각 작업들 간에 전환이 가능하게 되었다.이와 같이 리액트 18버전부터는 동시성 렌더링을 통해서 렌더링 자체에 개임하고, 이를 중단하거나 재개, 폐기하는 등 작업들을 단위별로 조정할 수 있게 되었다.React 18 이전에는 렌더링이 동기적으로 처리되었기 때문에 이 중간에 어떤 것도 개입할 수 없었다. 이는 곧 렌더링이 실행되면 렌더링이 끝날 때까지 무조건 기다려야 했다는 이야기기도 했다.그래서 만약 렌더링이 오래 걸리는 작업의 경우에는, 다음 수행한 작업이 블로킹되어 애플리케이션 자체가 렉을 먹는 듯한 모습을 보여주어 UX가 현저히 떨어지게 된다.이러한 문제를 해결하기 위해서 개발자들은 Debounce와 Throttle 방식을 사용하여 어느정도 해소할 수 있었다.\nDebounce\n사용자의 입력이 연속으로 들어올 때 마지막 입력 후 일정 시간이 지난 다음에 무거운 작업을 수행하는 방식 Throttle\n특정 시간 동안 한 번만 함수를 실행할 수 있도록 제한하는 방식.\n하지만 이러한 방식 또한 Debounce의 경우에는 성능이 좋아도 모든 기기에서 같은 시간동안 대기 후에 작업 수행을 해야했고, Throttle의 경우에는 Throttle 주기를 짧게 가져갈수록 성능은 점점 떨어진다는 한계가 보였다.그렇기 때문에 이러한 동기적 렌더링의 한계를 해소하고자 동시성의 필요성이 대두되어 나오게 되었다.기존의 ReactDOM 함수의 프로토타입 함수로 사용하던 render를 사용하지 않고 ReactDOM의 프로토타입 함수인 createRoot를 통해서 객체를 생성한 뒤, 해당 객체의 render 함수를 통해 엔트리 포인트를 렌더링시킨다.import ReactDOM from 'react-dom';\nimport App from 'App'; const container = document.getElementById('app'); // 이전 버전(React 17)\nconst container = document.getElementById('app'); ReactDOM.render(&lt;App /&gt;, container); // Concurrent Mode 도입 이후(React 18)\n// 루트 생성\nconst root = ReactDOM.createRoot(container); // 루트 객체의 메서드로 앱을 렌더링\nroot.render(&lt;App /&gt;);\n{루트객체}.render를 통해서 앱을 렌더링시키게 되면 개선된 기능들과 동시 처리를 위한 startTransition, useTransition, useDeferredValue 훅을 사용할 수 있다.<img src=\"https://i.imgur.com/VbEpPyR.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n여러 개의 상태를 업데이트할 경우, 기존에는 하나의 state의 업데이트 -&gt; 변경된 상태를 리렌더링 -&gt; 다음 state의 업데이트의 단계로 상태가 업데이트 되었기 때문에 여러번 리렌더링이 발생하였고, 이에 성능적으로 좋지 않은 효과를 가져왔다.기존의 React 17까지도 Automatic Batching이 적용은 되어 있었지만, 적용되는 곳이 이벤트 핸들러 함수 내부로 한정적인 특성을 가졌다.\n그러다보니 네트워크 호출(Promise)에 대한 .then 메서드의 콜백 함수에 여러개의 상태 업데이트가 들어가 있다거나 setTimeout의 콜백 함수 안의 여러 상태 업데이트 등에서는 상태 업데이트가 일괄처리가 아닌, 순차처리 방식으로 동작하면서 변경된 state의 수만큼 리렌더링을 수행하게 된다. 그러다보니 성능적으로 떨어지는 효과를 가지게 된 것이다.이에 React18부터 Concurrent Mode가 활성화되면, 모든 Promise나 setTimeout, 이벤트 콜백 등에서 다수 개의 상태 업데이트가 일괄로 처리되도록 변경되었다.<br><img src=\"https://i.imgur.com/rwH08eL.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Transition 관련 훅들은 전부 우선순위를 직접 관리하여 렌더링 과정에서 성능을 개선하기 위해 새롭게 추가된 훅들이다.\n위에서 말한 것과 같이 이전의 렌더링 방식은 동기적으로 계속해서 UI에 대한 업데이트 실행 -&gt; 리렌더링의 반복이었다. <br><img src=\"https://i.imgur.com/CQ49j39.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">하지만 동시성 렌더링 방식으로 변경되면서 첫 상태 업데이트부터 최종적으로 보여야 하는 화면의 렌더링까지 가는 과정에서 중간에 계속해서 우선순위가 낮은, 즉 가벼운 업데이트를 끼워 비교적 가벼운 업데이트 -&gt; 무거운 업데이트순으로 업데이트를 시킬 수 있도록 처리하여 UI blocking 없이 동시에 다른 작업이 수행되는 것과 같은 사용자 경험을 제공할 수 있게 되었다.useTransition은 이러한 동시성을 구현하기 위해 필요한 훅이다. 이 훅은 리액트 컴포넌트 안에서 동시성 모드에 접근할 수 있도록 해준다.import { useState } from 'react'; export function FilterList({ names }) { const [query, setQuery] = useState(''); const changeHandler = ({ target: { value } }) =&gt; setQuery(value); return ( &lt;div&gt; &lt;input onChange={changeHandler} value={query} type=\"text\" /&gt; {names.map((name, i) =&gt; ( &lt;ListItem key={i} name={name} highlight={query} /&gt; ))} &lt;/div&gt; );\n} function ListItem({ name, highlight }) { const index = name.toLowerCase().indexOf(highlight.toLowerCase()); if (index === -1) { return &lt;div&gt;{name}&lt;/div&gt;; } return ( &lt;div&gt; {name.slice(0, index)} &lt;span className=\"highlight\"&gt; {name.slice(index, index + highlight.length)} &lt;/span&gt; {name.slice(index + highlight.length)} &lt;/div&gt; );\n}\n해당 코드를 보면 input의 내용이 바뀔 때마다 setState를 실행하고 있고, state가 바뀌게 되면 리렌더링이 이루어지며, names를 map하는 함수가 리렌더링 때마다 실행되며 UI를 다시금 화면에 띄운다.하지만 이러한 name들이 점점 많아질 수록, input에 빠르게 입력하게 된다면 리렌더링 속도가 input 이벤트핸들러의 setState가 실행되는 속도를 따라가지 못하게 되고, 결극 input의 value가 빠르게 입력될 수 없는 문제를 가지게 된다.<br>\n<a data-tooltip-position=\"top\" aria-label=\"https://codesandbox.io/p/sandbox/heavy-update-as-urgent-ejwbg\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://codesandbox.io/p/sandbox/heavy-update-as-urgent-ejwbg\" target=\"_self\">예시 보기</a>이럴때, 무거운 작업은 List의 리렌더링이 될 것이고, 비교적 가벼운 작업은 input의 eventHandler 안에 들어있는 setState에 대한 input의 value 리렌더링이다. 그렇다면 이 input의 리렌더링에 대해서 우선순위를 높여 input먼저 계속 먼저 리렌더링 될 수 있게만 한다면 input이 밀리게 되는 현상을 방지할 수 있는 것이다. 그럴 때 사용하는 훅이 useTransition 훅이다.[isPending, startTransition] = useTransition()\nuseTransition을 사용하면 isPending, startTranstion의 리턴값을 받는다.\nisPending: transition이 pending 상태인지 알려주는 boolean 값\nstartTransition(callbackFn): UI 업데이트에 관한 로직을 콜백 함수로 넘겨줌\n이 startTransition을 통해서 콜백함수의 setState를 통한 리렌더링 로직을 우선순위가 낮도록 설정하여 후순위로 렌더링이 이루어질 수 있도록 하면서 성능을 개선한다.\n`startTransition` lets you update the state without blocking the UI.\n라고 React의 공식문서에서 나와 있는 설명과 같이, UI를 따로 블로킹하지 않고 상태를 업데이트 하도록 시킴으로써 비교적 무거워서 다른 UI의 렌더링을 막는 작업들을 의도적으로 지연시킬 수 있다.import { startTransition } from 'react'; function TabContainer() { const [tab, setTab] = useState('about'); function selectTab(nextTab) { startTransition(() =&gt; { setTab(nextTab); }); } // ...\n}\n이런 식으로 setState가 있는 부분의 경우 렌더링 과정에서 막히지 않고 따로 진행되기 때문에 가벼운 UI의 업데이트 등이 막히지 않고 바로바로 렌더링이 될 수 있는 환경을 제공한다.useDeferredValue는 상태의 업데이트 우선순위를 낮춘다는 점에서 useTransition과 유사하게 동작하는 면이 있다.\n하지만 startTransition은 콜백함수 내부에 setState를 사용하는 방식이고, useDeferredValue는 state값을 인자로 받아서 지연된 값을 반환하는 함수이다. 따라서 useTransition은 상태를 변화시키는 행동 자체를 래핑하는 것이고, useDeferredValue은 값 자체를 래핑해서 사용하는 형태이다.useDeferredValue로 래핑한 상태의 경우에는 다른 상태값이 모두 상태 변경이 이루어진 이후에 자신이 바뀌게 된다. 값 변화의 우선순위가 낮아지기 때문에 다른 상태들의 업데이트 이후에 실행되는 것이다.그렇기에 사용하는 방식에 따라 useTransition과 useDeferredValue를 취사 선택하여 사용한다.\nuseTransition : 상태 변경에 대한 리렌더링이 모두 이루어진 후 콜백 함수 실행 콜백 함수 안에 setState를 넣어 사용 useDeferredValue: 상태 변경에 대한 리렌더링이 모두 이루어진 후에 변한 값에 대한 리렌더링\n추가적으로 useDeferredValue는 Suspense와 함께 사용이 가능하다 .\n만약 useDeferredValue의 인자로 설정한 상태가 변경하게 되면 새로운 값으로 인한 백그라운드 업데이트 동안 이전의 상태를 보여준다. 업데이트 이전의 상태를 보여주면서 다음 컴포넌트들의 렌더링이 모두 이루어진 후에 해당 상태를 참조하는 컴포넌트에서 다시금 렌더링을 시도한다. 이 렌더링을 시도하는 과정에서 기존에는 훅을 사용하여 새롭게 데이터를 fetching하는 동안 나올 ui를 설정하거나 Suspense를 활용하여 fallback UI를 보여줌으로써 사용자에게 로딩중임을 보여줄 수 있다.\nSuspense\n콘텐츠가 렌더링할 준비가 되기 전까지 대체 UI를 보여주는 태그\nexport default function App() { const [query, setQuery] = useState(''); return ( &lt;&gt; &lt;label&gt; Search albums: &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt; &lt;/label&gt; &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt; &lt;SearchResults query={query} /&gt; &lt;/Suspense&gt; &lt;/&gt; );\n} 기본적으로 컴포넌트가 일시 중단됐을 때 lazy loading이나 use, Next.js와 같은 suspense 지원하는 프레임워크의 데이터 페칭 등을 사용하게 되면 가장 가까운 상위 Suspense 컴포넌트가 fallback ui를 띄워주게 된다. import { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return ( &lt;&gt; &lt;label&gt; Search albums: &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt; &lt;/label&gt; &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt; &lt;SearchResults query={deferredQuery} /&gt; &lt;/Suspense&gt; &lt;/&gt; );\n}\n여기서 useDeferredValue를 사용하게 되면 기존 상태를 업데이트한 값에 대해서 지연된 렌더링이 이루어지고, 그 렌더링이 다시금 이루어지는 동안 이전의 값이 있을 경우 이를 표시함으로써 이전의 값을 나타낼 수 있다.또한 이 방식을 조금 더 활용하여 기존의 값과 만약 값이 바뀌었다면 이를 비교하는 변수 하나를 만들어 refetching하고 있는 상태를 알 수 있는 ui로 보여줄 수도 있다.import { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return ( &lt;&gt; &lt;label&gt; Search albums: &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt; &lt;/label&gt; &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt; &lt;div style={{ opacity: isStale ? 0.5 : 1, transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear' }}&gt; &lt;SearchResults query={deferredQuery} /&gt; &lt;/div&gt; &lt;/Suspense&gt; &lt;/&gt; );\n}\n위 예시에서는 새롭게 업데이트된 deferredQuery와 이전의 값이어던 query를 비교한 변수인 isStale을 따로 선언하여 이에 따라 transition을 주며 refetching중인 상태를 나타내었다. 이를 비교하여 ui를 띄울 때는 suspense의 fallback ui보다는 기존의 값을 띄우는 방식으로도 사용할 수 있다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://dmitripavlutin.com/react-usetransition/\" target=\"_self\">https://dmitripavlutin.com/react-usetransition/</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@heelieben/React-18-Concurrent-Rendering\" target=\"_self\">https://velog.io/@heelieben/React-18-Concurrent-Rendering</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Concurrent mode","level":2,"id":"Concurrent_mode_1"},{"heading":"왜 우선순위를 분리할까?","level":3,"id":"왜_우선순위를_분리할까?_0"},{"heading":"동시성의 도입 배경","level":3,"id":"동시성의_도입_배경_0"},{"heading":"Concurrent Mode 설정","level":3,"id":"Concurrent_Mode_설정_0"},{"heading":"Concurrent Mode의 활용","level":2,"id":"Concurrent_Mode의_활용_0"},{"heading":"Automatic Batching(상태 일괄처리)","level":3,"id":"Automatic_Batching(상태_일괄처리)_0"},{"heading":"Transition 관련 훅들","level":3,"id":"Transition_관련_훅들_0"},{"heading":"useTransition","level":4,"id":"useTransition_0"},{"heading":"useDeferredValue","level":4,"id":"useDeferredValue_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/react/concurrent-mode.html","pathToRoot":"../../..","attachments":[],"createdTime":1729496254879,"modifiedTime":1729858045744,"sourceSize":14955,"sourcePath":"학습 정리/Frontend/React/Concurrent mode.md","exportPath":"학습-정리/frontend/react/concurrent-mode.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/react/error-boundary와-suspense.html":{"title":"Error boundary와 Suspense","icon":"","description":"클라이언트에서 오류를 받게 되면 UI가 그대로 없어지는 현상을 많이 보았을 것이다.\n하지만 이러한 현상은 사용자경험에 있어서는 치명적인 오류가 아닐 수 없다.\n그렇기 때문에 Error boundary를 설정함으로써 깨진 컴포넌트 트리 대신 Fallback UI, 즉 대체할 수 있는 UI를 보여줄 수 있도록 해서 에러를 관리하는 패턴이다.리액트에서는 버전 16부터 이를 도입하여 렌더링 도중의 생명주기 / 하위 트리 에서 에러를 잡아낼 수 있도록 클래스형 컴포넌트에 두 가지 생명주기 메서드를 도입했다.\nstatic getDerivedStateFromError()\ncomponentDidCatch() 하지만 다음과 같은 에러는 잡지 못하니 주의하자. 이벤트 핸들러\n비동기적 코드 (예: setTimeout 혹은 requestAnimationFrame 콜백)\n서버 사이드 렌더링\n자식에서가 아닌 에러 경계 자체에서 발생하는 에러 class ErrorBoundary extends React.Component { constructor(props) { super(props) this.state = { hasError: false } } static getDerivedStateFromError(error) { // 다음 렌더링에서 폴백 UI가 보이도록 상태를 업데이트 return { hasError: true } } componentDidCatch(error, errorInfo) { // 에러 로그 찍기 logErrorToMyService(error, errorInfo) } render() { if (this.state.hasError) { // 폴백 UI를 커스텀하여 렌더링시키기 return &lt;h1&gt;Something went wrong.&lt;/h1&gt; } return this.props.children }\n}\n이렇게 만들어진 클래스형 컴포넌트는 &lt;ErrorBoundary&gt; &lt;App /&gt;\n&lt;/ErrorBoundary&gt;\n이런 식으로 프로젝트 자체를 전부 래핑하여 오류를 발견하고, 에러가 보일 시에 다른 텍스트를 통해 UI로 돌아가게끔 할 수 있다.\n하지만 위와 같이 제공해준 생명주기 메서드는 훅이 있는 함수형 컴포넌트에서는 사용이 불가능하다.그래서 클래스형으로 고차 컴포넌트를 만들고, 이를 감싸는 바운더리 컴포넌트를 통해 관리하는 것으로 보인다.import React from \"react\" type ErrorHandler = (error: Error, info: React.ErrorInfo) =&gt; void\ntype ErrorHandlingComponent&lt;Props&gt; = (props: Props, error?: Error) =&gt; React.ReactNode type ErrorState = { error?: Error } export default function withCatch&lt;Props extends {}&gt;( component: ErrorHandlingComponent&lt;Props&gt;, errorHandler?: ErrorHandler\n): React.ComponentType&lt;Props&gt; { function Inner(props: { error?: Error, props: Props }) { return &lt;React.Fragment&gt;{component(props, error)}&lt;/React.Fragment&gt; } return class extends React.Component&lt;Props, ErrorState&gt; { state: ErrorState = { error: undefined } static getDerivedStateFromError(error: Error) { return { error } } componentDidCatch(error: Error, info: React.ErrorInfo) { if (errorHandler) { errorHandler(error, info) } } render() { return &lt;Inner error={this.state.error} props={this.props} /&gt; } }\n}\n해당 컴포넌트는 고차 컴포넌트(Higher-Order Component, HOC)로 만들어 졌으며, 자식 컴포넌트의 에러를 잡아내고 처리하는 기능을 추가한 버전이다. 함수형 컴포넌트처럼 생겼지만서도 내부에서는 클래스형 컴포넌트를 이용해서 구현하였다.\n해당 컴포넌트는 children을 받는 것처럼 안쪽의 요소를 받아 그대로 컴포넌트로 에러 상태를 내려준다.Inner라는 함수형 컴포넌트를 통해 안쪽에 에러 바운더리를 설정하는데, 이를 에러의 상태를 잡아 캐치하게 되면 error에는 해당 에러의 내용이 담기게 되고, 에러가 있을 경우 getDerivedStateFromError에 에러가 담기게 되며, state가 업데이트 되고, componentDidCatch가 실행되어 해당 에러에 대해 처리를 하게 된다.따라서 에러 처리를 단계별로 나누어보자면\n컴포넌트 생성: Catch 함수를 통해 에러 바운더리 역할을 하는 클래스형 컴포넌트를 반환\n렌더링: 컴포넌트가 렌더링될 때, 자식 컴포넌트(Inner)가 호출되어 에러 또는 정상적인 props로 렌더링됩니다.\n에러 발생 시: 자식 컴포넌트에서 에러가 발생하면, getDerivedStateFromError 메서드가 호출되어 state.error가 설정되고 이 상태에 따라 에러가 렌더링됩니다.\n에러 후처리: 에러가 발생하면 componentDidCatch에서 에러 핸들러가 동작할 수 있습니다.\n이러한 방식은 라이브러리인 react-error-boundary에서도 비슷한 방식으로 활용한다.import { isDevelopment } from \"#is-development\";\nimport { Component, createElement, ErrorInfo, isValidElement } from \"react\";\nimport { ErrorBoundaryContext } from \"./ErrorBoundaryContext\";\nimport { ErrorBoundaryProps, FallbackProps } from \"./types\"; type ErrorBoundaryState = | { didCatch: true; error: any; } | { didCatch: false; error: null; }; const initialState: ErrorBoundaryState = { didCatch: false, error: null,\n}; export class ErrorBoundary extends Component&lt; ErrorBoundaryProps, ErrorBoundaryState\n&gt; { constructor(props: ErrorBoundaryProps) { super(props); this.resetErrorBoundary = this.resetErrorBoundary.bind(this); this.state = initialState; } static getDerivedStateFromError(error: Error) { return { didCatch: true, error }; } resetErrorBoundary(...args: any[]) { const { error } = this.state; if (error !== null) { this.props.onReset?.({ args, reason: \"imperative-api\", }); this.setState(initialState); } } componentDidCatch(error: Error, info: ErrorInfo) { this.props.onError?.(error, info); } componentDidUpdate( prevProps: ErrorBoundaryProps, prevState: ErrorBoundaryState ) { const { didCatch } = this.state; const { resetKeys } = this.props; // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array, // we'd end up resetting the error boundary immediately. // This would likely trigger a second error to be thrown. // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set. if ( didCatch &amp;&amp; prevState.error !== null &amp;&amp; hasArrayChanged(prevProps.resetKeys, resetKeys) ) { this.props.onReset?.({ next: resetKeys, prev: prevProps.resetKeys, reason: \"keys\", }); this.setState(initialState); } } render() { const { children, fallbackRender, FallbackComponent, fallback } = this.props; const { didCatch, error } = this.state; let childToRender = children; if (didCatch) { const props: FallbackProps = { error, resetErrorBoundary: this.resetErrorBoundary, }; if (typeof fallbackRender === \"function\") { childToRender = fallbackRender(props); } else if (FallbackComponent) { childToRender = createElement(FallbackComponent, props); } else if (fallback === null || isValidElement(fallback)) { childToRender = fallback; } else { if (isDevelopment) { console.error( \"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\" ); } throw error; } } return createElement( ErrorBoundaryContext.Provider, { value: { didCatch, error, resetErrorBoundary: this.resetErrorBoundary, }, }, childToRender ); }\n} function hasArrayChanged(a: any[] = [], b: any[] = []) { return ( a.length !== b.length || a.some((item, index) =&gt; !Object.is(item, b[index])) );\n}\n보다 리액트의 안쪽까지 들어가서 createElement를 통해 컴포넌트를 생성하고, Context를 이용해서 내려주는 방식을 사용하고 있다.아무튼 다시 위의 보다 간소화된 코드로 돌아가서,,import { Fragment } from \"react/jsx-runtime\";\nimport withCatch from \"./withCatch\"; type Props = { children: React.ReactNode;\n}; const ErrorBoundary = withCatch(function ErrorBoundary( props: Props, error?: Error,\n) { if (error) { return ( &lt;div&gt; &lt;h1&gt;{error.message}&lt;/h1&gt; &lt;/div&gt; ); } else { return &lt;Fragment&gt;{props.children}&lt;/Fragment&gt;; }\n}); export default ErrorBoundary; 고차컴포넌트를 활용한 방식이다. 아까 만들어진 withCatch을 사용한다.해당 에러 바운더리 컴포넌트는 현재 withCatch 고차 컴포넌트 안에 컴포넌트가 들어가 있는 방식이다. function App() { return ( &lt;ErrorBoundary&gt; &lt;div className=\"flex w-[930px] flex-col gap-9\"&gt; &lt;Header /&gt; &lt;ComponentA /&gt; &lt;ComponentB /&gt; &lt;/div&gt; &lt;/ErrorBoundary&gt; );\n}\n이런 식으로 Error Boundary 안에 children으로 안쪽 요소를 채워넣게 되는 형태가 되는데, 이 함수들의 흐름을 따라가면서 보다 자세하게 이해해보자.ErrorBoundary 컴포넌트의 props로는 children 속성으로 안에 들어가 있는 요소들이 들어가게 된다. container와 비슷한 느낌이라고 볼 수 있다.type Props = { children: React.ReactNode;\n}; const ErrorBoundary = withCatch(function ErrorBoundary( props: Props, error?: Error,\n) { if (error) { return ( &lt;div&gt; &lt;h1&gt;{error.message}&lt;/h1&gt; &lt;/div&gt; ); } else { return &lt;Fragment&gt;{props.children}&lt;/Fragment&gt;; }\n});\nErroBoundary에는 컴포넌트를 withCatch가 감싸고 있다.\nwitchCatch로 넘어가보자export default function withCatch&lt;Props extends {}&gt;( component: ErrorHandlingComponent&lt;Props&gt;, errorHandler?: ErrorHandler\n): React.ComponentType&lt;Props&gt;\nwithCatch는 에러를 핸들링하는 컴포넌트와 errorHandler를 가지게 된다.\n이 component의 타입을 보자type ErrorHandlingComponent&lt;Props&gt; = ( props: Props, error?: Error,\n) =&gt; React.ReactNode;\n필요한 props를 제네릭을 통해 넘겨받고, 여기에 error까지 서비스로 받는다(없을 수도 있음).\n그 error를 처리하는 로직을 담은 ErrorBoundary가 여기에 들어가는 것이다.type ErrorState = { error?: Error };\n...\nfunction Inner({ error, props }: { error?: Error; props: Props }) { return &lt;Fragment&gt;{component(props, error)}&lt;/Fragment&gt;; } return class extends Component&lt;Props, ErrorState&gt; { state: ErrorState = { error: undefined, }; static getDerivedStateFromError(error: Error) { return { error }; } componentDidCatch(error: Error, info: React.ErrorInfo) { if (errorHandler) { errorHandler(error, info); } } render() { return &lt;Inner error={this.state.error} props={this.props} /&gt;; } };\n이렇게 Errorboundary를 넣었을 경우에, withCatch는 다시금 컴포넌트를 내뱉는다. 하지만 이번엔 ErrorState까지 상태로 가진 컴포넌트이다.클래스형 컴포넌트에서는 리액트의 생명주기가 있는데, 이 생명주기에서 getDerivedStateFromError를 통해 에러를 잡는다. 얘는 하위 컴포넌트에서 오류가 발생하면 호출되면서 해당 오류를 인자로 받는다.\n에러가 발생한 뒤에 fallback UI를 렌더링 시키기 위해서는getDerivedStateFromError 를 통해 에러를 잡아야 한다. 얘는 하위 자식 컴포넌트에서 오류가 발생했을 때 render단계에서 호출된다.\n호출이 되면서 state라는 프로퍼티에는 error가 들어가게 되고, 그 다음 Inner 컴포넌트를 리턴한다. 이 컴포넌트에서 받았던 props 속성 + error를 서비스로 받게 되는 것이다.function Inner({ error, props }: { error?: Error; props: Props }) { return &lt;Fragment&gt;{component(props, error)}&lt;/Fragment&gt;; }\n그렇게 되면 해당 함수형 컴포넌트는 error와 props를 받아 Fragment 사이에 해당 컴포넌트 자체를 실행시켜 렌더링된 요소를 안쪽에 넣게 된다.const ErrorBoundary = withCatch(function ErrorBoundary( props: Props, error?: Error,\n) { if (error) { return ( &lt;div&gt; &lt;h1&gt;{error.message}&lt;/h1&gt; &lt;/div&gt; ); } else { return &lt;Fragment&gt;{props.children}&lt;/Fragment&gt;; }\n});\n그렇게 안쪽으로 들어간 애가 얘다. 보면 서비스로 받은 error를 달고 있다.\n그래서 얘는 하위 컴포넌트에서 에러가 발생했을 경우 error를 서비스로 받고 돌아오니까 이 error에 대해 처리를 해주기 위해 fallback UI를 띄우게 된다.\n하지만 error가 없을 경우 정상적으로 실행되었다는 소리니 ErrorBoundary로 감쌌던 children들을 그대로 넣어준다.<img src=\"https://i.imgur.com/dhpGn7A.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n이렇게 해서 만약 처음에 오류가 생기면 이와같이 에러를 받아 ErrorBoundary로 넘겨주고 Errorboundary가 이를 인지하고 해당 오류를 띄워주는 것이다!리액트에서는 throw에 대해서도 일반적으로 다 오류 취급하지 않는다.\n만약 throw한 것이 Promise 객체라면 리액트는 이에 대해서 Pending상태인 Promise구나! 하고 해당 작업에 대해서 비동기적으로 실행시켜놓는다.\nPromise는 resolve될 때해당 Promise에 대해서 실행한 결과를 const response = getHeadlines();\nexport default function ShortNews() {\n...\n}\n...\n//fetch하는 함수\nexport default function getHeadlines() { return fetchData&lt;Article[]&gt;(fetcher.get(HEADLINE_URI));\n} 중요한 점은 컴포넌트의 밖에다가 선언해야 한다는 점이다\n밖에다가 선언해놓지 않을 경우 리액트는 아무것도 모르는 상태에서 컴포넌트를 렌더링하려고 할 것이고, 그 과정에서 함수형 컴포넌트를 실행시키는데 fetch하게 된다면 이 때마다 Promise를 받고 다시금 요청하려고 하는데, 리렌더링이 무한히 되는 루프에 빠져버리고 만다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Error boundary","level":2,"id":"Error_boundary_0"},{"heading":"작동 방식 이해하기","level":3,"id":"작동_방식_이해하기_0"},{"heading":"이게 가능한 이유","level":3,"id":"이게_가능한_이유_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/react/error-boundary와-suspense.html","pathToRoot":"../../..","attachments":[],"createdTime":1728992847463,"modifiedTime":1732017011302,"sourceSize":14330,"sourcePath":"학습 정리/Frontend/React/Error boundary와 Suspense.md","exportPath":"학습-정리/frontend/react/error-boundary와-suspense.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/react/jsx에-관한-고찰.html":{"title":"JSX에 관한 고찰","icon":"","description":"JSX는 주로 우리가 리액트에서 사용하는 확장자명이다.\n페이스북에서 JSX를 리액트 만들면서 새롭게 만들기도 했지만, 그렇다고 무조건 리액트에서만 쓰이는 구문은 아니라는 점을 알아야 한다.\nJSX는 기존 자바스크립트를 확장한 문법으로, 공식적인 문법은 아니기 때문에 바벨을 사용하여 트랜스파일링할 필요가 있다.리액트 자동 런타임은 활성화되어있을 경우 자동적으로 runtime 파일을 import 해와 JSX를 컴파일하는 함수를 알아서 불러오고, 이를 실행한다.const profile = ( &lt;div&gt; &lt;img src=\"avatar.png\" className=\"profile\" /&gt; &lt;h3&gt;{[user.firstName, user.lastName].join(\" \")}&lt;/h3&gt; &lt;/div&gt;\n);\n이런 식으로 된 jsx 문법을 babel은 @babel/plugin-transform-react-jsx이라는 컴파일 플러그인을 통해서 컴파일시킬 수 있다.import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\"; const profile = _jsxs(\"div\", { children: [ _jsx(\"img\", { src: \"avatar.png\", className: \"profile\", }), _jsx(\"h3\", { children: [user.firstName, user.lastName].join(\" \"), }), ],\n});\n그렇게 바뀐 코드는 이러한 형태로 나오게 된다.\n여기서 babel은 따로 런타임 import에 대해 따로 설정을 해놓지 않았을 경우 기존 react의 jsx-runtime을 사용하여 컴파일한 결과를 내보낸다./** @jsxImportSource custom-jsx-library */ const profile = ( &lt;div&gt; &lt;img src=\"avatar.png\" className=\"profile\" /&gt; &lt;h3&gt;{[user.firstName, user.lastName].join(\" \")}&lt;/h3&gt; &lt;/div&gt;\n);\n만약 내가 커스텀한 jsx 라이브러리로 만들기 위해서는 위에 주석처럼 따로 경로디렉토리를 설정해주면 해당 경로의 jsx-runtime에서 가져와 사용한다.// 결과\nimport { jsx as _jsx } from \"custom-jsx-library/jsx-runtime\";\nimport { jsxs as _jsxs } from \"custom-jsx-library/jsx-runtime\"; const profile = _jsxs(\"div\", { children: [ _jsx(\"img\", { src: \"avatar.png\", className: \"profile\", }), _jsx(\"h3\", { children: [user.firstName, user.lastName].join(\" \"), }), ],\n});\nClassic Runtime의 경우, \bv7혹은 그 이전 바벨의 버전에서는 디폴트로 설정되어있는 기능이다.const profile = ( &lt;div&gt; &lt;img src=\"avatar.png\" className=\"profile\" /&gt; &lt;h3&gt;{[user.firstName, user.lastName].join(\" \")}&lt;/h3&gt; &lt;/div&gt;\n);\n얘는 React의 Runtime을 import해와서 사용하기보다는 React자체를 불러오고, createElement를 그대로 가져와서 사용한다.const profile = React.createElement( \"div\", null, React.createElement(\"img\", { src: \"avatar.png\", className: \"profile\" }), React.createElement(\"h3\", null, [user.firstName, user.lastName].join(\" \"))\n);\n이러한 Classic Runtime을 커스터마이징 하기 위해서는 맨 위에 주석처럼 /** @jsx Preact.h */\n과 같이 써주면, jsx 옆 모듈의 함수를 가져와 쓸 수 있도록 할 수 있다./** @jsx Preact.h */ import Preact from \"preact\"; const profile = ( &lt;div&gt; &lt;img src=\"avatar.png\" className=\"profile\" /&gt; &lt;h3&gt;{[user.firstName, user.lastName].join(\" \")}&lt;/h3&gt; &lt;/div&gt;\n);\n그렇게 되면 내가 설정한 라이브러리에서 모듈을 가져와 사용할 수도 있는 형태가 된다.\nimport문을 통해 미리 모듈을 import해주지 않으면 예상대로 동작하지 않으니 주의해야 한다./** @jsx mhreact.createElement */ import mhreact from \"mhreact\"; const test = ( &lt;div id=\"app\"&gt; &lt;p&gt;안녕하세요&lt;/p&gt; &lt;div&gt; &lt;p&gt;테스트&lt;/p&gt; &lt;div&gt; &lt;p&gt;테스트2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;\n); console.log(test); 이를 활용하여 mhreact라는 라이브러리를 만들고, 클라이언트의 의존성에 추가해준 뒤에 import해오고, createElement라는 함수를 가져와 jsx 형식에서 작성된 html 요소들을 변환해주었다./** @jsx mhreact.createElement */ import mhreact from \"mhreact\";\nvar test = mhreact.createElement( \"div\", { id: \"app\", }, mhreact.createElement(\"p\", null, \"\\uC548\\uB155\\uD558\\uC138\\uC694\"), mhreact.createElement( \"div\", null, mhreact.createElement(\"p\", null, \"\\uD14C\\uC2A4\\uD2B8\"), mhreact.createElement( \"div\", null, mhreact.createElement(\"p\", null, \"\\uD14C\\uC2A4\\uD2B82\") ) )\n);\nconsole.log(test); 변환하게 되면 이와 같이 바벨이 트랜스파일링을 해준 다음에 그 결과를 createElement의 인자로 들어가는 로직으로 변경되었다.<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://d2.naver.com/helloworld/2690975\" target=\"_self\">https://d2.naver.com/helloworld/2690975</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"React Automatic Runtime","level":3,"id":"React_Automatic_Runtime_0"},{"heading":"React Classic Runtime","level":3,"id":"React_Classic_Runtime_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/react/jsx에-관한-고찰.html","pathToRoot":"../../..","attachments":[],"createdTime":1727075943139,"modifiedTime":1727106112754,"sourceSize":4785,"sourcePath":"학습 정리/Frontend/React/JSX에 관한 고찰.md","exportPath":"학습-정리/frontend/react/jsx에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/react/react.html":{"title":"React","icon":"","description":"\n<a data-href=\"Concurrent mode\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/concurrent-mode.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Concurrent mode</a>\n<br><a data-href=\"Error boundary와 Suspense\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/error-boundary와-suspense.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Error boundary와 Suspense</a>\n<br><a data-href=\"JSX에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/jsx에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">JSX에 관한 고찰</a>\n<br><a data-href=\"React 19 베타에서 새롭게 추가된 것들\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">React 19 베타에서 새롭게 추가된 것들</a>\n<br><a data-href=\"React Fiber에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/react-fiber에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">React Fiber에 관한 고찰</a>\n<br><a data-href=\"React Portal\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/react-portal.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">React Portal</a>\n<br><a data-href=\"useEffect에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/useeffect에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">useEffect에 관한 고찰</a>\n<br><a data-href=\"useMemo와 useCallback에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">useMemo와 useCallback에 관한 고찰</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["학습-정리/frontend/react/concurrent-mode.html#_0","학습-정리/frontend/react/error-boundary와-suspense.html#_0","학습-정리/frontend/react/jsx에-관한-고찰.html#_0","학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html#_0","학습-정리/frontend/react/react-fiber에-관한-고찰.html#_0","학습-정리/frontend/react/react-portal.html#_0","학습-정리/frontend/react/useeffect에-관한-고찰.html#_0","학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/react/react.html","pathToRoot":"../../..","attachments":[],"createdTime":1738514536234,"modifiedTime":1738514545918,"sourceSize":269,"sourcePath":"학습 정리/Frontend/React/React.md","exportPath":"학습-정리/frontend/react/react.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html":{"title":"React 19 베타에서 새롭게 추가된 것들","icon":"","description":"React 19가 2024년 4월 25일 베타버전이 나오게 되었다.\n여기에 대해서도 조금 더 자세히 알아보고 이를 어떻게 활용하면 좋을지 생각하기 위해 새롭게 추가된 주요 기능들을 정리해 보려고 한다.리액트에서 말하는 Actions는 비동기적인 작업의 수행을 의미한다. 그렇다고 일반적인 data를 가져오기 위한 fetching이 아니라, form에 대한 action과 같이 사용자의 상호작용에 따라 비동기적으로 http 요청을 보내는 등의 작업을 정의한 것으로 보인다.\nReact 19는 이러한 Actions에 대해 정의하고 이를 기반으로 구축되었다. 따라서 이를 통한 여러가지 기능들이 추가되었다.이전까지의 비동기적으로 http 요청을 보내고 받아서 응답에 따라 뷰를 렌더링 하는 방식으로 많이 사용했었다.// Before Actions\nfunction UpdateName({}) { const [name, setName] = useState(\"\"); const [error, setError] = useState(null); const [isPending, setIsPending] = useState(false); const handleSubmit = async () =&gt; { setIsPending(true); const error = await updateName(name); setIsPending(false); if (error) { setError(error); return; } redirect(\"/path\"); }; return ( &lt;div&gt; &lt;input value={name} onChange={(event) =&gt; setName(event.target.value)} /&gt; &lt;button onClick={handleSubmit} disabled={isPending}&gt; Update &lt;/button&gt; {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;} &lt;/div&gt; );\n}\n따라서 이를 위한 isPending, error와 같은 state가 필요했다. data fetching하는 로직의 경우에는 사용자 경험을 위해서 로딩 상태와 에러 상태를 기록하는 것은 중요한 관심사였다.이에 fetching에서는 항상 loading과 error의 상태를 관리하는 로직 자체가 반복이 되다보니 과거에는 useFetch라는 커스텀 훅을 만들어 이를 다양한 api fetching에 활용했었다.import { useState, useEffect } from 'react'; type Status = 'initial' | 'pending' | 'fulfilled' | 'rejected'; interface UseFetch&lt;T&gt; { data?: T; status: Status; error?: Error;\n} export const useFetch = &lt;T&gt;( fetchFunction: (...args: any[]) =&gt; Promise&lt;T&gt;, ...args: any[]\n): UseFetch&lt;T&gt; =&gt; { const [state, setState] = useState&lt;UseFetch&lt;T&gt;&gt;({ status: 'initial', data: undefined, error: undefined, }); useEffect(() =&gt; { let ignore = false; const fetchData = async () =&gt; { setState({ ...state, status: 'pending' }); try { const data = await fetchFunction(...args); if (!ignore) { setState({ status: 'fulfilled', data }); } } catch (error) { if (!ignore) { setState({ status: 'rejected', error: error as Error }); } } }; fetchData(); return () =&gt; { ignore = true; }; }, [fetchFunction]); return state;\n}; 이를 통해서 코드의 재사용성이나 가독성을 더 높일 수 있었다.\nReact 19에서는 이러한 비동기 처리 코드에 대해서 useTransition에서 pending상태를 리액트 내부에서 관리할 수 있도록 해주어 로딩 상태에 대해서 따로 상태로 선언하여 관리할 필요성이 줄어들었다.// Using pending state from Actions\nfunction UpdateName({}) { const [name, setName] = useState(\"\"); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const handleSubmit = () =&gt; { startTransition(async () =&gt; { const error = await updateName(name); if (error) { setError(error); return; } redirect(\"/path\"); }) }; return ( &lt;div&gt; &lt;input value={name} onChange={(event) =&gt; setName(event.target.value)} /&gt; &lt;button onClick={handleSubmit} disabled={isPending}&gt; Update &lt;/button&gt; {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;} &lt;/div&gt; );\n}\n비동기 함수가 실행되면서 isPending은 즉시 true값으로 바뀌고 비동기 처리가 일어난 후에는 다시 false값으로 바뀐다. startTransition을 통해 렌더링의 우선순위를 낮추어 isPending에 대한 리렌더링을 우선적으로 수행한 후에 비동기 작업을 처리함으로써 보다 상호작용이 가능하고 반응형이 될 수 있는 UI가 될 수 있다.이러한 Actions에 대해서 보다 범용적이고 쉽게 사용될 수 있도록 React 19에서는 useActionState라는 훅을 새롭게 추가했다.const [error, submitAction, isPending] = useActionState( async (previousState, newName) =&gt; { const error = await updateName(newName); if (error) { // You can return any result of the action. // Here, we return only the error. return error; } // handle success return null; }, null,\n위에서 본 useFetch와 비슷하게 useActionState가 작동하고 있음을 볼 수 있다. 이 actionState는 기존에 ReactDOM.useFormState로 사용되었지만 현재는 deprecated되고 useActionState로 이름이 바뀌어 나오게 되었다.\n인자로 콜백 함수가 들어가며, 래핑된 상태로 action이 반환된다. 이를 통해 사용자의 action에 대해서 로딩, 에러 상태 처리를 위한 코드를 보다 간편하고 가독성 있게 작성할 수 있다.&lt;form action={actionFunction}&gt;\nform에 대한 액션 처리는 이전까지만 해도 쓰기가 어려운 부분이 있었다. form에 대한 action을 처리하는 방법은 onSubmit과 같은 방법을 통해 이벤트를 처리했지만, action이라는 어트리뷰트를 추가하여 여기에 action에 대한 핸들러 함수를 넣게 된다면 form 자체 뿐만 아니라 input, button요소의 action과 formAction 프로퍼티로 넘겨줄 수 있다.&lt;form&gt;은 action이 성공했을 경우에 제어되지 않은 컴포넌트에 대해 form을 재설정한다. action 뿐만이 아니라 따로 수동으로 form을 초기화 할 때는 requestFormReset이라는 새로운 React DOM API를 통해서 폼을 초기화시킬 수 있다.form의 상태를 보고 이에 대한 처리를 하기 위해서는 다른 버튼과 같은 컴포넌트 요소들에게도 따로 props를 내려줘서 이에 대한 상태를 처리해야 했다.\n이전까지의 경우 그대로 props로 받아 내려주거나, useContext훅을 사용하여 내려주고, 이를 컴포넌트에서 받아 사용할 수 있었다.이번에 React 19에서는 이러한 부분에 대해 useFormStatus라는 새로운 훅을 추가하여 props를 직접 내려받거나 context api를 사용할 일 없이 폼 하위의 요소들에서 useFormStatus 훅을 실행시키면서 부모 폼에 대해서 pending state를 받을 수 있게 되었다.import {useFormStatus} from 'react-dom'; function DesignButton() { const {pending} = useFormStatus(); return &lt;button type=\"submit\" disabled={pending} /&gt;\n}\n데이터의 변경이 이루어질 때 UI 패턴에서 많이 이루어지던 방식이 낙관적 업데이트이다. 낙관적인 업데이트는 서버로 보낸 요청이 정상적일 것이라고 예상하고,&nbsp;클라이언트의 요청에 대한 응답이 오기 전에 클라이언트의 데이터를 미리 변경시키는 작업을 말한다.\n이러한 낙관적 업데이트의 경우는 React에서 없었던 기능이었기에 React Query를 이용하여 사용하였다. 하지만 React 19에서 새롭게 useOptimistic 훅이 추가되어 이를 사용하여 낙관적 업데이트를 할 수 있다.function ChangeName({currentName, onUpdateName}) { const [optimisticName, setOptimisticName] = useOptimistic(currentName); const submitAction = async formData =&gt; { const newName = formData.get(\"name\"); setOptimisticName(newName); const updatedName = await updateName(newName); onUpdateName(updatedName); }; return ( &lt;form action={submitAction}&gt; &lt;p&gt;Your name is: {optimisticName}&lt;/p&gt; &lt;p&gt; &lt;label&gt;Change Name:&lt;/label&gt; &lt;input type=\"text\" name=\"name\" disabled={currentName !== optimisticName} /&gt; &lt;/p&gt; &lt;/form&gt; );\n}\n위의 예시를 볼 때, useOptimistic을 실행하면 낙관적 업데이트를 시킬 상태와 이 상태를 조작하는 setter 함수를 반환한다. optimisticName를 사용하여 action이 일어남과 동시에 setOptimisticName을 통해 기존의 데이터를 업데이트가 일어난 후의 데이터로 바꿔주면 그 즉시 렌더링에 반영된 후, action에 대한 비동기 요청이 이루어진다. 만약 이 과정에서 비동기 요청이 실패하거나 끝났을 경우, optimisticName는 다시 setter함수를 실행하기 전, 즉 newName에서 currentName으로 돌아가게 된다.React 19에서는 렌더링에서 리소스를 읽을 수 있는 use라는 새로운 API를 도입했다.\nuse중인 Promise를 읽으면 Promise가 resolve 될 때까지 React는 Suspend, 즉 중단 상태로 기다린다. import {use} from 'react'; function Comments({commentsPromise}) { // `use` will suspend until the promise resolves. const comments = use(commentsPromise); return comments.map(comment =&gt; &lt;p key={comment.id}&gt;{comment}&lt;/p&gt;);\n} function Page({commentsPromise}) { // When `use` suspends in Comments, // this Suspense boundary will be shown. return ( &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;Comments commentsPromise={commentsPromise} /&gt; &lt;/Suspense&gt; )\n}\n따라서 use를 사용하는 컴포넌트는 렌더링을 하지 않고 Promise가 resolve될 때까지 기다린 다음에 resolve가 되면(Promise가 fulfilled된 상태) 그때부터 렌더링을 하기 시작한다.그렇기 때문에 선언적 프로그래밍이 가능해지고, 이는 곧 가독성과 유지보수성을 높여준다. 선언적 프로그래밍\n무엇을(WHAT) 나타내야 하는지를 프로그래밍적으로 표현하는 것\n어떻게(HOW) 나타내야 하는지를 프로그래밍적으로 표현하는 명령형 프로그래밍보다 한 단계 더 추상화된 프로그래밍 방식\n무엇보다 이 use가 쓸만하다고 느낀 점은 Suspense와 합쳐졌을 때이다.\n기존의 Suspense의 경우는 데이터를 fetching하는 컴포넌트의 모듈에서 Promise를 throw하고, Suspense가 이를 받아 Promise가 resolve되지 않은 상태면 fallback 프로퍼치에 들어가 있는 UI를 렌더링하고, resolve된 이후에는 선언형으로 작성된 코드에 데이터를 넣어 렌더링만 하는 방식으로 활용했었다.export function fetchData&lt;T&gt;(fn: Promise&lt;T&gt;): { read: () =&gt; T } { let status = \"pending\"; let result: T; const suspender = fn.then( (r) =&gt; { status = \"success\"; result = r; }, (e) =&gt; { status = \"error\"; result = e; }, ); function read() { switch (status) { case \"pending\": throw suspender; case \"error\": throw result; default: return result; } } return { read };\n}\n그래서 이런 식으로 fetchData라는 함수를 따로 만들어 활용하는 방식으로 했었지만 함수형 컴포넌트 안에 들어가게 된다면 무한루프가 돌게 되기 때문에 바깥쪽에서 가져와야만 했다.const response = getHeadlines();\nexport default function ShortNews() { const headlines = response.read(); return ( &lt;div&gt;...&lt;/div&gt; )\n}\n이런 식으로 바깥쪽에서 함수를 실행하고 read 함수를 통해 데이터를 가져오는 방법도 있고&lt;Suspense fallback={&lt;p&gt;사용자 정보 로딩중...&lt;/p&gt;}&gt; &lt;User resource={fetchData(\"1\")} /&gt;\n&lt;/Suspense&gt;\n...\nfunction User({ resource }) { const user = resource.user.read(); return ( &lt;div&gt; &lt;p&gt; {user.name}({user.email}) 님이 작성한 글 &lt;/p&gt; &lt;Suspense fallback={&lt;p&gt;글목록 로딩중...&lt;/p&gt;}&gt; &lt;Posts resource={resource} /&gt; &lt;/Suspense&gt; &lt;/div&gt; );\n} 이런 식으로 아예 함수를 실행한 결과를 컴포넌트의 props로 넘겨주는 방식도 있다.나 또한 waterfall 현상과 같은 부분을 해결하고 지긋지긋한 useEffect-fetchData의 늪에서 벗어날 수 있다는 점에서 좋은 기능이라고 생각했지만 이런 식으로 데이터를 가져오는 방식이 정말 마음에 들지 않았다. 선언형 프로그래밍으로 가독성은 높아졌지만, 코드의 흐름이 원래 알던 방식과는 달라서 불편했다.\nwaterfall 현상\nUI가 마치 폭포처럼 위에서 아래로 순차적으로 나타나는 현상\n상위 컴포넌트의 렌더링이 끝난 후에 하위 컴포넌트의 렌더링이 시작되기 때문에 발생하는 현상\nreact Query를 쓸 수도 있겠지만 이제까지 react Query를 쓰지 않은 내 입장에서는 use의 기능 추가가 매우 반가웠다!use 안에 Promise, fetching하는 함수를 실행하면 이에 따라 promise가 reosolve 될 때까지 Suspense의 fallback ui가 띄워지기 때문에 보다 코드의 흐름을 명확히 알 수 있다는 점이 좋았다.하지만 use는 맨 처음 렌더링 과정에서 만들어진 Promise에 대해서는 지원하지 않는 특징을 가지고 있다. 따라서 아직은 맨 처음 데이터를 가져올 때만 유용하게 사용될 수 있을 것 같다. 아니면 react-Query와 함께 사용하는 방법도 방법 중 하나가 될 수 있을 것 같다.또 하나 강력한 기능으로, context 또한 use를 통해 읽어오는 것이 가능하다.const ColorContext = createContext(\"\"); function App() { return ( &lt;ColorContext value=\"blue\"&gt; &lt;Form /&gt; &lt;/ColorContext&gt; );\n} function Form() { return ( &lt;div&gt; &lt;Button show={true}&gt;True&lt;/Button&gt; &lt;Button show={false}&gt;False&lt;/Button&gt; &lt;/div&gt; );\n} function Button({ show, children,\n}: { show: boolean; children: React.ReactNode;\n}) { if (show) { const theme = use(ColorContext); return &lt;button style={{ backgroundColor: theme }}&gt;{children}&lt;/button&gt;; } return false;\n}\n컴포넌트의 최상위 레벨에서만 호출해야 하는 useContext의 단점을 보완하고 조건분이나 반복문 내부에서도 사용할 수 있어 보다 유연하게 사용될 수 있으며, 추가적으로 Provider를 쓰지 않고도 context를 내려줄 수 있는 기능 또한 추가되어 use와의 시너지가 잘 맞을 것 같다.React Server Component는 리액트의 새로운 패러다임으로, 기존 클라이언트 사이드 렌더링만 지원하는 React에서 보다 Next.js같이 발전한 방식으로 볼 수 있다.리액트의 서버 컴포넌트는 기존에 CSR 방식으로 운영되던 리액트가 한 번에 모든 리소스를 다운로드 받고 띄워야 하는 만큼 이에 대한 대기 시간이 점차 길어지자 이를 개선하기 위해 설계된 방식이다.사용자와의 상호작용 없이 정적 요소만 담은 컴포넌트의 경우, 훨씬 빨리 컴포넌트를 렌더링할 수 있는 환경인 서버에서 직접 렌더링하는 편이 낫다. 이를 통해\n리렌더링의 필요성을 없애 성능 개선\n자바스크립트의 번들링 크기 축소\n초기 페이지 로드 속도 개선\n이외에도 많은 성능적, 사용자 환경적 개선을 기대할 수 있기 때문에 React 또한 next.js처럼 서버 컴포넌트에 대한 지원을 계속 업데이트하고 있다.\nReact는 서버사이드 렌더링을 지원하기 위해 기존 SSR 서버와는 다른 별도의 서버를 사용했다. 별도의 서버에서 미리 서버 컴포넌트를 렌더링 한 다음, 이를 띄워주는 방식이다. 해당 서버 컴포넌트는 빌드 시 CI 서버에서 한번 실행할 수도 있고, 웹 서버를 사용하여 각 요청마다 새롭게 실행할 수도 있다. import db from './database'; async function Note({id}) { const note = await db.notes.get(id); return ( &lt;div&gt; &lt;Author id={note.authorId} /&gt; &lt;p&gt;{note}&lt;/p&gt; &lt;/div&gt; ); } async function Author({id}) { const author = await db.authors.get(id); return &lt;span&gt;By: {author.name}&lt;/span&gt;; } ```\n이런 식으로 함수형 컴포넌트 자체를 비동기 함수로 만든 다음에, 서버에서 데이터를 가지고 와 렌더링하여 사용자와 상호작용 없는 컴포넌트를 빠르게 보여줄 수 있다.\n앱이 로드될 때 클라이언트는 사용된 라이브러리를 보지 못하고 오로지 렌더링된 출력물만 볼 수 있기 때문에 상호작용과 상태 관리는 되지 않지만, 상호작용이 필요한 부분과 필요없는 부분을 나누어 서버 컴포넌트와 클라이언트 컴포넌트를 나누어 개발하면 보다 성능이 올라갈 것이다. ```jsx\n// Server Component\nimport db from './database'; async function Page({id}) { // Will suspend the Server Component. const note = await db.notes.get(id); // NOTE: not awaited, will start here and await on the client. const commentsPromise = db.comments.get(note.id); return ( &lt;div&gt; {note} &lt;Suspense fallback={&lt;p&gt;Loading Comments...&lt;/p&gt;}&gt; &lt;Comments commentsPromise={commentsPromise} /&gt; &lt;/Suspense&gt; &lt;/div&gt; );\n} ... // Client Component\n\"use client\";\nimport {use} from 'react'; function Comments({commentsPromise}) { // NOTE: this will resume the promise from the server. // It will suspend until the data is available. const comments = use(commentsPromise); return comments.map(commment =&gt; &lt;p&gt;{comment}&lt;/p&gt;);\n}\n서버에서 직접 Suspense에 대한 스트리밍이 지원되기 때문에 보다 Suspense가 활용될만한 곳이 많아진 것 같다고 생각한다.\n위에 보이는 예시처럼 서버 컴포넌트는 직접 서버에서 비동기 컴포넌트에 대해 fetching하는 함수를 넘겨주고, use를 사용하여 Promise를 인자로 넣음으로써 서버 컴포넌트 안에 클라이언트 컴포넌트가 작동하는 방식으로도 활용이 가능하다.\n여기서 suspense 또한 Comments의 부모로 있기 때문에 정상적으로 Suspense fallback UI가 렌더링되고, 클라이언트 컴포넌트에서 비동기적으로 데이터가 들어오면 이에 따라 안쪽 요소를 채우도록 할 수 있다.// Server Component\nimport Button from './Button'; function EmptyNote () { async function createNoteAction() { // Server Action 'use server'; await db.notes.create(); } return &lt;Button onClick={createNoteAction}/&gt;;\n}\n\"use server\" 지시어를 사용하여 서버에서 실행하는 비동기 함수를 서버 컴포넌트에서 사용할 수 있도록 할 수 있다.\n위와 같이 액션에 대해서 비동기적으로 처리해야 하는 부분에서 use server를 쓰고, 서버에서 이 액션에 대해 처리할 수 있다.리액트가 컴포넌트를 생성하는 과정에서 이렇게 서버에서 사용하는 비동기 함수를 가져오게 되면 함수에 대한 참조를 Button의 onClick 인자에 넘겨준다. \"use server\"; export async function createNoteAction() { await db.notes.create();\n}\n클라이언트 컴포넌트의 경우에는 \"use server\" 지시어를 사용하는 파일에서 서버 액션을 가져올 수 있다.\"use client\";\nimport {createNoteAction} from './actions'; function EmptyNote() { console.log(createNoteAction); // {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNoteAction'} return &lt;button onClick={createNoteAction} /&gt;\n}\n그러면 클라이언트 컴포넌트가 빌드되는 과정에서 함수에 대한 참조를 생성하여 넘겨줌으로써 서버 액션을 사용할 수 있도록 할 수 있다.액션으로 서버 액션을 구성한다는 것이 무슨 뜻일까?\n이는 아래의 예시를 보면 어느정도 이해가 가능하다.\"use server\"; export async function updateName(name) { if (!name) { return {error: 'Name is required'}; } await db.users.updateName(name);\n}\n...\n\"use client\"; import {updateName} from './actions'; function UpdateName() { const [name, setName] = useState(''); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const submitAction = async () =&gt; { startTransition(async () =&gt; { const {error} = await updateName(name); if (!error) { setError(error); } else { setName(''); } }) return ( &lt;form action={submitAction}&gt; &lt;input type=\"text\" name=\"name\" disabled={isPending}/&gt; {state.error &amp;&amp; &lt;span&gt;Failed: {state.error}&lt;/span&gt;} &lt;/form&gt; ) }\n예시에서는 \"use server\" 지시어를 사용하여 updateName이라는 서버 액션을 만들었다. 이 서버 액션의 경우 직접적으로 db에 접근하여 이름을 수정하는 로직이 담겨있다.\n아래 \"use client\"를 사용한 코드에서는 안에서 submitAction이라는 액션을 하나 더 만들었다. 이 액션은 클라이언트에서 서버와의 데이터 통신에 한 겹 더 래핑한 구조를 가지고 있다. 추가적으로 비동기적으로 동작하는 서버 액션에 대해 에러 상태와 pending 상태를 추가하기 위해서 error라는 state와 useTransition을 통해 pending 상태를 관리하고 있다. 이를 통해 서버 액션에 대해 pending 상태에 접근할 수 있기 때문에 이런 식으로도 액션을 둘 다 활용하여 로직을 더 보완할 수 있다.<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.jeong-min.com/64-react-19-use/\" target=\"_self\">https://www.jeong-min.com/64-react-19-use/</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"React 19 베타에서 새롭게 추가된 것들","level":2,"id":"React_19_베타에서_새롭게_추가된_것들_1"},{"heading":"Actions를 관리하기 위한 기능 추가","level":3,"id":"Actions를_관리하기_위한_기능_추가_0"},{"heading":"Pending State 관리하기","level":4,"id":"Pending_State_관리하기_0"},{"heading":"새로운 훅 추가 - useActionState","level":4,"id":"새로운_훅_추가_-_useActionState_0"},{"heading":"form에 대한 action 처리","level":4,"id":"form에_대한_action_처리_0"},{"heading":"폼의 상태를 관리하는 훅 추가 - useFormStatus","level":4,"id":"폼의_상태를_관리하는_훅_추가_-_useFormStatus_0"},{"heading":"새로운 훅 useOptimistic - 낙관적 업데이트","level":3,"id":"새로운_훅_useOptimistic_-_낙관적_업데이트_0"},{"heading":"새로운 API : use","level":3,"id":"새로운_API_use_0"},{"heading":"React Server Components","level":3,"id":"React_Server_Components_0"},{"heading":"서버 액션 처리","level":3,"id":"서버_액션_처리_0"},{"heading":"서버 컴포넌트에서의 서버 액션","level":4,"id":"서버_컴포넌트에서의_서버_액션_0"},{"heading":"클라이언트 컴포넌트에서의 서버 액션","level":4,"id":"클라이언트_컴포넌트에서의_서버_액션_0"},{"heading":"액션으로 서버 액션 구성하기","level":4,"id":"액션으로_서버_액션_구성하기_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html","pathToRoot":"../../..","attachments":[],"createdTime":1729857380566,"modifiedTime":1729964219422,"sourceSize":22415,"sourcePath":"학습 정리/Frontend/React/React 19 베타에서 새롭게 추가된 것들.md","exportPath":"학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/react/react-fiber에-관한-고찰.html":{"title":"React Fiber에 관한 고찰","icon":"","description":"리액트 파이버는 리액트 버전 16버전부터 새롭게 등장한 재조정 알고리즘이다.\n해당 알고리즘은 기존의 스택 형식으로 되어있던 리액트의 리렌더링 자체를 바꾼 알고리즘으로, 리액트를 동작하는 근간 자체를 바꾸었다고 보아도 과언이 아니다. 리액트 팀은 16버전까지 사용하던 스택 기반의 재조정 알고리즘을 사용했다.\n하지만 이러한 스택 기반 재조정 알고리즘의 경우 치명적인 문제점이 존재했다.<img src=\"https://blog.kakaocdn.net/dn/bnWwD4/btqGexjfADe/GWh2KY6PKrn3QPr7dXWlk1/img.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n해당 gif를 보자.\n해당 방식은 리액트의 스택 기반의 재조정 알고리즘을 사용해 reconciliation(재조정)을 거치며 애니메이션을 렌더링한 것이다.<br><img src=\"https://blog.kakaocdn.net/dn/rJmXg/btqGdLWNC9q/tJ0w8uPOaztVyqyIkck80k/img.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n반면 새로운 재조정 알고리즘은 꽤나 깔끔하게 움직이는 모습을 보인다.\n둘 사이에 왜 이런 차이가 났느냐고 하면 우리의 모니터를 생각해보면 된다.\n현대 일반적인 모니터는 보통 초당 60회 화면 갱신을 한다. 화면을 한번 갱신하고 다음 화면을 갱신하기까지동안 1/60초, 즉 16ms 정도가 걸린다는 얘기다.\n하지만 만약에 렌더링을 하는 시간이 16ms보다 더 걸린다면 어떻게 될까?\n렌더링을 하는 시간이 16ms보다 더 걸리게 된다면 ui가 업데이트되는 속도는 모니터의 주사율을 따라갈 수 없어 모니터가 원하는 만큼의 속도로 빠르게 갱신되지 못하고 끊기게 된다. 그렇기 때문에 위처럼 끊기는 듯한 애니메이션이 연출된다.하지만 스택 알고리즘의 문제는, 이러한 작업들에 대해서 중단하거나 중요한 작업에 대해 먼저 수행할 수 없다는 점이었다. 렌더링에 필요한 작업들이 스택에 들어가서 쌓이면 내부적으로 해당 스택을 전부 비울 때까지 동기적으로 작업이 이루어졌는데, 싱글 스레드로 작동하는 자바스크립트로는 이러한 동기 작업을 중단할 수 없었다. 그렇기에 중요한 렌더링 작업들이 후에 비효율적으로 렌더링 작업을 진행하면서 렌더링 문제가 발생하게 되었다.이러한 이유 때문에 메타의 리액트 팀에게 있어서 16ms는 중요 고려사항으로 자리잡은데 비해, 스택 기반의 알고리즘은 이를 따라갈 수 없기 때문에 결국 새롭게 내놓은 것이 파이버 아키텍처를 기반으로 한 재조정 알고리즘이다.그럼 이제 이러한 파이버 아키텍처에 대해 알아보자.React의 내부 동작은 크게 네 가지의 단계로 구분된다.\nRender : JSX 트랜스파일러를 통해 React.createElement를 실행하여 React Element 생성\nReconcile(재조정) : 이전에 렌더링된 실제 DOM트리와 새로 렌더링할 React 엘리먼트를 비교하여 변경점 적용\nCommit : 재조정 후 새롭게 만들어진 DOM Element를 브라우저 뷰에 보이게 함\nUpdate : props, state등이 변경 시에 해당 컴포넌트와 하위 컴포넌트에 대해 업데이트 반복\n리액트는 이처럼 Render 후 Update(Reconcile &amp; Commit) 단계를 반복하면서 렌더링을 수행한다. 이 과정에서 활용되는 개념이 가상 DOM(Virtual DOM), 정확히 말하면 Fiber Node이다.\n리액트의 렌더링 과정은 Fiber Node를 제외하고 설명할 수 없다. 렌더링 과정에서 근본적으로 활용되는 가상DOM이 곧 Fiber Node이기 때문이다. 그러니 먼저 Fiber Node에 대해 알아보도록 하자.리액트 파이버는 리액트에서 관리하는 자바스크립트 객체이다. 파이버는 파이버 재조정자(Fiber Reconciler)가 관리하는데, 이 재조정자가 가상 DOM과 실제 DOM을 비교해 변동사항을 수집 및 반영하는 역할을 한다.이 리액트 파이버를 도입하게 된 이유, 즉 리액트 파이버의 목표는 크게 두가지로 볼 수 있다.\n반응성 문제 해결(애니메이션, 레이아웃, 사용자 인터랙션 등) 작업을 분할하고 우선순위를 매겨 먼저 필요한 렌더링부터 작업\n상대적으로 우선순위가 낮은 작업을 중단 후에 나중에 다시 시작\n이전에 했던 작업이 필요없어질 경우 폐기 비동기적으로 동작하여 효율 증대\n- 싱글 스레드에서 동작하는 자바스크립트에서 동기적인 작업을 통해 가지는 비효율성을 해소\n이러한 문제를 해결하기 위해 리액트 팀은 파이버를 도입했다. 사실상 점점 애플리케이션 자체가 고도화되면서 하나의 인터랙션에도 많은 이벤트와 애니메이션들이 이루어지는 상황에 위와 같은 문제를 해결하는 것은 필수불가결한 일이기도 했다.\n그렇다면 Fiber Node의 구성요소에 대해 알아보자.function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode,\n) { // Instance this.tag = tag; this.key = key; this.elementType = null; this.type = null; this.stateNode = null; // Fiber this.return = null; this.child = null; this.sibling = null; this.index = 0; this.ref = null; this.refCleanup = null; this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // Effects this.flags = NoFlags; this.subtreeFlags = NoFlags; this.deletions = null; this.lanes = NoLanes; this.childLanes = NoLanes; this.alternate = null; ...\n} tag 리액트 파이버는 1:1관계를 가진다. DOM이든 컴포넌트든 무조건 1:1의 관계를 지니며, 이 유형은 태그 속성 내의 this.tag에 저장된다. 이 type에서는 fuctional component, class component 등 우리가 아는 여러 유형들의 노드들에 대해서 번호로 관리한다. type\nelementType 어떤 요소인지 타입 구분 key 컴포넌트를 식별하는데 사용되는 고유값이다. 한 배열 안에서 같은 tag를 가진 여러 개의 요소들이 있다면 재조정자는 순서와 일부 요소의 변경에 대해서 같은 태그를 가지고 있기 때문에 비교하기가 어렵다. 따라서 key를 통해 각 컴포넌트를 구별할 수 있도록 하여 불필요한 렌더링을 방지한다. StateNode 해당 객체에 대한 참조를 가지고 있으며 이 속성을 사용하여 파이버와 관련된 상태들에 접근할 수 있다. child, sibling, return Fiber를 기반으로 트리를 만드는 과정에서 필요한 관계가 이 세 가지 속성에 의해 결정된다. 특히 child가 children(여러개)이 아닌 하나의 자식만을 가지고 있다는 점이 특이한데, 그 child는 자식의 첫 번째 요소를 가리킨다. 자식이 첫 번째 요소만 가리키기 때문에, 만약 하나의 부모에 여러 개의 요소가 들어 있다면, 첫 번째 요소만 자식 요소가 되고 마너지는 해당 자식 요소의 형제 요소들이 된다.\nreturn의 경우 상위 항목, 즉 부모 항목에 대한 참조를 나타낸다. index 같은 태그로 된 여러 개의 형제가 있을 경우 이러한 요소들의 순서를 구별하기 위해 숫자로 관리한다 ref, refCleanup 특정 컴포넌트나 DOM요소에 접근할 수 있도록 DOM요소나 인스턴스에 대한 참조\n컴포넌트가 언마운트 될 떄 메모리 누수를 방지하기 위해 refCleanup을 통해 불필요한 참조를 제거함 mode FiberNode가 렌더링되는 방식 정의\nConcurrent Mode나 StrictMode와 같은 동작 결정 pendingprops 아직 작업에 대해서 처리하지 못한 props를 저장 memoizedProps pendingprops이 렌더링이 완료되면 memoizedProps로 옮겨가며 현재 가지고 있는 props를 표현한다 updateQueue 상태 업데이트, 콜백함수, DOM 업데이트 등 필요한 작업을 담아두는 큐이다. memoizedState 함수 컴포넌트의 훅 목록으로, useState를 비롯한 모든 훅 리스트와 최신 상태 값 Alternate 뒤에서 더 설명할 것으로, 리액트에 존재하는 두 가지 트리 중에서 자신을 포함하지 않은 반대편 트리를 의미함 flags 노드에서 수행하는 작업을 나타내는 비트 플래그\nplacement(새로운 DOM 노드 삽입), Update(기존 DOM 노드 업데이트), Deletion(DOM 노드 삭제) 등의 플래그를 통해 리렌더링 여부를 결정 subtreeflags 하위 트리 내에서 발생해야 하는 작업을 나타냄 deletions 삭제해야 하는 자식 노드들의 목록 관리\n삭제해야 하는 노드들을 미리 배열에 추가해놓고, 일괄로 처리함 lanes Concurrent Mode에서 작업의 우선순위를 투적 childLanes 하위 트리에서 실행할 작업들의 우선순위를 추적 리액트의 virtual DOM 개념은 렌더링 되어 있는 상태의 DOM 요소에 가지고 있는 rootFiber의 정보와 더불어 추가적으로 하나의 rootfiber를 따로 구성한다.\n여기서 root의 경우 fiberRoot와 rootFiber로 두 가지의 root가 있다. fiberRoot의 경우 createRoot를 통해 만드는 가장 기본적인 html 템플릿의 루트로, 계속해서 안쪽 요소의 렌더링이 이루어지는 SPA의 특성상 고정적인 head와 body를 가진 root를 두고 안쪽 요소들만 갈아끼우기 위해 rootFiber를 따로 두어 실질적인 렌더링이 반복적으로 이루어지는 root를 따로 구분했다. 이 root에 대한 fiber를 구성하는 과정에서 root fiber를 하나 더 구성하는 것이 react virtual DOM의 핵심이다. 리액트는 기존 렌더링 되어 있는 상태의 DOM의 정보를 가진 fiber와 새롭게 변동사항이 있을 경우에 이를 반영한 버전의 fiber를 따로 가지고 있는 것이다.상태가 변경됐을 경우에, 리액트는 재조정 과정을 통해 현재 렌더링된 DOM 상태를 가진 fiber와 상태 변경이 이루어진 fiber를 비교하여 변경이 이루어져 업데이트가 이루어져야 하는 부분을 찾고 반영한다. 이 일련의 과정은 fiber를 비교하는 과정에서 볼 수 있다.<br>\n<img src=\"https://i.imgur.com/WX5Ji1T.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n위 사진과 같이 rootFiber에서부터 재조정 과정을 시작한다. 파이버는 재조정 과정에서 performUnitOfWork라는 함수를 실행시키는데, beginwork와 completework 함수가 포함되어 있다. 따라서 안쪽의 파이버로 계속해서 들어가면서 beginwork가 실행되고, 끝까지 들어갔다가 돌아오는 과정에서 return받으면 completework를 실행하며 해당 파이버에 대한 작업을 종료한다.<br>\n<img src=\"https://i.imgur.com/bMKqP19.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n아까 말했던 말을 다시금 생각해보자.\n상태가 변경됐을 경우에, 리액트는 재조정 과정을 통해 현재 렌더링된 DOM 상태를 가진 fiber와 상태 변경이 이루어진 fiber를 비교하여 변경이 이루어져 업데이트가 이루어져야 하는 부분을 찾고 반영한다\n그렇다면 이 상태변경이 이루어진 fiber는 어디에 할당되어 있는가? 바로 현재 렌더링 되어 있는 DOM 트리, 즉 fiberRootNode의 current 가리키고 있는 rootFiber의 alternate 프로퍼티이다.rootFiber는 current가 가리키고 있는 rootFiber와는 별개로 현재 렌더링된 rootFiber의 alternate props로 다른 rootFiber를 가지고 있다. alternate에 할당된 rootFiber는 변동사항이 반영된 rootFiber이다.\n이 두 fiber는 alternate를 통해 서로에 대해 접근하며 변동사항을 반영하고 업데이트된 DOM tree를 만들어낸다. 이렇게 만들어지는 DOM tree는 workInProgress 트리라고 한다. 다시금 강조하지만 workInProgress 트리는 current가 가리키고 있지 않은 alternate의 rootFiber에서 만들어진다.export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber { let workInProgress = current.alternate; if (workInProgress === null) { workInProgress = createFiber( current.tag, pendingProps, current.key, current.mode, ); workInProgress.elementType = current.elementType; workInProgress.type = current.type; workInProgress.stateNode = current.stateNode; if (__DEV__) { workInProgress._debugID = current._debugID; workInProgress._debugSource = current._debugSource; workInProgress._debugOwner = current._debugOwner; workInProgress._debugHookTypes = current._debugHookTypes; } workInProgress.alternate = current; current.alternate = workInProgress; } else { workInProgress.pendingProps = pendingProps; workInProgress.type = current.type; workInProgress.subtreeFlags = NoFlags; workInProgress.deletions = null; if (enableProfilerTimer) { workInProgress.actualDuration = 0; workInProgress.actualStartTime = -1; } } workInProgress.flags = current.flags &amp; StaticMask; workInProgress.childLanes = current.childLanes; workInProgress.lanes = current.lanes; workInProgress.child = current.child; workInProgress.memoizedProps = current.memoizedProps; workInProgress.memoizedState = current.memoizedState; workInProgress.updateQueue = current.updateQueue; const currentDependencies = current.dependencies; workInProgress.dependencies = currentDependencies === null ? null : { lanes: currentDependencies.lanes, firstContext: currentDependencies.firstContext, }; workInProgress.sibling = current.sibling; workInProgress.index = current.index; workInProgress.ref = current.ref; if (enableProfilerTimer) { workInProgress.selfBaseDuration = current.selfBaseDuration; workInProgress.treeBaseDuration = current.treeBaseDuration; } if (__DEV__) { workInProgress._debugNeedsRemount = current._debugNeedsRemount; switch (workInProgress.tag) { case IndeterminateComponent: case FunctionComponent: case SimpleMemoComponent: workInProgress.type = resolveFunctionForHotReloading(current.type); break; case ClassComponent: workInProgress.type = resolveClassForHotReloading(current.type); break; case ForwardRef: workInProgress.type = resolveForwardRefForHotReloading(current.type); break; default: break; } } return workInProgress;\n}\ndfs(깊이우선탐색) 방식을 활용하여 새롭게 변동사항이 반영된 fiber와 기존의 fiber를 비교한 뒤, 바뀐 부분을 찾고 반영하고, 마지막에 root의 DOM 요소를 리턴하게 되면 새롭게 바꾸어야 할 부분을 반영한 DOM element를 가지게 된다.변경사항이 모두 반영된 rootFiber의 DOM Element가 모두 만들어지고 나면, fiberRoot, 즉 createRoot로 만든 root 컨테이너 파이버의 current가 alternate의 rootFiber를 가리키게 한다. 해당 파이버는 새롭게 반영 및 DOM element 생성이 완료된 fiber이다. current의 포인터만을 alternate를 통해 반대편의 만들어진 rootFiber를 가리키도록 하면서 대기 없이 바로 업데이트가 반영된 DOM 트리를 갈아끼우는 것이다.<br><img src=\"https://d2.naver.com/content/images/2023/07/14.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이처럼 상태의 변경이나 다른 렌더링에 영향을 끼치는 상태가 변경이 됐을 경우에 재조정을 통해서 fiber를 업데이트하고 이를 DOM 요소에 반영하는 과정을 계속해서 반복하는 과정에서 rootFiber는 기존의 root container인 fiberRoot를 알아야 할 필요성이 있다. 자신이 해당 fiberRoot 안에서 렌더링 되어야 할 요소들의 정보를 담고 있기 때문이다.전체적인 두 트리가 공존하면서 비교되고 만들어진 workInProgressfiber를 한 그림에 표현하면 아래와 같이 나오게 된다.<br>\n<img src=\"https://i.imgur.com/1EfuMA3.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">위에서 알아본 Fiber Node와 렌더링 방식에 대한 정보는 알았지만 막상 이 객체가 어떤 로직으로 렌더링을 수행하는 지는 아직도 감이 잡히지 않을 것이다.\n따라서 우리는 소스 코드를 따라서 대략적인 첫 렌더링 과정을 알아볼 필요가 있다.\n리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다\n가장 처음 엔트리 포인트를 만드는 과정부터 첫 페이지가 만들어지기까지의 과정을 알아보자.import { createRoot } from 'react-dom/client'; const root = createRoot(document.getElementById('root'));\nroot.render(&lt;App /&gt;);\nreact-dom의 공식문서에서는 createRoot라는 api를 통해 React에 의해 관리되는 UI의 root, 즉 React 컴포넌트를 표시하는 루트를 생성할 수 있다고 한다. 코드를 보면 root라는 id를 가지는 element 자체를 루트로 삼고 여기에 React 컴포넌트들을 렌더링시키기 위해 지정하는 것으로 보인다.\nReact는 SPA(Single-Page-Application)이기 때문에 여러 페이지를 전환하는 것이 아닌, 하나의 페이지에서 모든 서비스 로직이 이루어지는 형태이며, 페이지 또한 새롭게 페이지 전환을 하는 방식이 아니다 보니까 하나의 Index.html만 두고 안쪽 요소만 바꾸어 가면서 렌더링을 하는 방식을 사용한다. 따라서 React가 렌더링할 공간을 createRoot를 통해 만들고, createFiberRoot()를 호출하여 고유한 FiberRootNode를 생성한다. // Cyclic construction. This cheats the type system right now because\n// stateNode is any.\nconst root = (new FiberRootNode(containerInfo, tag, hydrate): any); if (enableSuspenseCallback) { root.hydrationCallbacks = hydrationCallbacks; } const uninitializedFiber = createHostRootFiber( tag, isStrictMode, concurrentUpdatesByDefaultOverride,\n);\nroot.current = uninitializedFiber; uninitializedFiber.stateNode = root; FiberRootNode 생성자로 만들어진 FiberRootNode는 컨테이너와 태그, 하이드레이션에 대한 정보를 가지고 있다.하지만 FiberRootNode가 만들어지고 createHostRootFiber()를 통해 추가적으로 HostRootFiber 객체를 만들어 root(FiberRoot)의 current에 해당 fiber node를 할당하고, 추가적으로 uninitializedFiber.stateNode 라는 곳에 root를 다시 참조하도록 하면서 순환 참조 구조를 이루게 하는 모습을 볼 수 있다.<br><img src=\"https://i.imgur.com/t5Nqgnq.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">root.render(&lt;SimpleComp /&gt;); 만들어지는 root에 대해서 render 메서드를 실행시키는 과정에서 JSX로 쓰여진 커스텀 컴포넌트는 babel의 트랜스파일러를 통해서 함수로 바뀌게 된다.root.render(React.createElement(SimpleComp, null)); 트랜스파일된 js에서는 pragma로 createElement가 설정되어 있기 때문에createElement를 호출시켜 React Element라는 일반 객체를 만들어 반환하는 함수를 render함수에 콜백으로 넣는 듯한 형태를 띈다. Pragma\n트랜스파일러나 컴파일러가 특정 코드를 해석하거나 처리할 때 특별한 지시를 내리기 위해 사용하는 주석 형식의 지시문\n// Transpiled &lt;SimpleComp /&gt;\nexport function SimpleComp() { const [name, setName] = React.useState(\"Alice\"); return React.createElement( \"div\", null, React.createElement(\"h1\", null, \"Hello react!\"), React.createElement( \"section\", null, React.createElement(\"p\", null, `Name : ${name}`), React.createElement( \"button\", { onClick: (e) =&gt; setName(name === \"Samuel\" ? \"Alice\" : \"Samuel\") }, \"Click me\" ) ) );\n}\n참고로 pragma는 jsx에서 모든 dom 요소들에 대해 호출하는 형식으로 되어있기 때문에 계층 구조를 알 수 있다.\n아무튼 함수형 커스텀 컴포넌트를 render함수가 콜백으로 가지고 있는 형태이다. 이 createElement를 통해 만들어지는 객체를 render함수를 통해 root에 넣어주는 작업이 수행된다.export function createElement(type, config, children) { let propName; // ..... props[propName] = config[propName]; // props 세팅 key = '' + config.key; // key 세팅 props.children = children; // childrent 세팅 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );\n}\ncreateElement는 이런 형식으로 되어 있는데, ReactElement를 반환하는 함수이다.\n일반 html element의 경우에는 jsx 트랜스파일링 과정에서\ntype: html element 이름\nkey : element의 key\nchildren: 하위 요소\n를 가지게 되는데 , SingleComp와 같은 커스텀 컴포넌트와 같은 경우에는 위에서 봤다시피 함수형으로 되어있기 때문에 createElement 안에 SingleComp라는 함수를 반환하는 함수가 type에 들어가게 되고, render api를 통해 root에 SingleComp의 Element를 가지게 된다.\n앞에서 말했다시피 첫 렌더링 단계에서는 root.render(&lt;SingleComp/&gt;)를 실행하면 SimpleComp 라는 React Element만 생성하도록 한 뒤에 재조정 단계로 넘어간다.Reconcilation 단계에서는 아까 만들었던 FiberRootNode에 대해서 performUnitOfWork함수를 실행시킨다.\n위의 코드에서도 볼 수 있다시피 현재 FiberRoot는 uninitialized된 상태이다\n// [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1836-L1862)\nfunction performUnitOfWork(unitOfWork: Fiber): void { // The current, flushed, state of this fiber is the alternate. Ideally // nothing should rely on this, but relying on it here means that we don't // need an additional field on the work in progress. const current = unitOfWork.alternate; setCurrentDebugFiberInDEV(unitOfWork); let next; if (enableProfilerTimer &amp;&amp; (unitOfWork.mode &amp; ProfileMode) !== NoMode) { startProfilerTimer(unitOfWork); next = beginWork(current, unitOfWork, subtreeRenderLanes); stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true); } else { next = beginWork(current, unitOfWork, subtreeRenderLanes); } resetCurrentDebugFiberInDEV(); unitOfWork.memoizedProps = unitOfWork.pendingProps; if (next === null) { // If this doesn't spawn new work, complete the current work. completeUnitOfWork(unitOfWork); } else { workInProgress = next; } ReactCurrentOwner.current = null;\n}\n하지만 가장 먼저 나오는 것은 current 변수에 unitOfWork.alternate 에 할당하는 일인데, 아까 Fiber node의 alternate는 순환참조하고 있는 fiber에서 반대편의 DOM을 가리킨다고 이야기 했던 것을 기억할 것이다.따라서 current 변수에 UnitOfWork(변경사항이 들어가있는 Fiber)의 alternate를 할당한 이유는 내가 현재 렌더링된 DOM이 아닌 반대편의 변경 사항을 반영한 DOM을 만든 다음에 이를 current로 교체하여 새로운 current로 만들기 위해 현재 작업할 Fiber 노드의 이전 작업 상태를 가져오는 것임을 알 수 있다.다음 코드를 보면 해당 함수에서 beginWork와 completeUnitOfWork 함수가 반복적으로 실행되고 있는 구조임을 알 수 있다.// [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3828-L3829)\nfunction beginWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes,\n): Fiber | null {\n... switch (workInProgress.tag) { ... case HostRoot: return updateHostRoot(current, workInProgress, renderLanes);\n...\n}\nbeginWork는 fiber와 workInProgress라는 다른 fiber를 받는데, next = beginWork(current, unitOfWork, subtreeRenderLanes);\n여기서 보면 인자로 받았던 current와 unitOfWork를 넣어주어 두 Fiber를 비교한 후에 변경사항을 반영한 DOM Element를 받는다여기서\ncurrent - 현재 렌더링된 DOM의 반대 DOM 트리의 파이버(곧 현재가 될 것이기 때문에 current에 할당)\nunitOfWork - 변경사항이 적용된 파이버\n라는 점은 계속 기억해두자! 아니면 헷갈려서 나처럼 계속 헤맨다.\n앞에서 말했듯이 react는 current라는 파이버 트리 workInProgress라는 파이버 트리, 두 가지 트리를 두고 계속해서 스위칭해가며 한쪽에서는 새롭게 변동사항이 반영된 workInProgress 트리를 만들고, 그 동안엔 current 트리를 보여주다가 workInProgress의 DOM이 모두 완성되면 이를 current로 바꿔주기 때문에 workInProgress Tree와 current Tree에 대해서 계속해서 인지하는 것이 중요하다.아무튼 beginWork에서 해당 파이버가 HostRoot, 즉 렌더링 되어야 하는 요소들의 루트라면 update를 진행한다.// [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1278-L1287)\nfunction updateHostRoot(current, workInProgress, renderLanes) { pushHostRootContext(workInProgress); if (current === null) { throw new Error('Should have a current fiber. This is a bug in React.'); } const nextProps = workInProgress.pendingProps; const prevState = workInProgress.memoizedState; const prevChildren = prevState.element; cloneUpdateQueue(current, workInProgress); processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n...\n}\nupdate과정에서 변동사항을 가진 workInProgress 트리에서 필요한 pendingprops와 memoizedState를 가져오고, 업데이트를 진행한다.\n여기서 updateQueue가 일어나는 이유는 여러 개의 상태가 업데이트 될 경우에 이러한 작업들을 계속 하나씩 처리하는 것보다 배치 처리하는 것이 효율적이기 때문에 queue를 활용하여 처리한다.beginwork에서 이렇게 분기처리를 해서 각각 요소들에 대해서 알맞은 처리를 해주는 과정을 거치고, 기존 fiber 또한 계층 구조로 이루어져 있기 때문에 자식이 있다면 자식으로, 형제가 있다면 형제 fiber node로 옮겨가면서 똑같이 beginwork를 실행해준다. 이 과정에서 재귀적으로 호출이 일어나며, return 받는 시기는 해당 fiber node가 작업을 마치고 completeUnitOfWork를 실행했을 때이다.\nbeginWork는 Fiber 트리의 하위로 내려가면서 자식 노드부터 작업을 처리\n자식 노드의 작업이 끝나면 그 Fiber에서 다시 completeUnitOfWork가 실행되어, 작업이 상위로 완료되며 반환\n이 과정에서 재귀적 호출이나 순환적 처리를 통해, 트리의 모든 노드에 대한 작업이 차례차례 처리\nfunction updateHostRoot(){ ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1306-L1307) const nextChildren = nextState.element; if (supportsHydration &amp;&amp; prevState.isDehydrated) { ... } else { // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1397) // Root is not dehydrated. Either this is a client-only root, or it // already hydrated. resetHydrationState(); if (nextChildren === prevChildren) { return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes); } reconcileChildren(current, workInProgress, nextChildren, renderLanes); }\n시작의 beginWork에서 HostRoot를 발견하게 되면 fiber는 기존의 fiber tree를 가지고 와서 새롭게 반영될 사항들의 정보를 가지고 있는 fiber node 객체와 기존 객체를 함께 비교하여 변동된 사항을 반영하고, 조정하는 과정을 reconcileChildren이라는 함수를 통해 반영한다. 만약 바꿀 변동사항이 없다면 그대로 둔다. // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L288)\nexport function reconcileChildren( current: Fiber | null, workInProgress: Fiber, nextChildren: any, renderLanes: Lanes,\n) { if (current === null) { // If this is a fresh new component that hasn't been rendered yet, we // won't update its child set by applying minimal side-effects. Instead, // we will add them all to the child before it gets rendered. That means // we can optimize this reconciliation pass by not tracking side-effects. workInProgress.child = mountChildFibers( workInProgress, null, nextChildren, renderLanes, ); } else { // If the current child is the same as the work in progress, it means that // we haven't yet started any work on these children. Therefore, we use // the clone algorithm to create a copy of all the current children. // If we had any progressed work already, that is invalid at this point so // let's throw it out. workInProgress.child = reconcileChildFibers( workInProgress, current.child, nextChildren, renderLanes, ); }\n} --&gt; // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1245-L1279)\n// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any, lanes: Lanes,\n): Fiber | null {\n.... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1269) // Handle object types if (typeof newChild === 'object' &amp;&amp; newChild !== null) { switch (newChild.$$typeof) { case REACT_ELEMENT_TYPE: return placeSingleChild( reconcileSingleElement( returnFiber, currentFirstChild, newChild, lanes, ), );\n...\n} --&gt; // [Link](https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactChildFiber.new.js#L1129)\nfunction reconcileSingleElement( returnFiber: Fiber, currentFirstChild: Fiber | null, element: ReactElement, lanes: Lanes, ): Fiber { const key = element.key; let child = currentFirstChild; while (child !== null) { ... } if (element.type === REACT_FRAGMENT_TYPE) { const created = createFiberFromFragment( element.props.children, returnFiber.mode, lanes, element.key, ); created.return = returnFiber; return created; } else { // [[Link]](https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactChildFiber.new.js#L1199) const created = createFiberFromElement(element, returnFiber.mode, lanes); created.ref = coerceRef(returnFiber, currentFirstChild, element); created.return = returnFiber; return created; } } 재조정 과정은 reconcileChildren -&gt; reconcileChildFibers -&gt; reconcileSingleElement이라는 일련의 과정을 통해 모든 Fiber에 대해 비교하고 재조정하는 과정을 거친다.reconcileChildren의 경우는 기존 노드와 비교하여 변경 사항을 감지하고, 새롭게 Fiber 트리를 만들거나 갱신하는 등의 작업을 수행한다. 이 과정에서 내부에서 호출하는 reconcileChildFibers를 통해 자식 Fiber들을 비교하여 어떤 노드를 갱신, 추가 등의 작업을 할지 결정하고, reconcileSingleElement를 통해 단일 자식 요소를 비교하여 갱신이 됐을 경우 새로운 fiber를 생성하거나 갱신이 필요없는 경우 기존의 fiber를 재활용한다. 이 기존 업데이트가 없는 노드의 fiber에 대해서 재활용하는 과정을 통해 리액트는 작업을 효율적으로 관리할 수 있었다.// [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L849)\nfunction completeWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes,\n): Fiber | null { ... switch (workInProgress.tag) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L959) case HostComponent: { ... // 렌더링된 FiberNode가 있거나 `stateNode`에 DOM 인스턴스가 생성되었다면 if (current !== null &amp;&amp; workInProgress.stateNode != null) { // Update 로직 updateHostComponent( current, workInProgress, type, newProps, rootContainerInstance, ); ... } else { // 없다면 DOM 인스턴스 생성 ... const instance = createInstance( type, newProps, rootContainerInstance, currentHostContext, workInProgress, ); appendAllChildren(instance, workInProgress, false, false); workInProgress.stateNode = instance; ... return null; }\n작업이 계속해서 깊이 우선 탐색으로 진행되면서 끝에 다다를 때면 다시 completeWork를 실행시키고 return시킨다. 예시로 든 최초 렌더링의 경우에는&nbsp;createInstance()를 호출하여 DOM 인스턴스를 생성한다.createInstance()&nbsp;내부에서는&nbsp;react-dom&nbsp;렌더러에서&nbsp;document.createElement web api를 이용하여&nbsp;html element 인스턴스를 생성한다. 그리고&nbsp;appendAllChildren()에서 child, 즉&nbsp;FiberNode.stateNode를 생성된 DOM 인스턴스에 부착한다. 다시 말해&nbsp;completeWork는 FiberNode로부터 DOM 인스턴스를 완성시키는 과정이다. 마지막에 모든 reconcile 작업이 완료되었을 때는 결국 갱신된 root fiber를 기반으로 재조정되는 하나의 루트 element가 만들어진다.Reconcile 단계가 끝나면 DOM을 교체하기 위한 모든 준비는 끝이 났다. DOM element들도 모두 만들어진 상태이며, 해당 요소들은 갱신된 정보들을 기준으로 만들어진 요소들이다.\n이 떄, RootComplete status가 되며 Commit 단계로 돌입하여 브라우저에 변경된 사항들이 보이도록 그리는 것이다.function finishConcurrentRender(root, exitStatus, lanes) { switch (exitStatus) { ... case RootCompleted: { // The work completed. Ready to commit. commitRoot( root, workInProgressRootRecoverableErrors, workInProgressTransitions, ); break; } default: { throw new Error('Unknown root exit status.'); } }\n} function commitRoot( root: FiberRoot, recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;, transitions: Array&lt;Transition&gt; | null,\n) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1976) commitRootImpl( root, recoverableErrors, transitions, previousUpdateLanePriority, ); ...\n} function commitRootImpl( root: FiberRoot, recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;, transitions: Array&lt;Transition&gt; | null, renderPriorityLevel: EventPriority,\n) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2163) commitMutationEffects(root, finishedWork, lanes);\n} export function commitMutationEffects( root: FiberRoot, finishedWork: Fiber, committedLanes: Lanes,\n) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L2045) commitMutationEffectsOnFiber(finishedWork, root, committedLanes); ...\n}\nfinishConcurrentRender -&gt; CommitRoot -&gt; commitRootImpl -&gt; commitMutationEffects -&gt; commitMutationEffectsOnFiber의 순서대로 안쪽으로 들어가면서 함수가 호출되고, 본격적으로 변경 내용을 커밋하기 시작한다.function commitMutationEffectsOnFiber( finishedWork: Fiber, root: FiberRoot, lanes: Lanes,\n) { ... // The effect flag should be checked *after* we refine the type of fiber, // because the fiber tag is more specific. An exception is any flag related // to reconcilation, because those can be set on all fiber types. switch (finishedWork.tag) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L2254-L2286) case HostRoot: { recursivelyTraverseMutationEffects(root, finishedWork, lanes); commitReconciliationEffects(finishedWork); ...\n}\ncommitMutationEffectsOnFiber에서는 가장 먼저 들어가는 요소가 fiberRoot가 될 것이므로 recursivelyTraverseMutationEffects를 통해 재귀적으로commitMutationEffectsOnFiber를 DFS 방식으로 호출하여 요소들을 만들어낸다function recursivelyTraverseMutationEffects( root: FiberRoot, parentFiber: Fiber, lanes: Lanes,\n) { ... // [[Link]](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L2071-L2079) const prevDebugFiber = getCurrentDebugFiberInDEV(); if (parentFiber.subtreeFlags &amp; MutationMask) { let child = parentFiber.child; while (child !== null) { setCurrentDebugFiberInDEV(child); commitMutationEffectsOnFiber(child, root, lanes); child = child.sibling; } } setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n더이상 child와 sibling을 돌고 난 후 child가 없어 탐색할 것들이 없어졌을 경우에는 다음으로 넘어가 commitReconciliationEffects()를 실행한다function commitReconciliationEffects(finishedWork: Fiber) { ... commitPlacement(finishedWork); ...\n} function commitPlacement(finishedWork: Fiber): void { ... // Recursively insert all host nodes into the parent. const parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together. switch (parentFiber.tag) { ... case HostRoot: case HostPortal: { const parent: Container = parentFiber.stateNode.containerInfo; const before = getHostSibling(finishedWork); insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent); break; } ...\n}\nfinishedWork 인자에는 작업이 끝난 Fiber가 들어오며, 이를 commitPlacement()를 통해서 tag의 분기문 중 HostRoot로 가게 되고insertOrAppendPlacementNodeIntoContainer()를 실행시킨다.function insertOrAppendPlacementNodeIntoContainer( node: Fiber, before: ?Instance, parent: Container,\n): void { const {tag} = node; const isHost = tag === HostComponent || tag === HostText; if (isHost) { const stateNode = node.stateNode; if (before) { insertInContainerBefore(parent, stateNode, before); } else { appendChildToContainer(parent, stateNode); } } else if (tag === HostPortal) { // If the insertion itself is a portal, then we don't want to traverse // down its children. Instead, we'll get insertions from each child in // the portal directly. } else { const child = node.child; if (child !== null) { insertOrAppendPlacementNodeIntoContainer(child, before, parent); let sibling = child.sibling; while (sibling !== null) { insertOrAppendPlacementNodeIntoContainer(sibling, before, parent); sibling = sibling.sibling; } } }\n}\ninsertOrAppendPlacementNodeIntoContainer를 통해 만들어진 element가 fiber 정보를 가지고 알맞은 위치에 들어갈 수 있도록 DOM을 구성한다.\n완성된 DOM 트리의 경우에는 한번에 커밋되면서 실제 브라우저 상에서 변경 사항이 반영된 DOM 구성요소들이 그려져 볼 수 있는 상태가 비로소 된다.function commitRootImpl( root: FiberRoot, recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;, transitions: Array&lt;Transition&gt; | null, renderPriorityLevel: EventPriority,\n) { ... // The work-in-progress tree is now the current tree. This must come after // the mutation phase, so that the previous tree is still current during // componentWillUnmount, but before the layout phase, so that the finished // work is current during componentDidMount/Update. root.current = finishedWork;\n}\ncommit이 모두 끝나면 root의 current를 finishedWork로 갱신하여 최신 변경사항을 반영한 rootFiber를 재할당시키면서 최신화시킨다.update와 다른 hook과 같은 경우는 너무 길어져서 다음 화에 계속..<br>\n<img src=\"https://i.imgur.com/MtyQSoN.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">react fiber의 존재는 알고 있었지만, 이번에 이렇게 소스코드를 뜯어가면서 딥다이브하고 어떤 식으로 동작하는지 알게 되면서 정말 많은 것들을 알게된 것 같다. 지피지기면 백전백승이라고, 리액트의 원리를 알게 되니 보다 hook과 같은 요소들을 보다 더 잘 쓸 수 있는 용기마저 생긴다..! 아무튼 이런 dfs와 방식으로 학습하는 것을 좋아하는 편이긴 한데, 이거 하나 쓰는데 지금 이해하고 쓰고 고치고를 반복하느라 하루 이상 쓴 것 같다. 적당히 밸런스를 맞춰 학습해야 할 필요성 또한 깨닫게 된 좋은 시간이었을지도...<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.cnblogs.com/huayang1995/p/15910753.html\" target=\"_self\">https://www.cnblogs.com/huayang1995/p/15910753.html</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://d2.naver.com/helloworld/2690975\" target=\"_self\">https://d2.naver.com/helloworld/2690975</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://m.blog.naver.com/dlaxodud2388/223195103660\" target=\"_self\">https://m.blog.naver.com/dlaxodud2388/223195103660</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;t=1463s\" target=\"_self\">https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;t=1463s</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.youtube.com/watch?v=0ympFIwQFJw\" target=\"_self\">https://www.youtube.com/watch?v=0ympFIwQFJw</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"React Fiber란?","level":2,"id":"React_Fiber란?_0"},{"heading":"새로운 렌더링 재조정 알고리즘의 필요성","level":2,"id":"새로운_렌더링_재조정_알고리즘의_필요성_0"},{"heading":"React의 동작 단계","level":2,"id":"React의_동작_단계_0"},{"heading":"Fiber Node","level":2,"id":"Fiber_Node_0"},{"heading":"왜 도입하게 되었을까?","level":3,"id":"왜_도입하게_되었을까?_0"},{"heading":"Fiber Node의 구성요소","level":3,"id":"Fiber_Node의_구성요소_0"},{"heading":"Instance","level":4,"id":"Instance_0"},{"heading":"Fiber","level":4,"id":"Fiber_0"},{"heading":"flags","level":4,"id":"flags_0"},{"heading":"가상 DOM(fiber)을 이용한 리액트 렌더링","level":2,"id":"가상_DOM(fiber)을_이용한_리액트_렌더링_0"},{"heading":"첫 브라우저 렌더링까지의 과정 훑어보기","level":2,"id":"첫_브라우저_렌더링까지의_과정_훑어보기_0"},{"heading":"엔트리 포인트 만들기","level":3,"id":"엔트리_포인트_만들기_0"},{"heading":"재조정(Reconcile)","level":3,"id":"재조정(Reconcile)_0"},{"heading":"Commit 단계","level":3,"id":"Commit_단계_0"},{"heading":"참조","level":3,"id":"참조_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/react/react-fiber에-관한-고찰.html","pathToRoot":"../../..","attachments":[],"createdTime":1727163435701,"modifiedTime":1727612996707,"sourceSize":42831,"sourcePath":"학습 정리/Frontend/React/React Fiber에 관한 고찰.md","exportPath":"학습-정리/frontend/react/react-fiber에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/react/react-portal.html":{"title":"React Portal","icon":"","description":"React에는 참 신기한게 많다.\n별별 것들을 다 해놓고 라이브러리라고 우기는게 되게 초보 사냥터에서 독식하는 고인물같다..암튼 React Portal은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 방식을 제공한다. 간단하게 생각해보자면 자식 컴포넌트를 다른 곳에 갖다 전달할 수 있다는 뜻이다. React의 트리 구조에 따라서 부모 컴포넌트가 렌더링 될 경우에 자식 요소 또한 따라서 렌더링 될 수밖에 없다. 하지만 만약 자식 요소가 바뀌지 않는다면 굳이 렌더링을 다시 할 필요가 없고, 성능을 떨어뜨리는 원인밖에 되지 않으므로 포탈을 사용한다.그렇게 포탈로 자식 컴포넌트를 바깥에 내놓음으로써 이러한 문제를 해결함과 동시에 DOM 요소에서는 부모-자식관계처럼 보이지만 이를 독립적으로 관리할 수 있기 때문에 사용한다.&lt;div&gt; &lt;SomeComponent /&gt; {createPortal(children, domNode, key?)}\n&lt;/div&gt; // 적용 예시\nimport { createPortal } from 'react-dom'; // ... &lt;div&gt; &lt;p&gt;This child is placed in the parent div.&lt;/p&gt; {createPortal( &lt;p&gt;This child is placed in the document body.&lt;/p&gt;, document.body )}\n&lt;/div&gt;\n포탈을 사용하기 위해서는 createPortal을 실행하여 포탈을 생성해야 한다.\nchildren: JSX 조각 (예: &lt;div /&gt; 나 &lt;SomeComponent /&gt;), Fragment (&lt;&gt;...&lt;/&gt;), 문자열이나 숫자, 또는 이들의 배열과 같이 React로 렌더링할 수 있는 모든 것.\ndomNode: document.getElementById()가 반환하는 것과 같은 일부 DOM 노드. 노드는\u001e 이미 존재하고 있어야 한다. 업데이트 중에 다른 DOM 노드를 전달하면 포털 콘텐츠가 다시 생성된다\n선택적 key: 포털의 키로 사용할 고유 문자열 또는 숫자\n이렇게 포탈을 생성하면 반환값으로 React node를 반환한다. 리액트는 렌더링 중에 이 포탈로 만들어진 React node를 보면 제공된 children을 설정한 domNode 안에 배치한다.\n따라서 위와 같은 예시로 포탈을 만들게 되면 현재 코드 상에서 &lt;p&gt;This child is placed in the document body.&lt;/p&gt;는 현재 우리가 보는 것과 같이 div 태그의 자식 요소처럼 보이지만 실제로 렌더링 할 때를 보면 다르다.&lt;body&gt; &lt;div id=\"root\"&gt; ... &lt;div style=\"border: 2px solid black\"&gt; &lt;p&gt;This child is placed inside the parent div.&lt;/p&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;p&gt;This child is placed in the document body.&lt;/p&gt;\n&lt;/body&gt;\n마치 이런식으로 포탈을 통해 뿅~ 넘어간 뒤 document의 body쪽으로 이동한 것이다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"React Portal","level":2,"id":"React_Portal_1"},{"heading":"왜 사용할까?","level":3,"id":"왜_사용할까?_0"},{"heading":"사용하기","level":3,"id":"사용하기_0"},{"heading":"createPortal(children)","level":4,"id":"createPortal(children)_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/react/react-portal.html","pathToRoot":"../../..","attachments":[],"createdTime":1728971372663,"modifiedTime":1729218189618,"sourceSize":2838,"sourcePath":"학습 정리/Frontend/React/React Portal.md","exportPath":"학습-정리/frontend/react/react-portal.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/react/useeffect에-관한-고찰.html":{"title":"useEffect에 관한 고찰","icon":"","description":"리액트 코드를 쓰다보면 비동기 통신에서 빠질 수 없는 것이 useEffect이다. 하지만 useEffect를 잘 못 쓰게 된다면 무한한 버그와 무한루프의 요청을 받을 가능성이 있으므로 특히 주의를 요하는 훅이다. 나 또한 무지성으로 리액트 훅들에 대한 고찰 없이 사용하다보니 이러한 훅들에 대한 깊은 이해가 바탕이 되어야 한다고 판단하여 정리하기로 결정했다.useEffect는 리액트의 훅으로, 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과(side effect)를 얻는 메커니즘이다.\n부수효과(side Effect)란?\n함수 내에서 어떤 구현이 함수 외부에 영향을 끼치는 효과. '의도하지 않은 결과'를 가질 수 있는 가능성이 있다는 의미를 내포한다.\nfunction component(){ useEffect(() =&gt; { //뭔가 이것저것 할 것들 }.[])\n}\nuseEffect 는 첫 번째 인수로 부수 효과가 포함된 콜백 함수, 두번째 인수로는 의존성 배열을 받는다. 의존성 배열의 경우 배열에 아무 것도 넣지 않을 수도 있다.useEffect가 두번째로 받는 의존성 배열에 담긴 값이 변경될 때마다 useEffect는 첫 번째로 받은 콜백 함수를 실행한다. 근데 얘는 어떻게 의존성 배열이 바뀐걸 알까? 함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다. 따라서 useEffect는 자바스크립트의 데이터 바인딩, 옵저버 등을 사용하여 값의 변화를 관찰하는 것이 아니고 이러한 리렌더링마다 매번 함수가 실행되고 useEffect도 실행되기는 하지만 렌더링 될 때마다 의존성의 값이 이전과 다른게 하나라도 있을 경우에만 부수효과를 실행하는 일반 함수라고 할 수 있다. 따라서 렌더링 과정에서 실행되는 부수 효과 함수인 셈이다.useEffect는 비동기 데이터를 받는 것뿐만 아니라 이전에 등록한 이벤트 핸들러를 지울 때도 사용된다.import { useEffect, useState } from \"react\"; export default function App() { const [counter, setCounter] = useState(0); function handleClick() { setCounter((prev) =&gt; prev + 1); } useEffect(() =&gt; { function addMouseEvent() { console.log(counter); } window.addEventListener(\"click\", addMouseEvent); return () =&gt; { console.log(\"클린업 함수 실행\", counter); window.removeEventListener(\"click\", addMouseEvent); }; }, [counter]); return ( &lt;&gt; &lt;h1&gt;{counter}&lt;/h1&gt; &lt;button onClick={handleClick}&gt;+&lt;/button&gt; &lt;/&gt; );\n} 해당 컴포넌트를 실행시켜보면 <img src=\"https://i.imgur.com/k59tYjy.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이런 식으로 counter를 참조했지만 0부터 나오는 것을 볼 수 있다. 분명 클린업 함수 실행은 counter가 1 올랐음에도 왜 0일까?답은 클린업 함수가 이전 counter 값, 즉 이전의 state를 참조에 실행되기 때문이다.\n클린업 함수는 새로운 값과 함께 렌더링 된 뒤에 실행되는데, 새로운 값을 기반으로 실행된다는 점은 맞지만, 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다. 그러니 왜 useEffect에 이벤트를 추가했을 때 클린업 함수에서 지워야 하는지 알 수 있다. useEffect는 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행한다. 그러므로 이벤트를 추가하기 전에 이전에 등록됐던 이벤트 핸들러를 삭제함으로써 특정 이벤트의 핸들러가 무한히 추가되는 것을 방지하는 것이다. 대부분 컴포넌트가 '언마운트될 때 이벤트 핸들러를 지운다'는 개념으로 접근하는데, '이전 이벤트 핸들러의 상태를 청소해준다'는 개념으로 접근해야 올바르게 안다고 말할 수 있다.\n언마운트(unmount)\n특정 컴포넌트가 DOM에서 사라질 때를 의미한다.\n클래스형 컴포넌트에서는 componentWillUnmount 함수를 의미한다.\n의존성 배열에 빈 배열을 둔다면 useEffect는 비교할 의존성이 없다고 판단해 최초 렌더링 직후 실행된 다음부터는 실행되지 않는다.그렇다면 앞에서 함수 컴포넌트는 매 렌더링마다 실행된다고 했는데, 그냥 여기다 useEffect 없이 쓰면 되지 않을까 생각할 수 있는데 그러다가 빈 의존성 배열마냥 내 합격 회사도 빈 배열로 남을 수 있다.function Component(){ console.log('렌더링')\n}\nfunction Component(){ useEffect(() =&gt; { console.log('렌더링') })\n}\n컴포넌트 내부에서 useEffect 없이 사용하는 방식과 useEffect를 사용하는 방법은 차이가 있다.컴포넌트 내부에서 직접 실행시킬 경우 위 코드는 컴포넌트 렌더링 중 실행된다. 반면 useEffect가 있으면 컴포넌트의 렌더링 후에 수행된다는 순서적 차이가 있다.이러한 순서는 useEffect가 클라이언트 사이드에서 실행되는 것을 보장해주어 window 객체의 접근에 의존하는 코드를 사용할 수 있다.또한 useEffect 없이 사용할 경우, 컴포넌트 렌더링 도중 실행되기 때문에 서버 사이드 렌더링의 경우에 서버에서도 실행되어 함수 컴포넌트의 리턴을 지연시켜 성능에 악영향을 끼친다.그러니 useEffect가 부수효과를 위한 훅임을 뇌에 박아놓고 사용하도록 하자.useState 다음으로 useEffect는 많이 사용되는 훅이다 . 잘 쓰면 좋지만 못 쓰면 나락이다. 그러니 유의할 점을 고려해서 쓰도록 하자.\nESLint란?\nES(Ecma Script) + Lint(에러 코드 표식)의 합성어로 내 코드를 분석하고 잠재적인 오류나 버그를 찾는데 도움을 주는 툴로, 협업에서 많이 쓰이며 시어머니같이 잔소리를 해주어 내 코드의 질을 높여준다\nuseEffect를 쓸 때 useEffect 인수 내부에서 사용하는 값 중 의존성 배열에 포함돼 있지 않은 값이 있을 경우 eslint-disable-line react-hooks/exhaustive-deps 경고가 뜬다.\n경고를 하는 데는 이유가 있다. 무지성 주석처리 하지 말자. useEffect는 클래스 컴포넌트 생명주기 메서드인 componentDidMount에 기반한 접근법이다. 마운트하는 시점에 실행시키기 위해 사용하기보다는 의존성 배열로 전달한 값의 변경에 의해 실행되어야 하는 코드가 있을 경우에 쓰는 경우가 이상적이다.부수효과가 발생한다는 것은 곧 값의 변경이 이루어진다는 것이다. 하지만 이러한 값을 관찰하지 않고 콜백함수 내에서 특정 값을 사용한다는 것은 부수효과의 관찰에서 실행해야 하는 값과는 별개로 작동한다는 것을 의미한다. 따라서 useEffect의 흐름과 컴포넌트 내 값들의 흐름이 맞지 않게 되기 때문에 잠재적인 버그의 위험성을 가진다.그러니 빈 배열을 쓸 때는 useEffect의 부수효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 여기서 호출하는게 최선인지 검토하자.<br><img src=\"https://i.imgur.com/HYl1IYe.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">특정 값을 사용하지만 해당 값의 변경 시점을 피할 목적으로 useEffect를 사용하려면 메모이제이션을 적절히 활용해 해당 값의 변화를 막거나 위치를 다시금 생각해보자.useEffect(function logActiveUser(){ logging(user.id) },[user.id])\n솔직히 안넣는게 당연하다고 여겼는데, 생각해보니 무슨 일을 하는 useEffect인지 확인하기가 어렵겠다 싶었다. 익명함수가 아닌 기명함수도 사용하는데는 상관이 없으니, 무슨 목적으로 사용하는 함수인지 이름을 넣어주어 가독성을 높이자.useEffect는 의존성이 변경될 때마다 부수 효과를 실행하므로 부수 효과의 크기가 커질수록 애플리케이션 성능에 악영향을 미친다.useEffect는 최대한 간결하고 가볍게 유지하자.\n부득이하게 크게 될 경우 useEffect를 여러 개 만들어 의존성마다 관리하는 것도 방법이 될 수 있다.\n만약 불가피하게 여러 개의 변수가 들어가야 하는 상황이라면 useCallback과 useMemo를 통해 정제된 내용만 담아두자function Component({id}){ const [info, setInfo] = useState(null) useEffect(() =&gt; { const controller = new AbortController() ;(async() =&gt; { const result = await fetchInfo(id, {signal: controller.signal}) })() return () =&gt; controller.abort() },[id]) return &lt;div&gt;렌더링&lt;/div&gt;\n}\nuseEffect에서 처리할 함수를 바깥에 만들지 말고 차라리 익명 함수로 만들어서 넣으면 가독성이 높아지고 간결해진다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"useEffect란?","level":2,"id":"useEffect란?_0"},{"heading":"클린업 함수의 목적","level":2,"id":"클린업_함수의_목적_0"},{"heading":"의존성 배열","level":2,"id":"의존성_배열_0"},{"heading":"useEffect 사용 주의점","level":2,"id":"useEffect_사용_주의점_0"},{"heading":"eslint-disable-line react-hooks/exhaustive-deps 주석 자제하기","level":3,"id":"eslint-disable-line_react-hooks/exhaustive-deps_주석_자제하기_0"},{"heading":"useEffect의 첫 번째 인수에 함수명을 넣기","level":3,"id":"useEffect의_첫_번째_인수에_함수명을_넣기_0"},{"heading":"거대한 useEffect 자제하기","level":3,"id":"거대한_useEffect_자제하기_0"},{"heading":"불필요한 외부 함수를 만들지 말기","level":3,"id":"불필요한_외부_함수를_만들지_말기_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/react/useeffect에-관한-고찰.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058382,"modifiedTime":1725254058383,"sourceSize":9386,"sourcePath":"학습 정리/Frontend/React/useEffect에 관한 고찰.md","exportPath":"학습-정리/frontend/react/useeffect에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html":{"title":"useMemo와 useCallback에 관한 고찰","icon":"","description":"비용이 큰 수행에 대해 수행결과를 메모이제이션하고 필요할 때마다 계속해서 연산을 하는 것이 아닌 저장된 값을 사용하는 최적화를 제공하는 useMemo와 useCallback에 대해 알아보자.\n얘네는 얼핏 보면 비슷한 놈들 같아 보이기 때문에 적절한 상황에 맞춰 사용하는 것이 중요하다.(사실 실제로도 비슷함)비용이 큰 연산에 대한 결과를 저장하고 저장된 값을 반환하는 훅이다.import { useMemo } from 'react' const memoizedValue = useMemo(() =&gt; expensiveComputation(a,b),[a,b])\n첫 번째 인자로는 값을 생성하는 콜백함수가 들어가고, 두번째 인자에는 의존성 배열이 들어가는데, 해당 의존성 배열 안의 값이 달라질 때마다 다시금 콜백 함수를 넣어 계산한 뒤 계산된 값을 다시 저장해 놓는다.해당 훅은 컴포넌트에도 사용이 가능하다.import { useEffect, useMemo, useState } from \"react\"; function ExpensiveComponent({ value }) { useEffect(() =&gt; { console.log(\"Rendering\"); }); return &lt;span&gt;{value + 1000}&lt;/span&gt;;\n} export default function App() { const [value, setValue] = useState(10); const [, triggerRendering] = useState(false); const memoizedComponent = useMemo( () =&gt; &lt;ExpensiveComponent value={value} /&gt;, [value] ); function handleChange(e) { setValue(Number(e.target.value)); } function handleClick() { triggerRendering((prev) =&gt; !prev); } return ( &lt;&gt; &lt;input value={value} onChange={handleChange} /&gt; &lt;button onClick={handleClick}&gt;렌더링하기&lt;/button&gt; &lt;br /&gt; {memoizedComponent} &lt;/&gt; );\n}\n얘를 비싼 연산을 가진 컴포넌트라고 보자<img src=\"https://i.imgur.com/fAZdCMY.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">처음에는 계산한 값이 없으므로 계산 후에 Rendering이 콘솔에 뜰 수밖에 없다.\n하지만 렌더링하기 버튼을 누르면 setter함수가 발생하기 때문에 렌더링이 계속 이루어지는데, ExpensiveComponent에 useEffect를 걸어 놓은 console.log가 뜨지 않는다.\n렌더링이 계속 이루어지기는 하지만 해당 value의 값이 변경하지 않았기에 해당 값의 연산 또한 따로 실행하지 않는 것이다.<br><img src=\"https://i.imgur.com/PR5o74J.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">하지만 값이 변하자마자 setter함수가 발동하면서 렌더링이 일어나고, 의존성 배열에 있는 value의 값이 바뀌었으므로 다시 연산을 실행하여 렌더링에 반영되는 것이다.이렇듯 그저 값 뿐만이 아닌 컴포넌트에서도 유용하게 사용이 가능하다.\n근데 이런 기능은 React.Memo 또한 가능하다. 그러니 고차 컴포넌트인 React.Memo를 쓰자\n고차 컴포넌트란(HOC, Higher-Order Component)\n고차 컴포넌트는 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수이다.\n애플리케이션의 각 계층에서 공통적으로 필요한 문제를 횡단하는 관심사(Cross-Cutting concern)로 컴포넌트를 래핑하여 객체를 추가하는 등의 확장이 가능하다\nuseMemo가 값이나 컴포넌트를 기억했다면, useCallback은 인수로 넘겨받은 콜백 자체를 기억한다. 매 렌더링마다 해당 함수를 실행하지 안고 기억해놨다가 다시 사용한다는 의미이다.import { useCallback } from 'react'; export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) =&gt; { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]);\n얘도 첫 번째 인수로 함수를 받고 두 번째 인수로 의존성 배열을 받는다.\n하지만 얘는 사용하는 방법이 약간 다른데, useMemo의 경우 해당 함수를 실행하여 나오는 값을 메모이제이션하는 반면, useCallback은 함수 자체를 메모이제이션하여 매 렌더링마다 새로 함수가 만들어지는 것을 방지하는 역할을 한다. 익명함수 쓰는 모양이 익숙해져서 기명 함수를 사용할 시 어색할 수도 있겠지만, 기명함수를 씀으로써 디버깅에 용이하다는 이점을 가지고 갈 수 있기 때문에 기명함수를 사용하는 것도 나쁘지 않다.import { useCallback } from 'react'; export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback( function handleSubmit(orderDetails){ post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]);\n어느 의존성 배열과 마찬가지로 얘도 의존성 배열에 있는 값이 변할 때만 함수가 새롭게 재생성된다.\n해당 값 말고는 해당 함수가 필요한 곳은 없을 테니 의존성 배열을 통해 필요할 때만 생성되도록 해놓는게 최적화에 긍정적이다./** * @param {() =&gt; void} callback * @param {any[]} args */\nexport function useCallback(callback, args) { currentHook = 8; return useMemo(() =&gt; callback, args);\n}\nuseMemo와 useCallback의 유일한 차이는 메모이제이션의 대상이 변수냐 함수냐의 차이일 뿐이다. 하지만 자바스크립트에서는 함수 또한 값으로 표현될 수 있으므로 useMemo를 통해 useCallback을 구현하는 것도 가능하다.const handleClick1 = useCallback(() =&gt; { setCounter((prev) =&gt; prev+1)\n}) const handleClick2 = useMemo(() =&gt; { return () =&gt; setCounter((prev) =&gt; prev+1)\n})\n따라서 위에 애랑 밑에 애 모두 똑같이 동작한다는 것이다.\n근데 함수 메모이제이션은 useMemo를 통해 구현하면 코드가 좀 더 길어지기에 귀찮아서 따로 만들어놓은듯 싶다뭘 쓸까?\n알아서 필요한 데 따라서 골라 쓰자\n함수 쓸 거면 useCallback 쓰고 함수가 아닌 값들을 쓸 때는 useMemo쓰는게 편하다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"UseMemo","level":1,"id":"UseMemo_0"},{"heading":"useCallback","level":1,"id":"useCallback_0"},{"heading":"useMemo vs. useCallback","level":1,"id":"useMemo_vs._useCallback_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html","pathToRoot":"../../..","attachments":[],"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":6063,"sourcePath":"학습 정리/Frontend/React/useMemo와 useCallback에 관한 고찰.md","exportPath":"학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"학습-정리/학습-정리.html":{"title":"학습 정리","icon":"","description":"\n<a data-href=\"배럴 파일에 대한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">배럴 파일에 대한 고찰</a>\n<br><a data-href=\"클로저에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/javascript/클로저에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">클로저에 관한 고찰</a>\n<br><a data-href=\"setInterval과 setTimeout에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">setInterval과 setTimeout에 관한 고찰</a>\n<br><a data-href=\"this 바인딩과 간접 호출\" href=\"https://alsgud8311.github.io/학습-정리/frontend/javascript/this-바인딩과-간접-호출.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">this 바인딩과 간접 호출</a> <br><a data-href=\"Concurrent mode\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/concurrent-mode.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Concurrent mode</a>\n<br><a data-href=\"Error boundary와 Suspense\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/error-boundary와-suspense.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Error boundary와 Suspense</a>\n<br><a data-href=\"JSX에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/jsx에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">JSX에 관한 고찰</a>\n<br><a data-href=\"React 19 베타에서 새롭게 추가된 것들\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">React 19 베타에서 새롭게 추가된 것들</a>\n<br><a data-href=\"React Fiber에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/react-fiber에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">React Fiber에 관한 고찰</a>\n<br><a data-href=\"React Portal\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/react-portal.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">React Portal</a>\n<br><a data-href=\"useEffect에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/useeffect에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">useEffect에 관한 고찰</a>\n<br><a data-href=\"useMemo와 useCallback에 관한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">useMemo와 useCallback에 관한 고찰</a> <br><a data-href=\"Tailwind 설정하기\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/tailwind-설정하기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Tailwind 설정하기</a>\n<br><a data-href=\"Prettier 설정하기\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/prettier-설정하기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Prettier 설정하기</a>\n<br><a data-href=\"aws 배포\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/aws-배포.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">aws 배포</a>\n<br><a data-href=\"firebase functions\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/firebase-functions.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">firebase functions</a>\n<br><a data-href=\"NOSQL 맛보기\" href=\"https://alsgud8311.github.io/학습-정리/frontend/others/nosql-맛보기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">NOSQL 맛보기</a> <br><a data-href=\"트랜잭션과 비즈니스 로직\" href=\"https://alsgud8311.github.io/학습-정리/backend/트랜잭션과-비즈니스-로직.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">트랜잭션과 비즈니스 로직</a>\n<br><a data-href=\"express+pug로 templating해서 SSR + CSR 구현하기\" href=\"https://alsgud8311.github.io/학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">express+pug로 templating해서 SSR + CSR 구현하기</a>\n<br><a data-href=\"mysql Join\" href=\"https://alsgud8311.github.io/학습-정리/backend/mysql-join.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">mysql Join</a>\n<br><a data-href=\"Node.js Libuv에 대한 고찰\" href=\"https://alsgud8311.github.io/학습-정리/backend/node.js-libuv에-대한-고찰.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Node.js Libuv에 대한 고찰</a>\n<br><a data-href=\"Passport의 로컬 인증전략\" href=\"https://alsgud8311.github.io/학습-정리/backend/passport의-로컬-인증전략.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Passport의 로컬 인증전략</a>\n<br><a data-href=\"REST API\" href=\"https://alsgud8311.github.io/학습-정리/backend/rest-api.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">REST API</a>\n<br><a data-href=\"sql 트리거\" href=\"https://alsgud8311.github.io/학습-정리/backend/sql-트리거.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">sql 트리거</a>\n<br><a data-href=\"sql 기본문법\" href=\"https://alsgud8311.github.io/학습-정리/backend/sql-기본문법.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">sql 기본문법</a> <br><a data-href=\"fsd 패턴\" href=\"https://alsgud8311.github.io/학습-정리/design-pattern/fsd-패턴.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">fsd 패턴</a>\n<br><a data-href=\"MVC패턴\" href=\"https://alsgud8311.github.io/학습-정리/design-pattern/mvc패턴.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">MVC패턴</a>\n<br><a data-href=\"Observer 패턴\" href=\"https://alsgud8311.github.io/학습-정리/design-pattern/observer-패턴.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Observer 패턴</a>\n<br><a data-href=\"Pub-Sub 패턴\" href=\"https://alsgud8311.github.io/학습-정리/design-pattern/pub-sub-패턴.html#_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Pub-Sub 패턴</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Frontend","level":2,"id":"Frontend_0"},{"heading":"JS","level":3,"id":"JS_0"},{"heading":"React","level":3,"id":"React_0"},{"heading":"Other Developments","level":3,"id":"Other_Developments_0"},{"heading":"Computer Science","level":2,"id":"Computer_Science_0"},{"heading":"Backend","level":2,"id":"Backend_0"},{"heading":"Design Pattern","level":2,"id":"Design_Pattern_0"}],"links":["학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html#_0","학습-정리/frontend/javascript/클로저에-관한-고찰.html#_0","학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html#_0","학습-정리/frontend/javascript/this-바인딩과-간접-호출.html#_0","학습-정리/frontend/react/concurrent-mode.html#_0","학습-정리/frontend/react/error-boundary와-suspense.html#_0","학습-정리/frontend/react/jsx에-관한-고찰.html#_0","학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html#_0","학습-정리/frontend/react/react-fiber에-관한-고찰.html#_0","학습-정리/frontend/react/react-portal.html#_0","학습-정리/frontend/react/useeffect에-관한-고찰.html#_0","학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html#_0","학습-정리/frontend/others/tailwind-설정하기.html#_0","학습-정리/frontend/others/prettier-설정하기.html#_0","학습-정리/frontend/others/aws-배포.html#_0","학습-정리/frontend/others/firebase-functions.html#_0","학습-정리/frontend/others/nosql-맛보기.html#_0","학습-정리/backend/트랜잭션과-비즈니스-로직.html#_0","학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html#_0","학습-정리/backend/mysql-join.html#_0","학습-정리/backend/node.js-libuv에-대한-고찰.html#_0","학습-정리/backend/passport의-로컬-인증전략.html#_0","학습-정리/backend/rest-api.html#_0","학습-정리/backend/sql-트리거.html#_0","학습-정리/backend/sql-기본문법.html#_0","학습-정리/design-pattern/fsd-패턴.html#_0","학습-정리/design-pattern/mvc패턴.html#_0","학습-정리/design-pattern/observer-패턴.html#_0","학습-정리/design-pattern/pub-sub-패턴.html#_0"],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/학습-정리/학습-정리.html","pathToRoot":"..","attachments":[],"createdTime":1738513343179,"modifiedTime":1739033999026,"sourceSize":980,"sourcePath":"학습 정리/학습 정리.md","exportPath":"학습-정리/학습-정리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"회고/부스트캠프-회고.html":{"title":"부스트캠프 회고","icon":"","description":"<img src=\"https://i.imgur.com/ueLbsul.jpeg\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n부스트캠프 멤버십을 수료했다.\n살면서 개발을 이렇게 열심히 해본 적은 처음이었던 것 같다(개발시작 1.5년차)\n매일 슬랙에 체크인아웃을 하던게 엊그제같은데 이제는 평일에 체크인아웃이 없으니 뭔가 허전한 느낌이 들기도 한다.아무튼 부스트캠프가 끝나고 헐레벌떡 바로 어제 리눅스 마스터 시험이 있어서 급하게 준비하고 보고 이제는 조금 여유가 생겨 회고를 쓰기로 했다.\n그냥 깨달은 것들을 중점적으로 생각나는 대로 두서없이 쓸 예정이니 의식의 흐름 주의,,,이번 회고에서는 특히 내가 성장한 경험을 위주로 작성할 예정이다.솔직히 냉정하게 말하자면.. 내가 이전까지 했던 프로젝트나 동아리 활동 모두 프론트엔드 개발에 있어서는 크게 동료에게 받는 깨달음 내지 배움은 거의 없었다고 생각한다.항상 내가 주도적으로 말하면 동료들이 어찌저찌 따라오기만 할 뿐, 기술적인 인사이트를 얻거나 코드에 대한 생산적인 리뷰 하나 받아보지 못했다. 물론 다들 인간적으로 너무 좋은 사람들이지만 이런 부분에 대해서는 항상 아쉬움을 느꼈던 것 같다.<br>\n<img src=\"https://i.imgur.com/4he9qEP.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n물론 제대로 된 PR을 올리지도 못했던 내 잘못도 있다고 생각한다.\n하지만 이런 LGTM 남발만 받다보니 내 스스로도 이게 좋은 코드인지에 대해서 의구심이 들었지만 물어볼 사람조차 없었다. 그렇기 때문에 더더욱 스터디 그룹별로 계속해서 코드리뷰를 받는다는 부스트캠프의 운영방식이 괜찮을까? 생각했었다.하지만 부스트캠프에 들어오면서 동료 피드백에 대한 많은 생각이 바뀌게 되었다.\n예상 외로 부스트캠프에 함께 하는 사람들은 정말 열심히 코드를 리뷰해주었으며, 내가 생전 처음 들어보는 키워드나 기능들을 말씀하시는걸 캐치하여 학습하면서 많은 것들을 새롭게 알아낼 수 있었다.\n더불어 나도 다른 분들이 정성들여 해주시는 만큼 나도 열심히 해야겠다고 생각하다보니 열심히 다른 분들의 코드를 읽게 되고, 자연스럽게 남들의 코드를 읽는 능력 또한 많이 늘었다.프로젝트에서는 매일 평균적으로 14시간정도를 코딩을 하는데 쓰면서 심적으로나 육체적으로 많이 약해졌었다. 그러다보니 나도 모르게 예민했던 적이 많았던 것 같다.<br> <img src=\"https://i.imgur.com/YKj0zpS.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그럼에도 불구하고 좋은 동료가 있었기에 제대로 프로젝트를 끝낼 수 있었다고 생각한다.\n트러블이 생길 수도 있을 뻔한 일이 있었다. 하지만 그렇다고 서로가 감정이 끝나는 상태에서 끝내지 않고, 솔직하게 서로의 감정을 털어내고 진심으로 사과하면서 모두가 다시 힘낼 수 있었다. 성숙한 태도를 가지는 동료들을 만난게 정말 행운이라고 생각한다.<br><img src=\"https://i.imgur.com/71VG8i8.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그리고 무엇보다 다같이 힘들면 더 끈끈해진다고 하지 않는가.\n다같이 힘들다보니 서로 배려해주고 응원해주면서 동료와의 끈끈한 우정을 통해 함께 프로젝트까지 야무지게 끝낼 수 있었다.<br><img src=\"https://i.imgur.com/HHqg3Se.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">무엇보다 부스트캠프를 통해 가장 많이 얻어간 것은 학습 방법과 다양한 학습 키워드라고 생각한다.\n부스트캠프에 들어오기 이전까지는 뭘 해야할 지 몰라서 제대로 학습을 못했었다면, 부스트캠프에서는 너무 공부하고 싶은 것들도 많았고 공부해야 하는 것들도 많았다.생전 처음 들어보는 키워드들이 난무했다. 하지만 부스트캠프에서는 이를 무조건 A부터 Z까지 알려주는 것이 아닌 스스로 학습하고 깨달아야 한다. 결국 이를 어떻게 학습해서 소화시키냐는 온전히 학습하는 사람의 몫인 것이다.<br><img src=\"https://i.imgur.com/Bzw1VfA.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">나 또한 그렇게 던져주는 학습 키워드들을 모두 흡수하지는 못했다고 생각한다. 부스트캠프가 끝난 지금까지도 학습 부채는 있기 때문에 시간이 날 때마다 틈틈히 정리해둘 예정이다.<br><img src=\"https://i.imgur.com/31FM193.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">아무튼 이렇게 던져주는 학습 키워드들을 줍고 이 학습 키워드에 대해서 직접 처음부터 정리해가며 문서화해나가는 과정을 통해 어떻게 '학습'해야 하는지에 대해 나름 나에게 가장 잘 맞는 학습 방식을 정립해 나갔다고 생각한다. 이러한 과정을 체험하길 장려했던 부스트캠프가 정말 개발자의 기본을 가르치는 곳이구나 깨달았다.부스트캠프에서는 모든 활동에 대해서 기록, 즉 문서화를 강조한다.\n나 또한 문서화는 조금씩 하고 있었지만 사실 이 문서화가 정말 중요한 걸까에 대해서는 스스로도 제대로 답을 내리지 못했다. 비록 기술 블로그는 조금씩 정리하고 있다고는 해도 부스트캠프가 강조하는 정도를 보면 이정도는 살짝 광기인 것 같은데.. 라는 생각이 들고는 했다.하지만 요즘 들어서는 문서화의 중요성을 깨달아가고있다.\n가장 기본적으로 문서화 과정은 나의 경험이나 학습을 글로 정리하는 과정인데, 사실 한번에 제대로 완벽한 문서를 만들기 쉽지 않다. 결국 일반 글쓰기와 다름 없이 몇 번의 퇴고를 통해서 비로소 온전한 문서 하나가 완성된다. 이 과정에서 내가 어떻게 이 경험, 학습을 기억해야 할 지 정리하면서 글을 써내려가다보니 머릿속에서도 자연스럽게 정리되는 느낌이 들었다. 그러다보니 비단 문서뿐만 아니라 머리에서도 이 글의 맥락을 모두 이해할 수 있었기에 이를 다시 말로 풀 때면 술술 나오는 느낌을 받았다. 또한 학습 과정에서 연관된 키워드 중에 까먹는 경우도 있기 때문에 이게 뭐였더라 싶은게 꽤 있었는데 내 문서를 찾아보면 내가 이해하기 쉽게 정리해놓은 문서가 있는 경우가 있었다. 이를 다시 읽고 개념을 다시금 이해하는 과정을 통해서 보다 장기적으로 기억이 저장되는 느낌을 받을 수 있었다.결국 이러한 문서화를 하는 일련의 과정 자체가 전부 나에게 알게모르게 영향을 끼치고 있었음을 깨닫고 아 이래서 문서화가 중요했구나를 깨닫게 되었다.<br><img src=\"https://i.imgur.com/apguQFZ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">문서화의 중요성을 깨달은 만큼 이제는 문서화를 귀찮아 하지 않고 열심히 퀄리티 좋은 문서를 만들기 위해서 노력할 생각이다.위에서도 말했다시피 부스트캠프가 끝난 후 나는 바로 리눅스마스터 시험을 준비하고 보고 왔다.<br><img src=\"https://i.imgur.com/z1TX6hP.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">솔직히 부스트캠프 전까지는 내가 리눅스를 공부하게 될 줄은 꿈에도 상상하지 못했다. 프론트엔드 개발자가 리눅스를? 이라는 생각이 들었기 때문이다.하지만 부스트캠프 과정에서 백엔드, 프론트엔드를 모두 경험하며 내가 내린 결론은 프론트엔드 개발자, 백엔드 개발자는 모두 개발자이다 였다.<br>\n<img src=\"https://i.imgur.com/LQTjYbM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n무슨 당연한 소리냐고 물어볼 수도 있다.\n내가 생각하는 프론트엔드 개발자나 백엔드 개발자는 자신이 조금 더 특화되어있는 분야가 앞에 붙을 뿐이지 이들은 모두 개발자로 추상화된다. 따라서 프백 상관없이 개발자로서 서로의 코드를 어느정도는 알고 있어야 하며 이를 위한 배경지식은 '개발자'에게의 공통사항이라고 생각한다. 물론 각자가 공부해야 하는 것들은 엄청 다르기 때문에 차이는 날 수 있더라도 이를 완전히 프백이 서로 완전히 독립적인 객체라고 생각하고 학습하게 되면 시야의 폭이 좁아질 수밖에 없다고 생각한다. 부캠 전의 나처럼아무튼 나는 그래서 부스트캠프가 끝난 후 프백을 가리지 않고 다양하게 학습할 계획이다. 기본적인 CS지식을 다시금 탄탄하게 잡고, 이를 기반으로 프론트엔드 개발을 하면서도 백엔드의 아키텍처와 객체 지향 프로그래밍 등등 폭넓게 학습할 것이다.<br>\n<img src=\"https://i.imgur.com/ioFEXUX.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n벌써부터 공부해야 할 것들이 태산이라 잘 할 수 있을까 걱정도 되지만서도 나름 부캠도 잘 끝냈는데 앞으로도 잘 되겠지! 하는 마음으로 열심히 해보려고 한다.<br><img src=\"https://i.imgur.com/9KbOMTr.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"동료의 중요성","level":2,"id":"동료의_중요성_0"},{"heading":"코드리뷰","level":3,"id":"코드리뷰_0"},{"heading":"경쟁상대가 아닌, 함께 가는 동료들","level":3,"id":"경쟁상대가_아닌,_함께_가는_동료들_0"},{"heading":"학습","level":2,"id":"학습_0"},{"heading":"기록하기","level":2,"id":"기록하기_0"},{"heading":"부스트캠프가 끝난 후","level":2,"id":"부스트캠프가_끝난_후_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/회고/부스트캠프-회고.html","pathToRoot":"..","attachments":[],"createdTime":1734235581559,"modifiedTime":1734279563244,"sourceSize":9066,"sourcePath":"회고/부스트캠프 회고.md","exportPath":"회고/부스트캠프-회고.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준-6064]-카잉-달력.html":{"title":"[백준 6064] 카잉 달력","icon":"","description":"<img src=\"https://i.imgur.com/HAeNjXs.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">카잉 제국의 달력은 각 년도를 &lt;x:y&gt;와 같은 형식으로 표현한다\n시초에 해당하는 첫번째 해를 &lt;1:1&gt;로 표현하고\n두번째 해를 &lt;2:2&gt;로 표현한다.&lt;x:y&gt;의 다음 해는 &lt;x':y'&gt;로, x&lt;M이면 x' = x+1, x=M이면 x'=1이다. 이는 y도 N과 비교했을 때 똑같이 작용한다.\nM=10, N=12일 때\n첫번째 해 &lt;1:1&gt; 11번째 해의 경우 &lt;11:11&gt;이지만 10번째 해로 넘어갈 때 x쪽의 값은 10까지 갔지만 열한번째 해로 넘어가면서 x는 M과 같은 상태이기 때문에 다시 1로 변했다. y의 경우는 N이 12이므로 11이 그대로 넘어가 &lt;1:11&gt; 이 되었다. 13번째 해의 경우\n- &lt;13:13&gt;이지만 11번째 해로 넘어갈 때 이미 x는 1로 변했다. 그렇기 때문에 2가 더해져 3이 되고, y의 경우는 N이 12이기 때문에 13이 되는 순간 1이 되었다.\n따라서 여기에서 알 수 있는 내용은 각 M, N에 따라서 x는 x%M, y는 y%N이 된다는 점이다.\n이런 식으로 달력은 넘어간다.\n우리가 풀어야 할 것은 각 줄마다 M, N, x, y가 주어지는데, 여기서 &lt;x:y&gt;를 보고 몇번째 해인지 맞춰야 한다.하지만 여기서 고려해야 할 사항이 있다.<br>\n<img src=\"https://i.imgur.com/mqbQsxR.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n위 예제처럼 카잉 달력이 유효하지 않은 경우, -1을 출력하도록 하였다. 그러므로 선형으로 브루트포스하게 푸는 것은 되지 않는다.\n그러므로 제대로 계산이 되지 않을 수도 있다는 것이다. 이 예외까지 고려할 수 있는 로직을 생각해보아야 한다.가장 먼저 생각난 것은 재귀 방식으로 푸는 것이다.\n어디서 시작했든 현재 가지고 있는 카잉 달력에서 계속 계산을 해나가다보면 유효한 달력일 경우 언젠가 1 1의 형태가 나올 것이다.\n또한 유효하지 않은 카잉 달력일 경우, 계속 재귀적으로 달력을 구해 나가다가 x에서 가장 큰 수인 M이고, N이 가장 큰 수가 된다면 이건 영원히 끝나지 않을 것이라 생각할 수 있다.다시금 x는 x%M, y는 y%N이 된다는 사실을 떠올리자.\n그렇다면 한 년도에 각각 M,N으로 나누었을 때 나머지가 x,y처럼 나와야 한다는 뜻이기도 하다.\n그럼 그 년도를 어떻게 찾을까?\nx,y의 나머지가 남는 년도에서 교집합을 찾으면 될 것 같다\n첫번째 입력의 경우\n10의 배수 + 3 해서 나오는 수들과 12의 배수 + 9 해서 나오는 수들 중에 교집합이 있는지 보면 x의 경우 -&gt; 3, 13, 23, 33, 43, 53..(3 + 10n)\ny의 경우 -&gt; 9, 21, 33, 45, 57, 69...(9 + 12n)\n이렇게 첫 수를 각각 x, y로 둔 M, N의 등차수열임을 알 수 있다.\n그렇다면 이 두 공차의 최소공배수를 기준으로 이 달력이 반복된다는 것이기 때문에 해당 최대공배수 전까지 루프를 돌면서 x,y가 조건에 만족하는 해가 있는지 찾아보면 된다.\n유클리드 호제법은 x를 y로 나눈 나머지는 r일 때, x, y의 최대공약수는 y, r의 최대공약수와 같다는 원리이다.\n이 원리를 사용해 x값에 y를 대입하고, y값에 r을 대입하면 r이 0이 될 때 둘의 최대공약수인 것이다.\n그리고 최소공배수는 두 수의 곱에 최대공약수로 나누면 나온다.function gcd(a, b) { if (a &lt; b) { const temp = a; a = b; b = temp; } while (b != 0) { const temp = a % b; a = b; b = temp; }\n} function lcm(a, b) { (a * b) / gcd(a, b);\n} 10과 12의 최대공약수를 구해보면 2가 나온다.\n최소공배수는 두 수의 곱 / 최대공약수 이므로10 * 12 / 2 = 60이다.\n따라서 우리는 최소공배수인 60을 주기로 달력이 반복된다는 사실을 알 수 있고, 이전까지만 루프를 돌아서 공통되는 년도를 찾으면 된다.function findYear(M, N, x, y) { const maxYear = lcm(M, N); let year = x; while (year &lt;= maxYear) { if (year === 0) { if (y === x) return maxYear; } else if (year % N === y || (year % N === 0 &amp;&amp; y === N)) { return year; } year += M; } return -1;\n}\nx를 기준으로 3, 13, 23, 33...이렇게 올라가지만서도 최소공배수인 120까지만 루프를 돌면서 y가 조건에 맞을 때가 있는지 확인한다.\n조건에 맞는 경우는\nx가 가지는 연도 중에 N으로 나눴을 때 y의 나머지가 나오는 경우\nx가 가지는 연도 중에 N으로 나눴을 때 나머지가 없고 최대년도에 딱 맞춘 숫자일 때\n이기 때문에 루프를 돌면서 검사하고, 만약 return문으로 빠져나가지 못했다면 서로 공통이 되는 숫자가 없다는 뜻이므로 -1을 출력한다.\nconst INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst [t, ...rest] = require(\"fs\") .readFileSync(INPUT_FILE) .toString() .trim() .split(\"\\n\"); function gcd(a, b) { while (b !== 0) { const r = a % b; a = b; b = r; } return a;\n} function lcm(a, b) { return (a * b) / gcd(a, b);\n} function findYear(M, N, x, y) { const maxYear = lcm(M, N); let year = x; while (year &lt;= maxYear) { if (year === 0) { if (y === x) return maxYear; } else if (year % N === y || (year % N === 0 &amp;&amp; y === N)) { return year; } year += M; } return -1;\n} rest.forEach((input) =&gt; { const [M, N, x, y] = input.split(\" \").map(Number); console.log(findYear(M, N, x, y));\n}); ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"분석하기","level":3,"id":"분석하기_0"},{"heading":"유클리드 호제법","level":3,"id":"유클리드_호제법_0"},{"heading":"다시 돌아와서","level":3,"id":"다시_돌아와서_0"},{"heading":"전체 코드","level":3,"id":"전체_코드_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-6064]-카잉-달력.html","pathToRoot":"..","attachments":[],"createdTime":1738551689134,"modifiedTime":1738569537084,"sourceSize":5662,"sourcePath":"알고리즘/[백준 6064] 카잉 달력.md","exportPath":"알고리즘/[백준-6064]-카잉-달력.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준-10597]-순열장난.html":{"title":"[백준 10597] 순열장난","icon":"","description":"<img src=\"https://i.imgur.com/lK7ssOY.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">하나의 문자열로 합쳐진 순열을 다시 복구하는 문제이다.\n일단 순열의 정의부터 아는 것이 좋다.\n순열은 서로 다른 n개의 원소를 가지는 어떤 집합에서 중복 없이 순서에 상관 있게 r개의 원소를 선택하거나 혹은 나열하는 것이다.kriii는 이러한 순열을 생각해서 중복되는 수가 없도록 수열을 다시 복구하면 된다.\n중복되는 수가 없도록 하기 위해서는 루프를 돌면서 이전에도 중복된 수가 있는지 검사를 해야한다.따라서 해당 문제는 각 수를 분할하여 계산\n메모이제이션이 필요\n하기 때문에, dp로 풀어야 할 것 같다고 생각했다.\nconst INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst inputs = require(\"fs\").readFileSync(INPUT_FILE).toString().trim();\nconst dpArr = new Array(); let pstring = \"\";\nfor (let i = 0; i &lt; inputs.length; i++) { pstring += inputs[i]; if (!dpArr.includes(pstring)) { dpArr.push(pstring); pstring = \"\"; continue; } for (let j = i + 1; j &lt; inputs.length; j++) { pstring += inputs[j]; if (!dpArr.includes(pstring)) { dpArr.push(pstring); pstring = \"\"; i = j; break; } }\n}\nconsole.log(dpArr.join(\" \")); 그렇게 처음 만들어진 코드\n제출하자마자 바로 컷당했다..결국 알고리즘 분류를 보았는데 백트래킹으로 풀어야 한다고 한다.\nkriii의 순열은 최소 1개 최대 50개의 수로 이루어져 있다.\n조건 중 하나를 제대로 보지 않았다. 순열에 들어가는 수는 제한이 있었다.\n이 말의 뜻은 곧 순열은 1부터 50까지의 수 중에 N개의 수를 고르면 해당 N개의 수는 1부터 N까지 숫자가 무조건 한 번씩은 사용이 되어야 하고, 중복이 없어야 한다.그렇다면 매 수가 가면서 해당 수를 넣었을 때와 넣지 않았을 때로 나누어 계산한 후, 중간에 조건이 맞지 않는다면 빠꾸 시키는 백트래킹 형식으로 가면 되지 않을까?결국 ai의 도움을 통해 풀었다... 백트래킹이 익숙치 않다보니 로직은 조금 더 보면서 익혀야 할 것 같다.// 백트래킹 함수\nfunction backtrack(index, path, used) { // 문자열 끝에 도달했을 때 if (index === inputs.length) { return path.length &gt; 0 ? path : null; } for (let length = 1; length &lt;= 2; length++) { if (index + length &gt; inputs.length) continue; // 현재 위치에서 length만큼의 숫자 추출 const num = parseInt(inputs.slice(index, index + length)); // 유효한 숫자인지 확인 if (isValid(num, used)) { // 현재 숫자를 사용했다고 표시 const newUsed = new Set(used); newUsed.add(num); // 다음 단계로 진행 const result = backtrack(index + length, [...path, num], newUsed); if (result) { return result; } } }\n}\n순열의 숫자의 경우 1~50까지의 수여야만 하기 때문에 수는 1자리 수가 될 수도 있고, 2자리 수가 될 수도 있다. 하지만 그 이상은 가지 못한다.\n따라서 1자리 수와 2자리 수를 구분하여 백트래킹을 진행했다.function isValid(num, used) { return num &gt;= 1 &amp;&amp; num &lt;= Math.min(inputs.length, 50) &amp;&amp; !used.has(num);\n}\n해당 수가 유효한지 검사하는 함수의 경우 맨 처음엔 고정적으로 50까지의 수라 했으니 50을 해야겠다!라고만 생각했다. 하지만 이렇게 될 경우 나중에 더 큰 수가 나오면서 순열의 조건을 해치는 경우가 있을 수 있으므로 받은 문자열의 길이를 통해 최대한 가질 수 있는 순열의 수를 유추했다. 하지만 이렇게 유추했을 때 50을 넘어버리는 경우가 있기 때문에 Math.min을 통해 조건부로 조건을 넘겨줄 수 있도록 하였다.const result = backtrack(0, [], new Set()); // 결과가 있고, 유효한 순열인지 확인\nif (result) { const maxNum = Math.max(...result); const expectedSet = new Set(Array.from({ length: maxNum }, (_, i) =&gt; i + 1)); const resultSet = new Set(result); // 1부터 maxNum까지의 모든 숫자가 정확히 한 번씩 사용되었는지 확인 if ( result.length === maxNum &amp;&amp; JSON.stringify([...expectedSet].sort()) === JSON.stringify([...resultSet].sort()) ) { console.log(result.join(\" \")); }\n} 백트래킹을 진행한 후에는 result에 순열이 담기게 되는데, 조건을 만족하는 것들이 여러개라면 하나만 받으면 되므로 조건이 맞았을 때 바로 return하도록 해서 그 후에 가져온 결과를 검사했다.\n유효한 수인지를 검사하고 이에 따라 1~최대 순열의 길이까지의 수들이 모두 사용되었는지를 검사하여 결과를 내보냈다.백트래킹,,,,어렵군,,,,","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-10597]-순열장난.html","pathToRoot":"..","attachments":[],"createdTime":1738634444372,"modifiedTime":1738638881395,"sourceSize":4979,"sourcePath":"알고리즘/[백준 10597] 순열장난.md","exportPath":"알고리즘/[백준-10597]-순열장난.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준-31836]-피보나치-기념품.html":{"title":"[백준 31836] 피보나치 기념품","icon":"","description":"<img src=\"https://i.imgur.com/KSslIhp.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">세림이랑 성주는 왜 대체 피보나치 수열을 좋아하는 걸까...?\n아무튼 두 사람이 받게 될 기념품에 적힌 피보나치 수의 합이 같아야 하면서 최대한 많은 개수의 기념품을 나눠줄 수 있도록 해야한다.<br><img src=\"https://i.imgur.com/rJt8KiI.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n입출력을 보자.\n예제 1의 경우 2개의 기념품이 있다.\n이 때, 세림이는 1이 적혀있는 기념품 한개를 받았고, 성주는 2가 적혀있는 기념품 한 개를 받았다.\n여기서 1과 2 모두 피보나치 수로 1이기 때문에 두 사람이 받은 기념품들의 합은 1로 같다.예제2의 경우 4개의 기념품을 받았다.\n세림이는 1, 3 두 개의 기념품을 받았고, 성주는 4로 된 기념품 하나를 받았다.\n세림이의 기념품들의 피보나치 수 합은 F1+F3 = 1+2 = 3\n성주의 기념품들의 피보나치 수 합은 F4 = 3 이므로 두 사람이 받은 기념품의 피보나치 수 합은 같다.이 문제는 어떻게 풀어야 할까?\nN이 주어지면 거기에서 공통의 합의 나오도록 해야 하는데, 이는 한 사람의 기념품을 받은 수를 가지고 계속 쪼갤 수 있다.\n예제 2처럼 N이 4라고 한다면 F4부터 시작해서 계속해서 피보나치 수로 쪼갤 수 있도록 하는 것이다.\n예제 2의 경우도 4로 시작해서 F4 = F2 + F3이므로 한도를 넘지 않는 선에서 2개의 기념품을 가지도록 한 것이다.\n또한 여기서 최대의 값을 가져야 하므로 기존에 나온 값들 중에서 가장 큰 값을 고르는 것이기 때문에 분할정복 혹은 dp로 풀어야 할 것 같다.\n흠 일단 피보나치로 나올 수 있는 수들에 대해서 미리 메모이제이션 한 다음에, 여기에서 가장 크게 나눠가질 수 있는 경우를 찾아보면 될 것 같다.\n샀던 N개의 기념품은 모두 N보다 작은 x의 수가 적혀있는 피보나치 수이다.\n가장 큰 수부터 시작해서 계속 피보나치를 나눠가면서 개수를 더하면?","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-31836]-피보나치-기념품.html","pathToRoot":"..","attachments":[],"createdTime":1738721552467,"modifiedTime":1738723879145,"sourceSize":2084,"sourcePath":"알고리즘/[백준 31836] 피보나치 기념품.md","exportPath":"알고리즘/[백준-31836]-피보나치-기념품.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html":{"title":"[백준26091] 현대모비스 소프트웨어 아카데미","icon":"","description":"<img src=\"https://i.imgur.com/EokJAxy.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nPPL문제는 참신하네요..두 조건을 만족하는 팀만 견학 할 수 있는데, 최대 몇 팀이나 견학을 보낼 수 있는지 구하면 된다.\n팀원은 무조건 두명인 걸 보니 생각해볼 수 있는 알고리즘의 폭이 많이 줄어들 수 있다고 생각한다.<br><img src=\"https://i.imgur.com/LzcehEB.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n예제를 보자.\n예제 1의 경우 6명이 있고 최소 능력치는 두명이 합쳐서 10이 넘어야 한다.\n여기서 나오는 조합들 중 10이 넘는 조합들을 구하고, 최대로 보낼 수 있는 팀 수를 출력하면 된다.const INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst inputs = require(\"fs\") .readFileSync(INPUT_FILE) .toString() .trim() .split(\"\\n\"); const [n, m] = inputs[0].split(\" \").map(Number);\nconst students = inputs[1] .split(\" \") .map(Number) .sort((a, b) =&gt; a - b); let left = 0;\nlet right = n - 1;\nlet team = 0;\nwhile (left &lt; right) { if (students[left] + students[right] &gt;= m) { team++; left++; right--; } else { left++; continue; }\n}\nconsole.log(team);\n어차피 한 번 참가한 팀원은 다시 참여할 수 없고, 무조건 두 명씩 팀을 해야 한다는 전제가 있기 때문에 간단하게 투포인터를 활용해서 풀 수 있었다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html","pathToRoot":"..","attachments":[],"createdTime":1738725963950,"modifiedTime":1738732699343,"sourceSize":1366,"sourcePath":"알고리즘/[백준26091] 현대모비스 소프트웨어 아카데미.md","exportPath":"알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/neo/구현의-상세-추상화.html":{"title":"구현의 상세 추상화","icon":"","description":"한 사람이 코드를 읽을 때 동시에 고려할 수 있는 총 맥락의 숫자는 제한되어 있다고 한다.\n그렇기 때문에 우리는 추상화를 통해서 불필요한 맥락을 줄여 코드를 읽기 쉽게 만듦으로써 좋은 코드를 만들 수 있다. 근데 이 프로그래밍에서 빠질 수 없는 추상화는 대체 무엇일까?추상화는 객체 지향 프로그래밍의 개념 중 하나이다.\n\"추상\" 이라는 용어의 사전적 의미는 \"사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것\" 이라 정의한다.소프트웨어적으로 말하자면 복잡한 시스템의 세부 구현을 숨기고, 필요한 핵심적인 개념만을 드러내어 다룰 수 있도록 하는 개념이라고 말할 수 있다. 즉, 불필요한 세부사항을 감추고 중요한 정보만을 제공하는 방식인 것이다.그렇다면 추상화를 통해 우리가 얻는 것은 무엇일까?\n복잡성 감소 불필요한 내부 동작을 숨기고 중요한 부분만 노출하여 코드의 가독성을 높이고 유지보수를 용이하게 함 모듈화와 재사용성 향상 여러 기능을 추상화하여 모듈화하면 코드가 독립적으로 동작할 수 있어 재사용성이 증가 유지보수성 향상 세부 구현을 감추고 인터페이스만 제공하면 내부 구현이 변경되어도 외부 코드에 미치는 영향을 최소화 아래 예시를 보자.function fetchUserData(userId: string) { return fetch(`https://api.example.com/users/${userId}`) .then((res) =&gt; res.json());\n} // 사용자는 내부 요청 방식(Fetch API 등)을 몰라도 데이터를 가져올 수 있음\nfetchUserData(\"123\").then((data) =&gt; console.log(data)); fetchUserData()는 유저의 정보를 가져오는 api라는 것을 우리는 함수의 명을 통해 알 수 있다.\n하지만 이 api는 그냥 부른다고 띡 되는게 아니다.이 안에는 Fetch문을 통해 Promise 기반의 http 요청을 보내야 하고, 이렇게 받은 요청에 대해서 체이닝을 통해 json 데이터로 변환하는 작업까지 담겨 있다.위에서 말하는 불필요한 세부사항은 바로 위에서 말한 것들이다. 우리는 요청을 보내는 과정에서 일어나는 것들을 굳이 그대로 쓰지 않고 한 단계 fetchUserData라는 함수로 추상화 함으로써 위와 같은 단계들을 하나의 함수명(중요한 정보) 을 통해서 알 수 있도록 하였다.이를 통해서 아 우리가 인식하지 않고 하고 있던 것들이 다 추상화였구나!를 깨달을 수 있었다. 함수를 나눠서 쓰는 것도 해당 함수에 꼭 필요한 내부 기능을 담게 코드를 작성하고 있었기 때문에 이 또한 추상화이기 때문이다.이번 Neo 프로젝트를 하면서 운이 좋게도 지인에게 코드 리뷰를 받을 수 있게 되었다.\n나는 이 코드 리뷰에서 집중적으로 봐줬으면 좋을 것 같은 부분 중 '추상화'를 꼽았다.추상화는 물론 많은 작업들을 보다 간단하게 이해할 수 있게끔 해주는 좋은 역할을 가지고 있지만, 그렇다고 무조건 해야만 좋은 것도 아니다.\n내가 쓰는 하나하나의 로직들을 전부 추상화하게 된다면, 프론트엔드에서는 컴포넌트를 계속 링크를 파고파고 들어가는 형태가 되어버린다. 결국 우리가 추상화를 하게 된 근본적인 이유는 보다 코드를 쉽게 이해하고 잘 재사용하기 위해서인데, 코드를 쉽게 이해하지도 못하고 재사용도 애매해지는 결과를 낳기도 한다. 이번에 직접 '섣부른 추상화'를 행하면서 깨달은 점이기도 하다.원래 코드는 아래와 같았다.// app/login/page.tsx\nexport default function Page() { const loginFormSchema = z.object({ email: z.string().email({ message: \"유효한 이메일 주소가 아닙니다.\" }), password: z .string() .regex( /^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@$!%*#?&amp;])[A-Za-z\\d@$!%*#?&amp;]{8,}$/, { message: \"비밀번호는 영문 대/소문자, 숫자, 특수문자를 포함하여 8자 이상이어야 합니다.\", } ), }); const form = useForm&lt;z.infer&lt;typeof loginFormSchema&gt;&gt;({ resolver: zodResolver(loginFormSchema), defaultValues: { email: \"\", password: \"\", }, }); function onSubmit(values: z.infer&lt;typeof loginFormSchema&gt;) { console.log(values); } return ( &lt;div className=\"h-screen grid px-8\"&gt; &lt;div className=\"flex flex-col items-center justify-center\"&gt; &lt;Image src=\"/neo_emblem.svg\" alt=\"logo\" width={100} height={100} /&gt; &lt;span className=\"text-xl font-bold\"&gt;NEO&lt;/span&gt; &lt;/div&gt; &lt;Form {...form}&gt; &lt;form onSubmit={form.handleSubmit(onSubmit)} className=\"flex flex-col gap-6\" &gt; &lt;div className=\"flex flex-col gap-4\"&gt; &lt;FormField control={form.control} name=\"email\" render={({ field }) =&gt; ( &lt;FormItem&gt; &lt;FormLabel className=\"flex justify-between\"&gt; &lt;span className=\"text-sm font-medium\"&gt;이메일 주소&lt;/span&gt; &lt;/FormLabel&gt; &lt;FormControl&gt; &lt;Input placeholder=\"example@gmail.com\" className=\"p-6 bg-gray-100 rounded-lg\" {...field} /&gt; &lt;/FormControl&gt; &lt;/FormItem&gt; )} /&gt; &lt;FormField control={form.control} name=\"password\" render={({ field }) =&gt; ( &lt;FormItem&gt; &lt;FormLabel className=\"flex justify-between\"&gt; &lt;span className=\"text-sm font-medium\"&gt;비밀번호&lt;/span&gt; &lt;/FormLabel&gt; &lt;FormControl&gt; &lt;Input className=\"p-6 bg-gray-100 rounded-lg\" {...field} /&gt; &lt;/FormControl&gt; &lt;div className=\"flex justify-between\"&gt; &lt;div className=\"flex items-center space-x-2\"&gt; &lt;Checkbox id=\"remember\" className=\"data-[state=checked]:bg-primary border-muted-foreground\" /&gt; &lt;Label htmlFor=\"remember\" className=\"text-sm font-medium text-muted-foreground leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\" &gt; 비밀번호 기억하기 &lt;/Label&gt; &lt;/div&gt; &lt;Button variant=\"link\" className=\"text-sm text-primary\" asChild &gt; &lt;Link href=\"/forgot-password\"&gt; 계정을 잃어버리셨나요? &lt;/Link&gt; &lt;/Button&gt; &lt;/div&gt; &lt;/FormItem&gt; )} /&gt; &lt;/div&gt; &lt;div className=\"flex flex-col gap-2\"&gt; &lt;Button type=\"submit\" variant=\"default\" className=\"w-full flex items-center justify-center gap-2 p-6 rounded-lg hover:opacity-90 hover:bg-primary\" &gt; &lt;span className=\"text-lg font-base\"&gt;다음&lt;/span&gt; &lt;ChevronRight className=\"w-6 h-6\" /&gt; &lt;/Button&gt; &lt;div className=\"flex justify-center items-center gap-2\"&gt; &lt;span className=\"text-sm text-muted-foreground\"&gt; 아직 회원이 아니신가요? &lt;/span&gt; &lt;Button variant=\"link\" className=\"text-sm text-primary\" asChild&gt; &lt;Link href=\"/signup\"&gt;회원가입하기&lt;/Link&gt; &lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/Form&gt; &lt;div className=\"flex flex-col gap-8\"&gt; &lt;div className=\"relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t after:border-border\"&gt; &lt;span className=\"relative z-10 bg-background px-2 text-muted-foreground\"&gt; 또는 10초만에 로그인 · 회원가입 하기 &lt;/span&gt; &lt;/div&gt; &lt;Button variant=\"outline\" className=\"w-full p-6 rounded-lg\"&gt; &lt;Image src=\"/auth/google_emblem.svg\" alt=\"google\" width={20} height={20} /&gt; &lt;span className=\"text-base font-light\"&gt;구글 로그인&lt;/span&gt; &lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; );\n}\n나는 처음에 거의 150줄이 넘어가는 코드의 개수를 보자마자 '아 이건 추상화를 해야겠다'라고 생각했다.\n일단 나는 100줄이 넘어가는 하나의 페이지는 무조건 지양해야 한다고 생각했기 때문이다.\n그래서 내가 생각했던 추상화는\n자체 로그인 부분만 loginForm으로 추상화 loginForm에서 공통으로 쓰이는 FormField내의 컴포넌트 구성을 loginFormField로 추상화 소셜 로그인 버튼을 socialLoginButton으로 추상화\n로그인에 필요한 스키마를 해당 파일에서 선언하는 것이 아닌 다른 곳으로 분리\nlogin에 필요한 server action을 추상화\nreact-hook-form에서 쓰이는 훅을 추상화\n정도로 나눠지게 되었다.\nimport { LoginForm } from \"@/app/(auth)/login/loginForm\";\nimport SocialLoginButton from \"@/components/ui/socialLoginButton\";\nimport Image from \"next/image\"; export default function Page() { return ( &lt;div className=\"h-screen grid px-8 relative\"&gt; &lt;div className=\"flex flex-col items-center justify-center\"&gt; &lt;Image src=\"/neo_emblem.svg\" alt=\"logo\" width={100} height={100} /&gt; &lt;span className=\"text-xl font-bold\"&gt;NEO&lt;/span&gt; &lt;/div&gt; &lt;LoginForm /&gt; &lt;div className=\"flex flex-col gap-8\"&gt; &lt;div className=\"relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t after:border-border\"&gt; &lt;span className=\"relative z-10 bg-background px-2 text-muted-foreground\"&gt; 또는 10초만에 로그인 · 회원가입 하기 &lt;/span&gt; &lt;/div&gt; &lt;div className=\"w-full flex flex-col justify-center items-center gap-5\"&gt; &lt;SocialLoginButton type=\"kakao\" /&gt; &lt;SocialLoginButton type=\"google\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );\n}\n그렇게 추상화한 결과 page는 이렇게 확실히 코드가 줄어지게 되었다.\n하지만 해당 추상화가 정말 잘된 추상화일까?이번에 내가 했던 코드 리뷰에서 이런 이야기가 나왔다.\n<img src=\"https://i.imgur.com/NyroIXU.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">나는 요게 맞는 말이라고 생각한다.\nurl은 비단 링크 정도의 기능만을 하는 것이 아니다. 각각의 페이지 모두 html 문서, js, css를 불러오는 get api를 불러오기 때문에 routing 또한 RESTFUL하게 이루어져야 한다.Next.js에서 app 라우터는 page라는 파일에 라우팅된다. 그러므로 app/login은 로그인이라는 자원을 불러온다는 의미기도 한데, 이미 route를 통해서 login이라는 추상화를 이루어냈음에도 불구하고 여기서 form을 따로 나누는 것은 불필요한 추상화가 아니었나 생각한다.\n또한 loginForm을 나누고, 이 form에서 가지고 있는 hook까지 커스텀 훅으로 빼게 되니 코드의 수가 더 늘어났다.물론 이게 나와 협업하는 다른 개발자들이 보기에 조금 더 편할 수 있다면 LOC가 늘어나는 것은 괜찮다고 생각하지만 문제는 평탄하게 뿌려진 폴더 구조였다.\n나는 어찌보면 route 하나하나가 각 도메인을 의미한다고 생각했기에 여기에 필요한 훅, 컴포넌트, 스키마 등을 나누었다.<br><img src=\"https://i.imgur.com/9xqqng5.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">원래대로라면 page.tsx가 하나만 있어야 할텐데 너무 늘어나 이에 대한 배경지식이 없다면 코드의 가독성이 더 떨어져 보이는 듯한 효과를 주는 것을 느끼게 되었다.또한 Login쪽에서 관리하는 Hook을 보자export function useLogin() { const { supabase } = useAuth(); const router = useRouter(); const { open: openErrorModal, switchModal, setMessage: setErrorMessage, message: errorMessage, } = useModal(); const form = useForm&lt;loginFormSchemaType&gt;({ resolver: zodResolver(loginFormSchema), defaultValues: { email: \"\", password: \"\", }, }); const { mutate, isPending } = useMutation({ mutationFn: handleEmailLogin, onSuccess: () =&gt; router.push(\"/\"), onError: (error) =&gt; { if (error instanceof Error) { setErrorMessage(error.message); switchModal(); } else { setErrorMessage( \"서버 상의 이유로 실패하였습니다.\\n 잠시 후 다시 시도해 주세요.\" ); switchModal(); } }, }); function submit(values: loginFormSchemaType) { const { email, password } = values; mutate({ email, password, supabase }); } return { form, submit, openErrorModal, switchModal, setErrorMessage, isPending, errorMessage, };\n} useLoginForm이라는 비즈니스 로직을 추상화한 하나의 커스텀 훅에 너무 많은 역할들이 혼재하고 있다.\n서버 상태 관리, 에러 상태 관리, 폼 관리를 하나의 훅으로 추상화하면서 어찌보면 이렇게 많은 역할들을 한번에 이해하기란 쉽지 않을 것 같다고 다시 코드를 봤을 때 느끼게 되었다.이번 코드 리뷰를 통해 '추상화' 라는 것이 무조건 내 코드의 품질을 높여주는 silver bullet이 아닌, '잘' 추상화 해야지만 추상화의 이점을 가질 수 있음을 깨달았다. 따라서 이번에 조금 더 추상화를 어떻게 더 '좋은 코드' 로 만들 수 있을까에 대해서 계속해서 고민하고 시도해가면서 감을 익혀나가야겠다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"추상화란?","level":3,"id":"추상화란?_0"},{"heading":"내가 쓴 코드의 추상화에 대하여","level":3,"id":"내가_쓴_코드의_추상화에_대하여_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/neo/구현의-상세-추상화.html","pathToRoot":"../..","attachments":[],"createdTime":1738596273912,"modifiedTime":1738598764434,"sourceSize":14417,"sourcePath":"프로젝트/Neo/구현의 상세 추상화.md","exportPath":"프로젝트/neo/구현의-상세-추상화.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/[백준-12891]-dna-비밀번호.html":{"title":"[백준 12891] DNA 비밀번호","icon":"","description":"<img src=\"https://i.imgur.com/j2BxAFf.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">DNA 문자열을 가지고 만들 수 있는 비밀번호의 종류의 수를 구하는 문제이다.\nDNA 문자열은 모든 문자열에 등장하는 문자가 A, C, G, T인 문자열을 의미한다.\n또한 일정 길이의 DNA 문자열과 A, C, G, T가 각각 가져야 하는 문자열의 개수를 세봤을 때 이보다 이상이어야 성립한다.\n어차피 비밀번호로 사용할 부분문자열의 길이는 주어져있고, 문자열에서 임의로 뽑아내는 것이 아닌 이어져 있는 문자열이기 때문에 슬라이딩 윈도우를 통해 풀면 될 것 같다.const INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst inputs = require(\"fs\") .readFileSync(INPUT_FILE) .toString() .trim() .split(\"\\n\");\nconst [s, p] = inputs[0].split(\" \").map(Number);\nconst str = inputs[1];\nconst [A, C, G, T] = inputs[2].split(\" \").map(Number);\nlet result = 0;\nfor (let i = 0; i &lt;= s - p; i++) { let a = A; let c = C; let g = G; let t = T; const partition = Array.from(str.slice(i, i + p)); partition.forEach((char) =&gt; { if (char === \"A\") a--; else if (char === \"C\") c--; else if (char === \"G\") g--; else if (char === \"T\") t--; }); if (a &lt;= 0 &amp;&amp; c &lt;= 0 &amp;&amp; g &lt;= 0 &amp;&amp; t &lt;= 0) result++;\n}\nconsole.log(result); 처음에는 switch - case문을 사용해 풀었지만 메모리 초과가 나와서 if문으로 바꿨는데도 역시 났다.\n사실 switch case문과는 솔직히 별 시간 차이가 나지 않을 것 같긴 해서 다른 곳이 문제라는 건데..const INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst inputs = require(\"fs\") .readFileSync(INPUT_FILE) .toString() .trim() .split(\"\\n\");\nconst [s, p] = inputs[0].split(\" \").map(Number);\nconst str = inputs[1];\nconst [a, c, g, t] = inputs[2].split(\" \").map(Number);\nconst testSum = a + c + g + t;\nconst regex = new RegExp( `^(?=(?:[^A]*A){${a}})(?=(?:[^C]*C){${c}})(?=(?:[^G]*G){${g}})(?=(?:[^T]*T){${t}}).*$`\n); if (testSum &gt; s) { console.log(0);\n} else { let result = 0; for (let i = 0; i &lt;= s - p; i++) { const testStr = str.slice(i, i + p); if (regex.test(testStr)) result++; } console.log(result);\n} 킹받아서 정규표현식으로도 해봤는데 이젠 시간 초과가 뜬다다시 생각해보니 나는 슬라이딩 윈도우를 어떻게 효율적으로 사용하는지 제대로 몰랐던 것 같다.슬라이딩 윈도우는 일정한 크기의 윈도우를 가지고 계속 옆으로 옮겨가면서 검사를 하는 방식이지만, 이 과정에서 계속해서 변수에 새롭게 문자열을 잘라 할당하게 되면 결국 메모리 손해로 이어지고 만다. 그렇기 때문에 매번 새롭게 할당하는 방식이 아니라 기존 데이터를 일정한 크기만큼 계속 움직이는 만큼 쓸 수 있는 데이터는 그대로 쓰면서 넘어가야만 효율적인 알고리즘이 될 수 있다.const INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst inputs = require(\"fs\") .readFileSync(INPUT_FILE) .toString() .trim() .split(\"\\n\"); const [s, p] = inputs[0].split(\" \").map(Number);\nconst str = inputs[1];\nconst [a, c, g, t] = inputs[2].split(\" \").map(Number);\nconst testSum = a + c + g + t; if (testSum &gt; s) { console.log(0); process.exit(0);\n} const count = { A: 0, C: 0, G: 0, T: 0 };\nlet result = 0;\nfor (let i = 0; i &lt; p; i++) count[str[i]]++;\nif (count[\"A\"] &gt;= a &amp;&amp; count[\"C\"] &gt;= c &amp;&amp; count[\"G\"] &gt;= g &amp;&amp; count[\"T\"] &gt;= t) result++; for (let i = p; i &lt; s; i++) { count[str[i]]++; count[str[i - p]]--; if (count[\"A\"] &gt;= a &amp;&amp; count[\"C\"] &gt;= c &amp;&amp; count[\"G\"] &gt;= g &amp;&amp; count[\"T\"] &gt;= t) result++;\n} console.log(result); 그렇기 때문에 객체에 기존 문자열을 모두 저장해놓고 옆으로 옮겨가면서 추가된 문자열만 하나씩 추가해주는 방식으로 바꿨더니 정답이 되었다.<br><img src=\"https://i.imgur.com/jFLzfRi.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">앞으로 슬라이딩 윈도우를 쓸 때는 딱 그렇게만 생각하는 것이 아닌, 쓰는 방식에 대해서도 고민을 하고 코드를 작성해야 할 것 같다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-12891]-dna-비밀번호.html","pathToRoot":"..","attachments":[],"createdTime":1738899631176,"modifiedTime":1738903131731,"sourceSize":4226,"sourcePath":"알고리즘/[백준 12891] DNA 비밀번호.md","exportPath":"알고리즘/[백준-12891]-dna-비밀번호.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html":{"title":"화면 기록 2025-02-07 오후 11.20.09","icon":"","description":"<img src=\"https://alsgud8311.github.io/프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html","pathToRoot":"../..","attachments":["프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html"],"createdTime":1738938249154,"modifiedTime":1738938249201,"sourceSize":12681528,"sourcePath":"프로젝트/forA/화면 기록 2025-02-07 오후 11.20.09.gif","exportPath":"프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"attachment"},"알고리즘/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html":{"title":"[백준 23307] 드디어 시작한 화석 발굴 이벤트","icon":"","description":"<img src=\"https://i.imgur.com/QgvfRjs.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n프로그래밍 경진대회 하는데 느닷없이 화석 캐는 사람들..4k+1의 변의 길이를 가진 정사각형 크기의 달팽이 형태 화석이 있으며 중심은 (2k+1, 2k+1)이다.여기서 달팽이 화석을 찾아 출력에 해당 화석의 중심 위치와 한 변의 길이, 화석의 방향을 출력하면 된다.<br><img src=\"https://i.imgur.com/3iSLYtT.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">방향은 위에 나온 것처럼 8가지로 구분할 수 있다.\n어디에서 출발해서 어떤 방향으로 가느냐가 관건인데, DFS를 시작하면서 나오는 방향에 따라 재귀함수로 넘겨줄 때 함께 넘겨주면 될 것 같다.이 문제는 어차피 화석이 항상 제대로 묻혀있다는 가정 하에 푸는 문제이기 때문에 딱히 해당 화석이 제대로 된 화석인지에 대해서는 따로 검증은 필요없을 것 같다.\n하지만 변의 길이는 제대로 알아야 한다.일단 먼저 DFS로 돌면서, 맨 처음 화석이 발견한 곳을 찾으면 재귀 함수로 DFS 탐색을 시작한다.\n탐색을 하면서 시작점과 중앙을 인자로 넘겨주면 이를 통해 한 변의 길이를 구할 수 있을 것 같고, 방향의 경우 어디 방향으로 나아가는지를 맨 처음부터 구별해서 주변 될 것 같다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html","pathToRoot":"..","attachments":[],"createdTime":1738804818833,"modifiedTime":1738805494290,"sourceSize":1332,"sourcePath":"알고리즘/[백준 23307] 드디어 시작한 화석 발굴 이벤트.md","exportPath":"알고리즘/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"알고리즘/백준-18113-그르다-김가놈.html":{"title":"백준 18113 그르다 김가놈","icon":"","description":"<img src=\"https://i.imgur.com/lCwjRBt.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n\u0001\n제목부터 웃음벨,,, 그르다 김가놈ㅋㅋㅋㅋㅋ\n일단 이 문제에서는 김밥을 꼬다리 Kcm만큼 양쪽을 자른 다음에 김밥을 썬다. 근데 문제는 2Kcm보다 짧으면 한쪽만 자른다는 것이다.\nPcm로 만든 각각의 김밥 조각들이 M개 나오게 되는데, 이 M이 주어지면 P가 나올 수 있는 가장 큰 수를 구해야 한다.<br><img src=\"https://i.imgur.com/0kDARzK.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n예제를 보자.\nn(손질해야 하는 김밥) : 3, k(꼬다리 길이) : 6, M(김밥 조각의 최소 개수) : 4이고, 김밥은 각각 20, 10, 3cm이다.\n첫 번째 김밥의 경우는 양옆 꼬다리를 제거하고 8cm가 남았고, 두번째 김밥의 경우는 한 쪽만 꼬다리를 잘라 4cm가 남았다. 세번째 김밥은 꼬다리 길이보다 작아서 폐기되었다.그럼 이 8cm와 4cm를 가지고 최대 4개의 조각을 가지면서 최대한의 길이를 가져야 한다. 그러기 위해서는 2cm로 나눠야만 m만큼의 조각이 나온다. 무턱대고 4cm로 자르거나 하면 최소 김밥 개수를 맞추지 않기 때문에 이를 맞추는 방법을 생각해야 한다.const INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst inputs = require(\"fs\") .readFileSync(INPUT_FILE) .toString() .trim() .split(\"\\n\");\nconst [n, k, m] = inputs[0].split(\" \").map(Number);\nconst kimbabs = inputs.slice(1).map(Number); let kimbabWithoutCcodari = kimbabs.map((kb) =&gt; { if (kb &gt;= 2 * k) return kb - 2 * k; if (kb &gt; k) return kb - k; return 0;\n}); const minP = Math.floor( kimbabWithoutCcodari.reduce((acc, curr) =&gt; acc + curr, 0) / m\n); for (let i = minP; i &gt; 0; i--) { let accM = 0; kimbabWithoutCcodari.forEach((bab) =&gt; { if (bab &lt;= minP) return; accM += Math.floor(bab / i); }); if (accM &gt;= m) { console.log(i); process.exit(0); }\n}\nconsole.log(-1); 처음에는 그냥 선형적으로 문제를 풀려 했다.\n꼬다리 없는 김밥을 미리 배열로 새롭게 만든 다음에 모든 길이를 합치고, 최소 개수로 나누면 이때부터 루프를 시작해도 되겠다고 생각했다. 이보다 더 큰 값은 나올 수 없기 때문이다.\n그렇게 한 뒤에는 루프문으로 최대부터 하나씩 내려가면서 조건에 맞는 경우 바로 루프문을 빠져 나오려 했다.하지만 이렇게 된 알고리즘의 문제는\n베스트케이스를 찾지 못할 경우 끝까지 감\n길이가 0인 김밥을 배열에 그대로 냅둬서 시간이 더 오래 걸리게 됨\n과 같은 문제가 있었다.\n결국 알고리즘 분류를 보게 되었고, 이러한 문제를 해결하기 위해서는 이분 탐색을 통해 풀어야 한다는 것을 알았다.const INPUT_FILE = process.platform === \"linux\" ? \"/dev/stdin\" : \"./inputs.txt\";\nconst inputs = require(\"fs\") .readFileSync(INPUT_FILE) .toString() .trim() .split(\"\\n\");\nconst [n, k, m] = inputs[0].split(\" \").map(Number);\nconst kimbabs = [];\nfor (let i = 1; i &lt; n + 1; i++) { const kb = +inputs[i]; if (kb &gt; 2 * k) { kimbabs.push(kb - 2 * k); } else if (2 * k &gt; kb &amp;&amp; kb &gt; k) { kimbabs.push(kb - k); }\n} if (kimbabs.length === 0) { console.log(-1); process.exit(0);\n} let result = -1;\nlet left = 1;\nlet right = Math.max(...kimbabs);\nwhile (left &lt;= right) { let mid = Math.floor((left + right) / 2); let count = kimbabs.reduce((acc, L) =&gt; acc + Math.floor(L / mid), 0); if (count &gt;= m) { result = mid; left = mid + 1; } else { right = mid - 1; }\n}\nconsole.log(result); 따라서 기존 김밥들을 map으로 길이를 바꾸는 것이 아니라 새 배열에 하나씩 Push해주는 방식으로 바꾸었고, 이분탐색을 통해 김밥들 중 가장 긴 값에서부터 시작해서 조건에 맞는 김밥이 나오는지 검사하여 탐색했다.<br><img src=\"https://i.imgur.com/SPo5Qzg.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">번외로 이 문제를 풀 때, 잠깐 백준의 채점 서버가 잘못되는 일이 있어 어떤 언어로 해도 틀렸거나 컴파일 오류가 나왔다는 등 바로 막혔었다.<br><img src=\"https://i.imgur.com/2QSJX9O.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">백퍼 로직에 문제는 없다고 생각하면서 몇시간동안 계속 고쳤는데 너무 이상해서 백준 메인페이지에 가보니 다들 비슷한 문제를 겪고 있었다.....결론: 계속 틀리면 내가 아니라 세상을 탓하자(?)<br><img src=\"https://i.imgur.com/KHhuEGw.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":["#백준","#이분탐색"],"headers":[{"heading":"문제","level":3,"id":"문제_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/알고리즘/백준-18113-그르다-김가놈.html","pathToRoot":"..","attachments":[],"createdTime":1738986258712,"modifiedTime":1739028749047,"sourceSize":4688,"sourcePath":"알고리즘/백준 18113 그르다 김가놈.md","exportPath":"알고리즘/백준-18113-그르다-김가놈.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"프로젝트/fora/fora_리팩토링_navigation-추상화하기.html":{"title":"forA_리팩토링_Navigation 추상화하기","icon":"","description":"포에이를 맡게 되면서 처음으로 시뮬레이터를 켰을 때는 회원가입조차 제대로 되어있지 않은 상태였기 때문에 제대로 뭔가를 볼 수가 없었다.\n그렇기 때문에 정작 뭐가 문제인지를 실제로 구동해보면서 알 수 없었는데도 불구하고 코드만 보고 여기는 안봐도 사용자경험이 매우 나쁘다고 생각했던 부분이 있었는데, 바로 네비게이션 부분이었다.\n이전 개발자분이 왜그러셨는지는 모르겠지만 모든 스크린들을 전부 하나의 stack navigator에 담은 코드를 보았다.\n<img src=\"https://i.imgur.com/e6XE73C.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n현재는 로그인쪽 스택 네비게이터와 홈 부분 스택 네비게이터를 따로 나눴음에도 불구하고 아직까지도 네비게이션의 구조를 제대로 알 수 없었다.그 뿐만 아니라 더 심각하다고 느꼈던 부분은 하단 탭 또한 스택 네비게이터로 관리하고 있었기 때문에 우리가 흔히 아는 하단 탭의 작동방식이 아닌, 스택의 작동방식으로 작동하였다. 사용자는 정상적이라고 생각했다면 하단 탭이 마치 안쪽 화면만 바뀌는 느낌이라고 생각했을 텐데 갑자기 화면 내의 컨텐츠를 눌렀을 때처럼 화면이 좌우로 움직여버리니 당황스러웠을 것이다. 게다가 안쪽 영역만 바뀌는 것이 아닌, 하단 탭까지 움직이는 듯한 사용자 경험은 보다 익숙치 않을 것이라 생각한다.문제는 이 뿐만이 아니다. React Navigation의 Navigation lifecycle에 나온 설명을 보면 이보다 훨씬 큰 스노우볼이 굴러가고 있다는 것을 알 수 있다.\nConsider a stack navigator with 2 screens:&nbsp;Home&nbsp;and&nbsp;Profile. When we first render the navigator, the&nbsp;Home&nbsp;screen is mounted, i.e. its&nbsp;useEffect&nbsp;or&nbsp;componentDidMount&nbsp;is called. When we navigate to&nbsp;Profile, now&nbsp;Profile&nbsp;is mounted and its&nbsp;useEffect&nbsp;or&nbsp;componentDidMount&nbsp;is called. But nothing happens to&nbsp;Home&nbsp;- it remains mounted in the stack. The cleanup function returned by&nbsp;useEffect&nbsp;or&nbsp;componentWillUnmount&nbsp;is not called.\n요약하자면 두 개의 스크린을 네비게이터에 등록해놓고 navigate를 시킨다면, stack navigator에는 그대로 스택이 쌓인다는 이야기다. 따라서 이러한 컴포넌트들이 언마운트 되는 것이 아니라 계속 위로 차곡차곡 쌓이고 있다는 소리이다.\n이게 문제가 뭐냐면, 한 유저가 오랫동안 앱에 머물게 된다면 그만큼 화면 이동을 많이 하게 될텐데, 이 과정에서 계속 화면이 쌓이고, 결국 디바이스 내의 메모리를 계속해서 잡아먹고 있다는 소리기도 하다.<br>\n<img alt=\"화면 기록 2025-02-07 오후 11.20.09.gif\" src=\"https://alsgud8311.github.io/프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif\" target=\"_self\">\n위 사진을 보면 기존의 탭들을 '이동' 한다는 개념이 아니라 스택처럼 '더 들어간다'는 개념으로 화면을 작동시키고 있는 것을 알 수 있다. 이러한 부분은 기존 데이터를 그대로 가지고 있는 스크린이기 때문에 쓸모 없는 화면이 메모리를 잡아먹고 있으며, 하단 탭의 이동 방식 또한 사용자가 예상하는 방식이 아니기 때문에 당황스러울 수 있다고 생각했다.그렇기 때문에 리팩토링의 우선순위에서 네비게이션 구조를 먼저 분리해봐야겠다는 생각이 들었고, 이참에 스택과 하단 탭을 세부적으로 나눠 추상화를 시켜 보다 가독성을 좋게 만들어 봐야 겠다는 생각이 들었다.예전에 프로젝트를 할 때는 항상 Navigation을 깊숙하게 Nesting하는 방식으로 처리를 했었지만, 당시에는 제대로 Docs를 보지 않고 했었는데, 이제서야 docs의 중요성을 깨닫고 조금씩 읽어보면서 알게 되었다.React Navigation에서는 navigation의 nesting을 가능하면 최대한 얕게 잡을 것을 추천한다. 그 이유는 navigation을 nesting하는 것은 잠재적 위험 요소들이 몇 가지 있기 때문이다.\n계층 구조가 깊어질수록 메모리 소모가 커지고, 보급형 폰같은 경우는 성능 저하 이슈로 이어질 수도 있음\n여러 타입의 navigation을 계속 겹치다 보면 사용자 경험에 좋지 않음\ndeep link와 같은 기능을 사용할 때, 코드의 작성이 어려워짐. 즉 유지보수 및 확장성이 떨어짐\n따라서 Nesting되는 구조의 깊이를 최대한 깊게 가져가는 것을 지양하면서 적당히 스택과 탭의 navigation을 나눠야 한다.&lt;Stack.Navigator&gt; {isLoggedIn ? ( // Screens for logged in users &lt;Stack.Group&gt; &lt;Stack.Screen name=\"Home\" component={Home} /&gt; &lt;Stack.Screen name=\"Profile\" component={Profile} /&gt; &lt;/Stack.Group&gt; ) : ( // Auth screens &lt;Stack.Group screenOptions={{ headerShown: false }}&gt; &lt;Stack.Screen name=\"SignIn\" component={SignIn} /&gt; &lt;Stack.Screen name=\"SignUp\" component={SignUp} /&gt; &lt;/Stack.Group&gt; )} {/* Common modal screens */} &lt;Stack.Group screenOptions={{ presentation: 'modal' }}&gt; &lt;Stack.Screen name=\"Help\" component={Help} /&gt; &lt;Stack.Screen name=\"Invite\" component={Invite} /&gt; &lt;/Stack.Group&gt;\n&lt;/Stack.Navigator&gt;\n이를 위해서는 Group과 같은 Stack의 컴포넌트를 이용할 수 있다.그렇게 네비게이션 구조에 대해 보다 이해하고 다시금 코드를 보면서 가장 먼저 나눴던 것은 로그인한 유저와 로그인하지 않은 유저의 스택을 나누는 일이었다.\n왜냐면 로그인의 경우 한번 로그인 하면 굳이 로그인 스택을 그대로 가지고 있는 것이 불필요하다고 생각했기 때문이다.const MainNavigation = () =&gt; { const Stack = createStackNavigator() const isLoggedIn = useAuthStore((state) =&gt; state.accessToken) const firstLaunch = useLaunch() const initialHomeScreen = firstLaunch ? 'OnBoard' : 'Home' const screenOptions: StackNavigationOptions = { headerShown: false, } return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator initialRouteName=\"launch\" screenOptions={screenOptions} &gt; {isLoggedIn ? ( &lt;Stack.Screen name=\"HomeStack\" component={() =&gt; ( &lt;HomeStack initialRoute={initialHomeScreen} /&gt; )} /&gt; ) : ( &lt;Stack.Screen name=\"LoginStack\" component={LoginStack} /&gt; )} &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; )\n}\nexport default MainNavigation 가장 먼저 앱의 엔트리 포인트에서 Navigation을 로그인 상태와 비로그인 상태에 따라 다른 로그인 스택을 관리할 수 있도록 하였다.\n여기서 위에처럼 Group 컴포넌트를 사용하면 해당 파일 안에서도 보다 잘 할 수 있지 않을까? 생각했지만 Home에서 관리하는 스택의 구조가 탭 하나당 화면 한 단위를 가진다고 생각하면 생각보다 Home이 가지는 구조가 많을 것 같아 따로 로그인과 일반 홈 상태의 스크린을 추상화하여 파일로 분리하였다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Navigation의 Nesting은 어떻게 처리해야 할까?","level":3,"id":"Navigation의_Nesting은_어떻게_처리해야_할까?_0"},{"heading":"로그인 한 유저와 로그인하지 않은 유저의 스택 구조 나누기","level":3,"id":"로그인_한_유저와_로그인하지_않은_유저의_스택_구조_나누기_0"}],"links":[],"author":"Cho Minhyung","coverImageURL":"","fullURL":"https://alsgud8311.github.io/프로젝트/fora/fora_리팩토링_navigation-추상화하기.html","pathToRoot":"../..","attachments":["프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html"],"createdTime":1738931048140,"modifiedTime":1738943295296,"sourceSize":7638,"sourcePath":"프로젝트/forA/forA_리팩토링_Navigation 추상화하기.md","exportPath":"프로젝트/fora/fora_리팩토링_navigation-추상화하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"}},"fileInfo":{"알고리즘/[백준-1004]-어린왕자.html":{"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":3319,"sourcePath":"알고리즘/[백준 1004] 어린왕자.md","exportPath":"알고리즘/[백준-1004]-어린왕자.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준-1912]-연속합.html":{"createdTime":1736209726467,"modifiedTime":1736213614508,"sourceSize":1845,"sourcePath":"알고리즘/[백준 1912] 연속합.md","exportPath":"알고리즘/[백준-1912]-연속합.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준-7576]-토마토.html":{"createdTime":1727047559689,"modifiedTime":1727048357871,"sourceSize":871,"sourcePath":"알고리즘/[백준 7576] 토마토.md","exportPath":"알고리즘/[백준-7576]-토마토.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준-9251]-lcs.html":{"createdTime":1734510487708,"modifiedTime":1734512061049,"sourceSize":2216,"sourcePath":"알고리즘/[백준 9251] LCS.md","exportPath":"알고리즘/[백준-9251]-lcs.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준-12865]-평범한-배낭.html":{"createdTime":1726984293710,"modifiedTime":1727006936776,"sourceSize":3466,"sourcePath":"알고리즘/[백준 12865] 평범한 배낭.md","exportPath":"알고리즘/[백준-12865]-평범한-배낭.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준-17123]-배열-놀이.html":{"createdTime":1738291207126,"modifiedTime":1738293283718,"sourceSize":1474,"sourcePath":"알고리즘/[백준 17123] 배열 놀이.md","exportPath":"알고리즘/[백준-17123]-배열-놀이.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준11631]-ascii-addition.html":{"createdTime":1738044174859,"modifiedTime":1738047399812,"sourceSize":2346,"sourcePath":"알고리즘/[백준11631] ASCII Addition.md","exportPath":"알고리즘/[백준11631]-ascii-addition.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준14596]-quilting(smaill).html":{"createdTime":1738160420595,"modifiedTime":1738160689116,"sourceSize":1062,"sourcePath":"알고리즘/[백준14596] Quilting(smaill).md","exportPath":"알고리즘/[백준14596]-quilting(smaill).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준31784]-포닉스의-문단속.html":{"createdTime":1738377260567,"modifiedTime":1738377938599,"sourceSize":1422,"sourcePath":"알고리즘/[백준31784] 포닉스의 문단속.md","exportPath":"알고리즘/[백준31784]-포닉스의-문단속.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html":{"createdTime":1726655676046,"modifiedTime":1726660140350,"sourceSize":2014,"sourcePath":"알고리즘/[프로그래머스] 두 원 사이의 정수 쌍.md","exportPath":"알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[프로그래머스]-방금그곡.html":{"createdTime":1726564996692,"modifiedTime":1726566729916,"sourceSize":886,"sourcePath":"알고리즘/[프로그래머스] 방금그곡.md","exportPath":"알고리즘/[프로그래머스]-방금그곡.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[프로그래머스]-석유-시추.html":{"createdTime":1729849354618,"modifiedTime":1729855082389,"sourceSize":4403,"sourcePath":"알고리즘/[프로그래머스] 석유 시추.md","exportPath":"알고리즘/[프로그래머스]-석유-시추.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[프로그래머스]-요격-시스템.html":{"createdTime":1729934294728,"modifiedTime":1729937918072,"sourceSize":2876,"sourcePath":"알고리즘/[프로그래머스] 요격 시스템.md","exportPath":"알고리즘/[프로그래머스]-요격-시스템.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[프로그래머스]-주차-요금-계산.html":{"createdTime":1726816871041,"modifiedTime":1726817496974,"sourceSize":504,"sourcePath":"알고리즘/[프로그래머스] 주차 요금 계산.md","exportPath":"알고리즘/[프로그래머스]-주차-요금-계산.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[프로그래머스]-행렬-테두리-회전하기.html":{"createdTime":1726713381890,"modifiedTime":1726714453401,"sourceSize":779,"sourcePath":"알고리즘/[프로그래머스] 행렬 테두리 회전하기.md","exportPath":"알고리즘/[프로그래머스]-행렬-테두리-회전하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/알고리즘.html":{"createdTime":1725254058383,"modifiedTime":1739028697967,"sourceSize":881,"sourcePath":"알고리즘/알고리즘.md","exportPath":"알고리즘/알고리즘.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"index.html":{"createdTime":1738506132180,"modifiedTime":1738943532312,"sourceSize":2071,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"site-lib/scripts/graph-wasm.wasm":{"createdTime":1738507608818,"modifiedTime":1738507531424.882,"sourceSize":23655,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.wasm","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1739037861412,"modifiedTime":1739037861412,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1739037861412,"modifiedTime":1739037861412,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1739037861413,"modifiedTime":1739037861413,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1739037861413,"modifiedTime":1739037861413,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1739037861414,"modifiedTime":1739037861414,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1739037861413,"modifiedTime":1739037861413,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1739037861415,"modifiedTime":1739037861415,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1739037861414,"modifiedTime":1739037861414,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1739037861423,"modifiedTime":1739037861423,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1739037861423,"modifiedTime":1739037861423,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1739037861423,"modifiedTime":1739037861423,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1739037861423,"modifiedTime":1739037861423,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1739037861392,"modifiedTime":1739037861392,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1739037861392,"modifiedTime":1739037861392,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/fonts/mathjax_zero.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":1368,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_zero.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-regular.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":34160,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-bold.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":34464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-italic.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":19360,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-italic.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":20832,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-bolditalic.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":19776,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-bolditalic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size1-regular.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":5792,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size1-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size2-regular.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":5464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size2-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size3-regular.woff":{"createdTime":1739037861388,"modifiedTime":1739037861388,"sourceSize":3244,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size3-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size4-regular.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":5148,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size4-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_ams-regular.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":40808,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_ams-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-regular.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":9600,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-bold.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":9908,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-regular.woff":{"createdTime":1739037861390,"modifiedTime":1739037861390,"sourceSize":21480,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-bold.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":22340,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-regular.woff":{"createdTime":1739037861389,"modifiedTime":1739037861389,"sourceSize":12660,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-bold.woff":{"createdTime":1739037861390,"modifiedTime":1739037861390,"sourceSize":15944,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-italic.woff":{"createdTime":1739037861390,"modifiedTime":1739037861390,"sourceSize":14628,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_script-regular.woff":{"createdTime":1739037861390,"modifiedTime":1739037861390,"sourceSize":11852,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_script-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_typewriter-regular.woff":{"createdTime":1739037861390,"modifiedTime":1739037861390,"sourceSize":17604,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_typewriter-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-regular.woff":{"createdTime":1739037861390,"modifiedTime":1739037861390,"sourceSize":1136,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-bold.woff":{"createdTime":1739037861390,"modifiedTime":1739037861390,"sourceSize":1116,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1739037862905,"modifiedTime":1739037862905,"sourceSize":62588,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1738507609266,"modifiedTime":1738507609266,"sourceSize":101494,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-wasm.js":{"createdTime":1738507609266,"modifiedTime":1738507609266,"sourceSize":12885,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-render-worker.js":{"createdTime":1738507609266,"modifiedTime":1738507609266,"sourceSize":5681,"sourcePath":"","exportPath":"site-lib/scripts/graph-render-worker.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/styles/snippets.css":{"createdTime":1739037861411,"modifiedTime":1739037861411,"sourceSize":24897,"sourcePath":"","exportPath":"site-lib/styles/snippets.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/obsidian.css":{"createdTime":1739037861458,"modifiedTime":1739037861458,"sourceSize":162189,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1739037861356,"modifiedTime":1739037861356,"sourceSize":305,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/supported-plugins.css":{"createdTime":1739037861356,"modifiedTime":1739037861356,"sourceSize":120,"sourcePath":"","exportPath":"site-lib/styles/supported-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1738507609291,"modifiedTime":1738507609291,"sourceSize":19129,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/rss.xml":{"createdTime":1739037864262,"modifiedTime":1739037864262,"sourceSize":159352,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"부스트캠프/멤버십/8주차/화면-기록-2024-11-10-오후-11.20.13.mov":{"createdTime":1731248453395,"modifiedTime":1731248453396,"sourceSize":4997605,"sourcePath":"부스트캠프/멤버십/8주차/화면 기록 2024-11-10 오후 11.20.13.mov","exportPath":"부스트캠프/멤버십/8주차/화면-기록-2024-11-10-오후-11.20.13.mov","showInTree":true,"treeOrder":0,"backlinks":[],"type":"other","data":null},"알고리즘/자바스크립트-알고리즘-강의/스택(stack)과-큐(queue).html":{"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":5644,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/스택(Stack)과 큐(Queue).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/스택(stack)과-큐(queue).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/자바스크립트-알고리즘-강의/이진-탐색-트리(binary-search-tree).html":{"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":5220,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/이진 탐색 트리(Binary Search Tree).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/이진-탐색-트리(binary-search-tree).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/자바스크립트-알고리즘-강의/정렬-기수정렬(radix-sort).html":{"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":5027,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/정렬 - 기수정렬(Radix Sort).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/정렬-기수정렬(radix-sort).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/자바스크립트-알고리즘-강의/정렬-버블,-삽입,-선택정렬.html":{"createdTime":1725254058383,"modifiedTime":1725254058384,"sourceSize":7975,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/정렬 - 버블, 삽입, 선택정렬.md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/정렬-버블,-삽입,-선택정렬.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/자바스크립트-알고리즘-강의/정렬-퀵정렬(quick-sort).html":{"createdTime":1725254058384,"modifiedTime":1725254058384,"sourceSize":6653,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/정렬 - 퀵정렬(Quick Sort).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/정렬-퀵정렬(quick-sort).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/자바스크립트-알고리즘-강의/정렬-합병정렬(merge-sort).html":{"createdTime":1725254058384,"modifiedTime":1725254058384,"sourceSize":5217,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/정렬 - 합병정렬(Merge Sort).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/정렬-합병정렬(merge-sort).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/자바스크립트-알고리즘-강의/트리-순회(tree-traversal).html":{"createdTime":1725254058384,"modifiedTime":1725254058384,"sourceSize":7387,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/트리 순회(Tree Traversal).md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/트리-순회(tree-traversal).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/자바스크립트-알고리즘-강의/udemy_자바스크립트-알고리즘.html":{"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":444,"sourcePath":"알고리즘/자바스크립트 알고리즘 강의/udemy_자바스크립트 알고리즘.md","exportPath":"알고리즘/자바스크립트-알고리즘-강의/udemy_자바스크립트-알고리즘.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/boomap/boomap.html":{"createdTime":1738514304296,"modifiedTime":1738514343654,"sourceSize":217,"sourcePath":"프로젝트/Boomap/Boomap.md","exportPath":"프로젝트/boomap/boomap.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html":{"createdTime":1731426244112,"modifiedTime":1731460224141,"sourceSize":4523,"sourcePath":"프로젝트/Boomap/react-konva를 이용하여 노드 추가기능 구현하기.md","exportPath":"프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html":{"createdTime":1731133332983,"modifiedTime":1731137120877,"sourceSize":11518,"sourcePath":"프로젝트/Boomap/react-konva를 이용하여 원 사이 라인 그리기.md","exportPath":"프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html":{"createdTime":1731238556042,"modifiedTime":1731248483936,"sourceSize":11332,"sourcePath":"프로젝트/Boomap/react-konva를 이용하여 원 사이 충돌 방지 시키기.md","exportPath":"프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/fora/fora.html":{"createdTime":1737689866280,"modifiedTime":1738942701396,"sourceSize":247,"sourcePath":"프로젝트/forA/forA.md","exportPath":"프로젝트/fora/fora.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/fora/fora_트러블슈팅.html":{"createdTime":1737689882069,"modifiedTime":1738942717136,"sourceSize":1121,"sourcePath":"프로젝트/forA/forA_트러블슈팅.md","exportPath":"프로젝트/fora/fora_트러블슈팅.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/neo/반응형을-자바스크립트로-해보기.html":{"createdTime":1738321920477,"modifiedTime":1738322702790,"sourceSize":2757,"sourcePath":"프로젝트/Neo/반응형을 자바스크립트로 해보기.md","exportPath":"프로젝트/neo/반응형을-자바스크립트로-해보기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/neo/axios를-떠나보내기.html":{"createdTime":1738053627742,"modifiedTime":1738054189820,"sourceSize":2124,"sourcePath":"프로젝트/Neo/axios를 떠나보내기.md","exportPath":"프로젝트/neo/axios를-떠나보내기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/neo/neo.html":{"createdTime":1738053593062,"modifiedTime":1738596273053,"sourceSize":405,"sourcePath":"프로젝트/Neo/Neo.md","exportPath":"프로젝트/neo/neo.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/backend/트랜잭션과-비즈니스-로직.html":{"createdTime":1725254058408,"modifiedTime":1725254058408,"sourceSize":4400,"sourcePath":"학습 정리/Backend/트랜잭션과 비즈니스 로직.md","exportPath":"학습-정리/backend/트랜잭션과-비즈니스-로직.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/backend/backend.html":{"createdTime":1738514692840,"modifiedTime":1738514706253,"sourceSize":252,"sourcePath":"학습 정리/Backend/Backend.md","exportPath":"학습-정리/backend/backend.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html":{"createdTime":1725254058386,"modifiedTime":1725254058386,"sourceSize":9084,"sourcePath":"학습 정리/Backend/express+pug로 templating해서 SSR + CSR 구현하기.md","exportPath":"학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/backend/mysql-join.html":{"createdTime":1725787203633,"modifiedTime":1725797402548,"sourceSize":8273,"sourcePath":"학습 정리/Backend/mysql Join.md","exportPath":"학습-정리/backend/mysql-join.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/backend/node.js-libuv에-대한-고찰.html":{"createdTime":1727007369417,"modifiedTime":1727014265529,"sourceSize":7709,"sourcePath":"학습 정리/Backend/Node.js Libuv에 대한 고찰.md","exportPath":"학습-정리/backend/node.js-libuv에-대한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/backend/passport의-로컬-인증전략.html":{"createdTime":1725373005731,"modifiedTime":1725541410582,"sourceSize":9931,"sourcePath":"학습 정리/Backend/Passport의 로컬 인증전략.md","exportPath":"학습-정리/backend/passport의-로컬-인증전략.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/backend/rest-api.html":{"createdTime":1726067961664,"modifiedTime":1726072273414,"sourceSize":4877,"sourcePath":"학습 정리/Backend/REST API.md","exportPath":"학습-정리/backend/rest-api.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/backend/sql-기본문법.html":{"createdTime":1725254058395,"modifiedTime":1739035385494,"sourceSize":9054,"sourcePath":"학습 정리/Backend/sql 기본문법.md","exportPath":"학습-정리/backend/sql-기본문법.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/backend/sql-트리거.html":{"createdTime":1725340456332,"modifiedTime":1725357605970,"sourceSize":3684,"sourcePath":"학습 정리/Backend/sql 트리거.md","exportPath":"학습-정리/backend/sql-트리거.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/연결-리스트-이중-연결-리스트(doubly-linked-list).html":{"createdTime":1725254058366,"modifiedTime":1725254058366,"sourceSize":6886,"sourcePath":"학습 정리/Computer Science/운영체제/연결 리스트 - 이중 연결 리스트(Doubly Linked List).md","exportPath":"학습-정리/computer-science/운영체제/연결-리스트-이중-연결-리스트(doubly-linked-list).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/연결-리스트-단일-연결-리스트(singly-linked-lists).html":{"createdTime":1725254058366,"modifiedTime":1725254058366,"sourceSize":9519,"sourcePath":"학습 정리/Computer Science/운영체제/연결 리스트- 단일 연결 리스트(Singly Linked Lists).md","exportPath":"학습-정리/computer-science/운영체제/연결-리스트-단일-연결-리스트(singly-linked-lists).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제.html":{"createdTime":1725254058366,"modifiedTime":1738514203775,"sourceSize":3017,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제.md","exportPath":"학습-정리/computer-science/운영체제/운영체제.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html":{"createdTime":1725254058366,"modifiedTime":1725254058366,"sourceSize":14863,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_1주차_기본 구성요소, 명령어 수행, 인터럽트.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html":{"createdTime":1725254058366,"modifiedTime":1725254058366,"sourceSize":16586,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_가상 메모리_하드웨어와 제어구조.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html":{"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":7619,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_가상메모리_운영체제 소프트웨어.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html":{"createdTime":1725254058366,"modifiedTime":1725254058367,"sourceSize":2193,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_가상메모리_Linux, Windows의 가상 메모리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html":{"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":19838,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_단일처리기 스케줄링_스케줄링 알고리즘.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html":{"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":1697,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_단일처리기 스케줄링_처리기 스케줄링의 유형.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html":{"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":12583,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 계층 구조, 캐시 메모리, IO연산 기법, 멀티프로세서와 멀티코어.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html":{"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":4660,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 관리_메모리 관리 요구조건.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html":{"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":7847,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 관리_메모리 분할(memory partitioning).md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html":{"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":4731,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 관리_세그먼테이션.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html":{"createdTime":1725254058367,"modifiedTime":1725254058367,"sourceSize":2685,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_메모리 관리_페이징.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html":{"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":3053,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_교착상태 발견.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html":{"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":6488,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_교착상태 예방,회피,발견.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html":{"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":7340,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_교착상태의 원리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html":{"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":1894,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_식사하는 철학자 문제.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html":{"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":2362,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_모니터.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html":{"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":11583,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_병행성의 원리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html":{"createdTime":1725254058368,"modifiedTime":1725254058368,"sourceSize":5132,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_상호 배제-하드웨어 지원.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html":{"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":13002,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_병행성_세마포어.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html":{"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":1848,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_스레드_멀티코어와 멀티스레딩.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html":{"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":5878,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_스레드_스레드의 유형.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html":{"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":8417,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_스레드_프로세스와 스레드.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html":{"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":4524,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_운영체제 개요_결함 허용.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html":{"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":5318,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_운영체제 개요_멀티프로세서와 멀티코어를 위한 운영체제 설계 사항.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html":{"createdTime":1725254058369,"modifiedTime":1725254058369,"sourceSize":4928,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_운영체제 개요_최근 운영체제로의 발전.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html":{"createdTime":1725254058369,"modifiedTime":1725254058370,"sourceSize":21503,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_운영체제의 목적 및 기능.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html":{"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":3752,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_디스크 스케줄링.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html":{"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":2683,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_디스크 캐시.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html":{"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":2650,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_운영체제 설계 이슈.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html":{"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":2556,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_입출력 버퍼링.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html":{"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":5898,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_입출력 장치, 입출력 기능 구성.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html":{"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":5875,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_RAID.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html":{"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":2906,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_UNIX SVR4의 입출력.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html":{"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":2897,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_개요.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html":{"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":2873,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_파일 구성과 접근.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html":{"createdTime":1725254058370,"modifiedTime":1725254058370,"sourceSize":4608,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_B-트리, 파일 디렉토리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html":{"createdTime":1725254058370,"modifiedTime":1725254058371,"sourceSize":5997,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_Linux의 가상파일시스템과 windows 파일 시스템.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html":{"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":3137,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일 관리_UNIX의 파일 관리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html":{"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":4342,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일관리_보조 저장공간 관리.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html":{"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":2354,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_파일관리_파일 공유와 레코드 블로킹.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html":{"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":3957,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_프로세스 기술과 제어_운영체제의 수행.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html":{"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":7340,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_프로세스 기술과 제어_프로세스 기술.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html":{"createdTime":1725254058371,"modifiedTime":1725254058371,"sourceSize":10048,"sourcePath":"학습 정리/Computer Science/운영체제/운영체제_프로세스 기술과 제어_프로세스 제어.md","exportPath":"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/브라우저의-렌더링과-캔버스.html":{"createdTime":1730392795313,"modifiedTime":1730645140716,"sourceSize":16589,"sourcePath":"학습 정리/Computer Science/브라우저의 렌더링과 캔버스.md","exportPath":"학습-정리/computer-science/브라우저의-렌더링과-캔버스.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/웹페이지,-웹사이트,-웹서버,-검색엔진의-차이.html":{"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":5712,"sourcePath":"학습 정리/Computer Science/웹페이지, 웹사이트, 웹서버, 검색엔진의 차이.md","exportPath":"학습-정리/computer-science/웹페이지,-웹사이트,-웹서버,-검색엔진의-차이.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/이벤트-루프와-비동기.html":{"createdTime":1725254058403,"modifiedTime":1727007283430,"sourceSize":7326,"sourcePath":"학습 정리/Computer Science/이벤트 루프와 비동기.md","exportPath":"학습-정리/computer-science/이벤트-루프와-비동기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html":{"createdTime":1725254058387,"modifiedTime":1725254058387,"sourceSize":17349,"sourcePath":"학습 정리/Computer Science/이벤트 전파와 위임에 대한 고찰.md","exportPath":"학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/쿠키와-세션.html":{"createdTime":1725354949286,"modifiedTime":1725357331051,"sourceSize":8795,"sourcePath":"학습 정리/Computer Science/쿠키와 세션.md","exportPath":"학습-정리/computer-science/쿠키와-세션.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/broadcast,-unicast,-multicast.html":{"createdTime":1725254058392,"modifiedTime":1725254058392,"sourceSize":2973,"sourcePath":"학습 정리/Computer Science/Broadcast, Unicast, Multicast.md","exportPath":"학습-정리/computer-science/broadcast,-unicast,-multicast.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/computer-science.html":{"createdTime":1738514660870,"modifiedTime":1738514682113,"sourceSize":352,"sourcePath":"학습 정리/Computer Science/Computer Science.md","exportPath":"학습-정리/computer-science/computer-science.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/frontend-roadmap.html":{"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":144,"sourcePath":"학습 정리/Computer Science/Frontend RoadMap.md","exportPath":"학습-정리/computer-science/frontend-roadmap.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/http-메시지.html":{"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":6015,"sourcePath":"학습 정리/Computer Science/HTTP 메시지.md","exportPath":"학습-정리/computer-science/http-메시지.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/http-세션.html":{"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":3838,"sourcePath":"학습 정리/Computer Science/HTTP 세션.md","exportPath":"학습-정리/computer-science/http-세션.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/http3.html":{"createdTime":1725254058385,"modifiedTime":1725254058385,"sourceSize":12828,"sourcePath":"학습 정리/Computer Science/HTTP3.md","exportPath":"학습-정리/computer-science/http3.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/osi-7-layer.html":{"createdTime":1725254058393,"modifiedTime":1725254058393,"sourceSize":6352,"sourcePath":"학습 정리/Computer Science/OSI 7 Layer.md","exportPath":"학습-정리/computer-science/osi-7-layer.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/tcp-ip.html":{"createdTime":1725254058395,"modifiedTime":1725254058395,"sourceSize":6687,"sourcePath":"학습 정리/Computer Science/TCP-IP.md","exportPath":"학습-정리/computer-science/tcp-ip.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/computer-science/telnet과-ssh.html":{"createdTime":1725254058395,"modifiedTime":1725254058395,"sourceSize":4801,"sourcePath":"학습 정리/Computer Science/TELNET과 SSH.md","exportPath":"학습-정리/computer-science/telnet과-ssh.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/design-pattern/design-pattern.html":{"createdTime":1738514624127,"modifiedTime":1738514638466,"sourceSize":76,"sourcePath":"학습 정리/Design Pattern/Design Pattern.md","exportPath":"학습-정리/design-pattern/design-pattern.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/design-pattern/fsd-패턴.html":{"createdTime":1725254058372,"modifiedTime":1728313582594,"sourceSize":5604,"sourcePath":"학습 정리/Design Pattern/fsd 패턴.md","exportPath":"학습-정리/design-pattern/fsd-패턴.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/design-pattern/mvc패턴.html":{"createdTime":1725254058372,"modifiedTime":1725254058372,"sourceSize":4265,"sourcePath":"학습 정리/Design Pattern/MVC패턴.md","exportPath":"학습-정리/design-pattern/mvc패턴.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/design-pattern/observer-패턴.html":{"createdTime":1725254058393,"modifiedTime":1725254058393,"sourceSize":3100,"sourcePath":"학습 정리/Design Pattern/Observer 패턴.md","exportPath":"학습-정리/design-pattern/observer-패턴.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/design-pattern/pub-sub-패턴.html":{"createdTime":1725254058394,"modifiedTime":1725254058394,"sourceSize":2898,"sourcePath":"학습 정리/Design Pattern/Pub-Sub 패턴.md","exportPath":"학습-정리/design-pattern/pub-sub-패턴.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html":{"createdTime":1728798242113,"modifiedTime":1728802871414,"sourceSize":8382,"sourcePath":"학습 정리/Frontend/Javascript/배럴 파일에 대한 고찰.md","exportPath":"학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/javascript/클로저에-관한-고찰.html":{"createdTime":1725254058407,"modifiedTime":1725254058408,"sourceSize":14454,"sourcePath":"학습 정리/Frontend/Javascript/클로저에 관한 고찰.md","exportPath":"학습-정리/frontend/javascript/클로저에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/javascript/javascript.html":{"createdTime":1738514494523,"modifiedTime":1738514506622,"sourceSize":156,"sourcePath":"학습 정리/Frontend/Javascript/Javascript.md","exportPath":"학습-정리/frontend/javascript/javascript.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html":{"createdTime":1728967282322,"modifiedTime":1728971277227,"sourceSize":3297,"sourcePath":"학습 정리/Frontend/Javascript/setInterval과 setTimeout에 관한 고찰.md","exportPath":"학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/javascript/this-바인딩과-간접-호출.html":{"createdTime":1725254058386,"modifiedTime":1725254058386,"sourceSize":1736,"sourcePath":"학습 정리/Frontend/Javascript/this 바인딩과 간접 호출.md","exportPath":"학습-정리/frontend/javascript/this-바인딩과-간접-호출.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/others/aws-배포.html":{"createdTime":1725798801718,"modifiedTime":1725802781992,"sourceSize":5475,"sourcePath":"학습 정리/Frontend/Others/aws 배포.md","exportPath":"학습-정리/frontend/others/aws-배포.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/others/firebase-functions.html":{"createdTime":1727774753076,"modifiedTime":1727973878501,"sourceSize":23532,"sourcePath":"학습 정리/Frontend/Others/firebase functions.md","exportPath":"학습-정리/frontend/others/firebase-functions.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/others/nosql-맛보기.html":{"createdTime":1728902718199,"modifiedTime":1728908174553,"sourceSize":8087,"sourcePath":"학습 정리/Frontend/Others/NOSQL 맛보기.md","exportPath":"학습-정리/frontend/others/nosql-맛보기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/others/others(frontend).html":{"createdTime":1738514583063,"modifiedTime":1738514617807,"sourceSize":120,"sourcePath":"학습 정리/Frontend/Others/Others(Frontend).md","exportPath":"학습-정리/frontend/others/others(frontend).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/others/prettier-설정하기.html":{"createdTime":1728287324761,"modifiedTime":1728287338207,"sourceSize":1834,"sourcePath":"학습 정리/Frontend/Others/Prettier 설정하기.md","exportPath":"학습-정리/frontend/others/prettier-설정하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/others/tailwind-설정하기.html":{"createdTime":1728347067386,"modifiedTime":1728348960657,"sourceSize":6372,"sourcePath":"학습 정리/Frontend/Others/Tailwind 설정하기.md","exportPath":"학습-정리/frontend/others/tailwind-설정하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/others/xss-공격.html":{"createdTime":1725338180168,"modifiedTime":1725338726635,"sourceSize":2589,"sourcePath":"학습 정리/Frontend/Others/xss 공격.md","exportPath":"학습-정리/frontend/others/xss-공격.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/react/concurrent-mode.html":{"createdTime":1729496254879,"modifiedTime":1729858045744,"sourceSize":14955,"sourcePath":"학습 정리/Frontend/React/Concurrent mode.md","exportPath":"학습-정리/frontend/react/concurrent-mode.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/react/error-boundary와-suspense.html":{"createdTime":1728992847463,"modifiedTime":1732017011302,"sourceSize":14330,"sourcePath":"학습 정리/Frontend/React/Error boundary와 Suspense.md","exportPath":"학습-정리/frontend/react/error-boundary와-suspense.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/react/jsx에-관한-고찰.html":{"createdTime":1727075943139,"modifiedTime":1727106112754,"sourceSize":4785,"sourcePath":"학습 정리/Frontend/React/JSX에 관한 고찰.md","exportPath":"학습-정리/frontend/react/jsx에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/react/react.html":{"createdTime":1738514536234,"modifiedTime":1738514545918,"sourceSize":269,"sourcePath":"학습 정리/Frontend/React/React.md","exportPath":"학습-정리/frontend/react/react.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html":{"createdTime":1729857380566,"modifiedTime":1729964219422,"sourceSize":22415,"sourcePath":"학습 정리/Frontend/React/React 19 베타에서 새롭게 추가된 것들.md","exportPath":"학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/react/react-fiber에-관한-고찰.html":{"createdTime":1727163435701,"modifiedTime":1727612996707,"sourceSize":42831,"sourcePath":"학습 정리/Frontend/React/React Fiber에 관한 고찰.md","exportPath":"학습-정리/frontend/react/react-fiber에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/react/react-portal.html":{"createdTime":1728971372663,"modifiedTime":1729218189618,"sourceSize":2838,"sourcePath":"학습 정리/Frontend/React/React Portal.md","exportPath":"학습-정리/frontend/react/react-portal.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/react/useeffect에-관한-고찰.html":{"createdTime":1725254058382,"modifiedTime":1725254058383,"sourceSize":9386,"sourcePath":"학습 정리/Frontend/React/useEffect에 관한 고찰.md","exportPath":"학습-정리/frontend/react/useeffect에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html":{"createdTime":1725254058383,"modifiedTime":1725254058383,"sourceSize":6063,"sourcePath":"학습 정리/Frontend/React/useMemo와 useCallback에 관한 고찰.md","exportPath":"학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"학습-정리/학습-정리.html":{"createdTime":1738513343179,"modifiedTime":1739033999026,"sourceSize":980,"sourcePath":"학습 정리/학습 정리.md","exportPath":"학습-정리/학습-정리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"회고/부스트캠프-회고.html":{"createdTime":1734235581559,"modifiedTime":1734279563244,"sourceSize":9066,"sourcePath":"회고/부스트캠프 회고.md","exportPath":"회고/부스트캠프-회고.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준-6064]-카잉-달력.html":{"createdTime":1738551689134,"modifiedTime":1738569537084,"sourceSize":5662,"sourcePath":"알고리즘/[백준 6064] 카잉 달력.md","exportPath":"알고리즘/[백준-6064]-카잉-달력.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준-10597]-순열장난.html":{"createdTime":1738634444372,"modifiedTime":1738638881395,"sourceSize":4979,"sourcePath":"알고리즘/[백준 10597] 순열장난.md","exportPath":"알고리즘/[백준-10597]-순열장난.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준-31836]-피보나치-기념품.html":{"createdTime":1738721552467,"modifiedTime":1738723879145,"sourceSize":2084,"sourcePath":"알고리즘/[백준 31836] 피보나치 기념품.md","exportPath":"알고리즘/[백준-31836]-피보나치-기념품.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html":{"createdTime":1738725963950,"modifiedTime":1738732699343,"sourceSize":1366,"sourcePath":"알고리즘/[백준26091] 현대모비스 소프트웨어 아카데미.md","exportPath":"알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/neo/구현의-상세-추상화.html":{"createdTime":1738596273912,"modifiedTime":1738598764434,"sourceSize":14417,"sourcePath":"프로젝트/Neo/구현의 상세 추상화.md","exportPath":"프로젝트/neo/구현의-상세-추상화.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"site-lib/media/favicon.png":{"createdTime":1738860966629.1335,"modifiedTime":1738827874000,"sourceSize":2471,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"알고리즘/[백준-12891]-dna-비밀번호.html":{"createdTime":1738899631176,"modifiedTime":1738903131731,"sourceSize":4226,"sourcePath":"알고리즘/[백준 12891] DNA 비밀번호.md","exportPath":"알고리즘/[백준-12891]-dna-비밀번호.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif":{"createdTime":1738938249154,"modifiedTime":1738938249201,"sourceSize":12681528,"sourcePath":"프로젝트/forA/화면 기록 2025-02-07 오후 11.20.09.gif","exportPath":"프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.gif","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html":{"createdTime":1738938249154,"modifiedTime":1738938249201,"sourceSize":12681528,"sourcePath":"프로젝트/forA/화면 기록 2025-02-07 오후 11.20.09.gif","exportPath":"프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"attachment","data":null},"알고리즘/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html":{"createdTime":1738804818833,"modifiedTime":1738805494290,"sourceSize":1332,"sourcePath":"알고리즘/[백준 23307] 드디어 시작한 화석 발굴 이벤트.md","exportPath":"알고리즘/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"알고리즘/백준-18113-그르다-김가놈.html":{"createdTime":1738986258712,"modifiedTime":1739028749047,"sourceSize":4688,"sourcePath":"알고리즘/백준 18113 그르다 김가놈.md","exportPath":"알고리즘/백준-18113-그르다-김가놈.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"프로젝트/fora/fora_리팩토링_navigation-추상화하기.html":{"createdTime":1738931048140,"modifiedTime":1738943295296,"sourceSize":7638,"sourcePath":"프로젝트/forA/forA_리팩토링_Navigation 추상화하기.md","exportPath":"프로젝트/fora/fora_리팩토링_navigation-추상화하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null}},"sourceToTarget":{"알고리즘/[백준 1004] 어린왕자.md":"알고리즘/[백준-1004]-어린왕자.html","알고리즘/[백준 1912] 연속합.md":"알고리즘/[백준-1912]-연속합.html","알고리즘/[백준 7576] 토마토.md":"알고리즘/[백준-7576]-토마토.html","알고리즘/[백준 9251] LCS.md":"알고리즘/[백준-9251]-lcs.html","알고리즘/[백준 12865] 평범한 배낭.md":"알고리즘/[백준-12865]-평범한-배낭.html","알고리즘/[백준 17123] 배열 놀이.md":"알고리즘/[백준-17123]-배열-놀이.html","알고리즘/[백준11631] ASCII Addition.md":"알고리즘/[백준11631]-ascii-addition.html","알고리즘/[백준14596] Quilting(smaill).md":"알고리즘/[백준14596]-quilting(smaill).html","알고리즘/[백준31784] 포닉스의 문단속.md":"알고리즘/[백준31784]-포닉스의-문단속.html","알고리즘/[프로그래머스] 두 원 사이의 정수 쌍.md":"알고리즘/[프로그래머스]-두-원-사이의-정수-쌍.html","알고리즘/[프로그래머스] 방금그곡.md":"알고리즘/[프로그래머스]-방금그곡.html","알고리즘/[프로그래머스] 석유 시추.md":"알고리즘/[프로그래머스]-석유-시추.html","알고리즘/[프로그래머스] 요격 시스템.md":"알고리즘/[프로그래머스]-요격-시스템.html","알고리즘/[프로그래머스] 주차 요금 계산.md":"알고리즘/[프로그래머스]-주차-요금-계산.html","알고리즘/[프로그래머스] 행렬 테두리 회전하기.md":"알고리즘/[프로그래머스]-행렬-테두리-회전하기.html","알고리즘/알고리즘.md":"알고리즘/알고리즘.html","index.md":"index.html","":"site-lib/rss.xml","부스트캠프/멤버십/1주차/1주차_코드리뷰 마스터클래스.md":"부스트캠프/멤버십/1주차/1주차_코드리뷰-마스터클래스.html","부스트캠프/멤버십/1주차/그룹프로젝트 1주차_마스터 클래스.md":"부스트캠프/멤버십/1주차/그룹프로젝트-1주차_마스터-클래스.html","부스트캠프/멤버십/1주차/마스터클래스_1주차.md":"부스트캠프/멤버십/1주차/마스터클래스_1주차.html","부스트캠프/멤버십/1주차/멤버십_1주차.md":"부스트캠프/멤버십/1주차/멤버십_1주차.html","부스트캠프/멤버십/1주차/멤버십_1주차_주간계획.md":"부스트캠프/멤버십/1주차/멤버십_1주차_주간계획.html","부스트캠프/멤버십/1주차/멤버십_2주차.md":"부스트캠프/멤버십/1주차/멤버십_2주차.html","부스트캠프/멤버십/1주차/멤버십_학습정리_1주차.md":"부스트캠프/멤버십/1주차/멤버십_학습정리_1주차.html","부스트캠프/멤버십/1주차/베이직.md":"부스트캠프/멤버십/1주차/베이직.html","부스트캠프/멤버십/1주차/이벤트 전파와 위임에 대한 고찰.md":"부스트캠프/멤버십/1주차/이벤트-전파와-위임에-대한-고찰.html","부스트캠프/멤버십/1주차/피어세션.md":"부스트캠프/멤버십/1주차/피어세션.html","부스트캠프/멤버십/1주차/express+pug로 templating해서 SSR + CSR 구현하기.md":"부스트캠프/멤버십/1주차/express+pug로-templating해서-ssr-+-csr-구현하기.html","부스트캠프/멤버십/1주차/this 바인딩과 간접 호출.md":"부스트캠프/멤버십/1주차/this-바인딩과-간접-호출.html","부스트캠프/멤버십/1주차/week1_1일차 PR.md":"부스트캠프/멤버십/1주차/week1_1일차-pr.html","부스트캠프/멤버십/1주차/week1_2일차 PR.md":"부스트캠프/멤버십/1주차/week1_2일차-pr.html","부스트캠프/멤버십/1주차/week1_3일차 PR.md":"부스트캠프/멤버십/1주차/week1_3일차-pr.html","부스트캠프/멤버십/1주차/week1_4일차 PR.md":"부스트캠프/멤버십/1주차/week1_4일차-pr.html","부스트캠프/멤버십/2주차/그룹 프로젝트_2주차.md":"부스트캠프/멤버십/2주차/그룹-프로젝트_2주차.html","부스트캠프/멤버십/2주차/그룹프로젝트_2주차 회고.md":"부스트캠프/멤버십/2주차/그룹프로젝트_2주차-회고.html","부스트캠프/멤버십/2주차/그룹프로젝트_2주차_마스터클래스.md":"부스트캠프/멤버십/2주차/그룹프로젝트_2주차_마스터클래스.html","부스트캠프/멤버십/2주차/멤버십_2주차_마스터클래스.md":"부스트캠프/멤버십/2주차/멤버십_2주차_마스터클래스.html","부스트캠프/멤버십/2주차/멤버십_2주차_주간계획.md":"부스트캠프/멤버십/2주차/멤버십_2주차_주간계획.html","부스트캠프/멤버십/2주차/멤버십_2주차_학습정리.md":"부스트캠프/멤버십/2주차/멤버십_2주차_학습정리.html","부스트캠프/멤버십/2주차/클린 코드와 코드 리뷰.md":"부스트캠프/멤버십/2주차/클린-코드와-코드-리뷰.html","부스트캠프/멤버십/2주차/fsd 패턴.md":"부스트캠프/멤버십/2주차/fsd-패턴.html","부스트캠프/멤버십/2주차/MVC패턴.md":"부스트캠프/멤버십/2주차/mvc패턴.html","부스트캠프/멤버십/2주차/week2_1일차_PR.md":"부스트캠프/멤버십/2주차/week2_1일차_pr.html","부스트캠프/멤버십/2주차/week2_2일차_PR.md":"부스트캠프/멤버십/2주차/week2_2일차_pr.html","부스트캠프/멤버십/2주차/week2_3일차_PR.md":"부스트캠프/멤버십/2주차/week2_3일차_pr.html","부스트캠프/멤버십/2주차/week2_4일차_PR.md":"부스트캠프/멤버십/2주차/week2_4일차_pr.html","부스트캠프/멤버십/3주차/그룹 프로젝트_3주차.md":"부스트캠프/멤버십/3주차/그룹-프로젝트_3주차.html","부스트캠프/멤버십/3주차/그룹 프로젝트_3주차_마스터클래스.md":"부스트캠프/멤버십/3주차/그룹-프로젝트_3주차_마스터클래스.html","부스트캠프/멤버십/3주차/그룹 프로젝트_3주차_회고.md":"부스트캠프/멤버십/3주차/그룹-프로젝트_3주차_회고.html","부스트캠프/멤버십/3주차/멤버십_3주차.md":"부스트캠프/멤버십/3주차/멤버십_3주차.html","부스트캠프/멤버십/3주차/멤버십_3주차_마스터클래스.md":"부스트캠프/멤버십/3주차/멤버십_3주차_마스터클래스.html","부스트캠프/멤버십/3주차/멤버십_3주차_주간계획.md":"부스트캠프/멤버십/3주차/멤버십_3주차_주간계획.html","부스트캠프/멤버십/3주차/멤버십_3주차_체크포인트.md":"부스트캠프/멤버십/3주차/멤버십_3주차_체크포인트.html","부스트캠프/멤버십/3주차/멤버십_3주차_특강.md":"부스트캠프/멤버십/3주차/멤버십_3주차_특강.html","부스트캠프/멤버십/3주차/멤버십_3주차_학습정리.md":"부스트캠프/멤버십/3주차/멤버십_3주차_학습정리.html","부스트캠프/멤버십/3주차/쿠키와 세션.md":"부스트캠프/멤버십/3주차/쿠키와-세션.html","부스트캠프/멤버십/3주차/aws 배포.md":"부스트캠프/멤버십/3주차/aws-배포.html","부스트캠프/멤버십/3주차/mysql Join.md":"부스트캠프/멤버십/3주차/mysql-join.html","부스트캠프/멤버십/3주차/Passport의 로컬 인증전략.md":"부스트캠프/멤버십/3주차/passport의-로컬-인증전략.html","부스트캠프/멤버십/3주차/sql 트리거.md":"부스트캠프/멤버십/3주차/sql-트리거.html","부스트캠프/멤버십/3주차/week3_1일차_PR.md":"부스트캠프/멤버십/3주차/week3_1일차_pr.html","부스트캠프/멤버십/3주차/week3_2일차_PR.md":"부스트캠프/멤버십/3주차/week3_2일차_pr.html","부스트캠프/멤버십/3주차/week3_3일차_PR.md":"부스트캠프/멤버십/3주차/week3_3일차_pr.html","부스트캠프/멤버십/3주차/week3_4일차_PR.md":"부스트캠프/멤버십/3주차/week3_4일차_pr.html","부스트캠프/멤버십/3주차/week3_주말계획.md":"부스트캠프/멤버십/3주차/week3_주말계획.html","부스트캠프/멤버십/3주차/xss 공격.md":"부스트캠프/멤버십/3주차/xss-공격.html","부스트캠프/멤버십/4주차/멤버십_4주차.md":"부스트캠프/멤버십/4주차/멤버십_4주차.html","부스트캠프/멤버십/4주차/멤버십_4주차_마스터클래스.md":"부스트캠프/멤버십/4주차/멤버십_4주차_마스터클래스.html","부스트캠프/멤버십/4주차/멤버십_4주차_주간계획.md":"부스트캠프/멤버십/4주차/멤버십_4주차_주간계획.html","부스트캠프/멤버십/4주차/멤버십_4주차_학습정리.md":"부스트캠프/멤버십/4주차/멤버십_4주차_학습정리.html","부스트캠프/멤버십/4주차/week4_1일차_PR.md":"부스트캠프/멤버십/4주차/week4_1일차_pr.html","부스트캠프/멤버십/4주차/week4_2일차_PR.md":"부스트캠프/멤버십/4주차/week4_2일차_pr.html","부스트캠프/멤버십/4주차/week4_3일차_PR.md":"부스트캠프/멤버십/4주차/week4_3일차_pr.html","부스트캠프/멤버십/4주차/week4_4일차_PR.md":"부스트캠프/멤버십/4주차/week4_4일차_pr.html","부스트캠프/멤버십/5주차/5주차_주간계획.md":"부스트캠프/멤버십/5주차/5주차_주간계획.html","부스트캠프/멤버십/5주차/마스터클래스_5주차.md":"부스트캠프/멤버십/5주차/마스터클래스_5주차.html","부스트캠프/멤버십/5주차/멤버십_5주차.md":"부스트캠프/멤버십/5주차/멤버십_5주차.html","부스트캠프/멤버십/5주차/학습스프린트2_마스터클래스_5주차.md":"부스트캠프/멤버십/5주차/학습스프린트2_마스터클래스_5주차.html","부스트캠프/멤버십/5주차/JSX에 대해서.md":"부스트캠프/멤버십/5주차/jsx에-대해서.html","부스트캠프/멤버십/5주차/Node.js Libuv에 대한 고찰.md":"부스트캠프/멤버십/5주차/node.js-libuv에-대한-고찰.html","부스트캠프/멤버십/5주차/React Fiber.md":"부스트캠프/멤버십/5주차/react-fiber.html","부스트캠프/멤버십/5주차/React의 내부구조.md":"부스트캠프/멤버십/5주차/react의-내부구조.html","부스트캠프/멤버십/5주차/React의 동작 단계 구현.md":"부스트캠프/멤버십/5주차/react의-동작-단계-구현.html","부스트캠프/멤버십/5주차/week5_1일차 PR.md":"부스트캠프/멤버십/5주차/week5_1일차-pr.html","부스트캠프/멤버십/5주차/week5_2일차 PR.md":"부스트캠프/멤버십/5주차/week5_2일차-pr.html","부스트캠프/멤버십/5주차/week5_3일차 PR.md":"부스트캠프/멤버십/5주차/week5_3일차-pr.html","부스트캠프/멤버십/5주차/week5_4일차 PR.md":"부스트캠프/멤버십/5주차/week5_4일차-pr.html","부스트캠프/멤버십/6주차/멤버십_6주차.md":"부스트캠프/멤버십/6주차/멤버십_6주차.html","부스트캠프/멤버십/6주차/멤버십_6주차_마스터클래스.md":"부스트캠프/멤버십/6주차/멤버십_6주차_마스터클래스.html","부스트캠프/멤버십/6주차/멤버십_6주차_주간계획.md":"부스트캠프/멤버십/6주차/멤버십_6주차_주간계획.html","부스트캠프/멤버십/6주차/firebase functions.md":"부스트캠프/멤버십/6주차/firebase-functions.html","부스트캠프/멤버십/6주차/MongoDb 설치부터 첫 시작까지.md":"부스트캠프/멤버십/6주차/mongodb-설치부터-첫-시작까지.html","부스트캠프/멤버십/6주차/npm.md":"부스트캠프/멤버십/6주차/npm.html","부스트캠프/멤버십/6주차/week6_1일차 PR.md":"부스트캠프/멤버십/6주차/week6_1일차-pr.html","부스트캠프/멤버십/6주차/week6_2일차 회고.md":"부스트캠프/멤버십/6주차/week6_2일차-회고.html","부스트캠프/멤버십/6주차/week6_2일차 PR.md":"부스트캠프/멤버십/6주차/week6_2일차-pr.html","부스트캠프/멤버십/6주차/week6_3일차 PR.md":"부스트캠프/멤버십/6주차/week6_3일차-pr.html","부스트캠프/멤버십/6주차/week6_4일차 PR.md":"부스트캠프/멤버십/6주차/week6_4일차-pr.html","부스트캠프/멤버십/7주차/멤버십_7주차.md":"부스트캠프/멤버십/7주차/멤버십_7주차.html","부스트캠프/멤버십/7주차/멤버십_7주차_마스터클래스.md":"부스트캠프/멤버십/7주차/멤버십_7주차_마스터클래스.html","부스트캠프/멤버십/7주차/멤버십_7주차_주간계획.md":"부스트캠프/멤버십/7주차/멤버십_7주차_주간계획.html","부스트캠프/멤버십/7주차/Atomic Design.md":"부스트캠프/멤버십/7주차/atomic-design.html","부스트캠프/멤버십/7주차/Prettier 설정하기.md":"부스트캠프/멤버십/7주차/prettier-설정하기.html","부스트캠프/멤버십/7주차/Tailwind 설정하기.md":"부스트캠프/멤버십/7주차/tailwind-설정하기.html","부스트캠프/멤버십/7주차/week7_1일차_PR.md":"부스트캠프/멤버십/7주차/week7_1일차_pr.html","부스트캠프/멤버십/7주차/week7_2일차_PR.md":"부스트캠프/멤버십/7주차/week7_2일차_pr.html","부스트캠프/멤버십/7주차/week7_3일차_PR.md":"부스트캠프/멤버십/7주차/week7_3일차_pr.html","부스트캠프/멤버십/7주차/week7_4일차_PR.md":"부스트캠프/멤버십/7주차/week7_4일차_pr.html","부스트캠프/멤버십/8주차/11.20 호눅스님 마스터클래스.md":"부스트캠프/멤버십/8주차/11.20-호눅스님-마스터클래스.html","부스트캠프/멤버십/8주차/그룹 프로젝트_리드미.md":"부스트캠프/멤버십/8주차/그룹-프로젝트_리드미.html","부스트캠프/멤버십/8주차/그룹프로젝트_사이드바.md":"부스트캠프/멤버십/8주차/그룹프로젝트_사이드바.html","부스트캠프/멤버십/8주차/그룹프로젝트_협업전략.md":"부스트캠프/멤버십/8주차/그룹프로젝트_협업전략.html","부스트캠프/멤버십/8주차/기술면접.md":"부스트캠프/멤버십/8주차/기술면접.html","부스트캠프/멤버십/8주차/데이터 페칭과 서버 상태 관리.md":"부스트캠프/멤버십/8주차/데이터-페칭과-서버-상태-관리.html","부스트캠프/멤버십/8주차/루카스 백업.md":"부스트캠프/멤버십/8주차/루카스-백업.html","부스트캠프/멤버십/8주차/리눅스 마스터 정리.md":"부스트캠프/멤버십/8주차/리눅스-마스터-정리.html","부스트캠프/멤버십/8주차/리액트 만들기 프로젝트를 위한 문법과 패턴.md":"부스트캠프/멤버십/8주차/리액트-만들기-프로젝트를-위한-문법과-패턴.html","부스트캠프/멤버십/8주차/리액트 재사용 컴포넌트.md":"부스트캠프/멤버십/8주차/리액트-재사용-컴포넌트.html","부스트캠프/멤버십/8주차/리액트 최적화.md":"부스트캠프/멤버십/8주차/리액트-최적화.html","부스트캠프/멤버십/8주차/리액트 커스텀 훅.md":"부스트캠프/멤버십/8주차/리액트-커스텀-훅.html","부스트캠프/멤버십/8주차/리액트 테스트.md":"부스트캠프/멤버십/8주차/리액트-테스트.html","부스트캠프/멤버십/8주차/멤버십_8주차.md":"부스트캠프/멤버십/8주차/멤버십_8주차.html","부스트캠프/멤버십/8주차/멤버십_8주차_마스터클래스.md":"부스트캠프/멤버십/8주차/멤버십_8주차_마스터클래스.html","부스트캠프/멤버십/8주차/멤버십_8주차_주간계획.md":"부스트캠프/멤버십/8주차/멤버십_8주차_주간계획.html","부스트캠프/멤버십/8주차/면접 및 취업 특강.md":"부스트캠프/멤버십/8주차/면접-및-취업-특강.html","부스트캠프/멤버십/8주차/무제 파일.md":"부스트캠프/멤버십/8주차/무제-파일.html","부스트캠프/멤버십/8주차/민형 이력서 브레인스토밍.md":"부스트캠프/멤버십/8주차/민형-이력서-브레인스토밍.html","부스트캠프/멤버십/8주차/배럴 파일에 대한 고찰.md":"부스트캠프/멤버십/8주차/배럴-파일에-대한-고찰.html","부스트캠프/멤버십/8주차/별이삼샵 UX 개선.md":"부스트캠프/멤버십/8주차/별이삼샵-ux-개선.html","부스트캠프/멤버십/8주차/부스트캠프 회고.md":"부스트캠프/멤버십/8주차/부스트캠프-회고.html","부스트캠프/멤버십/8주차/브라우저의 렌더링과 캔버스.md":"부스트캠프/멤버십/8주차/브라우저의-렌더링과-캔버스.html","부스트캠프/멤버십/8주차/상태 관리를 위한 context API와 전역 상태 라이브러리에 대한 고찰.md":"부스트캠프/멤버십/8주차/상태-관리를-위한-context-api와-전역-상태-라이브러리에-대한-고찰.html","부스트캠프/멤버십/8주차/상태관리 - props & Context API.md":"부스트캠프/멤버십/8주차/상태관리-props-&-context-api.html","부스트캠프/멤버십/8주차/오토스케일링.md":"부스트캠프/멤버십/8주차/오토스케일링.html","부스트캠프/멤버십/8주차/원래것들.md":"부스트캠프/멤버십/8주차/원래것들.html","부스트캠프/멤버십/8주차/웹소켓.md":"부스트캠프/멤버십/8주차/웹소켓.html","부스트캠프/멤버십/8주차/이력서 특강.md":"부스트캠프/멤버십/8주차/이력서-특강.html","부스트캠프/멤버십/8주차/커리어 특강.md":"부스트캠프/멤버십/8주차/커리어-특강.html","부스트캠프/멤버십/8주차/커피챗 - 새겨둬야 할 것들.md":"부스트캠프/멤버십/8주차/커피챗-새겨둬야-할-것들.html","부스트캠프/멤버십/8주차/컴포넌트 단위 개발.md":"부스트캠프/멤버십/8주차/컴포넌트-단위-개발.html","부스트캠프/멤버십/8주차/트랜잭션.md":"부스트캠프/멤버십/8주차/트랜잭션.html","부스트캠프/멤버십/8주차/트러블슈팅.md":"부스트캠프/멤버십/8주차/트러블슈팅.html","부스트캠프/멤버십/8주차/파일 시스템.md":"부스트캠프/멤버십/8주차/파일-시스템.html","부스트캠프/멤버십/8주차/프레임워크 렌더링 과정.md":"부스트캠프/멤버십/8주차/프레임워크-렌더링-과정.html","부스트캠프/멤버십/8주차/화면 기록 2024-11-10 오후 11.20.13.mov":"부스트캠프/멤버십/8주차/화면-기록-2024-11-10-오후-11.20.13.html","부스트캠프/멤버십/8주차/BOOMAP (2).pdf":"부스트캠프/멤버십/8주차/boomap-(2).html","부스트캠프/멤버십/8주차/canvas에서의 드래그앤드롭.md":"부스트캠프/멤버십/8주차/canvas에서의-드래그앤드롭.html","부스트캠프/멤버십/8주차/Concurrent mode.md":"부스트캠프/멤버십/8주차/concurrent-mode.html","부스트캠프/멤버십/8주차/Error boundary와 Suspense.md":"부스트캠프/멤버십/8주차/error-boundary와-suspense.html","부스트캠프/멤버십/8주차/flux & useReducer.md":"부스트캠프/멤버십/8주차/flux-&-usereducer.html","부스트캠프/멤버십/8주차/history API와 리액트 라우팅.md":"부스트캠프/멤버십/8주차/history-api와-리액트-라우팅.html","부스트캠프/멤버십/8주차/IMG_0231.jpg":"부스트캠프/멤버십/8주차/img_0231.html","부스트캠프/멤버십/8주차/IMG_0231 1.jpg":"부스트캠프/멤버십/8주차/img_0231-1.html","부스트캠프/멤버십/8주차/JS에서의 OOP.md":"부스트캠프/멤버십/8주차/js에서의-oop.html","부스트캠프/멤버십/8주차/lambda.md":"부스트캠프/멤버십/8주차/lambda.html","부스트캠프/멤버십/8주차/NCP 후기.md":"부스트캠프/멤버십/8주차/ncp-후기.html","부스트캠프/멤버십/8주차/NOSQL 맛보기.md":"부스트캠프/멤버십/8주차/nosql-맛보기.html","부스트캠프/멤버십/8주차/Oauth2.0.md":"부스트캠프/멤버십/8주차/oauth2.0.html","부스트캠프/멤버십/8주차/PR.md":"부스트캠프/멤버십/8주차/pr.html","부스트캠프/멤버십/8주차/pr-요소 추가.md":"부스트캠프/멤버십/8주차/pr-요소-추가.html","부스트캠프/멤버십/8주차/React Next.md":"부스트캠프/멤버십/8주차/react-next.html","부스트캠프/멤버십/8주차/React Portal.md":"부스트캠프/멤버십/8주차/react-portal.html","부스트캠프/멤버십/8주차/react-konva를 이용하여 노드 추가기능 구현하기.md":"부스트캠프/멤버십/8주차/react-konva를-이용하여-노드-추가기능-구현하기.html","부스트캠프/멤버십/8주차/react-konva를 이용하여 원 사이 라인 그리기.md":"부스트캠프/멤버십/8주차/react-konva를-이용하여-원-사이-라인-그리기.html","부스트캠프/멤버십/8주차/react-konva를 이용하여 원 사이 충돌 방지 시키기.md":"부스트캠프/멤버십/8주차/react-konva를-이용하여-원-사이-충돌-방지-시키기.html","부스트캠프/멤버십/8주차/SEO.md":"부스트캠프/멤버십/8주차/seo.html","부스트캠프/멤버십/8주차/setInterval과 setTimeout.md":"부스트캠프/멤버십/8주차/setinterval과-settimeout.html","부스트캠프/멤버십/8주차/tanstack-query의 쿼리 키 관리.md":"부스트캠프/멤버십/8주차/tanstack-query의-쿼리-키-관리.html","부스트캠프/멤버십/8주차/tree shaking과 code splitting.md":"부스트캠프/멤버십/8주차/tree-shaking과-code-splitting.html","부스트캠프/멤버십/8주차/vpc.md":"부스트캠프/멤버십/8주차/vpc.html","부스트캠프/멤버십/8주차/vpc미션.md":"부스트캠프/멤버십/8주차/vpc미션.html","부스트캠프/멤버십/8주차/week8_1일차_PR.md":"부스트캠프/멤버십/8주차/week8_1일차_pr.html","부스트캠프/멤버십/8주차/week8_2일차_PR.md":"부스트캠프/멤버십/8주차/week8_2일차_pr.html","부스트캠프/멤버십/8주차/week8_3일차_PR.md":"부스트캠프/멤버십/8주차/week8_3일차_pr.html","부스트캠프/멤버십/8주차/week8_4일차_PR.md":"부스트캠프/멤버십/8주차/week8_4일차_pr.html","부스트캠프/멤버십/그룹프로젝트 1주차/그룹 프로젝트_1주차.md":"부스트캠프/멤버십/그룹프로젝트-1주차/그룹-프로젝트_1주차.html","부스트캠프/멤버십/그룹프로젝트 1주차/특강.md":"부스트캠프/멤버십/그룹프로젝트-1주차/특강.html","부스트캠프/멤버십/그룹프로젝트 1주차/프로젝트 관련 수료생 밋업.md":"부스트캠프/멤버십/그룹프로젝트-1주차/프로젝트-관련-수료생-밋업.html","부스트캠프/멤버십/그룹프로젝트 1주차/현업에서 말하는 좋은 프로젝트 - 자문위원님들.md":"부스트캠프/멤버십/그룹프로젝트-1주차/현업에서-말하는-좋은-프로젝트-자문위원님들.html","부스트캠프/베이직/돌아보기.md":"부스트캠프/베이직/돌아보기.html","부스트캠프/베이직/문제.md":"부스트캠프/베이직/문제.html","부스트캠프/베이직/문제 분석.md":"부스트캠프/베이직/문제-분석.html","부스트캠프/베이직/부스트캠프.md":"부스트캠프/베이직/부스트캠프.html","부스트캠프/베이직/실수 축제.md":"부스트캠프/베이직/실수-축제.html","부스트캠프/베이직/웹프로그래밍.md":"부스트캠프/베이직/웹프로그래밍.html","부스트캠프/베이직/페이지 라우팅.md":"부스트캠프/베이직/페이지-라우팅.html","부스트캠프/베이직/학습 저장소 제출용.md":"부스트캠프/베이직/학습-저장소-제출용.html","부스트캠프/베이직/Day 1.md":"부스트캠프/베이직/day-1.html","부스트캠프/베이직/Day 2.md":"부스트캠프/베이직/day-2.html","부스트캠프/베이직/Day_3.md":"부스트캠프/베이직/day_3.html","부스트캠프/베이직/Day_3 문제.md":"부스트캠프/베이직/day_3-문제.html","부스트캠프/베이직/Day_3 피드백.md":"부스트캠프/베이직/day_3-피드백.html","부스트캠프/베이직/Day_3 학습내용.md":"부스트캠프/베이직/day_3-학습내용.html","부스트캠프/베이직/Day_4.md":"부스트캠프/베이직/day_4.html","부스트캠프/베이직/Day_4 문제.md":"부스트캠프/베이직/day_4-문제.html","부스트캠프/베이직/Day_4 제출용.md":"부스트캠프/베이직/day_4-제출용.html","부스트캠프/베이직/Day_4 학습저장소.md":"부스트캠프/베이직/day_4-학습저장소.html","부스트캠프/베이직/Day_5.md":"부스트캠프/베이직/day_5.html","부스트캠프/베이직/Day_5 문제.md":"부스트캠프/베이직/day_5-문제.html","부스트캠프/베이직/Day_5 학습제출용.md":"부스트캠프/베이직/day_5-학습제출용.html","부스트캠프/베이직/Day_6.md":"부스트캠프/베이직/day_6.html","부스트캠프/베이직/Day_6 문제.md":"부스트캠프/베이직/day_6-문제.html","부스트캠프/베이직/Day_6 셀프 체크리스트.md":"부스트캠프/베이직/day_6-셀프-체크리스트.html","부스트캠프/베이직/Day_6 학습저장소.md":"부스트캠프/베이직/day_6-학습저장소.html","부스트캠프/베이직/Day_7.md":"부스트캠프/베이직/day_7.html","부스트캠프/베이직/Day_7 셀프 체크리스트.md":"부스트캠프/베이직/day_7-셀프-체크리스트.html","부스트캠프/베이직/Day_7 스택 계산기.md":"부스트캠프/베이직/day_7-스택-계산기.html","부스트캠프/베이직/Day_7 실수축제.md":"부스트캠프/베이직/day_7-실수축제.html","부스트캠프/베이직/Day_7 학습저장소.md":"부스트캠프/베이직/day_7-학습저장소.html","부스트캠프/베이직/Day_8.md":"부스트캠프/베이직/day_8.html","부스트캠프/베이직/Day_8 문제.md":"부스트캠프/베이직/day_8-문제.html","부스트캠프/베이직/Day_8 학습저장소.md":"부스트캠프/베이직/day_8-학습저장소.html","부스트캠프/베이직/Day_9.md":"부스트캠프/베이직/day_9.html","부스트캠프/베이직/Day_9 문제.md":"부스트캠프/베이직/day_9-문제.html","부스트캠프/베이직/Day_9 실수파티.md":"부스트캠프/베이직/day_9-실수파티.html","부스트캠프/베이직/Day_9 학습저장소.md":"부스트캠프/베이직/day_9-학습저장소.html","부스트캠프/베이직/Day_10.md":"부스트캠프/베이직/day_10.html","부스트캠프/베이직/Day_10 문제.md":"부스트캠프/베이직/day_10-문제.html","부스트캠프/베이직/Day2_문제.md":"부스트캠프/베이직/day2_문제.html","부스트캠프/베이직/Day2_학습내용.md":"부스트캠프/베이직/day2_학습내용.html","부스트캠프/챌린지/2주차 릴레이노트.md":"부스트캠프/챌린지/2주차-릴레이노트.html","부스트캠프/챌린지/3주차 개인회고.md":"부스트캠프/챌린지/3주차-개인회고.html","부스트캠프/챌린지/가상 메모리.md":"부스트캠프/챌린지/가상-메모리.html","부스트캠프/챌린지/릴레이노트.md":"부스트캠프/챌린지/릴레이노트.html","부스트캠프/챌린지/릴레이프로젝트.md":"부스트캠프/챌린지/릴레이프로젝트.html","부스트캠프/챌린지/무제 파일.md":"부스트캠프/챌린지/무제-파일.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.29.30.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.29.30.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.35.33.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.35.33.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.36.40.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.36.40.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.39.37.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.39.37.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.40.46.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.40.46.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.44.03.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.44.03.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.48.39.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.48.39.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.50.34.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.50.34.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.52.17.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.52.17.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 3.54.32.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-3.54.32.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 4.11.30.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.11.30.html","부스트캠프/챌린지/스크린샷 2024-07-21 오후 4.13.14.png":"부스트캠프/챌린지/스크린샷-2024-07-21-오후-4.13.14.html","부스트캠프/챌린지/스크린샷 2024-07-23 오전 1.18.51.png":"부스트캠프/챌린지/스크린샷-2024-07-23-오전-1.18.51.html","부스트캠프/챌린지/이벤트 루프와 비동기.md":"부스트캠프/챌린지/이벤트-루프와-비동기.html","부스트캠프/챌린지/챌린지.md":"부스트캠프/챌린지/챌린지.html","부스트캠프/챌린지/챌린지 1주차 회고.md":"부스트캠프/챌린지/챌린지-1주차-회고.html","부스트캠프/챌린지/챌린지 회고.md":"부스트캠프/챌린지/챌린지-회고.html","부스트캠프/챌린지/챌린지 Day_1.md":"부스트캠프/챌린지/챌린지-day_1.html","부스트캠프/챌린지/챌린지 Day_2.md":"부스트캠프/챌린지/챌린지-day_2.html","부스트캠프/챌린지/챌린지 Day_3.md":"부스트캠프/챌린지/챌린지-day_3.html","부스트캠프/챌린지/챌린지 Day_4.md":"부스트캠프/챌린지/챌린지-day_4.html","부스트캠프/챌린지/챌린지 Day_4 학습저장소.md":"부스트캠프/챌린지/챌린지-day_4-학습저장소.html","부스트캠프/챌린지/챌린지 Day_4 학습정리.md":"부스트캠프/챌린지/챌린지-day_4-학습정리.html","부스트캠프/챌린지/챌린지 Day_5.md":"부스트캠프/챌린지/챌린지-day_5.html","부스트캠프/챌린지/챌린지 Day_7.md":"부스트캠프/챌린지/챌린지-day_7.html","부스트캠프/챌린지/챌린지 Day_8.md":"부스트캠프/챌린지/챌린지-day_8.html","부스트캠프/챌린지/챌린지 Day_9.md":"부스트캠프/챌린지/챌린지-day_9.html","부스트캠프/챌린지/챌린지 Day_10.md":"부스트캠프/챌린지/챌린지-day_10.html","부스트캠프/챌린지/챌린지 Day_11.md":"부스트캠프/챌린지/챌린지-day_11.html","부스트캠프/챌린지/챌린지 Day_13.md":"부스트캠프/챌린지/챌린지-day_13.html","부스트캠프/챌린지/챌린지 Day_16.md":"부스트캠프/챌린지/챌린지-day_16.html","부스트캠프/챌린지/챌린지 Day_18.md":"부스트캠프/챌린지/챌린지-day_18.html","부스트캠프/챌린지/챌린지 Day1_문제.md":"부스트캠프/챌린지/챌린지-day1_문제.html","부스트캠프/챌린지/챌린지 Day1_학습저장소용.md":"부스트캠프/챌린지/챌린지-day1_학습저장소용.html","부스트캠프/챌린지/챌린지 Day1_학습정리용.md":"부스트캠프/챌린지/챌린지-day1_학습정리용.html","부스트캠프/챌린지/챌린지_Day_3_문제.md":"부스트캠프/챌린지/챌린지_day_3_문제.html","부스트캠프/챌린지/챌린지_Day_3_학습저장소.md":"부스트캠프/챌린지/챌린지_day_3_학습저장소.html","부스트캠프/챌린지/챌린지_Day_3_학습정리.md":"부스트캠프/챌린지/챌린지_day_3_학습정리.html","부스트캠프/챌린지/챌린지_Day_7 학습저장소.md":"부스트캠프/챌린지/챌린지_day_7-학습저장소.html","부스트캠프/챌린지/챌린지_Day2_문제.md":"부스트캠프/챌린지/챌린지_day2_문제.html","부스트캠프/챌린지/챌린지_Day2_학습저장소.md":"부스트캠프/챌린지/챌린지_day2_학습저장소.html","부스트캠프/챌린지/챌린지_Day2_학습정리.md":"부스트캠프/챌린지/챌린지_day2_학습정리.html","부스트캠프/챌린지/챌린지_Day5_학습저장소.md":"부스트캠프/챌린지/챌린지_day5_학습저장소.html","부스트캠프/챌린지/커스텀 에러 만들기.md":"부스트캠프/챌린지/커스텀-에러-만들기.html","부스트캠프/챌린지/클로저.md":"부스트캠프/챌린지/클로저.html","부스트캠프/챌린지/트랜잭션과 비즈니스 로직.md":"부스트캠프/챌린지/트랜잭션과-비즈니스-로직.html","부스트캠프/챌린지/학습 정리.md":"부스트캠프/챌린지/학습-정리.html","부스트캠프/챌린지/aws ssa.md":"부스트캠프/챌린지/aws-ssa.html","부스트캠프/챌린지/Broadcast, Unicast, Multicast.md":"부스트캠프/챌린지/broadcast,-unicast,-multicast.html","부스트캠프/챌린지/Day13_학습정리.md":"부스트캠프/챌린지/day13_학습정리.html","부스트캠프/챌린지/DBMS와 RDBMS.md":"부스트캠프/챌린지/dbms와-rdbms.html","부스트캠프/챌린지/MFA.md":"부스트캠프/챌린지/mfa.html","부스트캠프/챌린지/Observer 패턴.md":"부스트캠프/챌린지/observer-패턴.html","부스트캠프/챌린지/OSI 7 Layer.md":"부스트캠프/챌린지/osi-7-layer.html","부스트캠프/챌린지/Pasted image 20240721133934.png":"부스트캠프/챌린지/pasted-image-20240721133934.html","부스트캠프/챌린지/Pasted image 20240723210155.png":"부스트캠프/챌린지/pasted-image-20240723210155.html","부스트캠프/챌린지/Pasted image 20240723210202.png":"부스트캠프/챌린지/pasted-image-20240723210202.html","부스트캠프/챌린지/Pasted image 20240726011348.png":"부스트캠프/챌린지/pasted-image-20240726011348.html","부스트캠프/챌린지/Pub-Sub 패턴.md":"부스트캠프/챌린지/pub-sub-패턴.html","부스트캠프/챌린지/React 19 베타에서 새롭게 추가된 것들.md":"부스트캠프/챌린지/react-19-베타에서-새롭게-추가된-것들.html","부스트캠프/챌린지/React Query.md":"부스트캠프/챌린지/react-query.html","부스트캠프/챌린지/ReactiveX.md":"부스트캠프/챌린지/reactivex.html","부스트캠프/챌린지/REST API.md":"부스트캠프/챌린지/rest-api.html","부스트캠프/챌린지/sql 기본문법.md":"부스트캠프/챌린지/sql-기본문법.html","부스트캠프/챌린지/TCP-IP.md":"부스트캠프/챌린지/tcp-ip.html","부스트캠프/챌린지/TELNET과 SSH.md":"부스트캠프/챌린지/telnet과-ssh.html","부스트캠프/멤버십 과정.md":"부스트캠프/멤버십-과정.html","알고리즘/자바스크립트 알고리즘 강의/스택(Stack)과 큐(Queue).md":"알고리즘/자바스크립트-알고리즘-강의/스택(stack)과-큐(queue).html","알고리즘/자바스크립트 알고리즘 강의/이진 탐색 트리(Binary Search Tree).md":"알고리즘/자바스크립트-알고리즘-강의/이진-탐색-트리(binary-search-tree).html","알고리즘/자바스크립트 알고리즘 강의/정렬 - 기수정렬(Radix Sort).md":"알고리즘/자바스크립트-알고리즘-강의/정렬-기수정렬(radix-sort).html","알고리즘/자바스크립트 알고리즘 강의/정렬 - 버블, 삽입, 선택정렬.md":"알고리즘/자바스크립트-알고리즘-강의/정렬-버블,-삽입,-선택정렬.html","알고리즘/자바스크립트 알고리즘 강의/정렬 - 퀵정렬(Quick Sort).md":"알고리즘/자바스크립트-알고리즘-강의/정렬-퀵정렬(quick-sort).html","알고리즘/자바스크립트 알고리즘 강의/정렬 - 합병정렬(Merge Sort).md":"알고리즘/자바스크립트-알고리즘-강의/정렬-합병정렬(merge-sort).html","알고리즘/자바스크립트 알고리즘 강의/트리 순회(Tree Traversal).md":"알고리즘/자바스크립트-알고리즘-강의/트리-순회(tree-traversal).html","알고리즘/자바스크립트 알고리즘 강의/udemy_자바스크립트 알고리즘.md":"알고리즘/자바스크립트-알고리즘-강의/udemy_자바스크립트-알고리즘.html","프로젝트/Boomap/Boomap.md":"프로젝트/boomap/boomap.html","프로젝트/Boomap/react-konva를 이용하여 노드 추가기능 구현하기.md":"프로젝트/boomap/react-konva를-이용하여-노드-추가기능-구현하기.html","프로젝트/Boomap/react-konva를 이용하여 원 사이 라인 그리기.md":"프로젝트/boomap/react-konva를-이용하여-원-사이-라인-그리기.html","프로젝트/Boomap/react-konva를 이용하여 원 사이 충돌 방지 시키기.md":"프로젝트/boomap/react-konva를-이용하여-원-사이-충돌-방지-시키기.html","프로젝트/forA/forA.md":"프로젝트/fora/fora.html","프로젝트/forA/forA_트러블슈팅.md":"프로젝트/fora/fora_트러블슈팅.html","프로젝트/Neo/반응형을 자바스크립트로 해보기.md":"프로젝트/neo/반응형을-자바스크립트로-해보기.html","프로젝트/Neo/axios를 떠나보내기.md":"프로젝트/neo/axios를-떠나보내기.html","프로젝트/Neo/Neo.md":"프로젝트/neo/neo.html","학습 정리/Backend/트랜잭션과 비즈니스 로직.md":"학습-정리/backend/트랜잭션과-비즈니스-로직.html","학습 정리/Backend/Backend.md":"학습-정리/backend/backend.html","학습 정리/Backend/express+pug로 templating해서 SSR + CSR 구현하기.md":"학습-정리/backend/express+pug로-templating해서-ssr-+-csr-구현하기.html","학습 정리/Backend/mysql Join.md":"학습-정리/backend/mysql-join.html","학습 정리/Backend/Node.js Libuv에 대한 고찰.md":"학습-정리/backend/node.js-libuv에-대한-고찰.html","학습 정리/Backend/Passport의 로컬 인증전략.md":"학습-정리/backend/passport의-로컬-인증전략.html","학습 정리/Backend/REST API.md":"학습-정리/backend/rest-api.html","학습 정리/Backend/sql 기본문법.md":"학습-정리/backend/sql-기본문법.html","학습 정리/Backend/sql 트리거.md":"학습-정리/backend/sql-트리거.html","학습 정리/Computer Science/운영체제/연결 리스트 - 이중 연결 리스트(Doubly Linked List).md":"학습-정리/computer-science/운영체제/연결-리스트-이중-연결-리스트(doubly-linked-list).html","학습 정리/Computer Science/운영체제/연결 리스트- 단일 연결 리스트(Singly Linked Lists).md":"학습-정리/computer-science/운영체제/연결-리스트-단일-연결-리스트(singly-linked-lists).html","학습 정리/Computer Science/운영체제/운영체제.md":"학습-정리/computer-science/운영체제/운영체제.html","학습 정리/Computer Science/운영체제/운영체제_1주차_기본 구성요소, 명령어 수행, 인터럽트.md":"학습-정리/computer-science/운영체제/운영체제_1주차_기본-구성요소,-명령어-수행,-인터럽트.html","학습 정리/Computer Science/운영체제/운영체제_가상 메모리_하드웨어와 제어구조.md":"학습-정리/computer-science/운영체제/운영체제_가상-메모리_하드웨어와-제어구조.html","학습 정리/Computer Science/운영체제/운영체제_가상메모리_운영체제 소프트웨어.md":"학습-정리/computer-science/운영체제/운영체제_가상메모리_운영체제-소프트웨어.html","학습 정리/Computer Science/운영체제/운영체제_가상메모리_Linux, Windows의 가상 메모리.md":"학습-정리/computer-science/운영체제/운영체제_가상메모리_linux,-windows의-가상-메모리.html","학습 정리/Computer Science/운영체제/운영체제_단일처리기 스케줄링_스케줄링 알고리즘.md":"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_스케줄링-알고리즘.html","학습 정리/Computer Science/운영체제/운영체제_단일처리기 스케줄링_처리기 스케줄링의 유형.md":"학습-정리/computer-science/운영체제/운영체제_단일처리기-스케줄링_처리기-스케줄링의-유형.html","학습 정리/Computer Science/운영체제/운영체제_메모리 계층 구조, 캐시 메모리, IO연산 기법, 멀티프로세서와 멀티코어.md":"학습-정리/computer-science/운영체제/운영체제_메모리-계층-구조,-캐시-메모리,-io연산-기법,-멀티프로세서와-멀티코어.html","학습 정리/Computer Science/운영체제/운영체제_메모리 관리_메모리 관리 요구조건.md":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-관리-요구조건.html","학습 정리/Computer Science/운영체제/운영체제_메모리 관리_메모리 분할(memory partitioning).md":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_메모리-분할(memory-partitioning).html","학습 정리/Computer Science/운영체제/운영체제_메모리 관리_세그먼테이션.md":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_세그먼테이션.html","학습 정리/Computer Science/운영체제/운영체제_메모리 관리_페이징.md":"학습-정리/computer-science/운영체제/운영체제_메모리-관리_페이징.html","학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_교착상태 발견.md":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-발견.html","학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_교착상태 예방,회피,발견.md":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태-예방,회피,발견.html","학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_교착상태의 원리.md":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_교착상태의-원리.html","학습 정리/Computer Science/운영체제/운영체제_병행성_교착상태와 기아상태_식사하는 철학자 문제.md":"학습-정리/computer-science/운영체제/운영체제_병행성_교착상태와-기아상태_식사하는-철학자-문제.html","학습 정리/Computer Science/운영체제/운영체제_병행성_모니터.md":"학습-정리/computer-science/운영체제/운영체제_병행성_모니터.html","학습 정리/Computer Science/운영체제/운영체제_병행성_병행성의 원리.md":"학습-정리/computer-science/운영체제/운영체제_병행성_병행성의-원리.html","학습 정리/Computer Science/운영체제/운영체제_병행성_상호 배제-하드웨어 지원.md":"학습-정리/computer-science/운영체제/운영체제_병행성_상호-배제-하드웨어-지원.html","학습 정리/Computer Science/운영체제/운영체제_병행성_세마포어.md":"학습-정리/computer-science/운영체제/운영체제_병행성_세마포어.html","학습 정리/Computer Science/운영체제/운영체제_스레드_멀티코어와 멀티스레딩.md":"학습-정리/computer-science/운영체제/운영체제_스레드_멀티코어와-멀티스레딩.html","학습 정리/Computer Science/운영체제/운영체제_스레드_스레드의 유형.md":"학습-정리/computer-science/운영체제/운영체제_스레드_스레드의-유형.html","학습 정리/Computer Science/운영체제/운영체제_스레드_프로세스와 스레드.md":"학습-정리/computer-science/운영체제/운영체제_스레드_프로세스와-스레드.html","학습 정리/Computer Science/운영체제/운영체제_운영체제 개요_결함 허용.md":"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_결함-허용.html","학습 정리/Computer Science/운영체제/운영체제_운영체제 개요_멀티프로세서와 멀티코어를 위한 운영체제 설계 사항.md":"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_멀티프로세서와-멀티코어를-위한-운영체제-설계-사항.html","학습 정리/Computer Science/운영체제/운영체제_운영체제 개요_최근 운영체제로의 발전.md":"학습-정리/computer-science/운영체제/운영체제_운영체제-개요_최근-운영체제로의-발전.html","학습 정리/Computer Science/운영체제/운영체제_운영체제의 목적 및 기능.md":"학습-정리/computer-science/운영체제/운영체제_운영체제의-목적-및-기능.html","학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_디스크 스케줄링.md":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-스케줄링.html","학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_디스크 캐시.md":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_디스크-캐시.html","학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_운영체제 설계 이슈.md":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_운영체제-설계-이슈.html","학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_입출력 버퍼링.md":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-버퍼링.html","학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_입출력 장치, 입출력 기능 구성.md":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_입출력-장치,-입출력-기능-구성.html","학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_RAID.md":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_raid.html","학습 정리/Computer Science/운영체제/운영체제_입출력 관리와 디스크 스케줄링_UNIX SVR4의 입출력.md":"학습-정리/computer-science/운영체제/운영체제_입출력-관리와-디스크-스케줄링_unix-svr4의-입출력.html","학습 정리/Computer Science/운영체제/운영체제_파일 관리_개요.md":"학습-정리/computer-science/운영체제/운영체제_파일-관리_개요.html","학습 정리/Computer Science/운영체제/운영체제_파일 관리_파일 구성과 접근.md":"학습-정리/computer-science/운영체제/운영체제_파일-관리_파일-구성과-접근.html","학습 정리/Computer Science/운영체제/운영체제_파일 관리_B-트리, 파일 디렉토리.md":"학습-정리/computer-science/운영체제/운영체제_파일-관리_b-트리,-파일-디렉토리.html","학습 정리/Computer Science/운영체제/운영체제_파일 관리_Linux의 가상파일시스템과 windows 파일 시스템.md":"학습-정리/computer-science/운영체제/운영체제_파일-관리_linux의-가상파일시스템과-windows-파일-시스템.html","학습 정리/Computer Science/운영체제/운영체제_파일 관리_UNIX의 파일 관리.md":"학습-정리/computer-science/운영체제/운영체제_파일-관리_unix의-파일-관리.html","학습 정리/Computer Science/운영체제/운영체제_파일관리_보조 저장공간 관리.md":"학습-정리/computer-science/운영체제/운영체제_파일관리_보조-저장공간-관리.html","학습 정리/Computer Science/운영체제/운영체제_파일관리_파일 공유와 레코드 블로킹.md":"학습-정리/computer-science/운영체제/운영체제_파일관리_파일-공유와-레코드-블로킹.html","학습 정리/Computer Science/운영체제/운영체제_프로세스 기술과 제어_운영체제의 수행.md":"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_운영체제의-수행.html","학습 정리/Computer Science/운영체제/운영체제_프로세스 기술과 제어_프로세스 기술.md":"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-기술.html","학습 정리/Computer Science/운영체제/운영체제_프로세스 기술과 제어_프로세스 제어.md":"학습-정리/computer-science/운영체제/운영체제_프로세스-기술과-제어_프로세스-제어.html","학습 정리/Computer Science/브라우저의 렌더링과 캔버스.md":"학습-정리/computer-science/브라우저의-렌더링과-캔버스.html","학습 정리/Computer Science/웹페이지, 웹사이트, 웹서버, 검색엔진의 차이.md":"학습-정리/computer-science/웹페이지,-웹사이트,-웹서버,-검색엔진의-차이.html","학습 정리/Computer Science/이벤트 루프와 비동기.md":"학습-정리/computer-science/이벤트-루프와-비동기.html","학습 정리/Computer Science/이벤트 전파와 위임에 대한 고찰.md":"학습-정리/computer-science/이벤트-전파와-위임에-대한-고찰.html","학습 정리/Computer Science/쿠키와 세션.md":"학습-정리/computer-science/쿠키와-세션.html","학습 정리/Computer Science/Broadcast, Unicast, Multicast.md":"학습-정리/computer-science/broadcast,-unicast,-multicast.html","학습 정리/Computer Science/Computer Science.md":"학습-정리/computer-science/computer-science.html","학습 정리/Computer Science/Frontend RoadMap.md":"학습-정리/computer-science/frontend-roadmap.html","학습 정리/Computer Science/HTTP 메시지.md":"학습-정리/computer-science/http-메시지.html","학습 정리/Computer Science/HTTP 세션.md":"학습-정리/computer-science/http-세션.html","학습 정리/Computer Science/HTTP3.md":"학습-정리/computer-science/http3.html","학습 정리/Computer Science/OSI 7 Layer.md":"학습-정리/computer-science/osi-7-layer.html","학습 정리/Computer Science/TCP-IP.md":"학습-정리/computer-science/tcp-ip.html","학습 정리/Computer Science/TELNET과 SSH.md":"학습-정리/computer-science/telnet과-ssh.html","학습 정리/Design Pattern/Design Pattern.md":"학습-정리/design-pattern/design-pattern.html","학습 정리/Design Pattern/fsd 패턴.md":"학습-정리/design-pattern/fsd-패턴.html","학습 정리/Design Pattern/MVC패턴.md":"학습-정리/design-pattern/mvc패턴.html","학습 정리/Design Pattern/Observer 패턴.md":"학습-정리/design-pattern/observer-패턴.html","학습 정리/Design Pattern/Pub-Sub 패턴.md":"학습-정리/design-pattern/pub-sub-패턴.html","학습 정리/Frontend/Javascript/배럴 파일에 대한 고찰.md":"학습-정리/frontend/javascript/배럴-파일에-대한-고찰.html","학습 정리/Frontend/Javascript/클로저에 관한 고찰.md":"학습-정리/frontend/javascript/클로저에-관한-고찰.html","학습 정리/Frontend/Javascript/Javascript.md":"학습-정리/frontend/javascript/javascript.html","학습 정리/Frontend/Javascript/setInterval과 setTimeout에 관한 고찰.md":"학습-정리/frontend/javascript/setinterval과-settimeout에-관한-고찰.html","학습 정리/Frontend/Javascript/this 바인딩과 간접 호출.md":"학습-정리/frontend/javascript/this-바인딩과-간접-호출.html","학습 정리/Frontend/Others/aws 배포.md":"학습-정리/frontend/others/aws-배포.html","학습 정리/Frontend/Others/firebase functions.md":"학습-정리/frontend/others/firebase-functions.html","학습 정리/Frontend/Others/NOSQL 맛보기.md":"학습-정리/frontend/others/nosql-맛보기.html","학습 정리/Frontend/Others/Others(Frontend).md":"학습-정리/frontend/others/others(frontend).html","학습 정리/Frontend/Others/Prettier 설정하기.md":"학습-정리/frontend/others/prettier-설정하기.html","학습 정리/Frontend/Others/Tailwind 설정하기.md":"학습-정리/frontend/others/tailwind-설정하기.html","학습 정리/Frontend/Others/xss 공격.md":"학습-정리/frontend/others/xss-공격.html","학습 정리/Frontend/React/Concurrent mode.md":"학습-정리/frontend/react/concurrent-mode.html","학습 정리/Frontend/React/Error boundary와 Suspense.md":"학습-정리/frontend/react/error-boundary와-suspense.html","학습 정리/Frontend/React/JSX에 관한 고찰.md":"학습-정리/frontend/react/jsx에-관한-고찰.html","학습 정리/Frontend/React/React.md":"학습-정리/frontend/react/react.html","학습 정리/Frontend/React/React 19 베타에서 새롭게 추가된 것들.md":"학습-정리/frontend/react/react-19-베타에서-새롭게-추가된-것들.html","학습 정리/Frontend/React/React Fiber에 관한 고찰.md":"학습-정리/frontend/react/react-fiber에-관한-고찰.html","학습 정리/Frontend/React/React Portal.md":"학습-정리/frontend/react/react-portal.html","학습 정리/Frontend/React/useEffect에 관한 고찰.md":"학습-정리/frontend/react/useeffect에-관한-고찰.html","학습 정리/Frontend/React/useMemo와 useCallback에 관한 고찰.md":"학습-정리/frontend/react/usememo와-usecallback에-관한-고찰.html","학습 정리/학습 정리.md":"학습-정리/학습-정리.html","회고/부스트캠프 회고.md":"회고/부스트캠프-회고.html","알고리즘/[백준 6064] 카잉 달력.md":"알고리즘/[백준-6064]-카잉-달력.html","알고리즘/[백준 10597] 순열장난.md":"알고리즘/[백준-10597]-순열장난.html","알고리즘/[백준 31836] 피보나치 기념품.md":"알고리즘/[백준-31836]-피보나치-기념품.html","알고리즘/[백준26091] 현대모비스 소프트웨어 아카데미.md":"알고리즘/[백준26091]-현대모비스-소프트웨어-아카데미.html","프로젝트/Neo/구현의 상세 추상화.md":"프로젝트/neo/구현의-상세-추상화.html","알고리즘/[백준 12891] DNA 비밀번호.md":"알고리즘/[백준-12891]-dna-비밀번호.html","프로젝트/forA/화면 기록 2025-02-07 오후 11.20.09.gif":"프로젝트/fora/화면-기록-2025-02-07-오후-11.20.09.html","알고리즘/[백준 23307] 드디어 시작한 화석 발굴 이벤트.md":"알고리즘/[백준-23307]-드디어-시작한-화석-발굴-이벤트.html","알고리즘/백준 18113 그르다 김가놈.md":"알고리즘/백준-18113-그르다-김가놈.html","프로젝트/forA/forA_리팩토링_Navigation 추상화하기.md":"프로젝트/fora/fora_리팩토링_navigation-추상화하기.html"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Backlinks","featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"","featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"","featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Properties","featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"","featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Search...","featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Outline","featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"","featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Graph View","featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Minhyung's Dev Log","featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":false,"siteUrl":"https://alsgud8311.github.io/","siteName":"Minhyung's Dev Log","authorName":"Cho Minhyung","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_siteName":{"show":true,"name":"","description":"The name of the vault / exported site","placeholder":""},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}}},"modifiedTime":1739037861470,"siteName":"Minhyung's Dev Log","vaultName":"mh_obsidian","exportRoot":"","baseURL":"https://alsgud8311.github.io/","pluginVersion":"1.9.0-3b","themeName":"Default","bodyClasses":"publish css-settings-manager native-scrollbars show-inline-title show-ribbon anp-theme-ext-amoled ctp-notion-light ctp-notion-dark is-focused","hasFavicon":true}